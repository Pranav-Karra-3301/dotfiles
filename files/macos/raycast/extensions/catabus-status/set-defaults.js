"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports2, (function(exports3) {
      "use strict";
      function noop2() {
        return void 0;
      }
      function typeIsObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      const rethrowAssertionErrorRejection = noop2;
      function setFunctionName(fn, name) {
        try {
          Object.defineProperty(fn, "name", {
            value: name,
            configurable: true
          });
        } catch (_a2) {
        }
      }
      const originalPromise = Promise;
      const originalPromiseThen = Promise.prototype.then;
      const originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return newPromise((resolve) => resolve(value));
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      let _queueMicrotask = (callback) => {
        if (typeof queueMicrotask === "function") {
          _queueMicrotask = queueMicrotask;
        } else {
          const resolvedPromise = promiseResolvedWith(void 0);
          _queueMicrotask = (cb) => PerformPromiseThen(resolvedPromise, cb);
        }
        return _queueMicrotask(callback);
      };
      function reflectCall(F2, V, args) {
        if (typeof F2 !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F2, V, args);
      }
      function promiseCall(F2, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F2, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      const QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        get length() {
          return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
          const oldBack = this._back;
          let newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() {
          const oldFront = this._front;
          let newFront = oldFront;
          const oldCursor = this._cursor;
          let newCursor = oldCursor + 1;
          const elements = oldFront._elements;
          const element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
          let i2 = this._cursor;
          let node = this._front;
          let elements = node._elements;
          while (i2 !== elements.length || node._next !== void 0) {
            if (i2 === elements.length) {
              node = node._next;
              elements = node._elements;
              i2 = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i2]);
            ++i2;
          }
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() {
          const front = this._front;
          const cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      const AbortSteps = Symbol("[[AbortSteps]]");
      const ErrorSteps = Symbol("[[ErrorSteps]]");
      const CancelSteps = Symbol("[[CancelSteps]]");
      const PullSteps = Symbol("[[PullSteps]]");
      const ReleaseSteps = Symbol("[[ReleaseSteps]]");
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        const stream = reader._ownerReadableStream;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        stream._readableStreamController[ReleaseSteps]();
        stream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve, reject) => {
          reader._closedPromise_resolve = resolve;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      const NumberIsFinite = Number.isFinite || function(x2) {
        return typeof x2 === "number" && isFinite(x2);
      };
      const MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x2) {
        return typeof x2 === "object" || typeof x2 === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertFunction(x2, context) {
        if (typeof x2 !== "function") {
          throw new TypeError(`${context} is not a function.`);
        }
      }
      function isObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      function assertObject(x2, context) {
        if (!isObject(x2)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertRequiredArgument(x2, position, context) {
        if (x2 === void 0) {
          throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
      }
      function assertRequiredField(x2, field, context) {
        if (x2 === void 0) {
          throw new TypeError(`${field} is required in '${context}'.`);
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function integerPart(x2) {
        return censorNegativeZero(MathTrunc(x2));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x2 = Number(value);
        x2 = censorNegativeZero(x2);
        if (!NumberIsFinite(x2)) {
          throw new TypeError(`${context} is not a finite number`);
        }
        x2 = integerPart(x2);
        if (x2 < lowerBound || x2 > upperBound) {
          throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x2) || x2 === 0) {
          return 0;
        }
        return x2;
      }
      function assertReadableStream(x2, context) {
        if (!IsReadableStream(x2)) {
          throw new TypeError(`${context} is not a ReadableStream.`);
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: () => resolvePromise({ value: void 0, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          ReadableStreamDefaultReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamDefaultReader.prototype.read, "read");
      setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function ReadableStreamDefaultReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e2 = new TypeError("Reader was released");
        ReadableStreamDefaultReaderErrorReadRequests(reader, e2);
      }
      function ReadableStreamDefaultReaderErrorReadRequests(reader, e2) {
        const readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue();
        readRequests.forEach((readRequest) => {
          readRequest._errorSteps(e2);
        });
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
      }
      const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
      }).prototype);
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        next() {
          const nextSteps = () => this._nextSteps();
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        }
        return(value) {
          const returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          const reader = this._reader;
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0;
              _queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        }
        _returnSteps(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          const reader = this._reader;
          if (!this._preventCancel) {
            const result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, () => ({ value, done: true }));
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        }
      }
      const ReadableStreamAsyncIteratorPrototype = {
        next() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a2) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
      }
      const NumberIsNaN = Number.isNaN || function(x2) {
        return x2 !== x2;
      };
      var _a, _b, _c;
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      let TransferArrayBuffer = (O) => {
        if (typeof O.transfer === "function") {
          TransferArrayBuffer = (buffer) => buffer.transfer();
        } else if (typeof structuredClone === "function") {
          TransferArrayBuffer = (buffer) => structuredClone(buffer, { transfer: [buffer] });
        } else {
          TransferArrayBuffer = (buffer) => buffer;
        }
        return TransferArrayBuffer(O);
      };
      let IsDetachedBuffer = (O) => {
        if (typeof O.detached === "boolean") {
          IsDetachedBuffer = (buffer) => buffer.detached;
        } else {
          IsDetachedBuffer = (buffer) => buffer.byteLength === 0;
        }
        return IsDetachedBuffer(O);
      };
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice) {
          return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
      }
      function GetMethod(receiver, prop) {
        const func = receiver[prop];
        if (func === void 0 || func === null) {
          return void 0;
        }
        if (typeof func !== "function") {
          throw new TypeError(`${String(prop)} is not a function`);
        }
        return func;
      }
      function CreateAsyncFromSyncIterator(syncIteratorRecord) {
        const syncIterable = {
          [Symbol.iterator]: () => syncIteratorRecord.iterator
        };
        const asyncIterator = (async function* () {
          return yield* syncIterable;
        })();
        const nextMethod = asyncIterator.next;
        return { iterator: asyncIterator, nextMethod, done: false };
      }
      const SymbolAsyncIterator = (_c = (_a = Symbol.asyncIterator) !== null && _a !== void 0 ? _a : (_b = Symbol.for) === null || _b === void 0 ? void 0 : _b.call(Symbol, "Symbol.asyncIterator")) !== null && _c !== void 0 ? _c : "@@asyncIterator";
      function GetIterator(obj, hint = "sync", method) {
        if (method === void 0) {
          if (hint === "async") {
            method = GetMethod(obj, SymbolAsyncIterator);
            if (method === void 0) {
              const syncMethod = GetMethod(obj, Symbol.iterator);
              const syncIteratorRecord = GetIterator(obj, "sync", syncMethod);
              return CreateAsyncFromSyncIterator(syncIteratorRecord);
            }
          } else {
            method = GetMethod(obj, Symbol.iterator);
          }
        }
        if (method === void 0) {
          throw new TypeError("The object is not iterable");
        }
        const iterator = reflectCall(method, obj, []);
        if (!typeIsObject(iterator)) {
          throw new TypeError("The iterator method must return an object");
        }
        const nextMethod = iterator.next;
        return { iterator, nextMethod, done: false };
      }
      function IteratorNext(iteratorRecord) {
        const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
        if (!typeIsObject(result)) {
          throw new TypeError("The iterator.next() method must return an object");
        }
        return result;
      }
      function IteratorComplete(iterResult) {
        return Boolean(iterResult.done);
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      function isDataViewConstructor(ctor) {
        return ctor === DataView;
      }
      function isDataView(view) {
        return isDataViewConstructor(view.constructor);
      }
      function arrayBufferViewElementSize(ctor) {
        if (isDataViewConstructor(ctor)) {
          return 1;
        }
        return ctor.BYTES_PER_ELEMENT;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer)) {
            throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);
          }
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer)) {
            throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
          }
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBRequest.prototype.respond, "respond");
      setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
          }
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError(`chunk's buffer must have non-zero byteLength`);
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
            return;
          }
          const autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            const pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              minimumFill: 1,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        }
        /** @internal */
        [ReleaseSteps]() {
          if (this._pendingPullIntos.length > 0) {
            const firstPullInto = this._pendingPullIntos.peek();
            firstPullInto.readerType = "none";
            this._pendingPullIntos = new SimpleQueue();
            this._pendingPullIntos.push(firstPullInto);
          }
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableByteStreamController.prototype.close, "close");
      setFunctionName(ReadableByteStreamController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableByteStreamController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
          return false;
        }
        return x2 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          return null;
        }, (e2) => {
          ReadableByteStreamControllerError(controller, e2);
          return null;
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === "closed") {
          done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {
        let clonedChunk;
        try {
          clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);
        } catch (cloneE) {
          ReadableByteStreamControllerError(controller, cloneE);
          throw cloneE;
        }
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
      }
      function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
        if (firstDescriptor.bytesFilled > 0) {
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
        const maxAlignedBytes = maxBytesFilled - remainderBytes;
        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          const headOfQueue = queue.peek();
          const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
        const reader = controller._controlledReadableByteStream._reader;
        while (reader._readRequests.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const readRequest = reader._readRequests.shift();
          ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        const ctor = view.constructor;
        const elementSize = arrayBufferViewElementSize(ctor);
        const { byteOffset, byteLength } = view;
        const minimumFill = min * elementSize;
        let buffer;
        try {
          buffer = TransferArrayBuffer(view.buffer);
        } catch (e2) {
          readIntoRequest._errorSteps(e2);
          return;
        }
        const pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset,
          byteLength,
          bytesFilled: 0,
          minimumFill,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        if (firstDescriptor.readerType === "none") {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "none") {
          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          return;
        }
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            throw e2;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        const { buffer, byteOffset, byteLength } = chunk;
        if (IsDetachedBuffer(buffer)) {
          throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
        }
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
            throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          if (firstPendingPullInto.readerType === "none") {
            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
          }
        }
        if (ReadableStreamHasDefaultReader(stream)) {
          ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e2) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
        const entry = controller._queue.shift();
        controller._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(controller);
        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
        readRequest._chunkSteps(view);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
          return null;
        }, (r2) => {
          ReadableByteStreamControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = () => underlyingByteSource.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = () => underlyingByteSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== "byob") {
          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
      }
      function convertByobReadOptions(options, context) {
        var _a2;
        assertDictionary(options, context);
        const min = (_a2 = options === null || options === void 0 ? void 0 : options.min) !== null && _a2 !== void 0 ? _a2 : 1;
        return {
          min: convertUnsignedLongLongWithEnforceRange(min, `${context} has member 'min' that`)
        };
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view, rawOptions = {}) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
          }
          if (IsDetachedBuffer(view.buffer)) {
            return promiseRejectedWith(new TypeError("view's buffer has been detached"));
          }
          let options;
          try {
            options = convertByobReadOptions(rawOptions, "options");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const min = options.min;
          if (min === 0) {
            return promiseRejectedWith(new TypeError("options.min must be greater than 0"));
          }
          if (!isDataView(view)) {
            if (min > view.length) {
              return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's length"));
            }
          } else if (min > view.byteLength) {
            return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's byteLength"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readIntoRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          ReadableStreamBYOBReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamBYOBReader.prototype.read, "read");
      setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);
        }
      }
      function ReadableStreamBYOBReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e2 = new TypeError("Reader was released");
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2);
      }
      function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2) {
        const readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue();
        readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._errorSteps(e2);
        });
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
          return () => 1;
        }
        return size;
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        const size = init === null || init === void 0 ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x2, context) {
        if (!IsWritableStream(x2)) {
          throw new TypeError(`${context} is not a WritableStream.`);
        }
      }
      function isAbortSignal2(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a2) {
          return false;
        }
      }
      const supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          const type = underlyingSink.type;
          if (type !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = void 0) {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(WritableStream.prototype.abort, "abort");
      setFunctionName(WritableStream.prototype.close, "close");
      setFunctionName(WritableStream.prototype.getWriter, "getWriter");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
          return false;
        }
        return x2 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a2;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort(reason);
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        const promise = newPromise((resolve, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve, reject) => {
          const closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve, reject) => {
          const writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        }, (reason) => {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        const state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          const state = stream._state;
          if (state === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            const storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writers lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writers lock is released.
         */
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      setFunctionName(WritableStreamDefaultWriter.prototype.abort, "abort");
      setFunctionName(WritableStreamDefaultWriter.prototype.close, "close");
      setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock");
      setFunctionName(WritableStreamDefaultWriter.prototype.write, "write");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        const state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      const closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e2 = void 0) {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          const state = this._controlledWritableStream._state;
          if (state !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [AbortSteps](reason) {
          const result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, (r2) => {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r2);
          return null;
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm;
        let writeAlgorithm;
        let closeAlgorithm;
        let abortAlgorithm;
        if (underlyingSink.start !== void 0) {
          startAlgorithm = () => underlyingSink.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
        } else {
          writeAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = () => underlyingSink.close();
        } else {
          closeAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = (reason) => underlyingSink.abort(reason);
        } else {
          abortAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        const state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
          return null;
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          const state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, (reason) => {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve, reject) => {
          writer._closedPromise_resolve = resolve;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve, reject) => {
          writer._readyPromise_resolve = resolve;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      function getGlobals() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      const globals = getGlobals();
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        if (ctor.name !== "DOMException") {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a2) {
          return false;
        }
      }
      function getFromGlobal() {
        const ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;
        return isDOMExceptionConstructor(ctor) ? ctor : void 0;
      }
      function createPolyfill() {
        const ctor = function DOMException3(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        setFunctionName(ctor, "DOMException");
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      const DOMException2 = getFromGlobal() || createPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        let currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = () => {
              const error = signal.reason !== void 0 ? signal.reason : new DOMException2("Aborted", "AbortError");
              const actions = [];
              if (!preventAbort) {
                actions.push(() => {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(() => {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, () => {
              return newPromise((resolveRead, rejectRead) => {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: (chunk) => {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);
                    resolveRead(false);
                  },
                  _closeSteps: () => resolveRead(true),
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            if (!preventAbort) {
              shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesClosed(source, reader._closedPromise, () => {
            if (!preventClose) {
              shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
            } else {
              shutdown();
            }
            return null;
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
            } else {
              shutdown(true, destClosed);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            const oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              return null;
            }
          }
          function shutdown(isError, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
            } else {
              finalize(isError, error);
            }
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error);
            } else {
              resolve(void 0);
            }
            return null;
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        }
        /** @internal */
        [ReleaseSteps]() {
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultController.prototype.close, "close");
      setFunctionName(ReadableStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableStreamDefaultController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
          return null;
        }, (e2) => {
          ReadableStreamDefaultControllerError(controller, e2);
          return null;
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingSource.start !== void 0) {
          startAlgorithm = () => underlyingSource.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = () => underlyingSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const readRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgain = false;
                const chunk1 = chunk;
                const chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r2) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
          return null;
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r2) => {
            if (thisReader !== reader) {
              return null;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r2);
            ReadableByteStreamControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
            return null;
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          const readRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const chunk1 = chunk;
                let chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          const byobBranch = forBranch2 ? branch2 : branch1;
          const otherBranch = forBranch2 ? branch1 : branch2;
          const readIntoRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: (chunk) => {
              reading = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function isReadableStreamLike(stream) {
        return typeIsObject(stream) && typeof stream.getReader !== "undefined";
      }
      function ReadableStreamFrom(source) {
        if (isReadableStreamLike(source)) {
          return ReadableStreamFromDefaultReader(source.getReader());
        }
        return ReadableStreamFromIterable(source);
      }
      function ReadableStreamFromIterable(asyncIterable) {
        let stream;
        const iteratorRecord = GetIterator(asyncIterable, "async");
        const startAlgorithm = noop2;
        function pullAlgorithm() {
          let nextResult;
          try {
            nextResult = IteratorNext(iteratorRecord);
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const nextPromise = promiseResolvedWith(nextResult);
          return transformPromiseWith(nextPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
            }
            const done = IteratorComplete(iterResult);
            if (done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              const value = IteratorValue(iterResult);
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          const iterator = iteratorRecord.iterator;
          let returnMethod;
          try {
            returnMethod = GetMethod(iterator, "return");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (returnMethod === void 0) {
            return promiseResolvedWith(void 0);
          }
          let returnResult;
          try {
            returnResult = reflectCall(returnMethod, iterator, [reason]);
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const returnPromise = promiseResolvedWith(returnResult);
          return transformPromiseWith(returnPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
            }
            return void 0;
          });
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function ReadableStreamFromDefaultReader(reader) {
        let stream;
        const startAlgorithm = noop2;
        function pullAlgorithm() {
          let readPromise;
          try {
            readPromise = reader.read();
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          return transformPromiseWith(readPromise, (readResult) => {
            if (!typeIsObject(readResult)) {
              throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
            }
            if (readResult.done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              const value = readResult.value;
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          try {
            return promiseResolvedWith(reader.cancel(reason));
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== "bytes") {
          throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal)) {
          throw new TypeError(`${context} is not an AbortSignal.`);
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
      }
      class ReadableStream2 {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            const highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = void 0) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          const options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          const transform2 = convertReadableWritablePair(rawTransform, "First parameter");
          const options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform2.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          const promise = ReadableStreamPipeTo(this, transform2.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          setPromiseIsHandledToTrue(promise);
          return transform2.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
          }
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          const branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          const options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
        [SymbolAsyncIterator](options) {
          return this.values(options);
        }
        /**
         * Creates a new ReadableStream wrapping the provided iterable or async iterable.
         *
         * This can be used to adapt various kinds of objects into a readable stream,
         * such as an array, an async generator, or a Node.js readable stream.
         */
        static from(asyncIterable) {
          return ReadableStreamFrom(asyncIterable);
        }
      }
      Object.defineProperties(ReadableStream2, {
        from: { enumerable: true }
      });
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(ReadableStream2.from, "from");
      setFunctionName(ReadableStream2.prototype.cancel, "cancel");
      setFunctionName(ReadableStream2.prototype.getReader, "getReader");
      setFunctionName(ReadableStream2.prototype.pipeThrough, "pipeThrough");
      setFunctionName(ReadableStream2.prototype.pipeTo, "pipeTo");
      setFunctionName(ReadableStream2.prototype.tee, "tee");
      setFunctionName(ReadableStream2.prototype.values, "values");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, Symbol.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      Object.defineProperty(ReadableStream2.prototype, SymbolAsyncIterator, {
        value: ReadableStream2.prototype.values,
        writable: true,
        configurable: true
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          const readIntoRequests = reader._readIntoRequests;
          reader._readIntoRequests = new SimpleQueue();
          readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._closeSteps(void 0);
          });
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop2);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          const readRequests = reader._readRequests;
          reader._readRequests = new SimpleQueue();
          readRequests.forEach((readRequest) => {
            readRequest._closeSteps();
          });
        }
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored";
        stream._storedError = e2;
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e2);
        if (IsReadableStreamDefaultReader(reader)) {
          ReadableStreamDefaultReaderErrorReadRequests(reader, e2);
        } else {
          ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2);
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
      };
      setFunctionName(byteLengthSizeFunction, "size");
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof ByteLengthQueuingStrategy;
      }
      const countSizeFunction = () => {
        return 1;
      };
      setFunctionName(countSizeFunction, "size");
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform2 = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          cancel: cancel === void 0 ? void 0 : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
          transform: transform2 === void 0 ? void 0 : convertTransformerTransformCallback(transform2, original, `${context} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function convertTransformerCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          const transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          let startPromise_resolve;
          const startPromise = newPromise((resolve) => {
            startPromise_resolve = resolve;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
          return false;
        }
        return x2 instanceof TransformStream;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
        TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
        TransformStreamUnblockWrite(stream);
      }
      function TransformStreamUnblockWrite(stream) {
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise((resolve) => {
          stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          const readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(TransformStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(TransformStreamDefaultController.prototype.error, "error");
      setFunctionName(TransformStreamDefaultController.prototype.terminate, "terminate");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
          return false;
        }
        return x2 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._finishPromise = void 0;
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm;
        let flushAlgorithm;
        let cancelAlgorithm;
        if (transformer.transform !== void 0) {
          transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
        } else {
          transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = () => transformer.flush(controller);
        } else {
          flushAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (transformer.cancel !== void 0) {
          cancelAlgorithm = (reason) => transformer.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
          throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r2) => {
          TransformStreamError(controller._controlledTransformStream, r2);
          throw r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
          const backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            const writable = stream._writable;
            const state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const readable = stream._readable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const readable = stream._readable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(flushPromise, () => {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const writable = stream._writable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
          if (writable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, writable._storedError);
          } else {
            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
            TransformStreamUnblockWrite(stream);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r2);
          TransformStreamUnblockWrite(stream);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
      }
      function defaultControllerFinishPromiseResolve(controller) {
        if (controller._finishPromise_resolve === void 0) {
          return;
        }
        controller._finishPromise_resolve();
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function defaultControllerFinishPromiseReject(controller, reason) {
        if (controller._finishPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(controller._finishPromise);
        controller._finishPromise_reject(reason);
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
      }
      exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports3.CountQueuingStrategy = CountQueuingStrategy;
      exports3.ReadableByteStreamController = ReadableByteStreamController;
      exports3.ReadableStream = ReadableStream2;
      exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports3.TransformStream = TransformStream;
      exports3.TransformStreamDefaultController = TransformStreamDefaultController;
      exports3.WritableStream = WritableStream;
      exports3.WritableStreamDefaultController = WritableStreamDefaultController;
      exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
    }));
  }
});

// node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS({
  "node_modules/fetch-blob/streams.cjs"() {
    var POOL_SIZE2 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error) {
          process2.emitWarning = emitWarning;
          throw error;
        }
      } catch (error) {
        Object.assign(globalThis, require_ponyfill_es2018());
      }
    }
    try {
      const { Blob: Blob3 } = require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE2));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error) {
    }
  }
});

// node_modules/fetch-blob/index.js
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* (
        /** @type {AsyncIterableIterator<Uint8Array>} */
        part.stream()
      );
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0, b = (
        /** @type {Blob} */
        part
      );
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
var import_streams, POOL_SIZE, _Blob, Blob2, fetch_blob_default;
var init_fetch_blob = __esm({
  "node_modules/fetch-blob/index.js"() {
    import_streams = __toESM(require_streams(), 1);
    POOL_SIZE = 65536;
    _Blob = class Blob {
      /** @type {Array.<(Blob|Uint8Array)>} */
      #parts = [];
      #type = "";
      #size = 0;
      #endings = "transparent";
      /**
       * The Blob() constructor returns a new Blob object. The content
       * of the blob consists of the concatenation of the values given
       * in the parameter array.
       *
       * @param {*} blobParts
       * @param {{ type?: string, endings?: string }} [options]
       */
      constructor(blobParts = [], options = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null) options = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob) {
            part = element;
          } else {
            part = encoder.encode(`${element}`);
          }
          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }
        this.#endings = `${options.endings === void 0 ? "transparent" : options.endings}`;
        const type = options.type === void 0 ? "" : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      /**
       * The Blob interface's size property returns the
       * size of the Blob in bytes.
       */
      get size() {
        return this.#size;
      }
      /**
       * The type property of a Blob object returns the MIME type of the file.
       */
      get type() {
        return this.#type;
      }
      /**
       * The text() method in the Blob interface returns a Promise
       * that resolves with a string containing the contents of
       * the blob, interpreted as UTF-8.
       *
       * @return {Promise<string>}
       */
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      /**
       * The arrayBuffer() method in the Blob interface returns a
       * Promise that resolves with the contents of the blob as
       * binary data contained in an ArrayBuffer.
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          // @ts-ignore
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      /**
       * The Blob interface's slice() method creates and returns a
       * new Blob object which contains data from a subset of the
       * blob on which it's called.
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [type]
       */
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob2 = _Blob;
    fetch_blob_default = Blob2;
  }
});

// node_modules/fetch-blob/file.js
var _File, File2, file_default;
var init_file = __esm({
  "node_modules/fetch-blob/file.js"() {
    init_fetch_blob();
    _File = class File extends fetch_blob_default {
      #lastModified = 0;
      #name = "";
      /**
       * @param {*[]} fileBits
       * @param {string} fileName
       * @param {{lastModified?: number, type?: string}} options
       */
      // @ts-ignore
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        if (options === null) options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    };
    File2 = _File;
    file_default = File2;
  }
});

// node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F2, B = fetch_blob_default) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t, i, h, r, m, f, e, x, FormData;
var init_esm_min = __esm({
  "node_modules/formdata-polyfill/esm.min.js"() {
    init_fetch_blob();
    init_file();
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData = class FormData2 {
      #d = [];
      constructor(...a) {
        if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        this.#d.push(f(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        this.#d = this.#d.filter(([b]) => b !== a);
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        this.#d.forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return this.#d.some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this) a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f(...a);
        this.#d.forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        this.#d = b;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a] of this) yield a;
      }
      *values() {
        for (var [, a] of this) yield a;
      }
    };
  }
});

// node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "node_modules/node-domexception/index.js"(exports2, module2) {
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    module2.exports = globalThis.DOMException;
  }
});

// node_modules/fetch-blob/from.js
var import_node_fs, import_node_domexception, stat;
var init_from = __esm({
  "node_modules/fetch-blob/from.js"() {
    import_node_fs = require("node:fs");
    import_node_domexception = __toESM(require_node_domexception(), 1);
    init_file();
    init_fetch_blob();
    ({ stat } = import_node_fs.promises);
  }
});

// node_modules/node-fetch/src/utils/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new file_default(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var s, S, f2, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/node-fetch/src/utils/multipart-parser.js"() {
    init_from();
    init_esm_min();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f2 = 1;
    F = {
      PART_BOUNDARY: f2,
      LAST_BOUNDARY: f2 *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop = () => {
    };
    MultipartParser = class {
      /**
       * @param {string} boundary
       */
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      /**
       * @param {Uint8Array} data
       */
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            // falls through
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            // falls through
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            // falls through
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/adm-zip/util/constants.js
var require_constants = __commonJS({
  "node_modules/adm-zip/util/constants.js"(exports2, module2) {
    module2.exports = {
      /* The local file header */
      LOCHDR: 30,
      // LOC header size
      LOCSIG: 67324752,
      // "PK\003\004"
      LOCVER: 4,
      // version needed to extract
      LOCFLG: 6,
      // general purpose bit flag
      LOCHOW: 8,
      // compression method
      LOCTIM: 10,
      // modification time (2 bytes time, 2 bytes date)
      LOCCRC: 14,
      // uncompressed file crc-32 value
      LOCSIZ: 18,
      // compressed size
      LOCLEN: 22,
      // uncompressed size
      LOCNAM: 26,
      // filename length
      LOCEXT: 28,
      // extra field length
      /* The Data descriptor */
      EXTSIG: 134695760,
      // "PK\007\008"
      EXTHDR: 16,
      // EXT header size
      EXTCRC: 4,
      // uncompressed file crc-32 value
      EXTSIZ: 8,
      // compressed size
      EXTLEN: 12,
      // uncompressed size
      /* The central directory file header */
      CENHDR: 46,
      // CEN header size
      CENSIG: 33639248,
      // "PK\001\002"
      CENVEM: 4,
      // version made by
      CENVER: 6,
      // version needed to extract
      CENFLG: 8,
      // encrypt, decrypt flags
      CENHOW: 10,
      // compression method
      CENTIM: 12,
      // modification time (2 bytes time, 2 bytes date)
      CENCRC: 16,
      // uncompressed file crc-32 value
      CENSIZ: 20,
      // compressed size
      CENLEN: 24,
      // uncompressed size
      CENNAM: 28,
      // filename length
      CENEXT: 30,
      // extra field length
      CENCOM: 32,
      // file comment length
      CENDSK: 34,
      // volume number start
      CENATT: 36,
      // internal file attributes
      CENATX: 38,
      // external file attributes (host system dependent)
      CENOFF: 42,
      // LOC header offset
      /* The entries in the end of central directory */
      ENDHDR: 22,
      // END header size
      ENDSIG: 101010256,
      // "PK\005\006"
      ENDSUB: 8,
      // number of entries on this disk
      ENDTOT: 10,
      // total number of entries
      ENDSIZ: 12,
      // central directory size in bytes
      ENDOFF: 16,
      // offset of first CEN header
      ENDCOM: 20,
      // zip file comment length
      END64HDR: 20,
      // zip64 END header size
      END64SIG: 117853008,
      // zip64 Locator signature, "PK\006\007"
      END64START: 4,
      // number of the disk with the start of the zip64
      END64OFF: 8,
      // relative offset of the zip64 end of central directory
      END64NUMDISKS: 16,
      // total number of disks
      ZIP64SIG: 101075792,
      // zip64 signature, "PK\006\006"
      ZIP64HDR: 56,
      // zip64 record minimum size
      ZIP64LEAD: 12,
      // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
      ZIP64SIZE: 4,
      // zip64 size of the central directory record
      ZIP64VEM: 12,
      // zip64 version made by
      ZIP64VER: 14,
      // zip64 version needed to extract
      ZIP64DSK: 16,
      // zip64 number of this disk
      ZIP64DSKDIR: 20,
      // number of the disk with the start of the record directory
      ZIP64SUB: 24,
      // number of entries on this disk
      ZIP64TOT: 32,
      // total number of entries
      ZIP64SIZB: 40,
      // zip64 central directory size in bytes
      ZIP64OFF: 48,
      // offset of start of central directory with respect to the starting disk number
      ZIP64EXTRA: 56,
      // extensible data sector
      /* Compression methods */
      STORED: 0,
      // no compression
      SHRUNK: 1,
      // shrunk
      REDUCED1: 2,
      // reduced with compression factor 1
      REDUCED2: 3,
      // reduced with compression factor 2
      REDUCED3: 4,
      // reduced with compression factor 3
      REDUCED4: 5,
      // reduced with compression factor 4
      IMPLODED: 6,
      // imploded
      // 7 reserved for Tokenizing compression algorithm
      DEFLATED: 8,
      // deflated
      ENHANCED_DEFLATED: 9,
      // enhanced deflated
      PKWARE: 10,
      // PKWare DCL imploded
      // 11 reserved by PKWARE
      BZIP2: 12,
      //  compressed using BZIP2
      // 13 reserved by PKWARE
      LZMA: 14,
      // LZMA
      // 15-17 reserved by PKWARE
      IBM_TERSE: 18,
      // compressed using IBM TERSE
      IBM_LZ77: 19,
      // IBM LZ77 z
      AES_ENCRYPT: 99,
      // WinZIP AES encryption method
      /* General purpose bit flag */
      // values can obtained with expression 2**bitnr
      FLG_ENC: 1,
      // Bit 0: encrypted file
      FLG_COMP1: 2,
      // Bit 1, compression option
      FLG_COMP2: 4,
      // Bit 2, compression option
      FLG_DESC: 8,
      // Bit 3, data descriptor
      FLG_ENH: 16,
      // Bit 4, enhanced deflating
      FLG_PATCH: 32,
      // Bit 5, indicates that the file is compressed patched data.
      FLG_STR: 64,
      // Bit 6, strong encryption (patented)
      // Bits 7-10: Currently unused.
      FLG_EFS: 2048,
      // Bit 11: Language encoding flag (EFS)
      // Bit 12: Reserved by PKWARE for enhanced compression.
      // Bit 13: encrypted the Central Directory (patented).
      // Bits 14-15: Reserved by PKWARE.
      FLG_MSK: 4096,
      // mask header values
      /* Load type */
      FILE: 2,
      BUFFER: 1,
      NONE: 0,
      /* 4.5 Extensible data fields */
      EF_ID: 0,
      EF_SIZE: 2,
      /* Header IDs */
      ID_ZIP64: 1,
      ID_AVINFO: 7,
      ID_PFS: 8,
      ID_OS2: 9,
      ID_NTFS: 10,
      ID_OPENVMS: 12,
      ID_UNIX: 13,
      ID_FORK: 14,
      ID_PATCH: 15,
      ID_X509_PKCS7: 20,
      ID_X509_CERTID_F: 21,
      ID_X509_CERTID_C: 22,
      ID_STRONGENC: 23,
      ID_RECORD_MGT: 24,
      ID_X509_PKCS7_RL: 25,
      ID_IBM1: 101,
      ID_IBM2: 102,
      ID_POSZIP: 18064,
      EF_ZIP64_OR_32: 4294967295,
      EF_ZIP64_OR_16: 65535,
      EF_ZIP64_SUNCOMP: 0,
      EF_ZIP64_SCOMP: 8,
      EF_ZIP64_RHO: 16,
      EF_ZIP64_DSN: 24
    };
  }
});

// node_modules/adm-zip/util/errors.js
var require_errors = __commonJS({
  "node_modules/adm-zip/util/errors.js"(exports2) {
    var errors = {
      /* Header error messages */
      INVALID_LOC: "Invalid LOC header (bad signature)",
      INVALID_CEN: "Invalid CEN header (bad signature)",
      INVALID_END: "Invalid END header (bad signature)",
      /* Descriptor */
      DESCRIPTOR_NOT_EXIST: "No descriptor present",
      DESCRIPTOR_UNKNOWN: "Unknown descriptor format",
      DESCRIPTOR_FAULTY: "Descriptor data is malformed",
      /* ZipEntry error messages*/
      NO_DATA: "Nothing to decompress",
      BAD_CRC: "CRC32 checksum failed {0}",
      FILE_IN_THE_WAY: "There is a file in the way: {0}",
      UNKNOWN_METHOD: "Invalid/unsupported compression method",
      /* Inflater error messages */
      AVAIL_DATA: "inflate::Available inflate data did not terminate",
      INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
      TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
      INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
      INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
      INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
      INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
      INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
      INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
      INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",
      /* ADM-ZIP error messages */
      CANT_EXTRACT_FILE: "Could not extract the file",
      CANT_OVERRIDE: "Target file already exists",
      DISK_ENTRY_TOO_LARGE: "Number of disk entries is too large",
      NO_ZIP: "No zip file was loaded",
      NO_ENTRY: "Entry doesn't exist",
      DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
      FILE_NOT_FOUND: 'File not found: "{0}"',
      NOT_IMPLEMENTED: "Not implemented",
      INVALID_FILENAME: "Invalid filename",
      INVALID_FORMAT: "Invalid or unsupported zip format. No END header found",
      INVALID_PASS_PARAM: "Incompatible password parameter",
      WRONG_PASSWORD: "Wrong Password",
      /* ADM-ZIP */
      COMMENT_TOO_LONG: "Comment is too long",
      // Comment can be max 65535 bytes long (NOTE: some non-US characters may take more space)
      EXTRA_FIELD_PARSE_ERROR: "Extra field parsing error"
    };
    function E(message) {
      return function(...args) {
        if (args.length) {
          message = message.replace(/\{(\d)\}/g, (_, n) => args[n] || "");
        }
        return new Error("ADM-ZIP: " + message);
      };
    }
    for (const msg of Object.keys(errors)) {
      exports2[msg] = E(errors[msg]);
    }
  }
});

// node_modules/adm-zip/util/utils.js
var require_utils = __commonJS({
  "node_modules/adm-zip/util/utils.js"(exports2, module2) {
    var fsystem = require("fs");
    var pth = require("path");
    var Constants = require_constants();
    var Errors = require_errors();
    var isWin = typeof process === "object" && "win32" === process.platform;
    var is_Obj = (obj) => typeof obj === "object" && obj !== null;
    var crcTable = new Uint32Array(256).map((t2, c) => {
      for (let k = 0; k < 8; k++) {
        if ((c & 1) !== 0) {
          c = 3988292384 ^ c >>> 1;
        } else {
          c >>>= 1;
        }
      }
      return c >>> 0;
    });
    function Utils(opts) {
      this.sep = pth.sep;
      this.fs = fsystem;
      if (is_Obj(opts)) {
        if (is_Obj(opts.fs) && typeof opts.fs.statSync === "function") {
          this.fs = opts.fs;
        }
      }
    }
    module2.exports = Utils;
    Utils.prototype.makeDir = function(folder) {
      const self2 = this;
      function mkdirSync(fpath) {
        let resolvedPath = fpath.split(self2.sep)[0];
        fpath.split(self2.sep).forEach(function(name) {
          if (!name || name.substr(-1, 1) === ":") return;
          resolvedPath += self2.sep + name;
          var stat2;
          try {
            stat2 = self2.fs.statSync(resolvedPath);
          } catch (e2) {
            self2.fs.mkdirSync(resolvedPath);
          }
          if (stat2 && stat2.isFile()) throw Errors.FILE_IN_THE_WAY(`"${resolvedPath}"`);
        });
      }
      mkdirSync(folder);
    };
    Utils.prototype.writeFileTo = function(path2, content, overwrite, attr) {
      const self2 = this;
      if (self2.fs.existsSync(path2)) {
        if (!overwrite) return false;
        var stat2 = self2.fs.statSync(path2);
        if (stat2.isDirectory()) {
          return false;
        }
      }
      var folder = pth.dirname(path2);
      if (!self2.fs.existsSync(folder)) {
        self2.makeDir(folder);
      }
      var fd;
      try {
        fd = self2.fs.openSync(path2, "w", 438);
      } catch (e2) {
        self2.fs.chmodSync(path2, 438);
        fd = self2.fs.openSync(path2, "w", 438);
      }
      if (fd) {
        try {
          self2.fs.writeSync(fd, content, 0, content.length, 0);
        } finally {
          self2.fs.closeSync(fd);
        }
      }
      self2.fs.chmodSync(path2, attr || 438);
      return true;
    };
    Utils.prototype.writeFileToAsync = function(path2, content, overwrite, attr, callback) {
      if (typeof attr === "function") {
        callback = attr;
        attr = void 0;
      }
      const self2 = this;
      self2.fs.exists(path2, function(exist) {
        if (exist && !overwrite) return callback(false);
        self2.fs.stat(path2, function(err, stat2) {
          if (exist && stat2.isDirectory()) {
            return callback(false);
          }
          var folder = pth.dirname(path2);
          self2.fs.exists(folder, function(exists) {
            if (!exists) self2.makeDir(folder);
            self2.fs.open(path2, "w", 438, function(err2, fd) {
              if (err2) {
                self2.fs.chmod(path2, 438, function() {
                  self2.fs.open(path2, "w", 438, function(err3, fd2) {
                    self2.fs.write(fd2, content, 0, content.length, 0, function() {
                      self2.fs.close(fd2, function() {
                        self2.fs.chmod(path2, attr || 438, function() {
                          callback(true);
                        });
                      });
                    });
                  });
                });
              } else if (fd) {
                self2.fs.write(fd, content, 0, content.length, 0, function() {
                  self2.fs.close(fd, function() {
                    self2.fs.chmod(path2, attr || 438, function() {
                      callback(true);
                    });
                  });
                });
              } else {
                self2.fs.chmod(path2, attr || 438, function() {
                  callback(true);
                });
              }
            });
          });
        });
      });
    };
    Utils.prototype.findFiles = function(path2) {
      const self2 = this;
      function findSync(dir, pattern, recursive) {
        if (typeof pattern === "boolean") {
          recursive = pattern;
          pattern = void 0;
        }
        let files = [];
        self2.fs.readdirSync(dir).forEach(function(file) {
          const path3 = pth.join(dir, file);
          const stat2 = self2.fs.statSync(path3);
          if (!pattern || pattern.test(path3)) {
            files.push(pth.normalize(path3) + (stat2.isDirectory() ? self2.sep : ""));
          }
          if (stat2.isDirectory() && recursive) files = files.concat(findSync(path3, pattern, recursive));
        });
        return files;
      }
      return findSync(path2, void 0, true);
    };
    Utils.prototype.findFilesAsync = function(dir, cb) {
      const self2 = this;
      let results = [];
      self2.fs.readdir(dir, function(err, list) {
        if (err) return cb(err);
        let list_length = list.length;
        if (!list_length) return cb(null, results);
        list.forEach(function(file) {
          file = pth.join(dir, file);
          self2.fs.stat(file, function(err2, stat2) {
            if (err2) return cb(err2);
            if (stat2) {
              results.push(pth.normalize(file) + (stat2.isDirectory() ? self2.sep : ""));
              if (stat2.isDirectory()) {
                self2.findFilesAsync(file, function(err3, res) {
                  if (err3) return cb(err3);
                  results = results.concat(res);
                  if (!--list_length) cb(null, results);
                });
              } else {
                if (!--list_length) cb(null, results);
              }
            }
          });
        });
      });
    };
    Utils.prototype.getAttributes = function() {
    };
    Utils.prototype.setAttributes = function() {
    };
    Utils.crc32update = function(crc, byte) {
      return crcTable[(crc ^ byte) & 255] ^ crc >>> 8;
    };
    Utils.crc32 = function(buf) {
      if (typeof buf === "string") {
        buf = Buffer.from(buf, "utf8");
      }
      let len = buf.length;
      let crc = ~0;
      for (let off = 0; off < len; ) crc = Utils.crc32update(crc, buf[off++]);
      return ~crc >>> 0;
    };
    Utils.methodToString = function(method) {
      switch (method) {
        case Constants.STORED:
          return "STORED (" + method + ")";
        case Constants.DEFLATED:
          return "DEFLATED (" + method + ")";
        default:
          return "UNSUPPORTED (" + method + ")";
      }
    };
    Utils.canonical = function(path2) {
      if (!path2) return "";
      const safeSuffix = pth.posix.normalize("/" + path2.split("\\").join("/"));
      return pth.join(".", safeSuffix);
    };
    Utils.zipnamefix = function(path2) {
      if (!path2) return "";
      const safeSuffix = pth.posix.normalize("/" + path2.split("\\").join("/"));
      return pth.posix.join(".", safeSuffix);
    };
    Utils.findLast = function(arr, callback) {
      if (!Array.isArray(arr)) throw new TypeError("arr is not array");
      const len = arr.length >>> 0;
      for (let i2 = len - 1; i2 >= 0; i2--) {
        if (callback(arr[i2], i2, arr)) {
          return arr[i2];
        }
      }
      return void 0;
    };
    Utils.sanitize = function(prefix, name) {
      prefix = pth.resolve(pth.normalize(prefix));
      var parts = name.split("/");
      for (var i2 = 0, l = parts.length; i2 < l; i2++) {
        var path2 = pth.normalize(pth.join(prefix, parts.slice(i2, l).join(pth.sep)));
        if (path2.indexOf(prefix) === 0) {
          return path2;
        }
      }
      return pth.normalize(pth.join(prefix, pth.basename(name)));
    };
    Utils.toBuffer = function toBuffer(input, encoder) {
      if (Buffer.isBuffer(input)) {
        return input;
      } else if (input instanceof Uint8Array) {
        return Buffer.from(input);
      } else {
        return typeof input === "string" ? encoder(input) : Buffer.alloc(0);
      }
    };
    Utils.readBigUInt64LE = function(buffer, index) {
      var slice = Buffer.from(buffer.slice(index, index + 8));
      slice.swap64();
      return parseInt(`0x${slice.toString("hex")}`);
    };
    Utils.fromDOS2Date = function(val) {
      return new Date((val >> 25 & 127) + 1980, Math.max((val >> 21 & 15) - 1, 0), Math.max(val >> 16 & 31, 1), val >> 11 & 31, val >> 5 & 63, (val & 31) << 1);
    };
    Utils.fromDate2DOS = function(val) {
      let date = 0;
      let time = 0;
      if (val.getFullYear() > 1979) {
        date = (val.getFullYear() - 1980 & 127) << 9 | val.getMonth() + 1 << 5 | val.getDate();
        time = val.getHours() << 11 | val.getMinutes() << 5 | val.getSeconds() >> 1;
      }
      return date << 16 | time;
    };
    Utils.isWin = isWin;
    Utils.crcTable = crcTable;
  }
});

// node_modules/adm-zip/util/fattr.js
var require_fattr = __commonJS({
  "node_modules/adm-zip/util/fattr.js"(exports2, module2) {
    var pth = require("path");
    module2.exports = function(path2, { fs: fs3 }) {
      var _path = path2 || "", _obj = newAttr(), _stat = null;
      function newAttr() {
        return {
          directory: false,
          readonly: false,
          hidden: false,
          executable: false,
          mtime: 0,
          atime: 0
        };
      }
      if (_path && fs3.existsSync(_path)) {
        _stat = fs3.statSync(_path);
        _obj.directory = _stat.isDirectory();
        _obj.mtime = _stat.mtime;
        _obj.atime = _stat.atime;
        _obj.executable = (73 & _stat.mode) !== 0;
        _obj.readonly = (128 & _stat.mode) === 0;
        _obj.hidden = pth.basename(_path)[0] === ".";
      } else {
        console.warn("Invalid path: " + _path);
      }
      return {
        get directory() {
          return _obj.directory;
        },
        get readOnly() {
          return _obj.readonly;
        },
        get hidden() {
          return _obj.hidden;
        },
        get mtime() {
          return _obj.mtime;
        },
        get atime() {
          return _obj.atime;
        },
        get executable() {
          return _obj.executable;
        },
        decodeAttributes: function() {
        },
        encodeAttributes: function() {
        },
        toJSON: function() {
          return {
            path: _path,
            isDirectory: _obj.directory,
            isReadOnly: _obj.readonly,
            isHidden: _obj.hidden,
            isExecutable: _obj.executable,
            mTime: _obj.mtime,
            aTime: _obj.atime
          };
        },
        toString: function() {
          return JSON.stringify(this.toJSON(), null, "	");
        }
      };
    };
  }
});

// node_modules/adm-zip/util/decoder.js
var require_decoder = __commonJS({
  "node_modules/adm-zip/util/decoder.js"(exports2, module2) {
    module2.exports = {
      efs: true,
      encode: (data) => Buffer.from(data, "utf8"),
      decode: (data) => data.toString("utf8")
    };
  }
});

// node_modules/adm-zip/util/index.js
var require_util = __commonJS({
  "node_modules/adm-zip/util/index.js"(exports2, module2) {
    module2.exports = require_utils();
    module2.exports.Constants = require_constants();
    module2.exports.Errors = require_errors();
    module2.exports.FileAttr = require_fattr();
    module2.exports.decoder = require_decoder();
  }
});

// node_modules/adm-zip/headers/entryHeader.js
var require_entryHeader = __commonJS({
  "node_modules/adm-zip/headers/entryHeader.js"(exports2, module2) {
    var Utils = require_util();
    var Constants = Utils.Constants;
    module2.exports = function() {
      var _verMade = 20, _version = 10, _flags = 0, _method = 0, _time = 0, _crc = 0, _compressedSize = 0, _size = 0, _fnameLen = 0, _extraLen = 0, _comLen = 0, _diskStart = 0, _inattr = 0, _attr = 0, _offset = 0;
      _verMade |= Utils.isWin ? 2560 : 768;
      _flags |= Constants.FLG_EFS;
      const _localHeader = {
        extraLen: 0
      };
      const uint32 = (val) => Math.max(0, val) >>> 0;
      const uint16 = (val) => Math.max(0, val) & 65535;
      const uint8 = (val) => Math.max(0, val) & 255;
      _time = Utils.fromDate2DOS(/* @__PURE__ */ new Date());
      return {
        get made() {
          return _verMade;
        },
        set made(val) {
          _verMade = val;
        },
        get version() {
          return _version;
        },
        set version(val) {
          _version = val;
        },
        get flags() {
          return _flags;
        },
        set flags(val) {
          _flags = val;
        },
        get flags_efs() {
          return (_flags & Constants.FLG_EFS) > 0;
        },
        set flags_efs(val) {
          if (val) {
            _flags |= Constants.FLG_EFS;
          } else {
            _flags &= ~Constants.FLG_EFS;
          }
        },
        get flags_desc() {
          return (_flags & Constants.FLG_DESC) > 0;
        },
        set flags_desc(val) {
          if (val) {
            _flags |= Constants.FLG_DESC;
          } else {
            _flags &= ~Constants.FLG_DESC;
          }
        },
        get method() {
          return _method;
        },
        set method(val) {
          switch (val) {
            case Constants.STORED:
              this.version = 10;
            case Constants.DEFLATED:
            default:
              this.version = 20;
          }
          _method = val;
        },
        get time() {
          return Utils.fromDOS2Date(this.timeval);
        },
        set time(val) {
          this.timeval = Utils.fromDate2DOS(val);
        },
        get timeval() {
          return _time;
        },
        set timeval(val) {
          _time = uint32(val);
        },
        get timeHighByte() {
          return uint8(_time >>> 8);
        },
        get crc() {
          return _crc;
        },
        set crc(val) {
          _crc = uint32(val);
        },
        get compressedSize() {
          return _compressedSize;
        },
        set compressedSize(val) {
          _compressedSize = uint32(val);
        },
        get size() {
          return _size;
        },
        set size(val) {
          _size = uint32(val);
        },
        get fileNameLength() {
          return _fnameLen;
        },
        set fileNameLength(val) {
          _fnameLen = val;
        },
        get extraLength() {
          return _extraLen;
        },
        set extraLength(val) {
          _extraLen = val;
        },
        get extraLocalLength() {
          return _localHeader.extraLen;
        },
        set extraLocalLength(val) {
          _localHeader.extraLen = val;
        },
        get commentLength() {
          return _comLen;
        },
        set commentLength(val) {
          _comLen = val;
        },
        get diskNumStart() {
          return _diskStart;
        },
        set diskNumStart(val) {
          _diskStart = uint32(val);
        },
        get inAttr() {
          return _inattr;
        },
        set inAttr(val) {
          _inattr = uint32(val);
        },
        get attr() {
          return _attr;
        },
        set attr(val) {
          _attr = uint32(val);
        },
        // get Unix file permissions
        get fileAttr() {
          return (_attr || 0) >> 16 & 4095;
        },
        get offset() {
          return _offset;
        },
        set offset(val) {
          _offset = uint32(val);
        },
        get encrypted() {
          return (_flags & Constants.FLG_ENC) === Constants.FLG_ENC;
        },
        get centralHeaderSize() {
          return Constants.CENHDR + _fnameLen + _extraLen + _comLen;
        },
        get realDataOffset() {
          return _offset + Constants.LOCHDR + _localHeader.fnameLen + _localHeader.extraLen;
        },
        get localHeader() {
          return _localHeader;
        },
        loadLocalHeaderFromBinary: function(input) {
          var data = input.slice(_offset, _offset + Constants.LOCHDR);
          if (data.readUInt32LE(0) !== Constants.LOCSIG) {
            throw Utils.Errors.INVALID_LOC();
          }
          _localHeader.version = data.readUInt16LE(Constants.LOCVER);
          _localHeader.flags = data.readUInt16LE(Constants.LOCFLG);
          _localHeader.method = data.readUInt16LE(Constants.LOCHOW);
          _localHeader.time = data.readUInt32LE(Constants.LOCTIM);
          _localHeader.crc = data.readUInt32LE(Constants.LOCCRC);
          _localHeader.compressedSize = data.readUInt32LE(Constants.LOCSIZ);
          _localHeader.size = data.readUInt32LE(Constants.LOCLEN);
          _localHeader.fnameLen = data.readUInt16LE(Constants.LOCNAM);
          _localHeader.extraLen = data.readUInt16LE(Constants.LOCEXT);
          const extraStart = _offset + Constants.LOCHDR + _localHeader.fnameLen;
          const extraEnd = extraStart + _localHeader.extraLen;
          return input.slice(extraStart, extraEnd);
        },
        loadFromBinary: function(data) {
          if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {
            throw Utils.Errors.INVALID_CEN();
          }
          _verMade = data.readUInt16LE(Constants.CENVEM);
          _version = data.readUInt16LE(Constants.CENVER);
          _flags = data.readUInt16LE(Constants.CENFLG);
          _method = data.readUInt16LE(Constants.CENHOW);
          _time = data.readUInt32LE(Constants.CENTIM);
          _crc = data.readUInt32LE(Constants.CENCRC);
          _compressedSize = data.readUInt32LE(Constants.CENSIZ);
          _size = data.readUInt32LE(Constants.CENLEN);
          _fnameLen = data.readUInt16LE(Constants.CENNAM);
          _extraLen = data.readUInt16LE(Constants.CENEXT);
          _comLen = data.readUInt16LE(Constants.CENCOM);
          _diskStart = data.readUInt16LE(Constants.CENDSK);
          _inattr = data.readUInt16LE(Constants.CENATT);
          _attr = data.readUInt32LE(Constants.CENATX);
          _offset = data.readUInt32LE(Constants.CENOFF);
        },
        localHeaderToBinary: function() {
          var data = Buffer.alloc(Constants.LOCHDR);
          data.writeUInt32LE(Constants.LOCSIG, 0);
          data.writeUInt16LE(_version, Constants.LOCVER);
          data.writeUInt16LE(_flags, Constants.LOCFLG);
          data.writeUInt16LE(_method, Constants.LOCHOW);
          data.writeUInt32LE(_time, Constants.LOCTIM);
          data.writeUInt32LE(_crc, Constants.LOCCRC);
          data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);
          data.writeUInt32LE(_size, Constants.LOCLEN);
          data.writeUInt16LE(_fnameLen, Constants.LOCNAM);
          data.writeUInt16LE(_localHeader.extraLen, Constants.LOCEXT);
          return data;
        },
        centralHeaderToBinary: function() {
          var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);
          data.writeUInt32LE(Constants.CENSIG, 0);
          data.writeUInt16LE(_verMade, Constants.CENVEM);
          data.writeUInt16LE(_version, Constants.CENVER);
          data.writeUInt16LE(_flags, Constants.CENFLG);
          data.writeUInt16LE(_method, Constants.CENHOW);
          data.writeUInt32LE(_time, Constants.CENTIM);
          data.writeUInt32LE(_crc, Constants.CENCRC);
          data.writeUInt32LE(_compressedSize, Constants.CENSIZ);
          data.writeUInt32LE(_size, Constants.CENLEN);
          data.writeUInt16LE(_fnameLen, Constants.CENNAM);
          data.writeUInt16LE(_extraLen, Constants.CENEXT);
          data.writeUInt16LE(_comLen, Constants.CENCOM);
          data.writeUInt16LE(_diskStart, Constants.CENDSK);
          data.writeUInt16LE(_inattr, Constants.CENATT);
          data.writeUInt32LE(_attr, Constants.CENATX);
          data.writeUInt32LE(_offset, Constants.CENOFF);
          return data;
        },
        toJSON: function() {
          const bytes = function(nr) {
            return nr + " bytes";
          };
          return {
            made: _verMade,
            version: _version,
            flags: _flags,
            method: Utils.methodToString(_method),
            time: this.time,
            crc: "0x" + _crc.toString(16).toUpperCase(),
            compressedSize: bytes(_compressedSize),
            size: bytes(_size),
            fileNameLength: bytes(_fnameLen),
            extraLength: bytes(_extraLen),
            commentLength: bytes(_comLen),
            diskNumStart: _diskStart,
            inAttr: _inattr,
            attr: _attr,
            offset: _offset,
            centralHeaderSize: bytes(Constants.CENHDR + _fnameLen + _extraLen + _comLen)
          };
        },
        toString: function() {
          return JSON.stringify(this.toJSON(), null, "	");
        }
      };
    };
  }
});

// node_modules/adm-zip/headers/mainHeader.js
var require_mainHeader = __commonJS({
  "node_modules/adm-zip/headers/mainHeader.js"(exports2, module2) {
    var Utils = require_util();
    var Constants = Utils.Constants;
    module2.exports = function() {
      var _volumeEntries = 0, _totalEntries = 0, _size = 0, _offset = 0, _commentLength = 0;
      return {
        get diskEntries() {
          return _volumeEntries;
        },
        set diskEntries(val) {
          _volumeEntries = _totalEntries = val;
        },
        get totalEntries() {
          return _totalEntries;
        },
        set totalEntries(val) {
          _totalEntries = _volumeEntries = val;
        },
        get size() {
          return _size;
        },
        set size(val) {
          _size = val;
        },
        get offset() {
          return _offset;
        },
        set offset(val) {
          _offset = val;
        },
        get commentLength() {
          return _commentLength;
        },
        set commentLength(val) {
          _commentLength = val;
        },
        get mainHeaderSize() {
          return Constants.ENDHDR + _commentLength;
        },
        loadFromBinary: function(data) {
          if ((data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) && (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)) {
            throw Utils.Errors.INVALID_END();
          }
          if (data.readUInt32LE(0) === Constants.ENDSIG) {
            _volumeEntries = data.readUInt16LE(Constants.ENDSUB);
            _totalEntries = data.readUInt16LE(Constants.ENDTOT);
            _size = data.readUInt32LE(Constants.ENDSIZ);
            _offset = data.readUInt32LE(Constants.ENDOFF);
            _commentLength = data.readUInt16LE(Constants.ENDCOM);
          } else {
            _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);
            _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);
            _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZE);
            _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);
            _commentLength = 0;
          }
        },
        toBinary: function() {
          var b = Buffer.alloc(Constants.ENDHDR + _commentLength);
          b.writeUInt32LE(Constants.ENDSIG, 0);
          b.writeUInt32LE(0, 4);
          b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);
          b.writeUInt16LE(_totalEntries, Constants.ENDTOT);
          b.writeUInt32LE(_size, Constants.ENDSIZ);
          b.writeUInt32LE(_offset, Constants.ENDOFF);
          b.writeUInt16LE(_commentLength, Constants.ENDCOM);
          b.fill(" ", Constants.ENDHDR);
          return b;
        },
        toJSON: function() {
          const offset = function(nr, len) {
            let offs = nr.toString(16).toUpperCase();
            while (offs.length < len) offs = "0" + offs;
            return "0x" + offs;
          };
          return {
            diskEntries: _volumeEntries,
            totalEntries: _totalEntries,
            size: _size + " bytes",
            offset: offset(_offset, 4),
            commentLength: _commentLength
          };
        },
        toString: function() {
          return JSON.stringify(this.toJSON(), null, "	");
        }
      };
    };
  }
});

// node_modules/adm-zip/headers/index.js
var require_headers = __commonJS({
  "node_modules/adm-zip/headers/index.js"(exports2) {
    exports2.EntryHeader = require_entryHeader();
    exports2.MainHeader = require_mainHeader();
  }
});

// node_modules/adm-zip/methods/deflater.js
var require_deflater = __commonJS({
  "node_modules/adm-zip/methods/deflater.js"(exports2, module2) {
    module2.exports = function(inbuf) {
      var zlib2 = require("zlib");
      var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };
      return {
        deflate: function() {
          return zlib2.deflateRawSync(inbuf, opts);
        },
        deflateAsync: function(callback) {
          var tmp = zlib2.createDeflateRaw(opts), parts = [], total = 0;
          tmp.on("data", function(data) {
            parts.push(data);
            total += data.length;
          });
          tmp.on("end", function() {
            var buf = Buffer.alloc(total), written = 0;
            buf.fill(0);
            for (var i2 = 0; i2 < parts.length; i2++) {
              var part = parts[i2];
              part.copy(buf, written);
              written += part.length;
            }
            callback && callback(buf);
          });
          tmp.end(inbuf);
        }
      };
    };
  }
});

// node_modules/adm-zip/methods/inflater.js
var require_inflater = __commonJS({
  "node_modules/adm-zip/methods/inflater.js"(exports2, module2) {
    var version = +(process.versions ? process.versions.node : "").split(".")[0] || 0;
    module2.exports = function(inbuf, expectedLength) {
      var zlib2 = require("zlib");
      const option = version >= 15 && expectedLength > 0 ? { maxOutputLength: expectedLength } : {};
      return {
        inflate: function() {
          return zlib2.inflateRawSync(inbuf, option);
        },
        inflateAsync: function(callback) {
          var tmp = zlib2.createInflateRaw(option), parts = [], total = 0;
          tmp.on("data", function(data) {
            parts.push(data);
            total += data.length;
          });
          tmp.on("end", function() {
            var buf = Buffer.alloc(total), written = 0;
            buf.fill(0);
            for (var i2 = 0; i2 < parts.length; i2++) {
              var part = parts[i2];
              part.copy(buf, written);
              written += part.length;
            }
            callback && callback(buf);
          });
          tmp.end(inbuf);
        }
      };
    };
  }
});

// node_modules/adm-zip/methods/zipcrypto.js
var require_zipcrypto = __commonJS({
  "node_modules/adm-zip/methods/zipcrypto.js"(exports2, module2) {
    "use strict";
    var { randomFillSync } = require("crypto");
    var Errors = require_errors();
    var crctable = new Uint32Array(256).map((t2, crc) => {
      for (let j = 0; j < 8; j++) {
        if (0 !== (crc & 1)) {
          crc = crc >>> 1 ^ 3988292384;
        } else {
          crc >>>= 1;
        }
      }
      return crc >>> 0;
    });
    var uMul = (a, b) => Math.imul(a, b) >>> 0;
    var crc32update = (pCrc32, bval) => {
      return crctable[(pCrc32 ^ bval) & 255] ^ pCrc32 >>> 8;
    };
    var genSalt = () => {
      if ("function" === typeof randomFillSync) {
        return randomFillSync(Buffer.alloc(12));
      } else {
        return genSalt.node();
      }
    };
    genSalt.node = () => {
      const salt = Buffer.alloc(12);
      const len = salt.length;
      for (let i2 = 0; i2 < len; i2++) salt[i2] = Math.random() * 256 & 255;
      return salt;
    };
    var config = {
      genSalt
    };
    function Initkeys(pw) {
      const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);
      this.keys = new Uint32Array([305419896, 591751049, 878082192]);
      for (let i2 = 0; i2 < pass.length; i2++) {
        this.updateKeys(pass[i2]);
      }
    }
    Initkeys.prototype.updateKeys = function(byteValue) {
      const keys = this.keys;
      keys[0] = crc32update(keys[0], byteValue);
      keys[1] += keys[0] & 255;
      keys[1] = uMul(keys[1], 134775813) + 1;
      keys[2] = crc32update(keys[2], keys[1] >>> 24);
      return byteValue;
    };
    Initkeys.prototype.next = function() {
      const k = (this.keys[2] | 2) >>> 0;
      return uMul(k, k ^ 1) >> 8 & 255;
    };
    function make_decrypter(pwd) {
      const keys = new Initkeys(pwd);
      return function(data) {
        const result = Buffer.alloc(data.length);
        let pos = 0;
        for (let c of data) {
          result[pos++] = keys.updateKeys(c ^ keys.next());
        }
        return result;
      };
    }
    function make_encrypter(pwd) {
      const keys = new Initkeys(pwd);
      return function(data, result, pos = 0) {
        if (!result) result = Buffer.alloc(data.length);
        for (let c of data) {
          const k = keys.next();
          result[pos++] = c ^ k;
          keys.updateKeys(c);
        }
        return result;
      };
    }
    function decrypt(data, header, pwd) {
      if (!data || !Buffer.isBuffer(data) || data.length < 12) {
        return Buffer.alloc(0);
      }
      const decrypter = make_decrypter(pwd);
      const salt = decrypter(data.slice(0, 12));
      const verifyByte = (header.flags & 8) === 8 ? header.timeHighByte : header.crc >>> 24;
      if (salt[11] !== verifyByte) {
        throw Errors.WRONG_PASSWORD();
      }
      return decrypter(data.slice(12));
    }
    function _salter(data) {
      if (Buffer.isBuffer(data) && data.length >= 12) {
        config.genSalt = function() {
          return data.slice(0, 12);
        };
      } else if (data === "node") {
        config.genSalt = genSalt.node;
      } else {
        config.genSalt = genSalt;
      }
    }
    function encrypt(data, header, pwd, oldlike = false) {
      if (data == null) data = Buffer.alloc(0);
      if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString());
      const encrypter = make_encrypter(pwd);
      const salt = config.genSalt();
      salt[11] = header.crc >>> 24 & 255;
      if (oldlike) salt[10] = header.crc >>> 16 & 255;
      const result = Buffer.alloc(data.length + 12);
      encrypter(salt, result);
      return encrypter(data, result, 12);
    }
    module2.exports = { decrypt, encrypt, _salter };
  }
});

// node_modules/adm-zip/methods/index.js
var require_methods = __commonJS({
  "node_modules/adm-zip/methods/index.js"(exports2) {
    exports2.Deflater = require_deflater();
    exports2.Inflater = require_inflater();
    exports2.ZipCrypto = require_zipcrypto();
  }
});

// node_modules/adm-zip/zipEntry.js
var require_zipEntry = __commonJS({
  "node_modules/adm-zip/zipEntry.js"(exports2, module2) {
    var Utils = require_util();
    var Headers2 = require_headers();
    var Constants = Utils.Constants;
    var Methods = require_methods();
    module2.exports = function(options, input) {
      var _centralHeader = new Headers2.EntryHeader(), _entryName = Buffer.alloc(0), _comment = Buffer.alloc(0), _isDirectory = false, uncompressedData = null, _extra = Buffer.alloc(0), _extralocal = Buffer.alloc(0), _efs = true;
      const opts = options;
      const decoder = typeof opts.decoder === "object" ? opts.decoder : Utils.decoder;
      _efs = decoder.hasOwnProperty("efs") ? decoder.efs : false;
      function getCompressedDataFromZip() {
        if (!input || !(input instanceof Uint8Array)) {
          return Buffer.alloc(0);
        }
        _extralocal = _centralHeader.loadLocalHeaderFromBinary(input);
        return input.slice(_centralHeader.realDataOffset, _centralHeader.realDataOffset + _centralHeader.compressedSize);
      }
      function crc32OK(data) {
        if (!_centralHeader.flags_desc) {
          if (Utils.crc32(data) !== _centralHeader.localHeader.crc) {
            return false;
          }
        } else {
          const descriptor = {};
          const dataEndOffset = _centralHeader.realDataOffset + _centralHeader.compressedSize;
          if (input.readUInt32LE(dataEndOffset) == Constants.LOCSIG || input.readUInt32LE(dataEndOffset) == Constants.CENSIG) {
            throw Utils.Errors.DESCRIPTOR_NOT_EXIST();
          }
          if (input.readUInt32LE(dataEndOffset) == Constants.EXTSIG) {
            descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC);
            descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ);
            descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN);
          } else if (input.readUInt16LE(dataEndOffset + 12) === 19280) {
            descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC - 4);
            descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ - 4);
            descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN - 4);
          } else {
            throw Utils.Errors.DESCRIPTOR_UNKNOWN();
          }
          if (descriptor.compressedSize !== _centralHeader.compressedSize || descriptor.size !== _centralHeader.size || descriptor.crc !== _centralHeader.crc) {
            throw Utils.Errors.DESCRIPTOR_FAULTY();
          }
          if (Utils.crc32(data) !== descriptor.crc) {
            return false;
          }
        }
        return true;
      }
      function decompress(async, callback, pass) {
        if (typeof callback === "undefined" && typeof async === "string") {
          pass = async;
          async = void 0;
        }
        if (_isDirectory) {
          if (async && callback) {
            callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR());
          }
          return Buffer.alloc(0);
        }
        var compressedData = getCompressedDataFromZip();
        if (compressedData.length === 0) {
          if (async && callback) callback(compressedData);
          return compressedData;
        }
        if (_centralHeader.encrypted) {
          if ("string" !== typeof pass && !Buffer.isBuffer(pass)) {
            throw Utils.Errors.INVALID_PASS_PARAM();
          }
          compressedData = Methods.ZipCrypto.decrypt(compressedData, _centralHeader, pass);
        }
        var data = Buffer.alloc(_centralHeader.size);
        switch (_centralHeader.method) {
          case Utils.Constants.STORED:
            compressedData.copy(data);
            if (!crc32OK(data)) {
              if (async && callback) callback(data, Utils.Errors.BAD_CRC());
              throw Utils.Errors.BAD_CRC();
            } else {
              if (async && callback) callback(data);
              return data;
            }
          case Utils.Constants.DEFLATED:
            var inflater = new Methods.Inflater(compressedData, _centralHeader.size);
            if (!async) {
              const result = inflater.inflate(data);
              result.copy(data, 0);
              if (!crc32OK(data)) {
                throw Utils.Errors.BAD_CRC(`"${decoder.decode(_entryName)}"`);
              }
              return data;
            } else {
              inflater.inflateAsync(function(result) {
                result.copy(result, 0);
                if (callback) {
                  if (!crc32OK(result)) {
                    callback(result, Utils.Errors.BAD_CRC());
                  } else {
                    callback(result);
                  }
                }
              });
            }
            break;
          default:
            if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD());
            throw Utils.Errors.UNKNOWN_METHOD();
        }
      }
      function compress(async, callback) {
        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {
          if (async && callback) callback(getCompressedDataFromZip());
          return getCompressedDataFromZip();
        }
        if (uncompressedData.length && !_isDirectory) {
          var compressedData;
          switch (_centralHeader.method) {
            case Utils.Constants.STORED:
              _centralHeader.compressedSize = _centralHeader.size;
              compressedData = Buffer.alloc(uncompressedData.length);
              uncompressedData.copy(compressedData);
              if (async && callback) callback(compressedData);
              return compressedData;
            default:
            case Utils.Constants.DEFLATED:
              var deflater = new Methods.Deflater(uncompressedData);
              if (!async) {
                var deflated = deflater.deflate();
                _centralHeader.compressedSize = deflated.length;
                return deflated;
              } else {
                deflater.deflateAsync(function(data) {
                  compressedData = Buffer.alloc(data.length);
                  _centralHeader.compressedSize = data.length;
                  data.copy(compressedData);
                  callback && callback(compressedData);
                });
              }
              deflater = null;
              break;
          }
        } else if (async && callback) {
          callback(Buffer.alloc(0));
        } else {
          return Buffer.alloc(0);
        }
      }
      function readUInt64LE(buffer, offset) {
        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);
      }
      function parseExtra(data) {
        try {
          var offset = 0;
          var signature, size, part;
          while (offset + 4 < data.length) {
            signature = data.readUInt16LE(offset);
            offset += 2;
            size = data.readUInt16LE(offset);
            offset += 2;
            part = data.slice(offset, offset + size);
            offset += size;
            if (Constants.ID_ZIP64 === signature) {
              parseZip64ExtendedInformation(part);
            }
          }
        } catch (error) {
          throw Utils.Errors.EXTRA_FIELD_PARSE_ERROR();
        }
      }
      function parseZip64ExtendedInformation(data) {
        var size, compressedSize, offset, diskNumStart;
        if (data.length >= Constants.EF_ZIP64_SCOMP) {
          size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);
          if (_centralHeader.size === Constants.EF_ZIP64_OR_32) {
            _centralHeader.size = size;
          }
        }
        if (data.length >= Constants.EF_ZIP64_RHO) {
          compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);
          if (_centralHeader.compressedSize === Constants.EF_ZIP64_OR_32) {
            _centralHeader.compressedSize = compressedSize;
          }
        }
        if (data.length >= Constants.EF_ZIP64_DSN) {
          offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);
          if (_centralHeader.offset === Constants.EF_ZIP64_OR_32) {
            _centralHeader.offset = offset;
          }
        }
        if (data.length >= Constants.EF_ZIP64_DSN + 4) {
          diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);
          if (_centralHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {
            _centralHeader.diskNumStart = diskNumStart;
          }
        }
      }
      return {
        get entryName() {
          return decoder.decode(_entryName);
        },
        get rawEntryName() {
          return _entryName;
        },
        set entryName(val) {
          _entryName = Utils.toBuffer(val, decoder.encode);
          var lastChar = _entryName[_entryName.length - 1];
          _isDirectory = lastChar === 47 || lastChar === 92;
          _centralHeader.fileNameLength = _entryName.length;
        },
        get efs() {
          if (typeof _efs === "function") {
            return _efs(this.entryName);
          } else {
            return _efs;
          }
        },
        get extra() {
          return _extra;
        },
        set extra(val) {
          _extra = val;
          _centralHeader.extraLength = val.length;
          parseExtra(val);
        },
        get comment() {
          return decoder.decode(_comment);
        },
        set comment(val) {
          _comment = Utils.toBuffer(val, decoder.encode);
          _centralHeader.commentLength = _comment.length;
          if (_comment.length > 65535) throw Utils.Errors.COMMENT_TOO_LONG();
        },
        get name() {
          var n = decoder.decode(_entryName);
          return _isDirectory ? n.substr(n.length - 1).split("/").pop() : n.split("/").pop();
        },
        get isDirectory() {
          return _isDirectory;
        },
        getCompressedData: function() {
          return compress(false, null);
        },
        getCompressedDataAsync: function(callback) {
          compress(true, callback);
        },
        setData: function(value) {
          uncompressedData = Utils.toBuffer(value, Utils.decoder.encode);
          if (!_isDirectory && uncompressedData.length) {
            _centralHeader.size = uncompressedData.length;
            _centralHeader.method = Utils.Constants.DEFLATED;
            _centralHeader.crc = Utils.crc32(value);
            _centralHeader.changed = true;
          } else {
            _centralHeader.method = Utils.Constants.STORED;
          }
        },
        getData: function(pass) {
          if (_centralHeader.changed) {
            return uncompressedData;
          } else {
            return decompress(false, null, pass);
          }
        },
        getDataAsync: function(callback, pass) {
          if (_centralHeader.changed) {
            callback(uncompressedData);
          } else {
            decompress(true, callback, pass);
          }
        },
        set attr(attr) {
          _centralHeader.attr = attr;
        },
        get attr() {
          return _centralHeader.attr;
        },
        set header(data) {
          _centralHeader.loadFromBinary(data);
        },
        get header() {
          return _centralHeader;
        },
        packCentralHeader: function() {
          _centralHeader.flags_efs = this.efs;
          _centralHeader.extraLength = _extra.length;
          var header = _centralHeader.centralHeaderToBinary();
          var addpos = Utils.Constants.CENHDR;
          _entryName.copy(header, addpos);
          addpos += _entryName.length;
          _extra.copy(header, addpos);
          addpos += _centralHeader.extraLength;
          _comment.copy(header, addpos);
          return header;
        },
        packLocalHeader: function() {
          let addpos = 0;
          _centralHeader.flags_efs = this.efs;
          _centralHeader.extraLocalLength = _extralocal.length;
          const localHeaderBuf = _centralHeader.localHeaderToBinary();
          const localHeader = Buffer.alloc(localHeaderBuf.length + _entryName.length + _centralHeader.extraLocalLength);
          localHeaderBuf.copy(localHeader, addpos);
          addpos += localHeaderBuf.length;
          _entryName.copy(localHeader, addpos);
          addpos += _entryName.length;
          _extralocal.copy(localHeader, addpos);
          addpos += _extralocal.length;
          return localHeader;
        },
        toJSON: function() {
          const bytes = function(nr) {
            return "<" + (nr && nr.length + " bytes buffer" || "null") + ">";
          };
          return {
            entryName: this.entryName,
            name: this.name,
            comment: this.comment,
            isDirectory: this.isDirectory,
            header: _centralHeader.toJSON(),
            compressedData: bytes(input),
            data: bytes(uncompressedData)
          };
        },
        toString: function() {
          return JSON.stringify(this.toJSON(), null, "	");
        }
      };
    };
  }
});

// node_modules/adm-zip/zipFile.js
var require_zipFile = __commonJS({
  "node_modules/adm-zip/zipFile.js"(exports2, module2) {
    var ZipEntry = require_zipEntry();
    var Headers2 = require_headers();
    var Utils = require_util();
    module2.exports = function(inBuffer, options) {
      var entryList = [], entryTable = {}, _comment = Buffer.alloc(0), mainHeader = new Headers2.MainHeader(), loadedEntries = false;
      var password = null;
      const temporary = /* @__PURE__ */ new Set();
      const opts = options;
      const { noSort, decoder } = opts;
      if (inBuffer) {
        readMainHeader(opts.readEntries);
      } else {
        loadedEntries = true;
      }
      function makeTemporaryFolders() {
        const foldersList = /* @__PURE__ */ new Set();
        for (const elem of Object.keys(entryTable)) {
          const elements = elem.split("/");
          elements.pop();
          if (!elements.length) continue;
          for (let i2 = 0; i2 < elements.length; i2++) {
            const sub = elements.slice(0, i2 + 1).join("/") + "/";
            foldersList.add(sub);
          }
        }
        for (const elem of foldersList) {
          if (!(elem in entryTable)) {
            const tempfolder = new ZipEntry(opts);
            tempfolder.entryName = elem;
            tempfolder.attr = 16;
            tempfolder.temporary = true;
            entryList.push(tempfolder);
            entryTable[tempfolder.entryName] = tempfolder;
            temporary.add(tempfolder);
          }
        }
      }
      function readEntries() {
        loadedEntries = true;
        entryTable = {};
        if (mainHeader.diskEntries > (inBuffer.length - mainHeader.offset) / Utils.Constants.CENHDR) {
          throw Utils.Errors.DISK_ENTRY_TOO_LARGE();
        }
        entryList = new Array(mainHeader.diskEntries);
        var index = mainHeader.offset;
        for (var i2 = 0; i2 < entryList.length; i2++) {
          var tmp = index, entry = new ZipEntry(opts, inBuffer);
          entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);
          entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);
          if (entry.header.extraLength) {
            entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);
          }
          if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);
          index += entry.header.centralHeaderSize;
          entryList[i2] = entry;
          entryTable[entry.entryName] = entry;
        }
        temporary.clear();
        makeTemporaryFolders();
      }
      function readMainHeader(readNow) {
        var i2 = inBuffer.length - Utils.Constants.ENDHDR, max = Math.max(0, i2 - 65535), n = max, endStart = inBuffer.length, endOffset = -1, commentEnd = 0;
        const trailingSpace = typeof opts.trailingSpace === "boolean" ? opts.trailingSpace : false;
        if (trailingSpace) max = 0;
        for (i2; i2 >= n; i2--) {
          if (inBuffer[i2] !== 80) continue;
          if (inBuffer.readUInt32LE(i2) === Utils.Constants.ENDSIG) {
            endOffset = i2;
            commentEnd = i2;
            endStart = i2 + Utils.Constants.ENDHDR;
            n = i2 - Utils.Constants.END64HDR;
            continue;
          }
          if (inBuffer.readUInt32LE(i2) === Utils.Constants.END64SIG) {
            n = max;
            continue;
          }
          if (inBuffer.readUInt32LE(i2) === Utils.Constants.ZIP64SIG) {
            endOffset = i2;
            endStart = i2 + Utils.readBigUInt64LE(inBuffer, i2 + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;
            break;
          }
        }
        if (endOffset == -1) throw Utils.Errors.INVALID_FORMAT();
        mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));
        if (mainHeader.commentLength) {
          _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);
        }
        if (readNow) readEntries();
      }
      function sortEntries() {
        if (entryList.length > 1 && !noSort) {
          entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));
        }
      }
      return {
        /**
         * Returns an array of ZipEntry objects existent in the current opened archive
         * @return Array
         */
        get entries() {
          if (!loadedEntries) {
            readEntries();
          }
          return entryList.filter((e2) => !temporary.has(e2));
        },
        /**
         * Archive comment
         * @return {String}
         */
        get comment() {
          return decoder.decode(_comment);
        },
        set comment(val) {
          _comment = Utils.toBuffer(val, decoder.encode);
          mainHeader.commentLength = _comment.length;
        },
        getEntryCount: function() {
          if (!loadedEntries) {
            return mainHeader.diskEntries;
          }
          return entryList.length;
        },
        forEach: function(callback) {
          this.entries.forEach(callback);
        },
        /**
         * Returns a reference to the entry with the given name or null if entry is inexistent
         *
         * @param entryName
         * @return ZipEntry
         */
        getEntry: function(entryName) {
          if (!loadedEntries) {
            readEntries();
          }
          return entryTable[entryName] || null;
        },
        /**
         * Adds the given entry to the entry list
         *
         * @param entry
         */
        setEntry: function(entry) {
          if (!loadedEntries) {
            readEntries();
          }
          entryList.push(entry);
          entryTable[entry.entryName] = entry;
          mainHeader.totalEntries = entryList.length;
        },
        /**
         * Removes the file with the given name from the entry list.
         *
         * If the entry is a directory, then all nested files and directories will be removed
         * @param entryName
         * @returns {void}
         */
        deleteFile: function(entryName, withsubfolders = true) {
          if (!loadedEntries) {
            readEntries();
          }
          const entry = entryTable[entryName];
          const list = this.getEntryChildren(entry, withsubfolders).map((child) => child.entryName);
          list.forEach(this.deleteEntry);
        },
        /**
         * Removes the entry with the given name from the entry list.
         *
         * @param {string} entryName
         * @returns {void}
         */
        deleteEntry: function(entryName) {
          if (!loadedEntries) {
            readEntries();
          }
          const entry = entryTable[entryName];
          const index = entryList.indexOf(entry);
          if (index >= 0) {
            entryList.splice(index, 1);
            delete entryTable[entryName];
            mainHeader.totalEntries = entryList.length;
          }
        },
        /**
         *  Iterates and returns all nested files and directories of the given entry
         *
         * @param entry
         * @return Array
         */
        getEntryChildren: function(entry, subfolders = true) {
          if (!loadedEntries) {
            readEntries();
          }
          if (typeof entry === "object") {
            if (entry.isDirectory && subfolders) {
              const list = [];
              const name = entry.entryName;
              for (const zipEntry of entryList) {
                if (zipEntry.entryName.startsWith(name)) {
                  list.push(zipEntry);
                }
              }
              return list;
            } else {
              return [entry];
            }
          }
          return [];
        },
        /**
         *  How many child elements entry has
         *
         * @param {ZipEntry} entry
         * @return {integer}
         */
        getChildCount: function(entry) {
          if (entry && entry.isDirectory) {
            const list = this.getEntryChildren(entry);
            return list.includes(entry) ? list.length - 1 : list.length;
          }
          return 0;
        },
        /**
         * Returns the zip file
         *
         * @return Buffer
         */
        compressToBuffer: function() {
          if (!loadedEntries) {
            readEntries();
          }
          sortEntries();
          const dataBlock = [];
          const headerBlocks = [];
          let totalSize = 0;
          let dindex = 0;
          mainHeader.size = 0;
          mainHeader.offset = 0;
          let totalEntries = 0;
          for (const entry of this.entries) {
            const compressedData = entry.getCompressedData();
            entry.header.offset = dindex;
            const localHeader = entry.packLocalHeader();
            const dataLength = localHeader.length + compressedData.length;
            dindex += dataLength;
            dataBlock.push(localHeader);
            dataBlock.push(compressedData);
            const centralHeader = entry.packCentralHeader();
            headerBlocks.push(centralHeader);
            mainHeader.size += centralHeader.length;
            totalSize += dataLength + centralHeader.length;
            totalEntries++;
          }
          totalSize += mainHeader.mainHeaderSize;
          mainHeader.offset = dindex;
          mainHeader.totalEntries = totalEntries;
          dindex = 0;
          const outBuffer = Buffer.alloc(totalSize);
          for (const content of dataBlock) {
            content.copy(outBuffer, dindex);
            dindex += content.length;
          }
          for (const content of headerBlocks) {
            content.copy(outBuffer, dindex);
            dindex += content.length;
          }
          const mh = mainHeader.toBinary();
          if (_comment) {
            _comment.copy(mh, Utils.Constants.ENDHDR);
          }
          mh.copy(outBuffer, dindex);
          inBuffer = outBuffer;
          loadedEntries = false;
          return outBuffer;
        },
        toAsyncBuffer: function(onSuccess, onFail, onItemStart, onItemEnd) {
          try {
            if (!loadedEntries) {
              readEntries();
            }
            sortEntries();
            const dataBlock = [];
            const centralHeaders = [];
            let totalSize = 0;
            let dindex = 0;
            let totalEntries = 0;
            mainHeader.size = 0;
            mainHeader.offset = 0;
            const compress2Buffer = function(entryLists) {
              if (entryLists.length > 0) {
                const entry = entryLists.shift();
                const name = entry.entryName + entry.extra.toString();
                if (onItemStart) onItemStart(name);
                entry.getCompressedDataAsync(function(compressedData) {
                  if (onItemEnd) onItemEnd(name);
                  entry.header.offset = dindex;
                  const localHeader = entry.packLocalHeader();
                  const dataLength = localHeader.length + compressedData.length;
                  dindex += dataLength;
                  dataBlock.push(localHeader);
                  dataBlock.push(compressedData);
                  const centalHeader = entry.packCentralHeader();
                  centralHeaders.push(centalHeader);
                  mainHeader.size += centalHeader.length;
                  totalSize += dataLength + centalHeader.length;
                  totalEntries++;
                  compress2Buffer(entryLists);
                });
              } else {
                totalSize += mainHeader.mainHeaderSize;
                mainHeader.offset = dindex;
                mainHeader.totalEntries = totalEntries;
                dindex = 0;
                const outBuffer = Buffer.alloc(totalSize);
                dataBlock.forEach(function(content) {
                  content.copy(outBuffer, dindex);
                  dindex += content.length;
                });
                centralHeaders.forEach(function(content) {
                  content.copy(outBuffer, dindex);
                  dindex += content.length;
                });
                const mh = mainHeader.toBinary();
                if (_comment) {
                  _comment.copy(mh, Utils.Constants.ENDHDR);
                }
                mh.copy(outBuffer, dindex);
                inBuffer = outBuffer;
                loadedEntries = false;
                onSuccess(outBuffer);
              }
            };
            compress2Buffer(Array.from(this.entries));
          } catch (e2) {
            onFail(e2);
          }
        }
      };
    };
  }
});

// node_modules/adm-zip/adm-zip.js
var require_adm_zip = __commonJS({
  "node_modules/adm-zip/adm-zip.js"(exports2, module2) {
    var Utils = require_util();
    var pth = require("path");
    var ZipEntry = require_zipEntry();
    var ZipFile = require_zipFile();
    var get_Bool = (...val) => Utils.findLast(val, (c) => typeof c === "boolean");
    var get_Str = (...val) => Utils.findLast(val, (c) => typeof c === "string");
    var get_Fun = (...val) => Utils.findLast(val, (c) => typeof c === "function");
    var defaultOptions = {
      // option "noSort" : if true it disables files sorting
      noSort: false,
      // read entries during load (initial loading may be slower)
      readEntries: false,
      // default method is none
      method: Utils.Constants.NONE,
      // file system
      fs: null
    };
    module2.exports = function(input, options) {
      let inBuffer = null;
      const opts = Object.assign(/* @__PURE__ */ Object.create(null), defaultOptions);
      if (input && "object" === typeof input) {
        if (!(input instanceof Uint8Array)) {
          Object.assign(opts, input);
          input = opts.input ? opts.input : void 0;
          if (opts.input) delete opts.input;
        }
        if (Buffer.isBuffer(input)) {
          inBuffer = input;
          opts.method = Utils.Constants.BUFFER;
          input = void 0;
        }
      }
      Object.assign(opts, options);
      const filetools = new Utils(opts);
      if (typeof opts.decoder !== "object" || typeof opts.decoder.encode !== "function" || typeof opts.decoder.decode !== "function") {
        opts.decoder = Utils.decoder;
      }
      if (input && "string" === typeof input) {
        if (filetools.fs.existsSync(input)) {
          opts.method = Utils.Constants.FILE;
          opts.filename = input;
          inBuffer = filetools.fs.readFileSync(input);
        } else {
          throw Utils.Errors.INVALID_FILENAME();
        }
      }
      const _zip = new ZipFile(inBuffer, opts);
      const { canonical, sanitize, zipnamefix } = Utils;
      function getEntry(entry) {
        if (entry && _zip) {
          var item;
          if (typeof entry === "string") item = _zip.getEntry(pth.posix.normalize(entry));
          if (typeof entry === "object" && typeof entry.entryName !== "undefined" && typeof entry.header !== "undefined") item = _zip.getEntry(entry.entryName);
          if (item) {
            return item;
          }
        }
        return null;
      }
      function fixPath(zipPath) {
        const { join, normalize, sep } = pth.posix;
        return join(".", normalize(sep + zipPath.split("\\").join(sep) + sep));
      }
      function filenameFilter(filterfn) {
        if (filterfn instanceof RegExp) {
          return /* @__PURE__ */ (function(rx) {
            return function(filename) {
              return rx.test(filename);
            };
          })(filterfn);
        } else if ("function" !== typeof filterfn) {
          return () => true;
        }
        return filterfn;
      }
      const relativePath = (local, entry) => {
        let lastChar = entry.slice(-1);
        lastChar = lastChar === filetools.sep ? filetools.sep : "";
        return pth.relative(local, entry) + lastChar;
      };
      return {
        /**
         * Extracts the given entry from the archive and returns the content as a Buffer object
         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
         * @param {Buffer|string} [pass] - password
         * @return Buffer or Null in case of error
         */
        readFile: function(entry, pass) {
          var item = getEntry(entry);
          return item && item.getData(pass) || null;
        },
        /**
         * Returns how many child elements has on entry (directories) on files it is always 0
         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
         * @returns {integer}
         */
        childCount: function(entry) {
          const item = getEntry(entry);
          if (item) {
            return _zip.getChildCount(item);
          }
        },
        /**
         * Asynchronous readFile
         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
         * @param {callback} callback
         *
         * @return Buffer or Null in case of error
         */
        readFileAsync: function(entry, callback) {
          var item = getEntry(entry);
          if (item) {
            item.getDataAsync(callback);
          } else {
            callback(null, "getEntry failed for:" + entry);
          }
        },
        /**
         * Extracts the given entry from the archive and returns the content as plain text in the given encoding
         * @param {ZipEntry|string} entry - ZipEntry object or String with the full path of the entry
         * @param {string} encoding - Optional. If no encoding is specified utf8 is used
         *
         * @return String
         */
        readAsText: function(entry, encoding) {
          var item = getEntry(entry);
          if (item) {
            var data = item.getData();
            if (data && data.length) {
              return data.toString(encoding || "utf8");
            }
          }
          return "";
        },
        /**
         * Asynchronous readAsText
         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
         * @param {callback} callback
         * @param {string} [encoding] - Optional. If no encoding is specified utf8 is used
         *
         * @return String
         */
        readAsTextAsync: function(entry, callback, encoding) {
          var item = getEntry(entry);
          if (item) {
            item.getDataAsync(function(data, err) {
              if (err) {
                callback(data, err);
                return;
              }
              if (data && data.length) {
                callback(data.toString(encoding || "utf8"));
              } else {
                callback("");
              }
            });
          } else {
            callback("");
          }
        },
        /**
         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
         *
         * @param {ZipEntry|string} entry
         * @returns {void}
         */
        deleteFile: function(entry, withsubfolders = true) {
          var item = getEntry(entry);
          if (item) {
            _zip.deleteFile(item.entryName, withsubfolders);
          }
        },
        /**
         * Remove the entry from the file or directory without affecting any nested entries
         *
         * @param {ZipEntry|string} entry
         * @returns {void}
         */
        deleteEntry: function(entry) {
          var item = getEntry(entry);
          if (item) {
            _zip.deleteEntry(item.entryName);
          }
        },
        /**
         * Adds a comment to the zip. The zip must be rewritten after adding the comment.
         *
         * @param {string} comment
         */
        addZipComment: function(comment) {
          _zip.comment = comment;
        },
        /**
         * Returns the zip comment
         *
         * @return String
         */
        getZipComment: function() {
          return _zip.comment || "";
        },
        /**
         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
         * The comment cannot exceed 65535 characters in length
         *
         * @param {ZipEntry} entry
         * @param {string} comment
         */
        addZipEntryComment: function(entry, comment) {
          var item = getEntry(entry);
          if (item) {
            item.comment = comment;
          }
        },
        /**
         * Returns the comment of the specified entry
         *
         * @param {ZipEntry} entry
         * @return String
         */
        getZipEntryComment: function(entry) {
          var item = getEntry(entry);
          if (item) {
            return item.comment || "";
          }
          return "";
        },
        /**
         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
         *
         * @param {ZipEntry} entry
         * @param {Buffer} content
         */
        updateFile: function(entry, content) {
          var item = getEntry(entry);
          if (item) {
            item.setData(content);
          }
        },
        /**
         * Adds a file from the disk to the archive
         *
         * @param {string} localPath File to add to zip
         * @param {string} [zipPath] Optional path inside the zip
         * @param {string} [zipName] Optional name for the file
         * @param {string} [comment] Optional file comment
         */
        addLocalFile: function(localPath2, zipPath, zipName, comment) {
          if (filetools.fs.existsSync(localPath2)) {
            zipPath = zipPath ? fixPath(zipPath) : "";
            const p = pth.win32.basename(pth.win32.normalize(localPath2));
            zipPath += zipName ? zipName : p;
            const _attr = filetools.fs.statSync(localPath2);
            const data = _attr.isFile() ? filetools.fs.readFileSync(localPath2) : Buffer.alloc(0);
            if (_attr.isDirectory()) zipPath += filetools.sep;
            this.addFile(zipPath, data, comment, _attr);
          } else {
            throw Utils.Errors.FILE_NOT_FOUND(localPath2);
          }
        },
        /**
         * Callback for showing if everything was done.
         *
         * @callback doneCallback
         * @param {Error} err - Error object
         * @param {boolean} done - was request fully completed
         */
        /**
         * Adds a file from the disk to the archive
         *
         * @param {(object|string)} options - options object, if it is string it us used as localPath.
         * @param {string} options.localPath - Local path to the file.
         * @param {string} [options.comment] - Optional file comment.
         * @param {string} [options.zipPath] - Optional path inside the zip
         * @param {string} [options.zipName] - Optional name for the file
         * @param {doneCallback} callback - The callback that handles the response.
         */
        addLocalFileAsync: function(options2, callback) {
          options2 = typeof options2 === "object" ? options2 : { localPath: options2 };
          const localPath2 = pth.resolve(options2.localPath);
          const { comment } = options2;
          let { zipPath, zipName } = options2;
          const self2 = this;
          filetools.fs.stat(localPath2, function(err, stats) {
            if (err) return callback(err, false);
            zipPath = zipPath ? fixPath(zipPath) : "";
            const p = pth.win32.basename(pth.win32.normalize(localPath2));
            zipPath += zipName ? zipName : p;
            if (stats.isFile()) {
              filetools.fs.readFile(localPath2, function(err2, data) {
                if (err2) return callback(err2, false);
                self2.addFile(zipPath, data, comment, stats);
                return setImmediate(callback, void 0, true);
              });
            } else if (stats.isDirectory()) {
              zipPath += filetools.sep;
              self2.addFile(zipPath, Buffer.alloc(0), comment, stats);
              return setImmediate(callback, void 0, true);
            }
          });
        },
        /**
         * Adds a local directory and all its nested files and directories to the archive
         *
         * @param {string} localPath - local path to the folder
         * @param {string} [zipPath] - optional path inside zip
         * @param {(RegExp|function)} [filter] - optional RegExp or Function if files match will be included.
         */
        addLocalFolder: function(localPath2, zipPath, filter) {
          filter = filenameFilter(filter);
          zipPath = zipPath ? fixPath(zipPath) : "";
          localPath2 = pth.normalize(localPath2);
          if (filetools.fs.existsSync(localPath2)) {
            const items = filetools.findFiles(localPath2);
            const self2 = this;
            if (items.length) {
              for (const filepath of items) {
                const p = pth.join(zipPath, relativePath(localPath2, filepath));
                if (filter(p)) {
                  self2.addLocalFile(filepath, pth.dirname(p));
                }
              }
            }
          } else {
            throw Utils.Errors.FILE_NOT_FOUND(localPath2);
          }
        },
        /**
         * Asynchronous addLocalFolder
         * @param {string} localPath
         * @param {callback} callback
         * @param {string} [zipPath] optional path inside zip
         * @param {RegExp|function} [filter] optional RegExp or Function if files match will
         *               be included.
         */
        addLocalFolderAsync: function(localPath2, callback, zipPath, filter) {
          filter = filenameFilter(filter);
          zipPath = zipPath ? fixPath(zipPath) : "";
          localPath2 = pth.normalize(localPath2);
          var self2 = this;
          filetools.fs.open(localPath2, "r", function(err) {
            if (err && err.code === "ENOENT") {
              callback(void 0, Utils.Errors.FILE_NOT_FOUND(localPath2));
            } else if (err) {
              callback(void 0, err);
            } else {
              var items = filetools.findFiles(localPath2);
              var i2 = -1;
              var next = function() {
                i2 += 1;
                if (i2 < items.length) {
                  var filepath = items[i2];
                  var p = relativePath(localPath2, filepath).split("\\").join("/");
                  p = p.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "");
                  if (filter(p)) {
                    filetools.fs.stat(filepath, function(er0, stats) {
                      if (er0) callback(void 0, er0);
                      if (stats.isFile()) {
                        filetools.fs.readFile(filepath, function(er1, data) {
                          if (er1) {
                            callback(void 0, er1);
                          } else {
                            self2.addFile(zipPath + p, data, "", stats);
                            next();
                          }
                        });
                      } else {
                        self2.addFile(zipPath + p + "/", Buffer.alloc(0), "", stats);
                        next();
                      }
                    });
                  } else {
                    process.nextTick(() => {
                      next();
                    });
                  }
                } else {
                  callback(true, void 0);
                }
              };
              next();
            }
          });
        },
        /**
         * Adds a local directory and all its nested files and directories to the archive
         *
         * @param {object | string} options - options object, if it is string it us used as localPath.
         * @param {string} options.localPath - Local path to the folder.
         * @param {string} [options.zipPath] - optional path inside zip.
         * @param {RegExp|function} [options.filter] - optional RegExp or Function if files match will be included.
         * @param {function|string} [options.namefix] - optional function to help fix filename
         * @param {doneCallback} callback - The callback that handles the response.
         *
         */
        addLocalFolderAsync2: function(options2, callback) {
          const self2 = this;
          options2 = typeof options2 === "object" ? options2 : { localPath: options2 };
          localPath = pth.resolve(fixPath(options2.localPath));
          let { zipPath, filter, namefix } = options2;
          if (filter instanceof RegExp) {
            filter = /* @__PURE__ */ (function(rx) {
              return function(filename) {
                return rx.test(filename);
              };
            })(filter);
          } else if ("function" !== typeof filter) {
            filter = function() {
              return true;
            };
          }
          zipPath = zipPath ? fixPath(zipPath) : "";
          if (namefix == "latin1") {
            namefix = (str) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "");
          }
          if (typeof namefix !== "function") namefix = (str) => str;
          const relPathFix = (entry) => pth.join(zipPath, namefix(relativePath(localPath, entry)));
          const fileNameFix = (entry) => pth.win32.basename(pth.win32.normalize(namefix(entry)));
          filetools.fs.open(localPath, "r", function(err) {
            if (err && err.code === "ENOENT") {
              callback(void 0, Utils.Errors.FILE_NOT_FOUND(localPath));
            } else if (err) {
              callback(void 0, err);
            } else {
              filetools.findFilesAsync(localPath, function(err2, fileEntries) {
                if (err2) return callback(err2);
                fileEntries = fileEntries.filter((dir) => filter(relPathFix(dir)));
                if (!fileEntries.length) callback(void 0, false);
                setImmediate(
                  fileEntries.reverse().reduce(function(next, entry) {
                    return function(err3, done) {
                      if (err3 || done === false) return setImmediate(next, err3, false);
                      self2.addLocalFileAsync(
                        {
                          localPath: entry,
                          zipPath: pth.dirname(relPathFix(entry)),
                          zipName: fileNameFix(entry)
                        },
                        next
                      );
                    };
                  }, callback)
                );
              });
            }
          });
        },
        /**
         * Adds a local directory and all its nested files and directories to the archive
         *
         * @param {string} localPath - path where files will be extracted
         * @param {object} props - optional properties
         * @param {string} [props.zipPath] - optional path inside zip
         * @param {RegExp|function} [props.filter] - optional RegExp or Function if files match will be included.
         * @param {function|string} [props.namefix] - optional function to help fix filename
         */
        addLocalFolderPromise: function(localPath2, props) {
          return new Promise((resolve, reject) => {
            this.addLocalFolderAsync2(Object.assign({ localPath: localPath2 }, props), (err, done) => {
              if (err) reject(err);
              if (done) resolve(this);
            });
          });
        },
        /**
         * Allows you to create a entry (file or directory) in the zip file.
         * If you want to create a directory the entryName must end in / and a null buffer should be provided.
         * Comment and attributes are optional
         *
         * @param {string} entryName
         * @param {Buffer | string} content - file content as buffer or utf8 coded string
         * @param {string} [comment] - file comment
         * @param {number | object} [attr] - number as unix file permissions, object as filesystem Stats object
         */
        addFile: function(entryName, content, comment, attr) {
          entryName = zipnamefix(entryName);
          let entry = getEntry(entryName);
          const update = entry != null;
          if (!update) {
            entry = new ZipEntry(opts);
            entry.entryName = entryName;
          }
          entry.comment = comment || "";
          const isStat = "object" === typeof attr && attr instanceof filetools.fs.Stats;
          if (isStat) {
            entry.header.time = attr.mtime;
          }
          var fileattr = entry.isDirectory ? 16 : 0;
          let unix = entry.isDirectory ? 16384 : 32768;
          if (isStat) {
            unix |= 4095 & attr.mode;
          } else if ("number" === typeof attr) {
            unix |= 4095 & attr;
          } else {
            unix |= entry.isDirectory ? 493 : 420;
          }
          fileattr = (fileattr | unix << 16) >>> 0;
          entry.attr = fileattr;
          entry.setData(content);
          if (!update) _zip.setEntry(entry);
          return entry;
        },
        /**
         * Returns an array of ZipEntry objects representing the files and folders inside the archive
         *
         * @param {string} [password]
         * @returns Array
         */
        getEntries: function(password) {
          _zip.password = password;
          return _zip ? _zip.entries : [];
        },
        /**
         * Returns a ZipEntry object representing the file or folder specified by ``name``.
         *
         * @param {string} name
         * @return ZipEntry
         */
        getEntry: function(name) {
          return getEntry(name);
        },
        getEntryCount: function() {
          return _zip.getEntryCount();
        },
        forEach: function(callback) {
          return _zip.forEach(callback);
        },
        /**
         * Extracts the given entry to the given targetPath
         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
         *
         * @param {string|ZipEntry} entry - ZipEntry object or String with the full path of the entry
         * @param {string} targetPath - Target folder where to write the file
         * @param {boolean} [maintainEntryPath=true] - If maintainEntryPath is true and the entry is inside a folder, the entry folder will be created in targetPath as well. Default is TRUE
         * @param {boolean} [overwrite=false] - If the file already exists at the target path, the file will be overwriten if this is true.
         * @param {boolean} [keepOriginalPermission=false] - The file will be set as the permission from the entry if this is true.
         * @param {string} [outFileName] - String If set will override the filename of the extracted file (Only works if the entry is a file)
         *
         * @return Boolean
         */
        extractEntryTo: function(entry, targetPath, maintainEntryPath, overwrite, keepOriginalPermission, outFileName) {
          overwrite = get_Bool(false, overwrite);
          keepOriginalPermission = get_Bool(false, keepOriginalPermission);
          maintainEntryPath = get_Bool(true, maintainEntryPath);
          outFileName = get_Str(keepOriginalPermission, outFileName);
          var item = getEntry(entry);
          if (!item) {
            throw Utils.Errors.NO_ENTRY();
          }
          var entryName = canonical(item.entryName);
          var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));
          if (item.isDirectory) {
            var children = _zip.getEntryChildren(item);
            children.forEach(function(child) {
              if (child.isDirectory) return;
              var content2 = child.getData();
              if (!content2) {
                throw Utils.Errors.CANT_EXTRACT_FILE();
              }
              var name = canonical(child.entryName);
              var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));
              const fileAttr2 = keepOriginalPermission ? child.header.fileAttr : void 0;
              filetools.writeFileTo(childName, content2, overwrite, fileAttr2);
            });
            return true;
          }
          var content = item.getData(_zip.password);
          if (!content) throw Utils.Errors.CANT_EXTRACT_FILE();
          if (filetools.fs.existsSync(target) && !overwrite) {
            throw Utils.Errors.CANT_OVERRIDE();
          }
          const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
          filetools.writeFileTo(target, content, overwrite, fileAttr);
          return true;
        },
        /**
         * Test the archive
         * @param {string} [pass]
         */
        test: function(pass) {
          if (!_zip) {
            return false;
          }
          for (var entry in _zip.entries) {
            try {
              if (entry.isDirectory) {
                continue;
              }
              var content = _zip.entries[entry].getData(pass);
              if (!content) {
                return false;
              }
            } catch (err) {
              return false;
            }
          }
          return true;
        },
        /**
         * Extracts the entire archive to the given location
         *
         * @param {string} targetPath Target location
         * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
         *                  Default is FALSE
         * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
         *                  Default is FALSE
         * @param {string|Buffer} [pass] password
         */
        extractAllTo: function(targetPath, overwrite, keepOriginalPermission, pass) {
          keepOriginalPermission = get_Bool(false, keepOriginalPermission);
          pass = get_Str(keepOriginalPermission, pass);
          overwrite = get_Bool(false, overwrite);
          if (!_zip) throw Utils.Errors.NO_ZIP();
          _zip.entries.forEach(function(entry) {
            var entryName = sanitize(targetPath, canonical(entry.entryName));
            if (entry.isDirectory) {
              filetools.makeDir(entryName);
              return;
            }
            var content = entry.getData(pass);
            if (!content) {
              throw Utils.Errors.CANT_EXTRACT_FILE();
            }
            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
            filetools.writeFileTo(entryName, content, overwrite, fileAttr);
            try {
              filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);
            } catch (err) {
              throw Utils.Errors.CANT_EXTRACT_FILE();
            }
          });
        },
        /**
         * Asynchronous extractAllTo
         *
         * @param {string} targetPath Target location
         * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
         *                  Default is FALSE
         * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
         *                  Default is FALSE
         * @param {function} callback The callback will be executed when all entries are extracted successfully or any error is thrown.
         */
        extractAllToAsync: function(targetPath, overwrite, keepOriginalPermission, callback) {
          callback = get_Fun(overwrite, keepOriginalPermission, callback);
          keepOriginalPermission = get_Bool(false, keepOriginalPermission);
          overwrite = get_Bool(false, overwrite);
          if (!callback) {
            return new Promise((resolve, reject) => {
              this.extractAllToAsync(targetPath, overwrite, keepOriginalPermission, function(err) {
                if (err) {
                  reject(err);
                } else {
                  resolve(this);
                }
              });
            });
          }
          if (!_zip) {
            callback(Utils.Errors.NO_ZIP());
            return;
          }
          targetPath = pth.resolve(targetPath);
          const getPath = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName)));
          const getError = (msg, file) => new Error(msg + ': "' + file + '"');
          const dirEntries = [];
          const fileEntries = [];
          _zip.entries.forEach((e2) => {
            if (e2.isDirectory) {
              dirEntries.push(e2);
            } else {
              fileEntries.push(e2);
            }
          });
          for (const entry of dirEntries) {
            const dirPath = getPath(entry);
            const dirAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
            try {
              filetools.makeDir(dirPath);
              if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr);
              filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);
            } catch (er) {
              callback(getError("Unable to create folder", dirPath));
            }
          }
          fileEntries.reverse().reduce(function(next, entry) {
            return function(err) {
              if (err) {
                next(err);
              } else {
                const entryName = pth.normalize(canonical(entry.entryName));
                const filePath = sanitize(targetPath, entryName);
                entry.getDataAsync(function(content, err_1) {
                  if (err_1) {
                    next(err_1);
                  } else if (!content) {
                    next(Utils.Errors.CANT_EXTRACT_FILE());
                  } else {
                    const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
                    filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function(succ) {
                      if (!succ) {
                        next(getError("Unable to write file", filePath));
                      }
                      filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function(err_2) {
                        if (err_2) {
                          next(getError("Unable to set times", filePath));
                        } else {
                          next();
                        }
                      });
                    });
                  }
                });
              }
            };
          }, callback)();
        },
        /**
         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
         *
         * @param {string} targetFileName
         * @param {function} callback
         */
        writeZip: function(targetFileName, callback) {
          if (arguments.length === 1) {
            if (typeof targetFileName === "function") {
              callback = targetFileName;
              targetFileName = "";
            }
          }
          if (!targetFileName && opts.filename) {
            targetFileName = opts.filename;
          }
          if (!targetFileName) return;
          var zipData = _zip.compressToBuffer();
          if (zipData) {
            var ok = filetools.writeFileTo(targetFileName, zipData, true);
            if (typeof callback === "function") callback(!ok ? new Error("failed") : null, "");
          }
        },
        /**
                 *
                 * @param {string} targetFileName
                 * @param {object} [props]
                 * @param {boolean} [props.overwrite=true] If the file already exists at the target path, the file will be overwriten if this is true.
                 * @param {boolean} [props.perm] The file will be set as the permission from the entry if this is true.
        
                 * @returns {Promise<void>}
                 */
        writeZipPromise: function(targetFileName, props) {
          const { overwrite, perm } = Object.assign({ overwrite: true }, props);
          return new Promise((resolve, reject) => {
            if (!targetFileName && opts.filename) targetFileName = opts.filename;
            if (!targetFileName) reject("ADM-ZIP: ZIP File Name Missing");
            this.toBufferPromise().then((zipData) => {
              const ret = (done) => done ? resolve(done) : reject("ADM-ZIP: Wasn't able to write zip file");
              filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);
            }, reject);
          });
        },
        /**
         * @returns {Promise<Buffer>} A promise to the Buffer.
         */
        toBufferPromise: function() {
          return new Promise((resolve, reject) => {
            _zip.toAsyncBuffer(resolve, reject);
          });
        },
        /**
         * Returns the content of the entire zip file as a Buffer object
         *
         * @prop {function} [onSuccess]
         * @prop {function} [onFail]
         * @prop {function} [onItemStart]
         * @prop {function} [onItemEnd]
         * @returns {Buffer}
         */
        toBuffer: function(onSuccess, onFail, onItemStart, onItemEnd) {
          if (typeof onSuccess === "function") {
            _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);
            return null;
          }
          return _zip.compressToBuffer();
        }
      };
    };
  }
});

// src/set-defaults.tsx
var set_defaults_exports = {};
__export(set_defaults_exports, {
  default: () => SetDefaults
});
module.exports = __toCommonJS(set_defaults_exports);
var import_react = require("react");
var import_api3 = require("@raycast/api");

// src/lib/gtfsStatic.ts
var import_promises = __toESM(require("fs/promises"));
var import_path = __toESM(require("path"));
var import_os = __toESM(require("os"));

// node_modules/node-fetch/src/index.js
var import_node_http2 = __toESM(require("node:http"), 1);
var import_node_https = __toESM(require("node:https"), 1);
var import_node_zlib = __toESM(require("node:zlib"), 1);
var import_node_stream2 = __toESM(require("node:stream"), 1);
var import_node_buffer2 = require("node:buffer");

// node_modules/data-uri-to-buffer/dist/index.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base64 = true;
    } else if (meta[i2]) {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var dist_default = dataUriToBuffer;

// node_modules/node-fetch/src/body.js
var import_node_stream = __toESM(require("node:stream"), 1);
var import_node_util = require("node:util");
var import_node_buffer = require("node:buffer");
init_fetch_blob();
init_esm_min();

// node_modules/node-fetch/src/errors/base.js
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};

// node_modules/node-fetch/src/errors/fetch-error.js
var FetchError = class extends FetchBaseError {
  /**
   * @param  {string} message -      Error message for human
   * @param  {string} [type] -        Error type for machine
   * @param  {SystemError} [systemError] - For Node.js system error
   */
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};

// node_modules/node-fetch/src/utils/is.js
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob = (object) => {
  return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
var isAbortSignal = (object) => {
  return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
};
var isDomainOrSubdomain = (destination, original) => {
  const orig = new URL(original).hostname;
  const dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
};
var isSameProtocol = (destination, original) => {
  const orig = new URL(original).protocol;
  const dest = new URL(destination).protocol;
  return orig === dest;
};

// node_modules/node-fetch/src/body.js
var pipeline = (0, import_node_util.promisify)(import_node_stream.default.pipeline);
var INTERNALS = Symbol("Body internals");
var Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = import_node_buffer.Buffer.from(body.toString());
    } else if (isBlob(body)) {
    } else if (import_node_buffer.Buffer.isBuffer(body)) {
    } else if (import_node_util.types.isAnyArrayBuffer(body)) {
      body = import_node_buffer.Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = import_node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_node_stream.default) {
    } else if (body instanceof FormData) {
      body = formDataToBlob(body);
      boundary = body.type.split("=")[1];
    } else {
      body = import_node_buffer.Buffer.from(String(body));
    }
    let stream = body;
    if (import_node_buffer.Buffer.isBuffer(body)) {
      stream = import_node_stream.default.Readable.from(body);
    } else if (isBlob(body)) {
      stream = import_node_stream.default.Readable.from(body.stream());
    }
    this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof import_node_stream.default) {
      body.on("error", (error_) => {
        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
        this[INTERNALS].error = error;
      });
    }
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  /**
   * Decode response as ArrayBuffer
   *
   * @return  Promise
   */
  async arrayBuffer() {
    const { buffer, byteOffset, byteLength } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    const ct = this.headers.get("content-type");
    if (ct.startsWith("application/x-www-form-urlencoded")) {
      const formData = new FormData();
      const parameters = new URLSearchParams(await this.text());
      for (const [name, value] of parameters) {
        formData.append(name, value);
      }
      return formData;
    }
    const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
    return toFormData2(this.body, ct);
  }
  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "";
    const buf = await this.arrayBuffer();
    return new fetch_blob_default([buf], {
      type: ct
    });
  }
  /**
   * Decode response as json
   *
   * @return  Promise
   */
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  /**
   * Decode response as text
   *
   * @return  Promise
   */
  async text() {
    const buffer = await consumeBody(this);
    return new TextDecoder().decode(buffer);
  }
  /**
   * Decode response as buffer (non-spec api)
   *
   * @return  Promise
   */
  buffer() {
    return consumeBody(this);
  }
};
Body.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true },
  data: { get: (0, import_node_util.deprecate)(
    () => {
    },
    "data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
    "https://github.com/node-fetch/node-fetch/issues/1000 (response)"
  ) }
});
async function consumeBody(data) {
  if (data[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS].disturbed = true;
  if (data[INTERNALS].error) {
    throw data[INTERNALS].error;
  }
  const { body } = data;
  if (body === null) {
    return import_node_buffer.Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream.default)) {
    return import_node_buffer.Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error);
        throw error;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error) {
    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return import_node_buffer.Buffer.from(accum.join(""));
      }
      return import_node_buffer.Buffer.concat(accum, accumBytes);
    } catch (error) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let { body } = instance[INTERNALS];
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_node_stream.default && typeof body.getBoundary !== "function") {
    p1 = new import_node_stream.PassThrough({ highWaterMark });
    p2 = new import_node_stream.PassThrough({ highWaterMark });
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].stream = p1;
    body = p2;
  }
  return body;
};
var getNonSpecFormDataBoundary = (0, import_node_util.deprecate)(
  (body) => body.getBoundary(),
  "form-data doesn't follow the spec and requires special treatment. Use alternative package",
  "https://github.com/node-fetch/node-fetch/issues/1167"
);
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (import_node_buffer.Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body instanceof FormData) {
    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
  }
  if (body instanceof import_node_stream.default) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const { body } = request[INTERNALS];
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (import_node_buffer.Buffer.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  return null;
};
var writeToStream = async (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else {
    await pipeline(body, dest);
  }
};

// node_modules/node-fetch/src/headers.js
var import_node_util2 = require("node:util");
var import_node_http = __toESM(require("node:http"), 1);
var validateHeaderName = typeof import_node_http.default.validateHeaderName === "function" ? import_node_http.default.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
    throw error;
  }
};
var validateHeaderValue = typeof import_node_http.default.validateHeaderValue === "function" ? import_node_http.default.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const error = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
    throw error;
  }
};
var Headers = class _Headers extends URLSearchParams {
  /**
   * Headers class
   *
   * @constructor
   * @param {HeadersInit} [init] - Response headers
   */
  constructor(init) {
    let result = [];
    if (init instanceof _Headers) {
      const raw = init.raw();
      for (const [name, values] of Object.entries(raw)) {
        result.push(...values.map((value) => [name, value]));
      }
    } else if (init == null) {
    } else if (typeof init === "object" && !import_node_util2.types.isBoxedPrimitive(init)) {
      const method = init[Symbol.iterator];
      if (method == null) {
        result.push(...Object.entries(init));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result = [...init].map((pair) => {
          if (typeof pair !== "object" || import_node_util2.types.isBoxedPrimitive(pair)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair];
        }).map((pair) => {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : void 0;
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(
                target,
                String(name).toLowerCase(),
                String(value)
              );
            };
          case "delete":
          case "has":
          case "getAll":
            return (name) => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(
                target,
                String(name).toLowerCase()
              );
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback, thisArg = void 0) {
    for (const name of this.keys()) {
      Reflect.apply(callback, thisArg, [this.get(name), name, this]);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }
  /**
   * @type {() => IterableIterator<[string, string]>}
   */
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Node-fetch non-spec method
   * returning all headers and their values as array
   * @returns {Record<string, string[]>}
   */
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }
  /**
   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
};
Object.defineProperties(
  Headers.prototype,
  ["get", "entries", "forEach", "values"].reduce((result, property) => {
    result[property] = { enumerable: true };
    return result;
  }, {})
);
function fromRawHeaders(headers = []) {
  return new Headers(
    headers.reduce((result, value, index, array) => {
      if (index % 2 === 0) {
        result.push(array.slice(index, index + 2));
      }
      return result;
    }, []).filter(([name, value]) => {
      try {
        validateHeaderName(name);
        validateHeaderValue(name, String(value));
        return true;
      } catch {
        return false;
      }
    })
  );
}

// node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};

// node_modules/node-fetch/src/response.js
var INTERNALS2 = Symbol("Response internals");
var Response = class _Response extends Body {
  constructor(body = null, options = {}) {
    super(body, options);
    const status = options.status != null ? options.status : 200;
    const headers = new Headers(options.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body, this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS2] = {
      type: "default",
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get type() {
    return this[INTERNALS2].type;
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  /**
   * Clone this response
   *
   * @return  Response
   */
  clone() {
    return new _Response(clone(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
    });
  }
  /**
   * @param {string} url    The URL that the new response is to originate from.
   * @param {number} status An optional status code for the response (e.g., 302.)
   * @returns {Response}    A Response object.
   */
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new _Response(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  static error() {
    const response = new _Response(null, { status: 0, statusText: "" });
    response[INTERNALS2].type = "error";
    return response;
  }
  static json(data = void 0, init = {}) {
    const body = JSON.stringify(data);
    if (body === void 0) {
      throw new TypeError("data is not JSON serializable");
    }
    const headers = new Headers(init && init.headers);
    if (!headers.has("content-type")) {
      headers.set("content-type", "application/json");
    }
    return new _Response(body, {
      ...init,
      headers
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response.prototype, {
  type: { enumerable: true },
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});

// node_modules/node-fetch/src/request.js
var import_node_url = require("node:url");
var import_node_util3 = require("node:util");

// node_modules/node-fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// node_modules/node-fetch/src/utils/referrer.js
var import_node_net = require("node:net");
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
var ReferrerPolicy = /* @__PURE__ */ new Set([
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
]);
var DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_node_net.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (url.host === "localhost" || url.host.endsWith(".localhost")) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}

// node_modules/node-fetch/src/request.js
var INTERNALS3 = Symbol("Request internals");
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS3] === "object";
};
var doBadDataWarn = (0, import_node_util3.deprecate)(
  () => {
  },
  ".data is not a valid RequestInit property, use .body instead",
  "https://github.com/node-fetch/node-fetch/issues/1000 (request)"
);
var Request = class _Request extends Body {
  constructor(input, init = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    if (parsedURL.username !== "" || parsedURL.password !== "") {
      throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
    }
    let method = init.method || input.method || "GET";
    if (/^(delete|get|head|options|post|put)$/i.test(method)) {
      method = method.toUpperCase();
    }
    if (!isRequest(init) && "data" in init) {
      doBadDataWarn();
    }
    if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init.size || input.size || 0
    });
    const headers = new Headers(init.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers.set("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init) {
      signal = init.signal;
    }
    if (signal != null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
    }
    let referrer = init.referrer == null ? input.referrer : init.referrer;
    if (referrer === "") {
      referrer = "no-referrer";
    } else if (referrer) {
      const parsedReferrer = new URL(referrer);
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
    } else {
      referrer = void 0;
    }
    this[INTERNALS3] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal,
      referrer
    };
    this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow;
    this.compress = init.compress === void 0 ? input.compress === void 0 ? true : input.compress : init.compress;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
    this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
  }
  /** @returns {string} */
  get method() {
    return this[INTERNALS3].method;
  }
  /** @returns {string} */
  get url() {
    return (0, import_node_url.format)(this[INTERNALS3].parsedURL);
  }
  /** @returns {Headers} */
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  /** @returns {AbortSignal} */
  get signal() {
    return this[INTERNALS3].signal;
  }
  // https://fetch.spec.whatwg.org/#dom-request-referrer
  get referrer() {
    if (this[INTERNALS3].referrer === "no-referrer") {
      return "";
    }
    if (this[INTERNALS3].referrer === "client") {
      return "about:client";
    }
    if (this[INTERNALS3].referrer) {
      return this[INTERNALS3].referrer.toString();
    }
    return void 0;
  }
  get referrerPolicy() {
    return this[INTERNALS3].referrerPolicy;
  }
  set referrerPolicy(referrerPolicy) {
    this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
  }
  /**
   * Clone this request
   *
   * @return  Request
   */
  clone() {
    return new _Request(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true },
  referrer: { enumerable: true },
  referrerPolicy: { enumerable: true }
});
var getNodeRequestOptions = (request) => {
  const { parsedURL } = request[INTERNALS3];
  const headers = new Headers(request[INTERNALS3].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (request.referrerPolicy === "") {
    request.referrerPolicy = DEFAULT_REFERRER_POLICY;
  }
  if (request.referrer && request.referrer !== "no-referrer") {
    request[INTERNALS3].referrer = determineRequestsReferrer(request);
  } else {
    request[INTERNALS3].referrer = "no-referrer";
  }
  if (request[INTERNALS3].referrer instanceof URL) {
    headers.set("Referer", request.referrer);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip, deflate, br");
  }
  let { agent } = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  const search = getSearch(parsedURL);
  const options = {
    // Overwrite search to retain trailing ? (issue #776)
    path: parsedURL.pathname + search,
    // The following options are not expressed in the URL
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return {
    /** @type {URL} */
    parsedURL,
    options
  };
};

// node_modules/node-fetch/src/errors/abort-error.js
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};

// node_modules/node-fetch/src/index.js
init_esm_min();
init_from();
var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
async function fetch(url, options_) {
  return new Promise((resolve, reject) => {
    const request = new Request(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dist_default(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http2.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error = new AbortError("The operation was aborted.");
      reject(error);
      if (request.body && request.body instanceof import_node_stream2.default.Readable) {
        request.body.destroy(error);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error) => {
      if (response && response.body) {
        response.body.destroy(error);
      }
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error = new Error("Premature close");
            error.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request.url);
        } catch {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOptions.headers.delete(name);
              }
            }
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream2.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error) => {
        if (error) {
          reject(error);
        }
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error) => {
          if (error) {
            reject(error);
          }
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflate(), (error) => {
              if (error) {
                reject(error);
              }
            });
          } else {
            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflateRaw(), (error) => {
              if (error) {
                reject(error);
              }
            });
          }
          response = new Response(body, responseOptions);
          resolve(response);
        });
        raw.once("end", () => {
          if (!response) {
            response = new Response(body, responseOptions);
            resolve(response);
          }
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve(response);
    });
    writeToStream(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = import_node_buffer2.Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error);
      }
    };
    const onData = (buf) => {
      properLastChunkReceived = import_node_buffer2.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = import_node_buffer2.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && import_node_buffer2.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    request.on("close", () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    });
  });
}

// src/lib/gtfsStatic.ts
var import_adm_zip = __toESM(require_adm_zip());

// node_modules/csv-parse/lib/api/CsvError.js
var CsvError = class _CsvError extends Error {
  constructor(code, message, options, ...contexts) {
    if (Array.isArray(message)) message = message.join(" ").trim();
    super(message);
    if (Error.captureStackTrace !== void 0) {
      Error.captureStackTrace(this, _CsvError);
    }
    this.code = code;
    for (const context of contexts) {
      for (const key in context) {
        const value = context[key];
        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));
      }
    }
  }
};

// node_modules/csv-parse/lib/utils/is_object.js
var is_object = function(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};

// node_modules/csv-parse/lib/api/normalize_columns_array.js
var normalize_columns_array = function(columns) {
  const normalizedColumns = [];
  for (let i2 = 0, l = columns.length; i2 < l; i2++) {
    const column = columns[i2];
    if (column === void 0 || column === null || column === false) {
      normalizedColumns[i2] = { disabled: true };
    } else if (typeof column === "string") {
      normalizedColumns[i2] = { name: column };
    } else if (is_object(column)) {
      if (typeof column.name !== "string") {
        throw new CsvError("CSV_OPTION_COLUMNS_MISSING_NAME", [
          "Option columns missing name:",
          `property "name" is required at position ${i2}`,
          "when column is an object literal"
        ]);
      }
      normalizedColumns[i2] = column;
    } else {
      throw new CsvError("CSV_INVALID_COLUMN_DEFINITION", [
        "Invalid column definition:",
        "expect a string or a literal object,",
        `got ${JSON.stringify(column)} at position ${i2}`
      ]);
    }
  }
  return normalizedColumns;
};

// node_modules/csv-parse/lib/utils/ResizeableBuffer.js
var ResizeableBuffer = class {
  constructor(size = 100) {
    this.size = size;
    this.length = 0;
    this.buf = Buffer.allocUnsafe(size);
  }
  prepend(val) {
    if (Buffer.isBuffer(val)) {
      const length = this.length + val.length;
      if (length >= this.size) {
        this.resize();
        if (length >= this.size) {
          throw Error("INVALID_BUFFER_STATE");
        }
      }
      const buf = this.buf;
      this.buf = Buffer.allocUnsafe(this.size);
      val.copy(this.buf, 0);
      buf.copy(this.buf, val.length);
      this.length += val.length;
    } else {
      const length = this.length++;
      if (length === this.size) {
        this.resize();
      }
      const buf = this.clone();
      this.buf[0] = val;
      buf.copy(this.buf, 1, 0, length);
    }
  }
  append(val) {
    const length = this.length++;
    if (length === this.size) {
      this.resize();
    }
    this.buf[length] = val;
  }
  clone() {
    return Buffer.from(this.buf.slice(0, this.length));
  }
  resize() {
    const length = this.length;
    this.size = this.size * 2;
    const buf = Buffer.allocUnsafe(this.size);
    this.buf.copy(buf, 0, 0, length);
    this.buf = buf;
  }
  toString(encoding) {
    if (encoding) {
      return this.buf.slice(0, this.length).toString(encoding);
    } else {
      return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
    }
  }
  toJSON() {
    return this.toString("utf8");
  }
  reset() {
    this.length = 0;
  }
};
var ResizeableBuffer_default = ResizeableBuffer;

// node_modules/csv-parse/lib/api/init_state.js
var np = 12;
var cr = 13;
var nl = 10;
var space = 32;
var tab = 9;
var init_state = function(options) {
  return {
    bomSkipped: false,
    bufBytesStart: 0,
    castField: options.cast_function,
    commenting: false,
    // Current error encountered by a record
    error: void 0,
    enabled: options.from_line === 1,
    escaping: false,
    escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,
    // columns can be `false`, `true`, `Array`
    expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : void 0,
    field: new ResizeableBuffer_default(20),
    firstLineToHeaders: options.cast_first_line_to_header,
    needMoreDataSize: Math.max(
      // Skip if the remaining buffer smaller than comment
      options.comment !== null ? options.comment.length : 0,
      ...options.delimiter.map((delimiter) => delimiter.length),
      // Skip if the remaining buffer can be escape sequence
      options.quote !== null ? options.quote.length : 0
    ),
    previousBuf: void 0,
    quoting: false,
    stop: false,
    rawBuffer: new ResizeableBuffer_default(100),
    record: [],
    recordHasError: false,
    record_length: 0,
    recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 0 : Math.max(...options.record_delimiter.map((v) => v.length)),
    trimChars: [
      Buffer.from(" ", options.encoding)[0],
      Buffer.from("	", options.encoding)[0]
    ],
    wasQuoting: false,
    wasRowDelimiter: false,
    timchars: [
      Buffer.from(Buffer.from([cr], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([nl], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([np], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([space], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([tab], "utf8").toString(), options.encoding)
    ]
  };
};

// node_modules/csv-parse/lib/utils/underscore.js
var underscore = function(str) {
  return str.replace(/([A-Z])/g, function(_, match) {
    return "_" + match.toLowerCase();
  });
};

// node_modules/csv-parse/lib/api/normalize_options.js
var normalize_options = function(opts) {
  const options = {};
  for (const opt in opts) {
    options[underscore(opt)] = opts[opt];
  }
  if (options.encoding === void 0 || options.encoding === true) {
    options.encoding = "utf8";
  } else if (options.encoding === null || options.encoding === false) {
    options.encoding = null;
  } else if (typeof options.encoding !== "string" && options.encoding !== null) {
    throw new CsvError(
      "CSV_INVALID_OPTION_ENCODING",
      [
        "Invalid option encoding:",
        "encoding must be a string or null to return a buffer,",
        `got ${JSON.stringify(options.encoding)}`
      ],
      options
    );
  }
  if (options.bom === void 0 || options.bom === null || options.bom === false) {
    options.bom = false;
  } else if (options.bom !== true) {
    throw new CsvError(
      "CSV_INVALID_OPTION_BOM",
      [
        "Invalid option bom:",
        "bom must be true,",
        `got ${JSON.stringify(options.bom)}`
      ],
      options
    );
  }
  options.cast_function = null;
  if (options.cast === void 0 || options.cast === null || options.cast === false || options.cast === "") {
    options.cast = void 0;
  } else if (typeof options.cast === "function") {
    options.cast_function = options.cast;
    options.cast = true;
  } else if (options.cast !== true) {
    throw new CsvError(
      "CSV_INVALID_OPTION_CAST",
      [
        "Invalid option cast:",
        "cast must be true or a function,",
        `got ${JSON.stringify(options.cast)}`
      ],
      options
    );
  }
  if (options.cast_date === void 0 || options.cast_date === null || options.cast_date === false || options.cast_date === "") {
    options.cast_date = false;
  } else if (options.cast_date === true) {
    options.cast_date = function(value) {
      const date = Date.parse(value);
      return !isNaN(date) ? new Date(date) : value;
    };
  } else if (typeof options.cast_date !== "function") {
    throw new CsvError(
      "CSV_INVALID_OPTION_CAST_DATE",
      [
        "Invalid option cast_date:",
        "cast_date must be true or a function,",
        `got ${JSON.stringify(options.cast_date)}`
      ],
      options
    );
  }
  options.cast_first_line_to_header = null;
  if (options.columns === true) {
    options.cast_first_line_to_header = void 0;
  } else if (typeof options.columns === "function") {
    options.cast_first_line_to_header = options.columns;
    options.columns = true;
  } else if (Array.isArray(options.columns)) {
    options.columns = normalize_columns_array(options.columns);
  } else if (options.columns === void 0 || options.columns === null || options.columns === false) {
    options.columns = false;
  } else {
    throw new CsvError(
      "CSV_INVALID_OPTION_COLUMNS",
      [
        "Invalid option columns:",
        "expect an array, a function or true,",
        `got ${JSON.stringify(options.columns)}`
      ],
      options
    );
  }
  if (options.group_columns_by_name === void 0 || options.group_columns_by_name === null || options.group_columns_by_name === false) {
    options.group_columns_by_name = false;
  } else if (options.group_columns_by_name !== true) {
    throw new CsvError(
      "CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",
      [
        "Invalid option group_columns_by_name:",
        "expect an boolean,",
        `got ${JSON.stringify(options.group_columns_by_name)}`
      ],
      options
    );
  } else if (options.columns === false) {
    throw new CsvError(
      "CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",
      [
        "Invalid option group_columns_by_name:",
        "the `columns` mode must be activated."
      ],
      options
    );
  }
  if (options.comment === void 0 || options.comment === null || options.comment === false || options.comment === "") {
    options.comment = null;
  } else {
    if (typeof options.comment === "string") {
      options.comment = Buffer.from(options.comment, options.encoding);
    }
    if (!Buffer.isBuffer(options.comment)) {
      throw new CsvError(
        "CSV_INVALID_OPTION_COMMENT",
        [
          "Invalid option comment:",
          "comment must be a buffer or a string,",
          `got ${JSON.stringify(options.comment)}`
        ],
        options
      );
    }
  }
  if (options.comment_no_infix === void 0 || options.comment_no_infix === null || options.comment_no_infix === false) {
    options.comment_no_infix = false;
  } else if (options.comment_no_infix !== true) {
    throw new CsvError(
      "CSV_INVALID_OPTION_COMMENT",
      [
        "Invalid option comment_no_infix:",
        "value must be a boolean,",
        `got ${JSON.stringify(options.comment_no_infix)}`
      ],
      options
    );
  }
  const delimiter_json = JSON.stringify(options.delimiter);
  if (!Array.isArray(options.delimiter))
    options.delimiter = [options.delimiter];
  if (options.delimiter.length === 0) {
    throw new CsvError(
      "CSV_INVALID_OPTION_DELIMITER",
      [
        "Invalid option delimiter:",
        "delimiter must be a non empty string or buffer or array of string|buffer,",
        `got ${delimiter_json}`
      ],
      options
    );
  }
  options.delimiter = options.delimiter.map(function(delimiter) {
    if (delimiter === void 0 || delimiter === null || delimiter === false) {
      return Buffer.from(",", options.encoding);
    }
    if (typeof delimiter === "string") {
      delimiter = Buffer.from(delimiter, options.encoding);
    }
    if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {
      throw new CsvError(
        "CSV_INVALID_OPTION_DELIMITER",
        [
          "Invalid option delimiter:",
          "delimiter must be a non empty string or buffer or array of string|buffer,",
          `got ${delimiter_json}`
        ],
        options
      );
    }
    return delimiter;
  });
  if (options.escape === void 0 || options.escape === true) {
    options.escape = Buffer.from('"', options.encoding);
  } else if (typeof options.escape === "string") {
    options.escape = Buffer.from(options.escape, options.encoding);
  } else if (options.escape === null || options.escape === false) {
    options.escape = null;
  }
  if (options.escape !== null) {
    if (!Buffer.isBuffer(options.escape)) {
      throw new Error(
        `Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`
      );
    }
  }
  if (options.from === void 0 || options.from === null) {
    options.from = 1;
  } else {
    if (typeof options.from === "string" && /\d+/.test(options.from)) {
      options.from = parseInt(options.from);
    }
    if (Number.isInteger(options.from)) {
      if (options.from < 0) {
        throw new Error(
          `Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`
        );
      }
    } else {
      throw new Error(
        `Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`
      );
    }
  }
  if (options.from_line === void 0 || options.from_line === null) {
    options.from_line = 1;
  } else {
    if (typeof options.from_line === "string" && /\d+/.test(options.from_line)) {
      options.from_line = parseInt(options.from_line);
    }
    if (Number.isInteger(options.from_line)) {
      if (options.from_line <= 0) {
        throw new Error(
          `Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`
        );
      }
    } else {
      throw new Error(
        `Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`
      );
    }
  }
  if (options.ignore_last_delimiters === void 0 || options.ignore_last_delimiters === null) {
    options.ignore_last_delimiters = false;
  } else if (typeof options.ignore_last_delimiters === "number") {
    options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);
    if (options.ignore_last_delimiters === 0) {
      options.ignore_last_delimiters = false;
    }
  } else if (typeof options.ignore_last_delimiters !== "boolean") {
    throw new CsvError(
      "CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS",
      [
        "Invalid option `ignore_last_delimiters`:",
        "the value must be a boolean value or an integer,",
        `got ${JSON.stringify(options.ignore_last_delimiters)}`
      ],
      options
    );
  }
  if (options.ignore_last_delimiters === true && options.columns === false) {
    throw new CsvError(
      "CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS",
      [
        "The option `ignore_last_delimiters`",
        "requires the activation of the `columns` option"
      ],
      options
    );
  }
  if (options.info === void 0 || options.info === null || options.info === false) {
    options.info = false;
  } else if (options.info !== true) {
    throw new Error(
      `Invalid Option: info must be true, got ${JSON.stringify(options.info)}`
    );
  }
  if (options.max_record_size === void 0 || options.max_record_size === null || options.max_record_size === false) {
    options.max_record_size = 0;
  } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {
  } else if (typeof options.max_record_size === "string" && /\d+/.test(options.max_record_size)) {
    options.max_record_size = parseInt(options.max_record_size);
  } else {
    throw new Error(
      `Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`
    );
  }
  if (options.objname === void 0 || options.objname === null || options.objname === false) {
    options.objname = void 0;
  } else if (Buffer.isBuffer(options.objname)) {
    if (options.objname.length === 0) {
      throw new Error(`Invalid Option: objname must be a non empty buffer`);
    }
    if (options.encoding === null) {
    } else {
      options.objname = options.objname.toString(options.encoding);
    }
  } else if (typeof options.objname === "string") {
    if (options.objname.length === 0) {
      throw new Error(`Invalid Option: objname must be a non empty string`);
    }
  } else if (typeof options.objname === "number") {
  } else {
    throw new Error(
      `Invalid Option: objname must be a string or a buffer, got ${options.objname}`
    );
  }
  if (options.objname !== void 0) {
    if (typeof options.objname === "number") {
      if (options.columns !== false) {
        throw Error(
          "Invalid Option: objname index cannot be combined with columns or be defined as a field"
        );
      }
    } else {
      if (options.columns === false) {
        throw Error(
          "Invalid Option: objname field must be combined with columns or be defined as an index"
        );
      }
    }
  }
  if (options.on_record === void 0 || options.on_record === null) {
    options.on_record = void 0;
  } else if (typeof options.on_record !== "function") {
    throw new CsvError(
      "CSV_INVALID_OPTION_ON_RECORD",
      [
        "Invalid option `on_record`:",
        "expect a function,",
        `got ${JSON.stringify(options.on_record)}`
      ],
      options
    );
  }
  if (options.on_skip !== void 0 && options.on_skip !== null && typeof options.on_skip !== "function") {
    throw new Error(
      `Invalid Option: on_skip must be a function, got ${JSON.stringify(options.on_skip)}`
    );
  }
  if (options.quote === null || options.quote === false || options.quote === "") {
    options.quote = null;
  } else {
    if (options.quote === void 0 || options.quote === true) {
      options.quote = Buffer.from('"', options.encoding);
    } else if (typeof options.quote === "string") {
      options.quote = Buffer.from(options.quote, options.encoding);
    }
    if (!Buffer.isBuffer(options.quote)) {
      throw new Error(
        `Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`
      );
    }
  }
  if (options.raw === void 0 || options.raw === null || options.raw === false) {
    options.raw = false;
  } else if (options.raw !== true) {
    throw new Error(
      `Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`
    );
  }
  if (options.record_delimiter === void 0) {
    options.record_delimiter = [];
  } else if (typeof options.record_delimiter === "string" || Buffer.isBuffer(options.record_delimiter)) {
    if (options.record_delimiter.length === 0) {
      throw new CsvError(
        "CSV_INVALID_OPTION_RECORD_DELIMITER",
        [
          "Invalid option `record_delimiter`:",
          "value must be a non empty string or buffer,",
          `got ${JSON.stringify(options.record_delimiter)}`
        ],
        options
      );
    }
    options.record_delimiter = [options.record_delimiter];
  } else if (!Array.isArray(options.record_delimiter)) {
    throw new CsvError(
      "CSV_INVALID_OPTION_RECORD_DELIMITER",
      [
        "Invalid option `record_delimiter`:",
        "value must be a string, a buffer or array of string|buffer,",
        `got ${JSON.stringify(options.record_delimiter)}`
      ],
      options
    );
  }
  options.record_delimiter = options.record_delimiter.map(function(rd, i2) {
    if (typeof rd !== "string" && !Buffer.isBuffer(rd)) {
      throw new CsvError(
        "CSV_INVALID_OPTION_RECORD_DELIMITER",
        [
          "Invalid option `record_delimiter`:",
          "value must be a string, a buffer or array of string|buffer",
          `at index ${i2},`,
          `got ${JSON.stringify(rd)}`
        ],
        options
      );
    } else if (rd.length === 0) {
      throw new CsvError(
        "CSV_INVALID_OPTION_RECORD_DELIMITER",
        [
          "Invalid option `record_delimiter`:",
          "value must be a non empty string or buffer",
          `at index ${i2},`,
          `got ${JSON.stringify(rd)}`
        ],
        options
      );
    }
    if (typeof rd === "string") {
      rd = Buffer.from(rd, options.encoding);
    }
    return rd;
  });
  if (typeof options.relax_column_count === "boolean") {
  } else if (options.relax_column_count === void 0 || options.relax_column_count === null) {
    options.relax_column_count = false;
  } else {
    throw new Error(
      `Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`
    );
  }
  if (typeof options.relax_column_count_less === "boolean") {
  } else if (options.relax_column_count_less === void 0 || options.relax_column_count_less === null) {
    options.relax_column_count_less = false;
  } else {
    throw new Error(
      `Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`
    );
  }
  if (typeof options.relax_column_count_more === "boolean") {
  } else if (options.relax_column_count_more === void 0 || options.relax_column_count_more === null) {
    options.relax_column_count_more = false;
  } else {
    throw new Error(
      `Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`
    );
  }
  if (typeof options.relax_quotes === "boolean") {
  } else if (options.relax_quotes === void 0 || options.relax_quotes === null) {
    options.relax_quotes = false;
  } else {
    throw new Error(
      `Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`
    );
  }
  if (typeof options.skip_empty_lines === "boolean") {
  } else if (options.skip_empty_lines === void 0 || options.skip_empty_lines === null) {
    options.skip_empty_lines = false;
  } else {
    throw new Error(
      `Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`
    );
  }
  if (typeof options.skip_records_with_empty_values === "boolean") {
  } else if (options.skip_records_with_empty_values === void 0 || options.skip_records_with_empty_values === null) {
    options.skip_records_with_empty_values = false;
  } else {
    throw new Error(
      `Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`
    );
  }
  if (typeof options.skip_records_with_error === "boolean") {
  } else if (options.skip_records_with_error === void 0 || options.skip_records_with_error === null) {
    options.skip_records_with_error = false;
  } else {
    throw new Error(
      `Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`
    );
  }
  if (options.rtrim === void 0 || options.rtrim === null || options.rtrim === false) {
    options.rtrim = false;
  } else if (options.rtrim !== true) {
    throw new Error(
      `Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`
    );
  }
  if (options.ltrim === void 0 || options.ltrim === null || options.ltrim === false) {
    options.ltrim = false;
  } else if (options.ltrim !== true) {
    throw new Error(
      `Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`
    );
  }
  if (options.trim === void 0 || options.trim === null || options.trim === false) {
    options.trim = false;
  } else if (options.trim !== true) {
    throw new Error(
      `Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`
    );
  }
  if (options.trim === true && opts.ltrim !== false) {
    options.ltrim = true;
  } else if (options.ltrim !== true) {
    options.ltrim = false;
  }
  if (options.trim === true && opts.rtrim !== false) {
    options.rtrim = true;
  } else if (options.rtrim !== true) {
    options.rtrim = false;
  }
  if (options.to === void 0 || options.to === null) {
    options.to = -1;
  } else {
    if (typeof options.to === "string" && /\d+/.test(options.to)) {
      options.to = parseInt(options.to);
    }
    if (Number.isInteger(options.to)) {
      if (options.to <= 0) {
        throw new Error(
          `Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`
        );
      }
    } else {
      throw new Error(
        `Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`
      );
    }
  }
  if (options.to_line === void 0 || options.to_line === null) {
    options.to_line = -1;
  } else {
    if (typeof options.to_line === "string" && /\d+/.test(options.to_line)) {
      options.to_line = parseInt(options.to_line);
    }
    if (Number.isInteger(options.to_line)) {
      if (options.to_line <= 0) {
        throw new Error(
          `Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`
        );
      }
    } else {
      throw new Error(
        `Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`
      );
    }
  }
  return options;
};

// node_modules/csv-parse/lib/api/index.js
var isRecordEmpty = function(record) {
  return record.every(
    (field) => field == null || field.toString && field.toString().trim() === ""
  );
};
var cr2 = 13;
var nl2 = 10;
var boms = {
  // Note, the following are equals:
  // Buffer.from("\ufeff")
  // Buffer.from([239, 187, 191])
  // Buffer.from('EFBBBF', 'hex')
  utf8: Buffer.from([239, 187, 191]),
  // Note, the following are equals:
  // Buffer.from "\ufeff", 'utf16le
  // Buffer.from([255, 254])
  utf16le: Buffer.from([255, 254])
};
var transform = function(original_options = {}) {
  const info = {
    bytes: 0,
    comment_lines: 0,
    empty_lines: 0,
    invalid_field_length: 0,
    lines: 1,
    records: 0
  };
  const options = normalize_options(original_options);
  return {
    info,
    original_options,
    options,
    state: init_state(options),
    __needMoreData: function(i2, bufLen, end) {
      if (end) return false;
      const { encoding, escape, quote } = this.options;
      const { quoting, needMoreDataSize, recordDelimiterMaxLength } = this.state;
      const numOfCharLeft = bufLen - i2 - 1;
      const requiredLength = Math.max(
        needMoreDataSize,
        // Skip if the remaining buffer smaller than record delimiter
        // If "record_delimiter" is yet to be discovered:
        // 1. It is equals to `[]` and "recordDelimiterMaxLength" equals `0`
        // 2. We set the length to windows line ending in the current encoding
        // Note, that encoding is known from user or bom discovery at that point
        // recordDelimiterMaxLength,
        recordDelimiterMaxLength === 0 ? Buffer.from("\r\n", encoding).length : recordDelimiterMaxLength,
        // Skip if remaining buffer can be an escaped quote
        quoting ? (escape === null ? 0 : escape.length) + quote.length : 0,
        // Skip if remaining buffer can be record delimiter following the closing quote
        quoting ? quote.length + recordDelimiterMaxLength : 0
      );
      return numOfCharLeft < requiredLength;
    },
    // Central parser implementation
    parse: function(nextBuf, end, push, close) {
      const {
        bom,
        comment_no_infix,
        encoding,
        from_line,
        ltrim,
        max_record_size,
        raw,
        relax_quotes,
        rtrim,
        skip_empty_lines,
        to,
        to_line
      } = this.options;
      let { comment, escape, quote, record_delimiter } = this.options;
      const { bomSkipped, previousBuf, rawBuffer, escapeIsQuote } = this.state;
      let buf;
      if (previousBuf === void 0) {
        if (nextBuf === void 0) {
          close();
          return;
        } else {
          buf = nextBuf;
        }
      } else if (previousBuf !== void 0 && nextBuf === void 0) {
        buf = previousBuf;
      } else {
        buf = Buffer.concat([previousBuf, nextBuf]);
      }
      if (bomSkipped === false) {
        if (bom === false) {
          this.state.bomSkipped = true;
        } else if (buf.length < 3) {
          if (end === false) {
            this.state.previousBuf = buf;
            return;
          }
        } else {
          for (const encoding2 in boms) {
            if (boms[encoding2].compare(buf, 0, boms[encoding2].length) === 0) {
              const bomLength = boms[encoding2].length;
              this.state.bufBytesStart += bomLength;
              buf = buf.slice(bomLength);
              this.options = normalize_options({
                ...this.original_options,
                encoding: encoding2
              });
              ({ comment, escape, quote } = this.options);
              break;
            }
          }
          this.state.bomSkipped = true;
        }
      }
      const bufLen = buf.length;
      let pos;
      for (pos = 0; pos < bufLen; pos++) {
        if (this.__needMoreData(pos, bufLen, end)) {
          break;
        }
        if (this.state.wasRowDelimiter === true) {
          this.info.lines++;
          this.state.wasRowDelimiter = false;
        }
        if (to_line !== -1 && this.info.lines > to_line) {
          this.state.stop = true;
          close();
          return;
        }
        if (this.state.quoting === false && record_delimiter.length === 0) {
          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(
            buf,
            pos
          );
          if (record_delimiterCount) {
            record_delimiter = this.options.record_delimiter;
          }
        }
        const chr = buf[pos];
        if (raw === true) {
          rawBuffer.append(chr);
        }
        if ((chr === cr2 || chr === nl2) && this.state.wasRowDelimiter === false) {
          this.state.wasRowDelimiter = true;
        }
        if (this.state.escaping === true) {
          this.state.escaping = false;
        } else {
          if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {
            if (escapeIsQuote) {
              if (this.__isQuote(buf, pos + escape.length)) {
                this.state.escaping = true;
                pos += escape.length - 1;
                continue;
              }
            } else {
              this.state.escaping = true;
              pos += escape.length - 1;
              continue;
            }
          }
          if (this.state.commenting === false && this.__isQuote(buf, pos)) {
            if (this.state.quoting === true) {
              const nextChr = buf[pos + quote.length];
              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos + quote.length);
              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);
              const isNextChrDelimiter = this.__isDelimiter(
                buf,
                pos + quote.length,
                nextChr
              );
              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);
              if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {
                pos += escape.length - 1;
              } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {
                this.state.quoting = false;
                this.state.wasQuoting = true;
                pos += quote.length - 1;
                continue;
              } else if (relax_quotes === false) {
                const err = this.__error(
                  new CsvError(
                    "CSV_INVALID_CLOSING_QUOTE",
                    [
                      "Invalid Closing Quote:",
                      `got "${String.fromCharCode(nextChr)}"`,
                      `at line ${this.info.lines}`,
                      "instead of delimiter, record delimiter, trimable character",
                      "(if activated) or comment"
                    ],
                    this.options,
                    this.__infoField()
                  )
                );
                if (err !== void 0) return err;
              } else {
                this.state.quoting = false;
                this.state.wasQuoting = true;
                this.state.field.prepend(quote);
                pos += quote.length - 1;
              }
            } else {
              if (this.state.field.length !== 0) {
                if (relax_quotes === false) {
                  const info2 = this.__infoField();
                  const bom2 = Object.keys(boms).map(
                    (b) => boms[b].equals(this.state.field.toString()) ? b : false
                  ).filter(Boolean)[0];
                  const err = this.__error(
                    new CsvError(
                      "INVALID_OPENING_QUOTE",
                      [
                        "Invalid Opening Quote:",
                        `a quote is found on field ${JSON.stringify(info2.column)} at line ${info2.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,
                        bom2 ? `(${bom2} bom)` : void 0
                      ],
                      this.options,
                      info2,
                      {
                        field: this.state.field
                      }
                    )
                  );
                  if (err !== void 0) return err;
                }
              } else {
                this.state.quoting = true;
                pos += quote.length - 1;
                continue;
              }
            }
          }
          if (this.state.quoting === false) {
            const recordDelimiterLength = this.__isRecordDelimiter(
              chr,
              buf,
              pos
            );
            if (recordDelimiterLength !== 0) {
              const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;
              if (skipCommentLine) {
                this.info.comment_lines++;
              } else {
                if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {
                  this.state.enabled = true;
                  this.__resetField();
                  this.__resetRecord();
                  pos += recordDelimiterLength - 1;
                  continue;
                }
                if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {
                  this.info.empty_lines++;
                  pos += recordDelimiterLength - 1;
                  continue;
                }
                this.info.bytes = this.state.bufBytesStart + pos;
                const errField = this.__onField();
                if (errField !== void 0) return errField;
                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;
                const errRecord = this.__onRecord(push);
                if (errRecord !== void 0) return errRecord;
                if (to !== -1 && this.info.records >= to) {
                  this.state.stop = true;
                  close();
                  return;
                }
              }
              this.state.commenting = false;
              pos += recordDelimiterLength - 1;
              continue;
            }
            if (this.state.commenting) {
              continue;
            }
            if (comment !== null && (comment_no_infix === false || this.state.record.length === 0 && this.state.field.length === 0)) {
              const commentCount = this.__compareBytes(comment, buf, pos, chr);
              if (commentCount !== 0) {
                this.state.commenting = true;
                continue;
              }
            }
            const delimiterLength = this.__isDelimiter(buf, pos, chr);
            if (delimiterLength !== 0) {
              this.info.bytes = this.state.bufBytesStart + pos;
              const errField = this.__onField();
              if (errField !== void 0) return errField;
              pos += delimiterLength - 1;
              continue;
            }
          }
        }
        if (this.state.commenting === false) {
          if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {
            return this.__error(
              new CsvError(
                "CSV_MAX_RECORD_SIZE",
                [
                  "Max Record Size:",
                  "record exceed the maximum number of tolerated bytes",
                  `of ${max_record_size}`,
                  `at line ${this.info.lines}`
                ],
                this.options,
                this.__infoField()
              )
            );
          }
        }
        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);
        const rappend = rtrim === false || this.state.wasQuoting === false;
        if (lappend === true && rappend === true) {
          this.state.field.append(chr);
        } else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {
          return this.__error(
            new CsvError(
              "CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE",
              [
                "Invalid Closing Quote:",
                "found non trimable byte after quote",
                `at line ${this.info.lines}`
              ],
              this.options,
              this.__infoField()
            )
          );
        } else {
          if (lappend === false) {
            pos += this.__isCharTrimable(buf, pos) - 1;
          }
          continue;
        }
      }
      if (end === true) {
        if (this.state.quoting === true) {
          const err = this.__error(
            new CsvError(
              "CSV_QUOTE_NOT_CLOSED",
              [
                "Quote Not Closed:",
                `the parsing is finished with an opening quote at line ${this.info.lines}`
              ],
              this.options,
              this.__infoField()
            )
          );
          if (err !== void 0) return err;
        } else {
          if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {
            this.info.bytes = this.state.bufBytesStart + pos;
            const errField = this.__onField();
            if (errField !== void 0) return errField;
            const errRecord = this.__onRecord(push);
            if (errRecord !== void 0) return errRecord;
          } else if (this.state.wasRowDelimiter === true) {
            this.info.empty_lines++;
          } else if (this.state.commenting === true) {
            this.info.comment_lines++;
          }
        }
      } else {
        this.state.bufBytesStart += pos;
        this.state.previousBuf = buf.slice(pos);
      }
      if (this.state.wasRowDelimiter === true) {
        this.info.lines++;
        this.state.wasRowDelimiter = false;
      }
    },
    __onRecord: function(push) {
      const {
        columns,
        group_columns_by_name,
        encoding,
        info: info2,
        from,
        relax_column_count,
        relax_column_count_less,
        relax_column_count_more,
        raw,
        skip_records_with_empty_values
      } = this.options;
      const { enabled, record } = this.state;
      if (enabled === false) {
        return this.__resetRecord();
      }
      const recordLength = record.length;
      if (columns === true) {
        if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
          this.__resetRecord();
          return;
        }
        return this.__firstLineToColumns(record);
      }
      if (columns === false && this.info.records === 0) {
        this.state.expectedRecordLength = recordLength;
      }
      if (recordLength !== this.state.expectedRecordLength) {
        const err = columns === false ? new CsvError(
          "CSV_RECORD_INCONSISTENT_FIELDS_LENGTH",
          [
            "Invalid Record Length:",
            `expect ${this.state.expectedRecordLength},`,
            `got ${recordLength} on line ${this.info.lines}`
          ],
          this.options,
          this.__infoField(),
          {
            record
          }
        ) : new CsvError(
          "CSV_RECORD_INCONSISTENT_COLUMNS",
          [
            "Invalid Record Length:",
            `columns length is ${columns.length},`,
            // rename columns
            `got ${recordLength} on line ${this.info.lines}`
          ],
          this.options,
          this.__infoField(),
          {
            record
          }
        );
        if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {
          this.info.invalid_field_length++;
          this.state.error = err;
        } else {
          const finalErr = this.__error(err);
          if (finalErr) return finalErr;
        }
      }
      if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
        this.__resetRecord();
        return;
      }
      if (this.state.recordHasError === true) {
        this.__resetRecord();
        this.state.recordHasError = false;
        return;
      }
      this.info.records++;
      if (from === 1 || this.info.records >= from) {
        const { objname } = this.options;
        if (columns !== false) {
          const obj = {};
          for (let i2 = 0, l = record.length; i2 < l; i2++) {
            if (columns[i2] === void 0 || columns[i2].disabled) continue;
            if (group_columns_by_name === true && obj[columns[i2].name] !== void 0) {
              if (Array.isArray(obj[columns[i2].name])) {
                obj[columns[i2].name] = obj[columns[i2].name].concat(record[i2]);
              } else {
                obj[columns[i2].name] = [obj[columns[i2].name], record[i2]];
              }
            } else {
              obj[columns[i2].name] = record[i2];
            }
          }
          if (raw === true || info2 === true) {
            const extRecord = Object.assign(
              { record: obj },
              raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {},
              info2 === true ? { info: this.__infoRecord() } : {}
            );
            const err = this.__push(
              objname === void 0 ? extRecord : [obj[objname], extRecord],
              push
            );
            if (err) {
              return err;
            }
          } else {
            const err = this.__push(
              objname === void 0 ? obj : [obj[objname], obj],
              push
            );
            if (err) {
              return err;
            }
          }
        } else {
          if (raw === true || info2 === true) {
            const extRecord = Object.assign(
              { record },
              raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {},
              info2 === true ? { info: this.__infoRecord() } : {}
            );
            const err = this.__push(
              objname === void 0 ? extRecord : [record[objname], extRecord],
              push
            );
            if (err) {
              return err;
            }
          } else {
            const err = this.__push(
              objname === void 0 ? record : [record[objname], record],
              push
            );
            if (err) {
              return err;
            }
          }
        }
      }
      this.__resetRecord();
    },
    __firstLineToColumns: function(record) {
      const { firstLineToHeaders } = this.state;
      try {
        const headers = firstLineToHeaders === void 0 ? record : firstLineToHeaders.call(null, record);
        if (!Array.isArray(headers)) {
          return this.__error(
            new CsvError(
              "CSV_INVALID_COLUMN_MAPPING",
              [
                "Invalid Column Mapping:",
                "expect an array from column function,",
                `got ${JSON.stringify(headers)}`
              ],
              this.options,
              this.__infoField(),
              {
                headers
              }
            )
          );
        }
        const normalizedHeaders = normalize_columns_array(headers);
        this.state.expectedRecordLength = normalizedHeaders.length;
        this.options.columns = normalizedHeaders;
        this.__resetRecord();
        return;
      } catch (err) {
        return err;
      }
    },
    __resetRecord: function() {
      if (this.options.raw === true) {
        this.state.rawBuffer.reset();
      }
      this.state.error = void 0;
      this.state.record = [];
      this.state.record_length = 0;
    },
    __onField: function() {
      const { cast, encoding, rtrim, max_record_size } = this.options;
      const { enabled, wasQuoting } = this.state;
      if (enabled === false) {
        return this.__resetField();
      }
      let field = this.state.field.toString(encoding);
      if (rtrim === true && wasQuoting === false) {
        field = field.trimRight();
      }
      if (cast === true) {
        const [err, f3] = this.__cast(field);
        if (err !== void 0) return err;
        field = f3;
      }
      this.state.record.push(field);
      if (max_record_size !== 0 && typeof field === "string") {
        this.state.record_length += field.length;
      }
      this.__resetField();
    },
    __resetField: function() {
      this.state.field.reset();
      this.state.wasQuoting = false;
    },
    __push: function(record, push) {
      const { on_record } = this.options;
      if (on_record !== void 0) {
        const info2 = this.__infoRecord();
        try {
          record = on_record.call(null, record, info2);
        } catch (err) {
          return err;
        }
        if (record === void 0 || record === null) {
          return;
        }
      }
      push(record);
    },
    // Return a tuple with the error and the casted value
    __cast: function(field) {
      const { columns, relax_column_count } = this.options;
      const isColumns = Array.isArray(columns);
      if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {
        return [void 0, void 0];
      }
      if (this.state.castField !== null) {
        try {
          const info2 = this.__infoField();
          return [void 0, this.state.castField.call(null, field, info2)];
        } catch (err) {
          return [err];
        }
      }
      if (this.__isFloat(field)) {
        return [void 0, parseFloat(field)];
      } else if (this.options.cast_date !== false) {
        const info2 = this.__infoField();
        return [void 0, this.options.cast_date.call(null, field, info2)];
      }
      return [void 0, field];
    },
    // Helper to test if a character is a space or a line delimiter
    __isCharTrimable: function(buf, pos) {
      const isTrim = (buf2, pos2) => {
        const { timchars } = this.state;
        loop1: for (let i2 = 0; i2 < timchars.length; i2++) {
          const timchar = timchars[i2];
          for (let j = 0; j < timchar.length; j++) {
            if (timchar[j] !== buf2[pos2 + j]) continue loop1;
          }
          return timchar.length;
        }
        return 0;
      };
      return isTrim(buf, pos);
    },
    // Keep it in case we implement the `cast_int` option
    // __isInt(value){
    //   // return Number.isInteger(parseInt(value))
    //   // return !isNaN( parseInt( obj ) );
    //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
    // }
    __isFloat: function(value) {
      return value - parseFloat(value) + 1 >= 0;
    },
    __compareBytes: function(sourceBuf, targetBuf, targetPos, firstByte) {
      if (sourceBuf[0] !== firstByte) return 0;
      const sourceLength = sourceBuf.length;
      for (let i2 = 1; i2 < sourceLength; i2++) {
        if (sourceBuf[i2] !== targetBuf[targetPos + i2]) return 0;
      }
      return sourceLength;
    },
    __isDelimiter: function(buf, pos, chr) {
      const { delimiter, ignore_last_delimiters } = this.options;
      if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {
        return 0;
      } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === "number" && this.state.record.length === ignore_last_delimiters - 1) {
        return 0;
      }
      loop1: for (let i2 = 0; i2 < delimiter.length; i2++) {
        const del = delimiter[i2];
        if (del[0] === chr) {
          for (let j = 1; j < del.length; j++) {
            if (del[j] !== buf[pos + j]) continue loop1;
          }
          return del.length;
        }
      }
      return 0;
    },
    __isRecordDelimiter: function(chr, buf, pos) {
      const { record_delimiter } = this.options;
      const recordDelimiterLength = record_delimiter.length;
      loop1: for (let i2 = 0; i2 < recordDelimiterLength; i2++) {
        const rd = record_delimiter[i2];
        const rdLength = rd.length;
        if (rd[0] !== chr) {
          continue;
        }
        for (let j = 1; j < rdLength; j++) {
          if (rd[j] !== buf[pos + j]) {
            continue loop1;
          }
        }
        return rd.length;
      }
      return 0;
    },
    __isEscape: function(buf, pos, chr) {
      const { escape } = this.options;
      if (escape === null) return false;
      const l = escape.length;
      if (escape[0] === chr) {
        for (let i2 = 0; i2 < l; i2++) {
          if (escape[i2] !== buf[pos + i2]) {
            return false;
          }
        }
        return true;
      }
      return false;
    },
    __isQuote: function(buf, pos) {
      const { quote } = this.options;
      if (quote === null) return false;
      const l = quote.length;
      for (let i2 = 0; i2 < l; i2++) {
        if (quote[i2] !== buf[pos + i2]) {
          return false;
        }
      }
      return true;
    },
    __autoDiscoverRecordDelimiter: function(buf, pos) {
      const { encoding } = this.options;
      const rds = [
        // Important, the windows line ending must be before mac os 9
        Buffer.from("\r\n", encoding),
        Buffer.from("\n", encoding),
        Buffer.from("\r", encoding)
      ];
      loop: for (let i2 = 0; i2 < rds.length; i2++) {
        const l = rds[i2].length;
        for (let j = 0; j < l; j++) {
          if (rds[i2][j] !== buf[pos + j]) {
            continue loop;
          }
        }
        this.options.record_delimiter.push(rds[i2]);
        this.state.recordDelimiterMaxLength = rds[i2].length;
        return rds[i2].length;
      }
      return 0;
    },
    __error: function(msg) {
      const { encoding, raw, skip_records_with_error } = this.options;
      const err = typeof msg === "string" ? new Error(msg) : msg;
      if (skip_records_with_error) {
        this.state.recordHasError = true;
        if (this.options.on_skip !== void 0) {
          this.options.on_skip(
            err,
            raw ? this.state.rawBuffer.toString(encoding) : void 0
          );
        }
        return void 0;
      } else {
        return err;
      }
    },
    __infoDataSet: function() {
      return {
        ...this.info,
        columns: this.options.columns
      };
    },
    __infoRecord: function() {
      const { columns, raw, encoding } = this.options;
      return {
        ...this.__infoDataSet(),
        error: this.state.error,
        header: columns === true,
        index: this.state.record.length,
        raw: raw ? this.state.rawBuffer.toString(encoding) : void 0
      };
    },
    __infoField: function() {
      const { columns } = this.options;
      const isColumns = Array.isArray(columns);
      return {
        ...this.__infoRecord(),
        column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,
        quoting: this.state.wasQuoting
      };
    }
  };
};

// node_modules/csv-parse/lib/sync.js
var parse = function(data, opts = {}) {
  if (typeof data === "string") {
    data = Buffer.from(data);
  }
  const records = opts && opts.objname ? {} : [];
  const parser = transform(opts);
  const push = (record) => {
    if (parser.options.objname === void 0) records.push(record);
    else {
      records[record[0]] = record[1];
    }
  };
  const close = () => {
  };
  const err1 = parser.parse(data, false, push, close);
  if (err1 !== void 0) throw err1;
  const err2 = parser.parse(void 0, true, push, close);
  if (err2 !== void 0) throw err2;
  return records;
};

// src/lib/gtfsStatic.ts
var import_api2 = require("@raycast/api");
var CACHE_DIR = import_path.default.join(import_api2.environment.supportPath, "gtfs-cache");
var CACHE_TTL = 12 * 60 * 60 * 1e3;
var GTFS_FEED_URL = "https://catabus.com/wp-content/uploads/google_transit.zip";
async function ensureCacheDir() {
  try {
    await import_promises.default.mkdir(CACHE_DIR, { recursive: true });
  } catch (error) {
    console.error("Failed to create cache directory:", error);
  }
}
async function getCachedData() {
  try {
    const cacheFile = import_path.default.join(CACHE_DIR, "static-gtfs.json");
    const cacheExists = await import_promises.default.access(cacheFile).then(() => true).catch(() => false);
    if (!cacheExists) {
      return null;
    }
    const cacheContent = await import_promises.default.readFile(cacheFile, "utf-8");
    const cache = JSON.parse(cacheContent);
    if (Date.now() - cache.timestamp > cache.ttl) {
      console.log("GTFS cache expired");
      return null;
    }
    const data = cache.data;
    return {
      stops: new Map(Object.entries(data.stops)),
      routes: new Map(Object.entries(data.routes)),
      trips: new Map(Object.entries(data.trips)),
      stopTimes: data.stopTimes,
      calendarDates: data.calendarDates,
      lastUpdated: new Date(data.lastUpdated)
    };
  } catch (error) {
    console.error("Failed to read cache:", error);
    return null;
  }
}
async function saveToCache(data) {
  try {
    await ensureCacheDir();
    const serializable = {
      stops: Object.fromEntries(data.stops),
      routes: Object.fromEntries(data.routes),
      trips: Object.fromEntries(data.trips),
      stopTimes: data.stopTimes,
      calendarDates: data.calendarDates,
      lastUpdated: data.lastUpdated
    };
    const cache = {
      data: serializable,
      timestamp: Date.now(),
      ttl: CACHE_TTL
    };
    const cacheFile = import_path.default.join(CACHE_DIR, "static-gtfs.json");
    await import_promises.default.writeFile(cacheFile, JSON.stringify(cache));
    console.log("GTFS data cached successfully");
  } catch (error) {
    console.error("Failed to save cache:", error);
  }
}
async function downloadAndExtractGTFS() {
  const tempDir = import_path.default.join(import_os.default.tmpdir(), `gtfs-${Date.now()}`);
  await import_promises.default.mkdir(tempDir, { recursive: true });
  try {
    console.log("Downloading GTFS feed from:", GTFS_FEED_URL);
    const response = await fetch(GTFS_FEED_URL, {
      signal: AbortSignal.timeout(3e4)
      // 30 second timeout
    });
    if (!response.ok) {
      throw new Error(`Failed to download GTFS feed: ${response.statusText}`);
    }
    const buffer = await response.arrayBuffer();
    const zipBuffer = Buffer.from(buffer);
    const zip = new import_adm_zip.default(zipBuffer);
    zip.extractAllTo(tempDir, true);
    console.log("GTFS feed extracted to:", tempDir);
    return tempDir;
  } catch (error) {
    await import_promises.default.rm(tempDir, { recursive: true, force: true }).catch(() => {
    });
    throw error;
  }
}
async function parseCSVFile(filePath, required = false) {
  try {
    const content = await import_promises.default.readFile(filePath, "utf-8");
    return parse(content, {
      columns: true,
      skip_empty_lines: true,
      trim: true,
      cast: (value, context) => {
        if (context.header) return value;
        if (value === "") return void 0;
        const num = Number(value);
        if (!isNaN(num) && value.match(/^-?\d+(\.\d+)?$/)) {
          return num;
        }
        return value;
      }
    });
  } catch (error) {
    if (required || error.code !== "ENOENT") {
      console.error(`Failed to parse ${filePath}:`, error);
    }
    return [];
  }
}
async function loadStaticGTFS(forceRefresh = false) {
  if (!forceRefresh) {
    const cached = await getCachedData();
    if (cached) {
      console.log("Using cached GTFS data");
      return cached;
    }
  }
  console.log("Loading fresh GTFS data");
  let extractDir = null;
  try {
    extractDir = await downloadAndExtractGTFS();
    const [stops, routes, trips, stopTimes, calendarDates] = await Promise.all([
      parseCSVFile(import_path.default.join(extractDir, "stops.txt"), true),
      parseCSVFile(import_path.default.join(extractDir, "routes.txt"), true),
      parseCSVFile(import_path.default.join(extractDir, "trips.txt"), true),
      parseCSVFile(import_path.default.join(extractDir, "stop_times.txt"), true),
      parseCSVFile(import_path.default.join(extractDir, "calendar_dates.txt"), false)
    ]);
    console.log(`Loaded: ${stops.length} stops, ${routes.length} routes, ${trips.length} trips`);
    const stopsMap = /* @__PURE__ */ new Map();
    stops.forEach((stop) => {
      stopsMap.set(stop.stop_id, stop);
    });
    const routesMap = /* @__PURE__ */ new Map();
    routes.forEach((route) => {
      routesMap.set(route.route_id, route);
    });
    const tripsMap = /* @__PURE__ */ new Map();
    trips.forEach((trip) => {
      tripsMap.set(trip.trip_id, trip);
    });
    const data = {
      stops: stopsMap,
      routes: routesMap,
      trips: tripsMap,
      stopTimes,
      calendarDates,
      lastUpdated: /* @__PURE__ */ new Date()
    };
    await saveToCache(data);
    return data;
  } finally {
    if (extractDir) {
      await import_promises.default.rm(extractDir, { recursive: true, force: true }).catch(() => {
      });
    }
  }
}

// src/set-defaults.tsx
var import_jsx_runtime = require("react/jsx-runtime");
function SetDefaults() {
  const [isLoading, setIsLoading] = (0, import_react.useState)(true);
  const [stops, setStops] = (0, import_react.useState)([]);
  const [searchText, setSearchText] = (0, import_react.useState)("");
  const [savedStopId, setSavedStopId] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    loadStops();
    loadSavedStop();
  }, []);
  const loadSavedStop = async () => {
    try {
      const saved = await import_api3.LocalStorage.getItem("default-stop-id");
      if (saved) {
        setSavedStopId(saved);
      }
    } catch (error) {
      console.error("Error loading saved stop:", error);
    }
  };
  const loadStops = async () => {
    try {
      const gtfsData = await loadStaticGTFS();
      const allStops = Array.from(gtfsData.stops.values());
      allStops.sort((a, b) => a.stop_name.localeCompare(b.stop_name));
      setStops(allStops);
    } catch (error) {
      console.error("Error loading stops:", error);
      (0, import_api3.showToast)({
        style: import_api3.Toast.Style.Failure,
        title: "Failed to Load Stops",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    } finally {
      setIsLoading(false);
    }
  };
  const saveDefaultStop = async (stop) => {
    try {
      const stopId = String(stop.stop_id);
      await import_api3.LocalStorage.setItem("default-stop-id", stopId);
      await import_api3.LocalStorage.setItem("default-stop-name", stop.stop_name);
      setSavedStopId(stopId);
      (0, import_api3.showToast)({
        style: import_api3.Toast.Style.Success,
        title: "Default Stop Set",
        message: `${stop.stop_name} (${stopId})`
      });
    } catch (error) {
      (0, import_api3.showToast)({
        style: import_api3.Toast.Style.Failure,
        title: "Failed to Save",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  };
  const filteredStops = stops.filter((stop) => {
    const search = searchText.toLowerCase();
    const stopId = String(stop.stop_id);
    const stopName = stop.stop_name || "";
    return stopId.toLowerCase().includes(search) || stopName.toLowerCase().includes(search);
  });
  const campusStops = filteredStops.filter(
    (s2) => s2.stop_name.includes("Campus") || s2.stop_name.includes("Pattee") || s2.stop_name.includes("HUB") || s2.stop_name.includes("Pollock") || s2.stop_name.includes("Shields") || s2.stop_name.includes("Library")
  );
  const downtownStops = filteredStops.filter(
    (s2) => s2.stop_name.includes("Downtown") || s2.stop_name.includes("College Ave") || s2.stop_name.includes("Beaver Ave") || s2.stop_name.includes("Allen St")
  );
  const apartmentStops = filteredStops.filter(
    (s2) => s2.stop_name.includes("Apartment") || s2.stop_name.includes("Heights") || s2.stop_name.includes("Park") || s2.stop_name.includes("Plaza") || s2.stop_name.includes("Vairo") || s2.stop_name.includes("Toftrees")
  );
  const otherStops = filteredStops.filter(
    (s2) => !campusStops.includes(s2) && !downtownStops.includes(s2) && !apartmentStops.includes(s2)
  );
  return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
    import_api3.List,
    {
      isLoading,
      searchText,
      onSearchTextChange: setSearchText,
      searchBarPlaceholder: "Search by stop name or ID...",
      navigationTitle: "Set Default Stop",
      children: [
        savedStopId && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_api3.List.Section, { title: "Current Default", children: stops.filter((s2) => String(s2.stop_id) === savedStopId).map((stop) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import_api3.List.Item,
          {
            title: stop.stop_name,
            subtitle: `Stop ${String(stop.stop_id)}`,
            icon: { source: import_api3.Icon.Star, tintColor: "#FFD700" },
            accessories: [{ text: "Current Default", icon: import_api3.Icon.Checkmark }],
            actions: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_api3.ActionPanel, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
              import_api3.Action,
              {
                title: "View Status",
                icon: import_api3.Icon.ArrowRight,
                onAction: () => {
                  (0, import_api3.showToast)({
                    style: import_api3.Toast.Style.Success,
                    title: "Opening Status",
                    message: "Check menu bar for bus arrivals"
                  });
                }
              }
            ) })
          },
          String(stop.stop_id)
        )) }),
        campusStops.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_api3.List.Section, { title: "Campus Stops", children: campusStops.map((stop) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import_api3.List.Item,
          {
            title: stop.stop_name,
            subtitle: `Stop ${String(stop.stop_id)}`,
            icon: import_api3.Icon.Building,
            accessories: [
              String(stop.stop_id) === savedStopId && { icon: import_api3.Icon.Checkmark }
            ].filter(Boolean),
            actions: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_api3.ActionPanel, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action,
                {
                  title: "Set as Default Stop",
                  icon: import_api3.Icon.Star,
                  onAction: () => saveDefaultStop(stop)
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action.CopyToClipboard,
                {
                  title: "Copy Stop ID",
                  content: String(stop.stop_id),
                  shortcut: { modifiers: ["cmd"], key: "c" }
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action,
                {
                  title: "Open Extension Preferences",
                  icon: import_api3.Icon.Gear,
                  onAction: import_api3.openExtensionPreferences,
                  shortcut: { modifiers: ["cmd"], key: "," }
                }
              )
            ] })
          },
          String(stop.stop_id)
        )) }),
        downtownStops.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_api3.List.Section, { title: "Downtown Stops", children: downtownStops.map((stop) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import_api3.List.Item,
          {
            title: stop.stop_name,
            subtitle: `Stop ${String(stop.stop_id)}`,
            icon: import_api3.Icon.Store,
            accessories: [
              String(stop.stop_id) === savedStopId && { icon: import_api3.Icon.Checkmark }
            ].filter(Boolean),
            actions: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_api3.ActionPanel, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action,
                {
                  title: "Set as Default Stop",
                  icon: import_api3.Icon.Star,
                  onAction: () => saveDefaultStop(stop)
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action.CopyToClipboard,
                {
                  title: "Copy Stop ID",
                  content: String(stop.stop_id),
                  shortcut: { modifiers: ["cmd"], key: "c" }
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action,
                {
                  title: "Open Extension Preferences",
                  icon: import_api3.Icon.Gear,
                  onAction: import_api3.openExtensionPreferences,
                  shortcut: { modifiers: ["cmd"], key: "," }
                }
              )
            ] })
          },
          String(stop.stop_id)
        )) }),
        apartmentStops.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_api3.List.Section, { title: "Apartments & Residential", children: apartmentStops.map((stop) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import_api3.List.Item,
          {
            title: stop.stop_name,
            subtitle: `Stop ${String(stop.stop_id)}`,
            icon: import_api3.Icon.House,
            accessories: [
              String(stop.stop_id) === savedStopId && { icon: import_api3.Icon.Checkmark }
            ].filter(Boolean),
            actions: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_api3.ActionPanel, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action,
                {
                  title: "Set as Default Stop",
                  icon: import_api3.Icon.Star,
                  onAction: () => saveDefaultStop(stop)
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action.CopyToClipboard,
                {
                  title: "Copy Stop ID",
                  content: String(stop.stop_id),
                  shortcut: { modifiers: ["cmd"], key: "c" }
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action,
                {
                  title: "Open Extension Preferences",
                  icon: import_api3.Icon.Gear,
                  onAction: import_api3.openExtensionPreferences,
                  shortcut: { modifiers: ["cmd"], key: "," }
                }
              )
            ] })
          },
          String(stop.stop_id)
        )) }),
        otherStops.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_api3.List.Section, { title: "Other Stops", children: otherStops.map((stop) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import_api3.List.Item,
          {
            title: stop.stop_name,
            subtitle: `Stop ${String(stop.stop_id)}`,
            icon: import_api3.Icon.Pin,
            accessories: [
              String(stop.stop_id) === savedStopId && { icon: import_api3.Icon.Checkmark }
            ].filter(Boolean),
            actions: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_api3.ActionPanel, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action,
                {
                  title: "Set as Default Stop",
                  icon: import_api3.Icon.Star,
                  onAction: () => saveDefaultStop(stop)
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action.CopyToClipboard,
                {
                  title: "Copy Stop ID",
                  content: String(stop.stop_id),
                  shortcut: { modifiers: ["cmd"], key: "c" }
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_api3.Action,
                {
                  title: "Open Extension Preferences",
                  icon: import_api3.Icon.Gear,
                  onAction: import_api3.openExtensionPreferences,
                  shortcut: { modifiers: ["cmd"], key: "," }
                }
              )
            ] })
          },
          String(stop.stop_id)
        )) }),
        filteredStops.length === 0 && searchText && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import_api3.List.EmptyView,
          {
            title: "No Stops Found",
            description: `No stops matching "${searchText}"`,
            icon: import_api3.Icon.MagnifyingGlass
          }
        )
      ]
    }
  );
}
/*! Bundled license information:

web-streams-polyfill/dist/ponyfill.es2018.js:
  (**
   * @license
   * web-streams-polyfill v3.3.3
   * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)

fetch-blob/index.js:
  (*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

formdata-polyfill/esm.min.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

node-domexception/index.js:
  (*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL3V0aWxzLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvaGVscGVycy9taXNjZWxsYW5lb3VzLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvaGVscGVycy93ZWJpZGwudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9zaW1wbGUtcXVldWUudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcy50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9nZW5lcmljLXJlYWRlci50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvc3R1Yi9udW1iZXItaXNmaW5pdGUudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL3N0dWIvbWF0aC10cnVuYy50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3ZhbGlkYXRvcnMvYmFzaWMudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3JlYWRhYmxlLXN0cmVhbS50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LXJlYWRlci50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvdGFyZ2V0L2VzMjAxOC9zdHViL2FzeW5jLWl0ZXJhdG9yLXByb3RvdHlwZS50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9hc3luYy1pdGVyYXRvci50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvc3R1Yi9udW1iZXItaXNuYW4udHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9hYnN0cmFjdC1vcHMvZWNtYXNjcmlwdC50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL2Fic3RyYWN0LW9wcy9taXNjZWxsYW5lb3VzLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvYWJzdHJhY3Qtb3BzL3F1ZXVlLXdpdGgtc2l6ZXMudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9oZWxwZXJzL2FycmF5LWJ1ZmZlci12aWV3LnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL2J5dGUtc3RyZWFtLWNvbnRyb2xsZXIudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3JlYWRlci1vcHRpb25zLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL2J5b2ItcmVhZGVyLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvYWJzdHJhY3Qtb3BzL3F1ZXVpbmctc3RyYXRlZ3kudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3kudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3VuZGVybHlpbmctc2luay50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3ZhbGlkYXRvcnMvd3JpdGFibGUtc3RyZWFtLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvYWJvcnQtc2lnbmFsLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvd3JpdGFibGUtc3RyZWFtLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9nbG9iYWxzLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9zdHViL2RvbS1leGNlcHRpb24udHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vcGlwZS50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LWNvbnRyb2xsZXIudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vdGVlLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLXN0cmVhbS1saWtlLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL2Zyb20udHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3VuZGVybHlpbmctc291cmNlLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9pdGVyYXRvci1vcHRpb25zLnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9waXBlLW9wdGlvbnMudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3JlYWRhYmxlLXdyaXRhYmxlLXBhaXIudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0udHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3ktaW5pdC50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL2J5dGUtbGVuZ3RoLXF1ZXVpbmctc3RyYXRlZ3kudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9jb3VudC1xdWV1aW5nLXN0cmF0ZWd5LnRzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy90cmFuc2Zvcm1lci50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3RyYW5zZm9ybS1zdHJlYW0udHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9zdHJlYW1zLmNqcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9mZXRjaC1ibG9iL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL2ZldGNoLWJsb2IvZmlsZS5qcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9mb3JtZGF0YS1wb2x5ZmlsbC9lc20ubWluLmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL25vZGUtZG9tZXhjZXB0aW9uL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL2ZldGNoLWJsb2IvZnJvbS5qcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy91dGlscy9tdWx0aXBhcnQtcGFyc2VyLmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL2FkbS16aXAvdXRpbC9jb25zdGFudHMuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2Vycm9ycy5qcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9hZG0temlwL3V0aWwvdXRpbHMuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2ZhdHRyLmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL2FkbS16aXAvdXRpbC9kZWNvZGVyLmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL2FkbS16aXAvdXRpbC9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9hZG0temlwL2hlYWRlcnMvZW50cnlIZWFkZXIuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvYWRtLXppcC9oZWFkZXJzL21haW5IZWFkZXIuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvYWRtLXppcC9oZWFkZXJzL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL2FkbS16aXAvbWV0aG9kcy9kZWZsYXRlci5qcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9hZG0temlwL21ldGhvZHMvaW5mbGF0ZXIuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvYWRtLXppcC9tZXRob2RzL3ppcGNyeXB0by5qcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9hZG0temlwL21ldGhvZHMvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvYWRtLXppcC96aXBFbnRyeS5qcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9hZG0temlwL3ppcEZpbGUuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvYWRtLXppcC9hZG0temlwLmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvc3JjL3NldC1kZWZhdWx0cy50c3giLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9zcmMvbGliL2d0ZnNTdGF0aWMudHMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9zcmMvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvZGF0YS11cmktdG8tYnVmZmVyL3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy9ib2R5LmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL2Vycm9ycy9iYXNlLmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL2Vycm9ycy9mZXRjaC1lcnJvci5qcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy91dGlscy9pcy5qcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy9oZWFkZXJzLmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL3V0aWxzL2lzLXJlZGlyZWN0LmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL3Jlc3BvbnNlLmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL3JlcXVlc3QuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9zcmMvdXRpbHMvZ2V0LXNlYXJjaC5qcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy91dGlscy9yZWZlcnJlci5qcyIsICIuLi8uLi8uLi8uLi9EZXZlbG9wZXIvUmF5Y2FzdCBFeHRlbnNpb25zL2NhdGFidXMtc3RhdHVzL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy9lcnJvcnMvYWJvcnQtZXJyb3IuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi9hcGkvQ3N2RXJyb3IuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi91dGlscy9pc19vYmplY3QuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi9hcGkvbm9ybWFsaXplX2NvbHVtbnNfYXJyYXkuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi91dGlscy9SZXNpemVhYmxlQnVmZmVyLmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL2Nzdi1wYXJzZS9saWIvYXBpL2luaXRfc3RhdGUuanMiLCAiLi4vLi4vLi4vLi4vRGV2ZWxvcGVyL1JheWNhc3QgRXh0ZW5zaW9ucy9jYXRhYnVzLXN0YXR1cy9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi91dGlscy91bmRlcnNjb3JlLmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL2Nzdi1wYXJzZS9saWIvYXBpL25vcm1hbGl6ZV9vcHRpb25zLmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL2Nzdi1wYXJzZS9saWIvYXBpL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL0RldmVsb3Blci9SYXljYXN0IEV4dGVuc2lvbnMvY2F0YWJ1cy1zdGF0dXMvbm9kZV9tb2R1bGVzL2Nzdi1wYXJzZS9saWIvc3luYy5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKTogdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiIsICJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgQXNzZXJ0aW9uRXJyb3IgfSBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlSXNPYmplY3QoeDogYW55KTogeCBpcyBvYmplY3Qge1xuICByZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGNvbnN0IHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbjogKGU6IGFueSkgPT4gdm9pZCA9XG4gIERFQlVHID8gZSA9PiB7XG4gICAgLy8gVXNlZCB0aHJvdWdob3V0IHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24sIGFzIGAuY2F0Y2gocmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uKWAsIHRvIGVuc3VyZSBhbnkgZXJyb3JzXG4gICAgLy8gZ2V0IHNob3duLiBUaGVyZSBhcmUgcGxhY2VzIGluIHRoZSBzcGVjIHdoZXJlIHdlIGRvIHByb21pc2UgdHJhbnNmb3JtYXRpb25zIGFuZCBwdXJwb3NlZnVsbHkgaWdub3JlIG9yIGRvbid0XG4gICAgLy8gZXhwZWN0IGFueSBlcnJvcnMsIGJ1dCBhc3NlcnRpb24gZXJyb3JzIGFyZSBhbHdheXMgcHJvYmxlbWF0aWMuXG4gICAgaWYgKGUgJiYgZSBpbnN0YW5jZW9mIEFzc2VydGlvbkVycm9yKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfSA6IG5vb3A7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGdW5jdGlvbk5hbWUoZm46IEZ1bmN0aW9uLCBuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywge1xuICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBjYXRjaCB7XG4gICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBub24tY29uZmlndXJhYmxlIGluIG9sZGVyIGJyb3dzZXJzLCBzbyBpZ25vcmUgaWYgdGhpcyB0aHJvd3MuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZSNicm93c2VyX2NvbXBhdGliaWxpdHlcbiAgfVxufVxuIiwgImltcG9ydCB7IHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbiB9IGZyb20gJy4vbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcblxuY29uc3Qgb3JpZ2luYWxQcm9taXNlID0gUHJvbWlzZTtcbmNvbnN0IG9yaWdpbmFsUHJvbWlzZVRoZW4gPSBQcm9taXNlLnByb3RvdHlwZS50aGVuO1xuY29uc3Qgb3JpZ2luYWxQcm9taXNlUmVqZWN0ID0gUHJvbWlzZS5yZWplY3QuYmluZChvcmlnaW5hbFByb21pc2UpO1xuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2EtbmV3LXByb21pc2VcbmV4cG9ydCBmdW5jdGlvbiBuZXdQcm9taXNlPFQ+KGV4ZWN1dG9yOiAoXG4gIHJlc29sdmU6ICh2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KSA9PiB2b2lkLFxuICByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWRcbikgPT4gdm9pZCk6IFByb21pc2U8VD4ge1xuICByZXR1cm4gbmV3IG9yaWdpbmFsUHJvbWlzZShleGVjdXRvcik7XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jYS1wcm9taXNlLXJlc29sdmVkLXdpdGhcbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlUmVzb2x2ZWRXaXRoPFQ+KHZhbHVlOiBUIHwgUHJvbWlzZUxpa2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIG5ld1Byb21pc2UocmVzb2x2ZSA9PiByZXNvbHZlKHZhbHVlKSk7XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jYS1wcm9taXNlLXJlamVjdGVkLXdpdGhcbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlUmVqZWN0ZWRXaXRoPFQgPSBuZXZlcj4ocmVhc29uOiBhbnkpOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIG9yaWdpbmFsUHJvbWlzZVJlamVjdChyZWFzb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUGVyZm9ybVByb21pc2VUaGVuPFQsIFRSZXN1bHQxID0gVCwgVFJlc3VsdDIgPSBuZXZlcj4oXG4gIHByb21pc2U6IFByb21pc2U8VD4sXG4gIG9uRnVsZmlsbGVkPzogKHZhbHVlOiBUKSA9PiBUUmVzdWx0MSB8IFByb21pc2VMaWtlPFRSZXN1bHQxPixcbiAgb25SZWplY3RlZD86IChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pOiBQcm9taXNlPFRSZXN1bHQxIHwgVFJlc3VsdDI+IHtcbiAgLy8gVGhlcmUgZG9lc24ndCBhcHBlYXIgdG8gYmUgYW55IHdheSB0byBjb3JyZWN0bHkgZW11bGF0ZSB0aGUgYmVoYXZpb3VyIGZyb20gSmF2YVNjcmlwdCwgc28gdGhpcyBpcyBqdXN0IGFuXG4gIC8vIGFwcHJveGltYXRpb24uXG4gIHJldHVybiBvcmlnaW5hbFByb21pc2VUaGVuLmNhbGwocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIGFzIFByb21pc2U8VFJlc3VsdDEgfCBUUmVzdWx0Mj47XG59XG5cbi8vIEJsdWViaXJkIGxvZ3MgYSB3YXJuaW5nIHdoZW4gYSBwcm9taXNlIGlzIGNyZWF0ZWQgd2l0aGluIGEgZnVsZmlsbG1lbnQgaGFuZGxlciwgYnV0IHRoZW4gaXNuJ3QgcmV0dXJuZWRcbi8vIGZyb20gdGhhdCBoYW5kbGVyLiBUbyBwcmV2ZW50IHRoaXMsIHJldHVybiBudWxsIGluc3RlYWQgb2Ygdm9pZCBmcm9tIGFsbCBoYW5kbGVycy5cbi8vIGh0dHA6Ly9ibHVlYmlyZGpzLmNvbS9kb2NzL3dhcm5pbmctZXhwbGFuYXRpb25zLmh0bWwjd2FybmluZy1hLXByb21pc2Utd2FzLWNyZWF0ZWQtaW4tYS1oYW5kbGVyLWJ1dC13YXMtbm90LXJldHVybmVkLWZyb20taXRcbmV4cG9ydCBmdW5jdGlvbiB1cG9uUHJvbWlzZTxUPihcbiAgcHJvbWlzZTogUHJvbWlzZTxUPixcbiAgb25GdWxmaWxsZWQ/OiAodmFsdWU6IFQpID0+IG51bGwgfCBQcm9taXNlTGlrZTxudWxsPixcbiAgb25SZWplY3RlZD86IChyZWFzb246IGFueSkgPT4gbnVsbCB8IFByb21pc2VMaWtlPG51bGw+KTogdm9pZCB7XG4gIFBlcmZvcm1Qcm9taXNlVGhlbihcbiAgICBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpLFxuICAgIHVuZGVmaW5lZCxcbiAgICByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb25cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwb25GdWxmaWxsbWVudDxUPihwcm9taXNlOiBQcm9taXNlPFQ+LCBvbkZ1bGZpbGxlZDogKHZhbHVlOiBUKSA9PiBudWxsIHwgUHJvbWlzZUxpa2U8bnVsbD4pOiB2b2lkIHtcbiAgdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBvblJlamVjdGlvbihwcm9taXNlOiBQcm9taXNlPHVua25vd24+LCBvblJlamVjdGVkOiAocmVhc29uOiBhbnkpID0+IG51bGwgfCBQcm9taXNlTGlrZTxudWxsPik6IHZvaWQge1xuICB1cG9uUHJvbWlzZShwcm9taXNlLCB1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUHJvbWlzZVdpdGg8VCwgVFJlc3VsdDEgPSBULCBUUmVzdWx0MiA9IG5ldmVyPihcbiAgcHJvbWlzZTogUHJvbWlzZTxUPixcbiAgZnVsZmlsbG1lbnRIYW5kbGVyPzogKHZhbHVlOiBUKSA9PiBUUmVzdWx0MSB8IFByb21pc2VMaWtlPFRSZXN1bHQxPixcbiAgcmVqZWN0aW9uSGFuZGxlcj86IChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pOiBQcm9taXNlPFRSZXN1bHQxIHwgVFJlc3VsdDI+IHtcbiAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwcm9taXNlOiBQcm9taXNlPHVua25vd24+KTogdm9pZCB7XG4gIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCB1bmRlZmluZWQsIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbik7XG59XG5cbmxldCBfcXVldWVNaWNyb3Rhc2s6IChjYWxsYmFjazogKCkgPT4gdm9pZCkgPT4gdm9pZCA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIF9xdWV1ZU1pY3JvdGFzayA9IHF1ZXVlTWljcm90YXNrO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICBfcXVldWVNaWNyb3Rhc2sgPSBjYiA9PiBQZXJmb3JtUHJvbWlzZVRoZW4ocmVzb2x2ZWRQcm9taXNlLCBjYik7XG4gIH1cbiAgcmV0dXJuIF9xdWV1ZU1pY3JvdGFzayhjYWxsYmFjayk7XG59O1xuXG5leHBvcnQgeyBfcXVldWVNaWNyb3Rhc2sgYXMgcXVldWVNaWNyb3Rhc2sgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmxlY3RDYWxsPFQsIEEgZXh0ZW5kcyBhbnlbXSwgUj4oRjogKHRoaXM6IFQsIC4uLmZuQXJnczogQSkgPT4gUiwgVjogVCwgYXJnczogQSk6IFIge1xuICBpZiAodHlwZW9mIEYgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChGLCBWLCBhcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2VDYWxsPFQsIEEgZXh0ZW5kcyBhbnlbXSwgUj4oRjogKHRoaXM6IFQsIC4uLmZuQXJnczogQSkgPT4gUiB8IFByb21pc2VMaWtlPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVjogVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IEEpOiBQcm9taXNlPFI+IHtcbiAgYXNzZXJ0KHR5cGVvZiBGID09PSAnZnVuY3Rpb24nKTtcbiAgYXNzZXJ0KFYgIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChBcnJheS5pc0FycmF5KGFyZ3MpKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aChyZWZsZWN0Q2FsbChGLCBWLCBhcmdzKSk7XG4gIH0gY2F0Y2ggKHZhbHVlKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodmFsdWUpO1xuICB9XG59XG4iLCAiaW1wb3J0IGFzc2VydCBmcm9tICcuLi9zdHViL2Fzc2VydCc7XG5cbi8vIE9yaWdpbmFsIGZyb20gQ2hyb21pdW1cbi8vIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMvKy8wYWVlNDQzNGE0ZGJhNDJhNDJhYmFlYTliZmJjMGNkMTk2YTYzYmMxL3RoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2NvcmUvc3RyZWFtcy9TaW1wbGVRdWV1ZS5qc1xuXG5jb25zdCBRVUVVRV9NQVhfQVJSQVlfU0laRSA9IDE2Mzg0O1xuXG5pbnRlcmZhY2UgTm9kZTxUPiB7XG4gIF9lbGVtZW50czogVFtdO1xuICBfbmV4dDogTm9kZTxUPiB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVldWUgc3RydWN0dXJlLlxuICpcbiAqIEF2b2lkcyBzY2FsYWJpbGl0eSBpc3N1ZXMgd2l0aCB1c2luZyBhIHBhY2tlZCBhcnJheSBkaXJlY3RseSBieSB1c2luZ1xuICogbXVsdGlwbGUgYXJyYXlzIGluIGEgbGlua2VkIGxpc3QgYW5kIGtlZXBpbmcgdGhlIGFycmF5IHNpemUgYm91bmRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXBsZVF1ZXVlPFQ+IHtcbiAgcHJpdmF0ZSBfZnJvbnQ6IE5vZGU8VD47XG4gIHByaXZhdGUgX2JhY2s6IE5vZGU8VD47XG4gIHByaXZhdGUgX2N1cnNvciA9IDA7XG4gIHByaXZhdGUgX3NpemUgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIF9mcm9udCBhbmQgX2JhY2sgYXJlIGFsd2F5cyBkZWZpbmVkLlxuICAgIHRoaXMuX2Zyb250ID0ge1xuICAgICAgX2VsZW1lbnRzOiBbXSxcbiAgICAgIF9uZXh0OiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHRoaXMuX2JhY2sgPSB0aGlzLl9mcm9udDtcbiAgICAvLyBUaGUgY3Vyc29yIGlzIHVzZWQgdG8gYXZvaWQgY2FsbGluZyBBcnJheS5zaGlmdCgpLlxuICAgIC8vIEl0IGNvbnRhaW5zIHRoZSBpbmRleCBvZiB0aGUgZnJvbnQgZWxlbWVudCBvZiB0aGUgYXJyYXkgaW5zaWRlIHRoZVxuICAgIC8vIGZyb250LW1vc3Qgbm9kZS4gSXQgaXMgYWx3YXlzIGluIHRoZSByYW5nZSBbMCwgUVVFVUVfTUFYX0FSUkFZX1NJWkUpLlxuICAgIHRoaXMuX2N1cnNvciA9IDA7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBvbmx5IG9uZSBub2RlLCBzaXplID09PSBlbGVtZW50cy5sZW5ndGggLSBjdXJzb3IuXG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gIH1cblxuICBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuICAvLyBGb3IgZXhjZXB0aW9uIHNhZmV0eSwgdGhpcyBtZXRob2QgaXMgc3RydWN0dXJlZCBpbiBvcmRlcjpcbiAgLy8gMS4gUmVhZCBzdGF0ZVxuICAvLyAyLiBDYWxjdWxhdGUgcmVxdWlyZWQgc3RhdGUgbXV0YXRpb25zXG4gIC8vIDMuIFBlcmZvcm0gc3RhdGUgbXV0YXRpb25zXG4gIHB1c2goZWxlbWVudDogVCk6IHZvaWQge1xuICAgIGNvbnN0IG9sZEJhY2sgPSB0aGlzLl9iYWNrO1xuICAgIGxldCBuZXdCYWNrID0gb2xkQmFjaztcbiAgICBhc3NlcnQob2xkQmFjay5fbmV4dCA9PT0gdW5kZWZpbmVkKTtcbiAgICBpZiAob2xkQmFjay5fZWxlbWVudHMubGVuZ3RoID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSAtIDEpIHtcbiAgICAgIG5ld0JhY2sgPSB7XG4gICAgICAgIF9lbGVtZW50czogW10sXG4gICAgICAgIF9uZXh0OiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gcHVzaCgpIGlzIHRoZSBtdXRhdGlvbiBtb3N0IGxpa2VseSB0byB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGl0XG4gICAgLy8gZ29lcyBmaXJzdC5cbiAgICBvbGRCYWNrLl9lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIGlmIChuZXdCYWNrICE9PSBvbGRCYWNrKSB7XG4gICAgICB0aGlzLl9iYWNrID0gbmV3QmFjaztcbiAgICAgIG9sZEJhY2suX25leHQgPSBuZXdCYWNrO1xuICAgIH1cbiAgICArK3RoaXMuX3NpemU7XG4gIH1cblxuICAvLyBMaWtlIHB1c2goKSwgc2hpZnQoKSBmb2xsb3dzIHRoZSByZWFkIC0+IGNhbGN1bGF0ZSAtPiBtdXRhdGUgcGF0dGVybiBmb3JcbiAgLy8gZXhjZXB0aW9uIHNhZmV0eS5cbiAgc2hpZnQoKTogVCB7XG4gICAgYXNzZXJ0KHRoaXMuX3NpemUgPiAwKTsgLy8gbXVzdCBub3QgYmUgY2FsbGVkIG9uIGFuIGVtcHR5IHF1ZXVlXG5cbiAgICBjb25zdCBvbGRGcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIGxldCBuZXdGcm9udCA9IG9sZEZyb250O1xuICAgIGNvbnN0IG9sZEN1cnNvciA9IHRoaXMuX2N1cnNvcjtcbiAgICBsZXQgbmV3Q3Vyc29yID0gb2xkQ3Vyc29yICsgMTtcblxuICAgIGNvbnN0IGVsZW1lbnRzID0gb2xkRnJvbnQuX2VsZW1lbnRzO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tvbGRDdXJzb3JdO1xuXG4gICAgaWYgKG5ld0N1cnNvciA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUpIHtcbiAgICAgIGFzc2VydChlbGVtZW50cy5sZW5ndGggPT09IFFVRVVFX01BWF9BUlJBWV9TSVpFKTtcbiAgICAgIGFzc2VydChvbGRGcm9udC5fbmV4dCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIG5ld0Zyb250ID0gb2xkRnJvbnQuX25leHQhO1xuICAgICAgbmV3Q3Vyc29yID0gMDtcbiAgICB9XG5cbiAgICAvLyBObyBtdXRhdGlvbnMgYmVmb3JlIHRoaXMgcG9pbnQuXG4gICAgLS10aGlzLl9zaXplO1xuICAgIHRoaXMuX2N1cnNvciA9IG5ld0N1cnNvcjtcbiAgICBpZiAob2xkRnJvbnQgIT09IG5ld0Zyb250KSB7XG4gICAgICB0aGlzLl9mcm9udCA9IG5ld0Zyb250O1xuICAgIH1cblxuICAgIC8vIFBlcm1pdCBzaGlmdGVkIGVsZW1lbnQgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgZWxlbWVudHNbb2xkQ3Vyc29yXSA9IHVuZGVmaW5lZCE7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8vIFRoZSB0cmlja3kgdGhpbmcgYWJvdXQgZm9yRWFjaCgpIGlzIHRoYXQgaXQgY2FuIGJlIGNhbGxlZFxuICAvLyByZS1lbnRyYW50bHkuIFRoZSBxdWV1ZSBtYXkgYmUgbXV0YXRlZCBpbnNpZGUgdGhlIGNhbGxiYWNrLiBJdCBpcyBlYXN5IHRvXG4gIC8vIHNlZSB0aGF0IHB1c2goKSB3aXRoaW4gdGhlIGNhbGxiYWNrIGhhcyBubyBuZWdhdGl2ZSBlZmZlY3RzIHNpbmNlIHRoZSBlbmRcbiAgLy8gb2YgdGhlIHF1ZXVlIGlzIGNoZWNrZWQgZm9yIG9uIGV2ZXJ5IGl0ZXJhdGlvbi4gSWYgc2hpZnQoKSBpcyBjYWxsZWRcbiAgLy8gcmVwZWF0ZWRseSB3aXRoaW4gdGhlIGNhbGxiYWNrIHRoZW4gdGhlIG5leHQgaXRlcmF0aW9uIG1heSByZXR1cm4gYW5cbiAgLy8gZWxlbWVudCB0aGF0IGhhcyBiZWVuIHJlbW92ZWQuIEluIHRoaXMgY2FzZSB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAgLy8gd2l0aCB1bmRlZmluZWQgdmFsdWVzIHVudGlsIHdlIGVpdGhlciBcImNhdGNoIHVwXCIgd2l0aCBlbGVtZW50cyB0aGF0IHN0aWxsXG4gIC8vIGV4aXN0IG9yIHJlYWNoIHRoZSBiYWNrIG9mIHRoZSBxdWV1ZS5cbiAgZm9yRWFjaChjYWxsYmFjazogKGVsZW1lbnQ6IFQpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBsZXQgaSA9IHRoaXMuX2N1cnNvcjtcbiAgICBsZXQgbm9kZSA9IHRoaXMuX2Zyb250O1xuICAgIGxldCBlbGVtZW50cyA9IG5vZGUuX2VsZW1lbnRzO1xuICAgIHdoaWxlIChpICE9PSBlbGVtZW50cy5sZW5ndGggfHwgbm9kZS5fbmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaSA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGFzc2VydChub2RlLl9uZXh0ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBhc3NlcnQoaSA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUpO1xuICAgICAgICBub2RlID0gbm9kZS5fbmV4dCE7XG4gICAgICAgIGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVsZW1lbnRzW2ldKTtcbiAgICAgICsraTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIGVsZW1lbnQgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCBpZiBzaGlmdCgpIHdhcyBjYWxsZWQgbm93LFxuICAvLyB3aXRob3V0IG1vZGlmeWluZyB0aGUgcXVldWUuXG4gIHBlZWsoKTogVCB7XG4gICAgYXNzZXJ0KHRoaXMuX3NpemUgPiAwKTsgLy8gbXVzdCBub3QgYmUgY2FsbGVkIG9uIGFuIGVtcHR5IHF1ZXVlXG5cbiAgICBjb25zdCBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuX2N1cnNvcjtcbiAgICByZXR1cm4gZnJvbnQuX2VsZW1lbnRzW2N1cnNvcl07XG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgQWJvcnRTdGVwcyA9IFN5bWJvbCgnW1tBYm9ydFN0ZXBzXV0nKTtcbmV4cG9ydCBjb25zdCBFcnJvclN0ZXBzID0gU3ltYm9sKCdbW0Vycm9yU3RlcHNdXScpO1xuZXhwb3J0IGNvbnN0IENhbmNlbFN0ZXBzID0gU3ltYm9sKCdbW0NhbmNlbFN0ZXBzXV0nKTtcbmV4cG9ydCBjb25zdCBQdWxsU3RlcHMgPSBTeW1ib2woJ1tbUHVsbFN0ZXBzXV0nKTtcbmV4cG9ydCBjb25zdCBSZWxlYXNlU3RlcHMgPSBTeW1ib2woJ1tbUmVsZWFzZVN0ZXBzXV0nKTtcbiIsICJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbUNhbmNlbCwgdHlwZSBSZWFkYWJsZVN0cmVhbVJlYWRlciB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBuZXdQcm9taXNlLCBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHsgUmVsZWFzZVN0ZXBzIH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL2ludGVybmFsLW1ldGhvZHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZTxSPihyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPFI+LCBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+KSB7XG4gIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcbiAgc3RyZWFtLl9yZWFkZXIgPSByZWFkZXI7XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcbiAgfSBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKTtcblxuICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxufVxuXG4vLyBBIGNsaWVudCBvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgYW5kIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGVcbi8vIGNoZWNrLlxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55PiwgcmVhc29uOiBhbnkpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG4gIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIHJlYXNvbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55Pikge1xuICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChzdHJlYW0uX3JlYWRlciA9PT0gcmVhZGVyKTtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KFxuICAgICAgcmVhZGVyLFxuICAgICAgbmV3IFR5cGVFcnJvcihgUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQoXG4gICAgICByZWFkZXIsXG4gICAgICBuZXcgVHlwZUVycm9yKGBSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApKTtcbiAgfVxuXG4gIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW1JlbGVhc2VTdGVwc10oKTtcblxuICBzdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcbiAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID0gdW5kZWZpbmVkITtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkZXJMb2NrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdDYW5ub3QgJyArIG5hbWUgKyAnIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgcmVhZGVyJyk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIuXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+KSB7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+LCByZWFzb246IGFueSkge1xuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZChyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4pIHtcbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+LCByZWFzb246IGFueSkge1xuICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShyZWFkZXIuX2Nsb3NlZFByb21pc2UpO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+LCByZWFzb246IGFueSkge1xuICBhc3NlcnQocmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpO1xuXG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55Pikge1xuICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xufVxuIiwgIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzRmluaXRlI1BvbHlmaWxsXG5jb25zdCBOdW1iZXJJc0Zpbml0ZTogdHlwZW9mIE51bWJlci5pc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIGlzRmluaXRlKHgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTnVtYmVySXNGaW5pdGU7XG4iLCAiLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jI1BvbHlmaWxsXG5jb25zdCBNYXRoVHJ1bmM6IHR5cGVvZiBNYXRoLnRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xuICByZXR1cm4gdiA8IDAgPyBNYXRoLmNlaWwodikgOiBNYXRoLmZsb29yKHYpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTWF0aFRydW5jO1xuIiwgImltcG9ydCBOdW1iZXJJc0Zpbml0ZSBmcm9tICcuLi8uLi9zdHViL251bWJlci1pc2Zpbml0ZSc7XG5pbXBvcnQgTWF0aFRydW5jIGZyb20gJy4uLy4uL3N0dWIvbWF0aC10cnVuYyc7XG5cbi8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1kaWN0aW9uYXJpZXNcbmV4cG9ydCBmdW5jdGlvbiBpc0RpY3Rpb25hcnkoeDogYW55KTogeCBpcyBvYmplY3QgfCBudWxsIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydERpY3Rpb25hcnkob2JqOiB1bmtub3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyBvYmogaXMgb2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogIT09IHVuZGVmaW5lZCAmJiAhaXNEaWN0aW9uYXJ5KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBvYmplY3QuYCk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQW55RnVuY3Rpb24gPSAoLi4uYXJnczogYW55W10pID0+IGFueTtcblxuLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLWNhbGxiYWNrLWZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHg6IHVua25vd24sIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgeCBpcyBBbnlGdW5jdGlvbiB7XG4gIGlmICh0eXBlb2YgeCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLW9iamVjdFxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHg6IGFueSk6IHggaXMgb2JqZWN0IHtcbiAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPYmplY3QoeDogdW5rbm93bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyB4IGlzIG9iamVjdCB7XG4gIGlmICghaXNPYmplY3QoeCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBvYmplY3QuYCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkQXJndW1lbnQ8VD4oeDogVCB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBhc3NlcnRzIHggaXMgVCB7XG4gIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJHtwb3NpdGlvbn0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEZpZWxkPFQ+KHg6IFQgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyB4IGlzIFQge1xuICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmaWVsZH0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xuICB9XG59XG5cbi8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC11bnJlc3RyaWN0ZWQtZG91YmxlXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVucmVzdHJpY3RlZERvdWJsZSh2YWx1ZTogdW5rbm93bik6IG51bWJlciB7XG4gIHJldHVybiBOdW1iZXIodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBjZW5zb3JOZWdhdGl2ZVplcm8oeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHggPT09IDAgPyAwIDogeDtcbn1cblxuZnVuY3Rpb24gaW50ZWdlclBhcnQoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIGNlbnNvck5lZ2F0aXZlWmVybyhNYXRoVHJ1bmMoeCkpO1xufVxuXG4vLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtdW5zaWduZWQtbG9uZy1sb25nXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKHZhbHVlOiB1bmtub3duLCBjb250ZXh0OiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBsb3dlckJvdW5kID0gMDtcbiAgY29uc3QgdXBwZXJCb3VuZCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gIGxldCB4ID0gTnVtYmVyKHZhbHVlKTtcbiAgeCA9IGNlbnNvck5lZ2F0aXZlWmVybyh4KTtcblxuICBpZiAoIU51bWJlcklzRmluaXRlKHgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmaW5pdGUgbnVtYmVyYCk7XG4gIH1cblxuICB4ID0gaW50ZWdlclBhcnQoeCk7XG5cbiAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBvdXRzaWRlIHRoZSBhY2NlcHRlZCByYW5nZSBvZiAke2xvd2VyQm91bmR9IHRvICR7dXBwZXJCb3VuZH0sIGluY2x1c2l2ZWApO1xuICB9XG5cbiAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSB8fCB4ID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBUT0RPIFVzZSBCaWdJbnQgaWYgc3VwcG9ydGVkP1xuICAvLyBsZXQgeEJpZ0ludCA9IEJpZ0ludChpbnRlZ2VyUGFydCh4KSk7XG4gIC8vIHhCaWdJbnQgPSBCaWdJbnQuYXNVaW50Tig2NCwgeEJpZ0ludCk7XG4gIC8vIHJldHVybiBOdW1iZXIoeEJpZ0ludCk7XG5cbiAgcmV0dXJuIHg7XG59XG4iLCAiaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UmVhZGFibGVTdHJlYW0oeDogdW5rbm93biwgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyB4IGlzIFJlYWRhYmxlU3RyZWFtIHtcbiAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBSZWFkYWJsZVN0cmVhbS5gKTtcbiAgfVxufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlLFxuICByZWFkZXJMb2NrRXhjZXB0aW9uXG59IGZyb20gJy4vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCwgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgc2V0RnVuY3Rpb25OYW1lLCB0eXBlSXNPYmplY3QgfSBmcm9tICcuLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgUHVsbFN0ZXBzIH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL2ludGVybmFsLW1ldGhvZHMnO1xuaW1wb3J0IHsgbmV3UHJvbWlzZSwgcHJvbWlzZVJlamVjdGVkV2l0aCB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IGFzc2VydFJlcXVpcmVkQXJndW1lbnQgfSBmcm9tICcuLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGFzc2VydFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vdmFsaWRhdG9ycy9yZWFkYWJsZS1zdHJlYW0nO1xuXG4vKipcbiAqIEEgcmVzdWx0IHJldHVybmVkIGJ5IHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucmVhZH0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFQ+ID0ge1xuICBkb25lOiBmYWxzZTtcbiAgdmFsdWU6IFQ7XG59IHwge1xuICBkb25lOiB0cnVlO1xuICB2YWx1ZT86IHVuZGVmaW5lZDtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXG5leHBvcnQgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+IHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbn1cblxuLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdDxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+KTogdm9pZCB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0uX3JlYWRlcikpO1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJyk7XG5cbiAgKHN0cmVhbS5fcmVhZGVyISBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4pLl9yZWFkUmVxdWVzdHMucHVzaChyZWFkUmVxdWVzdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdDxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LCBjaHVuazogUiB8IHVuZGVmaW5lZCwgZG9uZTogYm9vbGVhbikge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj47XG5cbiAgYXNzZXJ0KHJlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aCA+IDApO1xuXG4gIGNvbnN0IHJlYWRSZXF1ZXN0ID0gcmVhZGVyLl9yZWFkUmVxdWVzdHMuc2hpZnQoKSE7XG4gIGlmIChkb25lKSB7XG4gICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcbiAgfSBlbHNlIHtcbiAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayEpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0czxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+KTogbnVtYmVyIHtcbiAgcmV0dXJuIChzdHJlYW0uX3JlYWRlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4pLl9yZWFkUmVxdWVzdHMubGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBib29sZWFuIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cbiAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFJlYWRlcnNcblxuZXhwb3J0IGludGVyZmFjZSBSZWFkUmVxdWVzdDxSPiB7XG4gIF9jaHVua1N0ZXBzKGNodW5rOiBSKTogdm9pZDtcblxuICBfY2xvc2VTdGVwcygpOiB2b2lkO1xuXG4gIF9lcnJvclN0ZXBzKGU6IGFueSk6IHZvaWQ7XG59XG5cbi8qKlxuICogQSBkZWZhdWx0IHJlYWRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW19LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSID0gYW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX293bmVyUmVhZGFibGVTdHJlYW0hOiBSZWFkYWJsZVN0cmVhbTxSPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZSE6IFByb21pc2U8dW5kZWZpbmVkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZV9yZXNvbHZlPzogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlX3JlamVjdD86IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZFJlcXVlc3RzOiBTaW1wbGVRdWV1ZTxSZWFkUmVxdWVzdDxSPj47XG5cbiAgY29uc3RydWN0b3Ioc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPikge1xuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyJyk7XG4gICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHJlYWRpbmcgYnkgYW5vdGhlciByZWFkZXInKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG5cbiAgICB0aGlzLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCxcbiAgICogb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvciB0aGUgcmVhZGVyJ3MgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuICAgKi9cbiAgZ2V0IGNsb3NlZCgpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFJlYWRhYmxlU3RyZWFtLmNhbmNlbCB8IHN0cmVhbS5jYW5jZWwocmVhc29uKX0uXG4gICAqL1xuICBjYW5jZWwocmVhc29uOiBhbnkgPSB1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBhbGxvd3MgYWNjZXNzIHRvIHRoZSBuZXh0IGNodW5rIGZyb20gdGhlIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLCBpZiBhdmFpbGFibGUuXG4gICAqXG4gICAqIElmIHJlYWRpbmcgYSBjaHVuayBjYXVzZXMgdGhlIHF1ZXVlIHRvIGJlY29tZSBlbXB0eSwgbW9yZSBkYXRhIHdpbGwgYmUgcHVsbGVkIGZyb20gdGhlIHVuZGVybHlpbmcgc291cmNlLlxuICAgKi9cbiAgcmVhZCgpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVQcm9taXNlITogKHJlc3VsdDogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPikgPT4gdm9pZDtcbiAgICBsZXQgcmVqZWN0UHJvbWlzZSE6IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRSZXF1ZXN0OiBSZWFkUmVxdWVzdDxSPiA9IHtcbiAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSksXG4gICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pLFxuICAgICAgX2Vycm9yU3RlcHM6IGUgPT4gcmVqZWN0UHJvbWlzZShlKVxuICAgIH07XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCh0aGlzLCByZWFkUmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIHJlYWRlcidzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuICAgKlxuICAgKiBBIHJlYWRlcidzIGxvY2sgY2Fubm90IGJlIHJlbGVhc2VkIHdoaWxlIGl0IHN0aWxsIGhhcyBhIHBlbmRpbmcgcmVhZCByZXF1ZXN0LCBpLmUuLCBpZiBhIHByb21pc2UgcmV0dXJuZWQgYnlcbiAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xuICAgKiBkbyBzbyB3aWxsIHRocm93IGEgYFR5cGVFcnJvcmAgYW5kIGxlYXZlIHRoZSByZWFkZXIgbG9ja2VkIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICByZWxlYXNlTG9jaygpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVsZWFzZSh0aGlzKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCB7XG4gIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlYWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUuY2FuY2VsLCAnY2FuY2VsJyk7XG5zZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZS5yZWFkLCAncmVhZCcpO1xuc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUucmVsZWFzZUxvY2ssICdyZWxlYXNlTG9jaycpO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgcmVhZGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFIgPSBhbnk+KHg6IGFueSk6IHggaXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRSZXF1ZXN0cycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkPFI+KHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+KTogdm9pZCB7XG4gIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuXG4gIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuICB9IGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcbiAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0IGFzIFJlYWRSZXF1ZXN0PGFueT4pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWxlYXNlKHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKSB7XG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgY29uc3QgZSA9IG5ldyBUeXBlRXJyb3IoJ1JlYWRlciB3YXMgcmVsZWFzZWQnKTtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyRXJyb3JSZWFkUmVxdWVzdHMocmVhZGVyLCBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlckVycm9yUmVhZFJlcXVlc3RzKHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLCBlOiBhbnkpIHtcbiAgY29uc3QgcmVhZFJlcXVlc3RzID0gcmVhZGVyLl9yZWFkUmVxdWVzdHM7XG4gIHJlYWRlci5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIHJlYWRSZXF1ZXN0cy5mb3JFYWNoKHJlYWRSZXF1ZXN0ID0+IHtcbiAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgfSk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIuXG5cbmZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcmApO1xufVxuIiwgIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxOC5hc3luY2l0ZXJhYmxlXCIgLz5cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uICovXG5leHBvcnQgY29uc3QgQXN5bmNJdGVyYXRvclByb3RvdHlwZTogQXN5bmNJdGVyYWJsZTxhbnk+ID1cbiAgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbiogKCk6IEFzeW5jSXRlcmFibGVJdGVyYXRvcjxhbnk+IHt9KS5wcm90b3R5cGUpO1xuIiwgIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxOC5hc3luY2l0ZXJhYmxlXCIgLz5cblxuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHtcbiAgQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkLFxuICB0eXBlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQsXG4gIHR5cGUgUmVhZFJlcXVlc3Rcbn0gZnJvbSAnLi9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwsIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UgfSBmcm9tICcuL2dlbmVyaWMtcmVhZGVyJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgQXN5bmNJdGVyYXRvclByb3RvdHlwZSB9IGZyb20gJ0BAdGFyZ2V0L3N0dWIvYXN5bmMtaXRlcmF0b3ItcHJvdG90eXBlJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4uL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQge1xuICBuZXdQcm9taXNlLFxuICBwcm9taXNlUmVqZWN0ZWRXaXRoLFxuICBwcm9taXNlUmVzb2x2ZWRXaXRoLFxuICBxdWV1ZU1pY3JvdGFzayxcbiAgdHJhbnNmb3JtUHJvbWlzZVdpdGhcbn0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuXG4vKipcbiAqIEFuIGFzeW5jIGl0ZXJhdG9yIHJldHVybmVkIGJ5IHtAbGluayBSZWFkYWJsZVN0cmVhbS52YWx1ZXN9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj4gZXh0ZW5kcyBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8Uj4ge1xuICBuZXh0KCk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8UiwgdW5kZWZpbmVkPj47XG5cbiAgcmV0dXJuKHZhbHVlPzogYW55KTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxhbnk+Pjtcbn1cblxuZXhwb3J0IGNsYXNzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGw8Uj4ge1xuICBwcml2YXRlIHJlYWRvbmx5IF9yZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPjtcbiAgcHJpdmF0ZSByZWFkb25seSBfcHJldmVudENhbmNlbDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBfb25nb2luZ1Byb21pc2U6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPj4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIHByaXZhdGUgX2lzRmluaXNoZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihyZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPiwgcHJldmVudENhbmNlbDogYm9vbGVhbikge1xuICAgIHRoaXMuX3JlYWRlciA9IHJlYWRlcjtcbiAgICB0aGlzLl9wcmV2ZW50Q2FuY2VsID0gcHJldmVudENhbmNlbDtcbiAgfVxuXG4gIG5leHQoKTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+PiB7XG4gICAgY29uc3QgbmV4dFN0ZXBzID0gKCkgPT4gdGhpcy5fbmV4dFN0ZXBzKCk7XG4gICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XG4gICAgICB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0aGlzLl9vbmdvaW5nUHJvbWlzZSwgbmV4dFN0ZXBzLCBuZXh0U3RlcHMpIDpcbiAgICAgIG5leHRTdGVwcygpO1xuICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZTtcbiAgfVxuXG4gIHJldHVybih2YWx1ZTogYW55KTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PGFueT4+IHtcbiAgICBjb25zdCByZXR1cm5TdGVwcyA9ICgpID0+IHRoaXMuX3JldHVyblN0ZXBzKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2UgP1xuICAgICAgdHJhbnNmb3JtUHJvbWlzZVdpdGgodGhpcy5fb25nb2luZ1Byb21pc2UsIHJldHVyblN0ZXBzLCByZXR1cm5TdGVwcykgOlxuICAgICAgcmV0dXJuU3RlcHMoKTtcbiAgfVxuXG4gIHByaXZhdGUgX25leHRTdGVwcygpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4+IHtcbiAgICBpZiAodGhpcy5faXNGaW5pc2hlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5fcmVhZGVyO1xuICAgIGFzc2VydChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gIT09IHVuZGVmaW5lZCk7XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2UhOiAocmVzdWx0OiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+KSA9PiB2b2lkO1xuICAgIGxldCByZWplY3RQcm9taXNlITogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgY29uc3QgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBieSBvbmUgbWljcm90YXNrLCBvdGhlcndpc2Ugd2Ugc3RvcCBwdWxsaW5nIHRvbyBlYXJseSB3aGljaCBicmVha3MgYSB0ZXN0LlxuICAgICAgICAvLyBGSVhNRSBJcyB0aGlzIGEgYnVnIGluIHRoZSBzcGVjaWZpY2F0aW9uLCBvciBpbiB0aGUgdGVzdD9cbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pKTtcbiAgICAgIH0sXG4gICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuICAgICAgfSxcbiAgICAgIF9lcnJvclN0ZXBzOiByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgcmVqZWN0UHJvbWlzZShyZWFzb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHByaXZhdGUgX3JldHVyblN0ZXBzKHZhbHVlOiBhbnkpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8YW55Pj4ge1xuICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG4gICAgfVxuICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5fcmVhZGVyO1xuICAgIGFzc2VydChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gIT09IHVuZGVmaW5lZCk7XG4gICAgYXNzZXJ0KHJlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aCA9PT0gMCk7XG5cbiAgICBpZiAoIXRoaXMuX3ByZXZlbnRDYW5jZWwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbChyZWFkZXIsIHZhbHVlKTtcbiAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChyZXN1bHQsICgpID0+ICh7IHZhbHVlLCBkb25lOiB0cnVlIH0pKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW5zdGFuY2U8Uj4gZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj4ge1xuICAvKiogQGludGVyYWwgKi9cbiAgX2FzeW5jSXRlcmF0b3JJbXBsOiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsPFI+O1xuXG4gIG5leHQoKTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxSLCB1bmRlZmluZWQ+PjtcblxuICByZXR1cm4odmFsdWU/OiBhbnkpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PGFueT4+O1xufVxuXG5jb25zdCBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGU6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckluc3RhbmNlPGFueT4gPSB7XG4gIG5leHQodGhpczogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW5zdGFuY2U8YW55Pik6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxhbnk+PiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24oJ25leHQnKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hc3luY0l0ZXJhdG9ySW1wbC5uZXh0KCk7XG4gIH0sXG5cbiAgcmV0dXJuKHRoaXM6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckluc3RhbmNlPGFueT4sIHZhbHVlOiBhbnkpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8YW55Pj4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXR1cm4nKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hc3luY0l0ZXJhdG9ySW1wbC5yZXR1cm4odmFsdWUpO1xuICB9XG59IGFzIGFueTtcbk9iamVjdC5zZXRQcm90b3R5cGVPZihSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbmV4cG9ydCBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50Q2FuY2VsOiBib29sZWFuKTogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+IHtcbiAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPihzdHJlYW0pO1xuICBjb25zdCBpbXBsID0gbmV3IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwocmVhZGVyLCBwcmV2ZW50Q2FuY2VsKTtcbiAgY29uc3QgaXRlcmF0b3I6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckluc3RhbmNlPFI+ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuICBpdGVyYXRvci5fYXN5bmNJdGVyYXRvckltcGwgPSBpbXBsO1xuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFIgPSBhbnk+KHg6IGFueSk6IHggaXMgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2FzeW5jSXRlcmF0b3JJbXBsJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIG5vaW5zcGVjdGlvbiBTdXNwaWNpb3VzVHlwZU9mR3VhcmRcbiAgICByZXR1cm4gKHggYXMgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW5zdGFuY2U8YW55PikuX2FzeW5jSXRlcmF0b3JJbXBsIGluc3RhbmNlb2ZcbiAgICAgIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGw7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbmZ1bmN0aW9uIHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdGVhbUFzeW5jSXRlcmF0b3JgKTtcbn1cbiIsICIvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc05hTiNQb2x5ZmlsbFxuY29uc3QgTnVtYmVySXNOYU46IHR5cGVvZiBOdW1iZXIuaXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gKHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCAhPT0geDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE51bWJlcklzTmFOO1xuIiwgImltcG9ydCB7IHJlZmxlY3RDYWxsIH0gZnJvbSAnbGliL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4uL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgQXJyYXlCdWZmZXIge1xuICAgIHJlYWRvbmx5IGRldGFjaGVkOiBib29sZWFuO1xuXG4gICAgdHJhbnNmZXIoKTogQXJyYXlCdWZmZXI7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJ1Y3R1cmVkQ2xvbmU8VD4odmFsdWU6IFQsIG9wdGlvbnM6IHsgdHJhbnNmZXI6IEFycmF5QnVmZmVyW10gfSk6IFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDcmVhdGVBcnJheUZyb21MaXN0PFQgZXh0ZW5kcyBhbnlbXT4oZWxlbWVudHM6IFQpOiBUIHtcbiAgLy8gV2UgdXNlIGFycmF5cyB0byByZXByZXNlbnQgbGlzdHMsIHNvIHRoaXMgaXMgYmFzaWNhbGx5IGEgbm8tb3AuXG4gIC8vIERvIGEgc2xpY2UgdGhvdWdoIGp1c3QgaW4gY2FzZSB3ZSBoYXBwZW4gdG8gZGVwZW5kIG9uIHRoZSB1bmlxdWUtbmVzcy5cbiAgcmV0dXJuIGVsZW1lbnRzLnNsaWNlKCkgYXMgVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvcHlEYXRhQmxvY2tCeXRlcyhkZXN0OiBBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdE9mZnNldDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM6IEFycmF5QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNPZmZzZXQ6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbjogbnVtYmVyKSB7XG4gIG5ldyBVaW50OEFycmF5KGRlc3QpLnNldChuZXcgVWludDhBcnJheShzcmMsIHNyY09mZnNldCwgbiksIGRlc3RPZmZzZXQpO1xufVxuXG5leHBvcnQgbGV0IFRyYW5zZmVyQXJyYXlCdWZmZXIgPSAoTzogQXJyYXlCdWZmZXIpOiBBcnJheUJ1ZmZlciA9PiB7XG4gIGlmICh0eXBlb2YgTy50cmFuc2ZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFRyYW5zZmVyQXJyYXlCdWZmZXIgPSBidWZmZXIgPT4gYnVmZmVyLnRyYW5zZmVyKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0cnVjdHVyZWRDbG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFRyYW5zZmVyQXJyYXlCdWZmZXIgPSBidWZmZXIgPT4gc3RydWN0dXJlZENsb25lKGJ1ZmZlciwgeyB0cmFuc2ZlcjogW2J1ZmZlcl0gfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm90IGltcGxlbWVudGVkIGNvcnJlY3RseVxuICAgIFRyYW5zZmVyQXJyYXlCdWZmZXIgPSBidWZmZXIgPT4gYnVmZmVyO1xuICB9XG4gIHJldHVybiBUcmFuc2ZlckFycmF5QnVmZmVyKE8pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIENhblRyYW5zZmVyQXJyYXlCdWZmZXIoTzogQXJyYXlCdWZmZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuICFJc0RldGFjaGVkQnVmZmVyKE8pO1xufVxuXG5leHBvcnQgbGV0IElzRGV0YWNoZWRCdWZmZXIgPSAoTzogQXJyYXlCdWZmZXIpOiBib29sZWFuID0+IHtcbiAgaWYgKHR5cGVvZiBPLmRldGFjaGVkID09PSAnYm9vbGVhbicpIHtcbiAgICBJc0RldGFjaGVkQnVmZmVyID0gYnVmZmVyID0+IGJ1ZmZlci5kZXRhY2hlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG4gICAgSXNEZXRhY2hlZEJ1ZmZlciA9IGJ1ZmZlciA9PiBidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMDtcbiAgfVxuICByZXR1cm4gSXNEZXRhY2hlZEJ1ZmZlcihPKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBBcnJheUJ1ZmZlclNsaWNlKGJ1ZmZlcjogQXJyYXlCdWZmZXIsIGJlZ2luOiBudW1iZXIsIGVuZDogbnVtYmVyKTogQXJyYXlCdWZmZXIge1xuICAvLyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTEwXG4gIC8vIGh0dHBzOi8vd3d3LmNhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX2FycmF5YnVmZmVyX3NsaWNlXG4gIGlmIChidWZmZXIuc2xpY2UpIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IGVuZCAtIGJlZ2luO1xuICBjb25zdCBzbGljZSA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xuICBDb3B5RGF0YUJsb2NrQnl0ZXMoc2xpY2UsIDAsIGJ1ZmZlciwgYmVnaW4sIGxlbmd0aCk7XG4gIHJldHVybiBzbGljZTtcbn1cblxuZXhwb3J0IHR5cGUgTWV0aG9kTmFtZTxUPiA9IHtcbiAgW1AgaW4ga2V5b2YgVF06IFRbUF0gZXh0ZW5kcyBGdW5jdGlvbiB8IHVuZGVmaW5lZCA/IFAgOiBuZXZlcjtcbn1ba2V5b2YgVF07XG5cbmV4cG9ydCBmdW5jdGlvbiBHZXRNZXRob2Q8VCwgSyBleHRlbmRzIE1ldGhvZE5hbWU8VD4+KHJlY2VpdmVyOiBULCBwcm9wOiBLKTogVFtLXSB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGZ1bmMgPSByZWNlaXZlcltwcm9wXTtcbiAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCB8fCBmdW5jID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke1N0cmluZyhwcm9wKX0gaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgfVxuICByZXR1cm4gZnVuYztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTeW5jSXRlcmF0b3JSZWNvcmQ8VD4ge1xuICBpdGVyYXRvcjogSXRlcmF0b3I8VD4sXG4gIG5leHRNZXRob2Q6IEl0ZXJhdG9yPFQ+WyduZXh0J10sXG4gIGRvbmU6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXN5bmNJdGVyYXRvclJlY29yZDxUPiB7XG4gIGl0ZXJhdG9yOiBBc3luY0l0ZXJhdG9yPFQ+LFxuICBuZXh0TWV0aG9kOiBBc3luY0l0ZXJhdG9yPFQ+WyduZXh0J10sXG4gIGRvbmU6IGJvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIFN5bmNPckFzeW5jSXRlcmF0b3JSZWNvcmQ8VD4gPSBTeW5jSXRlcmF0b3JSZWNvcmQ8VD4gfCBBc3luY0l0ZXJhdG9yUmVjb3JkPFQ+O1xuXG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlQXN5bmNGcm9tU3luY0l0ZXJhdG9yPFQ+KHN5bmNJdGVyYXRvclJlY29yZDogU3luY0l0ZXJhdG9yUmVjb3JkPFQ+KTogQXN5bmNJdGVyYXRvclJlY29yZDxUPiB7XG4gIC8vIEluc3RlYWQgb2YgcmUtaW1wbGVtZW50aW5nIENyZWF0ZUFzeW5jRnJvbVN5bmNJdGVyYXRvciBhbmQgJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUsXG4gIC8vIHdlIHVzZSB5aWVsZCogaW5zaWRlIGFuIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiB0byBhY2hpZXZlIHRoZSBzYW1lIHJlc3VsdC5cblxuICAvLyBXcmFwIHRoZSBzeW5jIGl0ZXJhdG9yIGluc2lkZSBhIHN5bmMgaXRlcmFibGUsIHNvIHdlIGNhbiB1c2UgaXQgd2l0aCB5aWVsZCouXG4gIGNvbnN0IHN5bmNJdGVyYWJsZSA9IHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gc3luY0l0ZXJhdG9yUmVjb3JkLml0ZXJhdG9yXG4gIH07XG4gIC8vIENyZWF0ZSBhbiBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gYW5kIGltbWVkaWF0ZWx5IGludm9rZSBpdC5cbiAgY29uc3QgYXN5bmNJdGVyYXRvciA9IChhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiB5aWVsZCogc3luY0l0ZXJhYmxlO1xuICB9KCkpO1xuICAvLyBSZXR1cm4gYXMgYW4gYXN5bmMgaXRlcmF0b3IgcmVjb3JkLlxuICBjb25zdCBuZXh0TWV0aG9kID0gYXN5bmNJdGVyYXRvci5uZXh0O1xuICByZXR1cm4geyBpdGVyYXRvcjogYXN5bmNJdGVyYXRvciwgbmV4dE1ldGhvZCwgZG9uZTogZmFsc2UgfTtcbn1cblxuLy8gQWxpZ25zIHdpdGggY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5hc3luYy1pdGVyYXRvci5qc1xuZXhwb3J0IGNvbnN0IFN5bWJvbEFzeW5jSXRlcmF0b3I6ICh0eXBlb2YgU3ltYm9sKVsnYXN5bmNJdGVyYXRvciddID1cbiAgU3ltYm9sLmFzeW5jSXRlcmF0b3IgPz9cbiAgU3ltYm9sLmZvcj8uKCdTeW1ib2wuYXN5bmNJdGVyYXRvcicpID8/XG4gICdAQGFzeW5jSXRlcmF0b3InO1xuXG5leHBvcnQgdHlwZSBTeW5jT3JBc3luY0l0ZXJhYmxlPFQ+ID0gSXRlcmFibGU8VD4gfCBBc3luY0l0ZXJhYmxlPFQ+O1xuZXhwb3J0IHR5cGUgU3luY09yQXN5bmNJdGVyYXRvck1ldGhvZDxUPiA9ICgpID0+IChJdGVyYXRvcjxUPiB8IEFzeW5jSXRlcmF0b3I8VD4pO1xuXG5mdW5jdGlvbiBHZXRJdGVyYXRvcjxUPihcbiAgb2JqOiBTeW5jT3JBc3luY0l0ZXJhYmxlPFQ+LFxuICBoaW50OiAnYXN5bmMnLFxuICBtZXRob2Q/OiBTeW5jT3JBc3luY0l0ZXJhdG9yTWV0aG9kPFQ+XG4pOiBBc3luY0l0ZXJhdG9yUmVjb3JkPFQ+O1xuZnVuY3Rpb24gR2V0SXRlcmF0b3I8VD4oXG4gIG9iajogSXRlcmFibGU8VD4sXG4gIGhpbnQ6ICdzeW5jJyxcbiAgbWV0aG9kPzogU3luY09yQXN5bmNJdGVyYXRvck1ldGhvZDxUPlxuKTogU3luY0l0ZXJhdG9yUmVjb3JkPFQ+O1xuZnVuY3Rpb24gR2V0SXRlcmF0b3I8VD4oXG4gIG9iajogU3luY09yQXN5bmNJdGVyYWJsZTxUPixcbiAgaGludCA9ICdzeW5jJyxcbiAgbWV0aG9kPzogU3luY09yQXN5bmNJdGVyYXRvck1ldGhvZDxUPlxuKTogU3luY09yQXN5bmNJdGVyYXRvclJlY29yZDxUPiB7XG4gIGFzc2VydChoaW50ID09PSAnc3luYycgfHwgaGludCA9PT0gJ2FzeW5jJyk7XG4gIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChoaW50ID09PSAnYXN5bmMnKSB7XG4gICAgICBtZXRob2QgPSBHZXRNZXRob2Qob2JqIGFzIEFzeW5jSXRlcmFibGU8VD4sIFN5bWJvbEFzeW5jSXRlcmF0b3IpO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHN5bmNNZXRob2QgPSBHZXRNZXRob2Qob2JqIGFzIEl0ZXJhYmxlPFQ+LCBTeW1ib2wuaXRlcmF0b3IpO1xuICAgICAgICBjb25zdCBzeW5jSXRlcmF0b3JSZWNvcmQgPSBHZXRJdGVyYXRvcihvYmogYXMgSXRlcmFibGU8VD4sICdzeW5jJywgc3luY01ldGhvZCk7XG4gICAgICAgIHJldHVybiBDcmVhdGVBc3luY0Zyb21TeW5jSXRlcmF0b3Ioc3luY0l0ZXJhdG9yUmVjb3JkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWV0aG9kID0gR2V0TWV0aG9kKG9iaiBhcyBJdGVyYWJsZTxUPiwgU3ltYm9sLml0ZXJhdG9yKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9iamVjdCBpcyBub3QgaXRlcmFibGUnKTtcbiAgfVxuICBjb25zdCBpdGVyYXRvciA9IHJlZmxlY3RDYWxsKG1ldGhvZCwgb2JqLCBbXSk7XG4gIGlmICghdHlwZUlzT2JqZWN0KGl0ZXJhdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBpdGVyYXRvciBtZXRob2QgbXVzdCByZXR1cm4gYW4gb2JqZWN0Jyk7XG4gIH1cbiAgY29uc3QgbmV4dE1ldGhvZCA9IGl0ZXJhdG9yLm5leHQ7XG4gIHJldHVybiB7IGl0ZXJhdG9yLCBuZXh0TWV0aG9kLCBkb25lOiBmYWxzZSB9IGFzIFN5bmNPckFzeW5jSXRlcmF0b3JSZWNvcmQ8VD47XG59XG5cbmV4cG9ydCB7IEdldEl0ZXJhdG9yIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBJdGVyYXRvck5leHQ8VD4oaXRlcmF0b3JSZWNvcmQ6IEFzeW5jSXRlcmF0b3JSZWNvcmQ8VD4pOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PFQ+PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHJlZmxlY3RDYWxsKGl0ZXJhdG9yUmVjb3JkLm5leHRNZXRob2QsIGl0ZXJhdG9yUmVjb3JkLml0ZXJhdG9yLCBbXSk7XG4gIGlmICghdHlwZUlzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgaXRlcmF0b3IubmV4dCgpIG1ldGhvZCBtdXN0IHJldHVybiBhbiBvYmplY3QnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXRlcmF0b3JDb21wbGV0ZTxUUmV0dXJuPihcbiAgaXRlclJlc3VsdDogSXRlcmF0b3JSZXN1bHQ8dW5rbm93biwgVFJldHVybj5cbik6IGl0ZXJSZXN1bHQgaXMgSXRlcmF0b3JSZXR1cm5SZXN1bHQ8VFJldHVybj4ge1xuICBhc3NlcnQodHlwZUlzT2JqZWN0KGl0ZXJSZXN1bHQpKTtcbiAgcmV0dXJuIEJvb2xlYW4oaXRlclJlc3VsdC5kb25lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEl0ZXJhdG9yVmFsdWU8VD4oaXRlclJlc3VsdDogSXRlcmF0b3JZaWVsZFJlc3VsdDxUPik6IFQge1xuICBhc3NlcnQodHlwZUlzT2JqZWN0KGl0ZXJSZXN1bHQpKTtcbiAgcmV0dXJuIGl0ZXJSZXN1bHQudmFsdWU7XG59XG4iLCAiaW1wb3J0IE51bWJlcklzTmFOIGZyb20gJy4uLy4uL3N0dWIvbnVtYmVyLWlzbmFuJztcbmltcG9ydCB7IEFycmF5QnVmZmVyU2xpY2UgfSBmcm9tICcuL2VjbWFzY3JpcHQnO1xuaW1wb3J0IHR5cGUgeyBOb25TaGFyZWQgfSBmcm9tICcuLi9oZWxwZXJzL2FycmF5LWJ1ZmZlci12aWV3JztcblxuZXhwb3J0IGZ1bmN0aW9uIElzTm9uTmVnYXRpdmVOdW1iZXIodjogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgdiAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoTnVtYmVySXNOYU4odikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodiA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENsb25lQXNVaW50OEFycmF5KE86IE5vblNoYXJlZDxBcnJheUJ1ZmZlclZpZXc+KTogTm9uU2hhcmVkPFVpbnQ4QXJyYXk+IHtcbiAgY29uc3QgYnVmZmVyID0gQXJyYXlCdWZmZXJTbGljZShPLmJ1ZmZlciwgTy5ieXRlT2Zmc2V0LCBPLmJ5dGVPZmZzZXQgKyBPLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSBhcyBOb25TaGFyZWQ8VWludDhBcnJheT47XG59XG4iLCAiaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQgeyBTaW1wbGVRdWV1ZSB9IGZyb20gJy4uL3NpbXBsZS1xdWV1ZSc7XG5pbXBvcnQgeyBJc05vbk5lZ2F0aXZlTnVtYmVyIH0gZnJvbSAnLi9taXNjZWxsYW5lb3VzJztcblxuZXhwb3J0IGludGVyZmFjZSBRdWV1ZUNvbnRhaW5lcjxUPiB7XG4gIF9xdWV1ZTogU2ltcGxlUXVldWU8VD47XG4gIF9xdWV1ZVRvdGFsU2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXVlUGFpcjxUPiB7XG4gIHZhbHVlOiBUO1xuICBzaXplOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZXF1ZXVlVmFsdWU8VD4oY29udGFpbmVyOiBRdWV1ZUNvbnRhaW5lcjxRdWV1ZVBhaXI8VD4+KTogVCB7XG4gIGFzc2VydCgnX3F1ZXVlJyBpbiBjb250YWluZXIgJiYgJ19xdWV1ZVRvdGFsU2l6ZScgaW4gY29udGFpbmVyKTtcbiAgYXNzZXJ0KGNvbnRhaW5lci5fcXVldWUubGVuZ3RoID4gMCk7XG5cbiAgY29uc3QgcGFpciA9IGNvbnRhaW5lci5fcXVldWUuc2hpZnQoKSE7XG4gIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgLT0gcGFpci5zaXplO1xuICBpZiAoY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA8IDApIHtcbiAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcbiAgfVxuXG4gIHJldHVybiBwYWlyLnZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRW5xdWV1ZVZhbHVlV2l0aFNpemU8VD4oY29udGFpbmVyOiBRdWV1ZUNvbnRhaW5lcjxRdWV1ZVBhaXI8VD4+LCB2YWx1ZTogVCwgc2l6ZTogbnVtYmVyKSB7XG4gIGFzc2VydCgnX3F1ZXVlJyBpbiBjb250YWluZXIgJiYgJ19xdWV1ZVRvdGFsU2l6ZScgaW4gY29udGFpbmVyKTtcblxuICBpZiAoIUlzTm9uTmVnYXRpdmVOdW1iZXIoc2l6ZSkgfHwgc2l6ZSA9PT0gSW5maW5pdHkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignU2l6ZSBtdXN0IGJlIGEgZmluaXRlLCBub24tTmFOLCBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICB9XG5cbiAgY29udGFpbmVyLl9xdWV1ZS5wdXNoKHsgdmFsdWUsIHNpemUgfSk7XG4gIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgKz0gc2l6ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFBlZWtRdWV1ZVZhbHVlPFQ+KGNvbnRhaW5lcjogUXVldWVDb250YWluZXI8UXVldWVQYWlyPFQ+Pik6IFQge1xuICBhc3NlcnQoJ19xdWV1ZScgaW4gY29udGFpbmVyICYmICdfcXVldWVUb3RhbFNpemUnIGluIGNvbnRhaW5lcik7XG4gIGFzc2VydChjb250YWluZXIuX3F1ZXVlLmxlbmd0aCA+IDApO1xuXG4gIGNvbnN0IHBhaXIgPSBjb250YWluZXIuX3F1ZXVlLnBlZWsoKTtcbiAgcmV0dXJuIHBhaXIudmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZXNldFF1ZXVlPFQ+KGNvbnRhaW5lcjogUXVldWVDb250YWluZXI8VD4pIHtcbiAgYXNzZXJ0KCdfcXVldWUnIGluIGNvbnRhaW5lciAmJiAnX3F1ZXVlVG90YWxTaXplJyBpbiBjb250YWluZXIpO1xuXG4gIGNvbnRhaW5lci5fcXVldWUgPSBuZXcgU2ltcGxlUXVldWU8VD4oKTtcbiAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA9IDA7XG59XG4iLCAiZXhwb3J0IHR5cGUgVHlwZWRBcnJheSA9XG4gIHwgSW50OEFycmF5XG4gIHwgVWludDhBcnJheVxuICB8IFVpbnQ4Q2xhbXBlZEFycmF5XG4gIHwgSW50MTZBcnJheVxuICB8IFVpbnQxNkFycmF5XG4gIHwgSW50MzJBcnJheVxuICB8IFVpbnQzMkFycmF5XG4gIHwgRmxvYXQzMkFycmF5XG4gIHwgRmxvYXQ2NEFycmF5O1xuXG5leHBvcnQgdHlwZSBOb25TaGFyZWQ8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4gPSBUICYge1xuICBidWZmZXI6IEFycmF5QnVmZmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFycmF5QnVmZmVyVmlld0NvbnN0cnVjdG9yPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlclZpZXc+IHtcbiAgbmV3KGJ1ZmZlcjogQXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQ6IG51bWJlciwgbGVuZ3RoPzogbnVtYmVyKTogVDtcblxuICByZWFkb25seSBwcm90b3R5cGU6IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHlwZWRBcnJheUNvbnN0cnVjdG9yPFQgZXh0ZW5kcyBUeXBlZEFycmF5ID0gVHlwZWRBcnJheT4gZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPiB7XG4gIHJlYWRvbmx5IEJZVEVTX1BFUl9FTEVNRU5UOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIERhdGFWaWV3Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxEYXRhVmlldz47XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdDb25zdHJ1Y3RvcihjdG9yOiBGdW5jdGlvbik6IGN0b3IgaXMgRGF0YVZpZXdDb25zdHJ1Y3RvciB7XG4gIHJldHVybiBjdG9yID09PSBEYXRhVmlldztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YVZpZXcodmlldzogQXJyYXlCdWZmZXJWaWV3KTogdmlldyBpcyBEYXRhVmlldyB7XG4gIHJldHVybiBpc0RhdGFWaWV3Q29uc3RydWN0b3Iodmlldy5jb25zdHJ1Y3Rvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUJ1ZmZlclZpZXdFbGVtZW50U2l6ZTxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3PihjdG9yOiBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPik6IG51bWJlciB7XG4gIGlmIChpc0RhdGFWaWV3Q29uc3RydWN0b3IoY3RvcikpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gKGN0b3IgYXMgdW5rbm93biBhcyBUeXBlZEFycmF5Q29uc3RydWN0b3IpLkJZVEVTX1BFUl9FTEVNRU5UO1xufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHsgUmVzZXRRdWV1ZSB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9xdWV1ZS13aXRoLXNpemVzJztcbmltcG9ydCB7XG4gIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdCxcbiAgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMsXG4gIFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcixcbiAgdHlwZSBSZWFkUmVxdWVzdFxufSBmcm9tICcuL2RlZmF1bHQtcmVhZGVyJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3QsXG4gIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyxcbiAgUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyLFxuICB0eXBlIFJlYWRJbnRvUmVxdWVzdFxufSBmcm9tICcuL2J5b2ItcmVhZGVyJztcbmltcG9ydCBOdW1iZXJJc0ludGVnZXIgZnJvbSAnLi4vLi4vc3R1Yi9udW1iZXItaXNpbnRlZ2VyJztcbmltcG9ydCB7XG4gIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQsXG4gIHR5cGUgUmVhZGFibGVCeXRlU3RyZWFtLFxuICBSZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBSZWFkYWJsZVN0cmVhbUVycm9yXG59IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgdHlwZSB7IFZhbGlkYXRlZFVuZGVybHlpbmdCeXRlU291cmNlIH0gZnJvbSAnLi91bmRlcmx5aW5nLXNvdXJjZSc7XG5pbXBvcnQgeyBzZXRGdW5jdGlvbk5hbWUsIHR5cGVJc09iamVjdCB9IGZyb20gJy4uL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQge1xuICBBcnJheUJ1ZmZlclNsaWNlLFxuICBDYW5UcmFuc2ZlckFycmF5QnVmZmVyLFxuICBDb3B5RGF0YUJsb2NrQnl0ZXMsXG4gIElzRGV0YWNoZWRCdWZmZXIsXG4gIFRyYW5zZmVyQXJyYXlCdWZmZXJcbn0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL2VjbWFzY3JpcHQnO1xuaW1wb3J0IHsgQ2FuY2VsU3RlcHMsIFB1bGxTdGVwcywgUmVsZWFzZVN0ZXBzIH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL2ludGVybmFsLW1ldGhvZHMnO1xuaW1wb3J0IHsgcHJvbWlzZVJlc29sdmVkV2l0aCwgdXBvblByb21pc2UgfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50LCBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UgfSBmcm9tICcuLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7XG4gIHR5cGUgQXJyYXlCdWZmZXJWaWV3Q29uc3RydWN0b3IsXG4gIGFycmF5QnVmZmVyVmlld0VsZW1lbnRTaXplLFxuICB0eXBlIE5vblNoYXJlZCxcbiAgdHlwZSBUeXBlZEFycmF5Q29uc3RydWN0b3Jcbn0gZnJvbSAnLi4vaGVscGVycy9hcnJheS1idWZmZXItdmlldyc7XG5cbi8qKlxuICogQSBwdWxsLWludG8gcmVxdWVzdCBpbiBhIHtAbGluayBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIhOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xuICAvKiogQGludGVybmFsICovXG4gIF92aWV3ITogTm9uU2hhcmVkPEFycmF5QnVmZmVyVmlldz4gfCBudWxsO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZpZXcgZm9yIHdyaXRpbmcgaW4gdG8sIG9yIGBudWxsYCBpZiB0aGUgQllPQiByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gcmVzcG9uZGVkIHRvLlxuICAgKi9cbiAgZ2V0IHZpZXcoKTogQXJyYXlCdWZmZXJWaWV3IHwgbnVsbCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcbiAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigndmlldycpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl92aWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0byB0aGUgYXNzb2NpYXRlZCByZWFkYWJsZSBieXRlIHN0cmVhbSB0aGF0IGBieXRlc1dyaXR0ZW5gIGJ5dGVzIHdlcmUgd3JpdHRlbiBpbnRvXG4gICAqIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnZpZXcgfCB2aWV3fSwgY2F1c2luZyB0aGUgcmVzdWx0IGJlIHN1cmZhY2VkIHRvIHRoZSBjb25zdW1lci5cbiAgICpcbiAgICogQWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC52aWV3IHwgdmlld30gd2lsbCBiZSB0cmFuc2ZlcnJlZCBhbmQgbm8gbG9uZ2VyXG4gICAqIG1vZGlmaWFibGUuXG4gICAqL1xuICByZXNwb25kKGJ5dGVzV3JpdHRlbjogbnVtYmVyKTogdm9pZDtcbiAgcmVzcG9uZChieXRlc1dyaXR0ZW46IG51bWJlciB8IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG4gICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3Jlc3BvbmQnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChieXRlc1dyaXR0ZW4sIDEsICdyZXNwb25kJyk7XG4gICAgYnl0ZXNXcml0dGVuID0gY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKGJ5dGVzV3JpdHRlbiwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXG4gICAgaWYgKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodGhpcy5fdmlldyEuYnVmZmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIEJZT0IgcmVxdWVzdCdzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIHVzZWQgYXMgYSByZXNwb25zZWApO1xuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLl92aWV3IS5ieXRlTGVuZ3RoID4gMCk7XG4gICAgYXNzZXJ0KHRoaXMuX3ZpZXchLmJ1ZmZlci5ieXRlTGVuZ3RoID4gMCk7XG5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZCh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgYnl0ZXNXcml0dGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdG8gdGhlIGFzc29jaWF0ZWQgcmVhZGFibGUgYnl0ZSBzdHJlYW0gdGhhdCBpbnN0ZWFkIG9mIHdyaXRpbmcgaW50b1xuICAgKiB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC52aWV3IHwgdmlld30sIHRoZSB1bmRlcmx5aW5nIGJ5dGUgc291cmNlIGlzIHByb3ZpZGluZyBhIG5ldyBgQXJyYXlCdWZmZXJWaWV3YCxcbiAgICogd2hpY2ggd2lsbCBiZSBnaXZlbiB0byB0aGUgY29uc3VtZXIgb2YgdGhlIHJlYWRhYmxlIGJ5dGUgc3RyZWFtLlxuICAgKlxuICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIGB2aWV3YCB3aWxsIGJlIHRyYW5zZmVycmVkIGFuZCBubyBsb25nZXIgbW9kaWZpYWJsZS5cbiAgICovXG4gIHJlc3BvbmRXaXRoTmV3Vmlldyh2aWV3OiBBcnJheUJ1ZmZlclZpZXcpOiB2b2lkO1xuICByZXNwb25kV2l0aE5ld1ZpZXcodmlldzogTm9uU2hhcmVkPEFycmF5QnVmZmVyVmlldz4pOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kV2l0aE5ld1ZpZXcnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCh2aWV3LCAxLCAncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG5cbiAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbiBvbmx5IHJlc3BvbmQgd2l0aCBhcnJheSBidWZmZXIgdmlld3MnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBnaXZlbiB2aWV3XFwncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSB1c2VkIGFzIGEgcmVzcG9uc2UnKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCB2aWV3KTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwge1xuICByZXNwb25kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVzcG9uZFdpdGhOZXdWaWV3OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLnJlc3BvbmQsICdyZXNwb25kJyk7XG5zZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uZFdpdGhOZXdWaWV3LCAncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuaW50ZXJmYWNlIEJ5dGVRdWV1ZUVsZW1lbnQge1xuICBidWZmZXI6IEFycmF5QnVmZmVyO1xuICBieXRlT2Zmc2V0OiBudW1iZXI7XG4gIGJ5dGVMZW5ndGg6IG51bWJlcjtcbn1cblxudHlwZSBQdWxsSW50b0Rlc2NyaXB0b3I8VCBleHRlbmRzIE5vblNoYXJlZDxBcnJheUJ1ZmZlclZpZXc+ID0gTm9uU2hhcmVkPEFycmF5QnVmZmVyVmlldz4+ID1cbiAgRGVmYXVsdFB1bGxJbnRvRGVzY3JpcHRvclxuICB8IEJZT0JQdWxsSW50b0Rlc2NyaXB0b3I8VD47XG5cbmludGVyZmFjZSBEZWZhdWx0UHVsbEludG9EZXNjcmlwdG9yIHtcbiAgYnVmZmVyOiBBcnJheUJ1ZmZlcjtcbiAgYnVmZmVyQnl0ZUxlbmd0aDogbnVtYmVyO1xuICBieXRlT2Zmc2V0OiBudW1iZXI7XG4gIGJ5dGVMZW5ndGg6IG51bWJlcjtcbiAgYnl0ZXNGaWxsZWQ6IG51bWJlcjtcbiAgbWluaW11bUZpbGw6IG51bWJlcjtcbiAgZWxlbWVudFNpemU6IG51bWJlcjtcbiAgdmlld0NvbnN0cnVjdG9yOiBUeXBlZEFycmF5Q29uc3RydWN0b3I8VWludDhBcnJheT47XG4gIHJlYWRlclR5cGU6ICdkZWZhdWx0JyB8ICdub25lJztcbn1cblxuaW50ZXJmYWNlIEJZT0JQdWxsSW50b0Rlc2NyaXB0b3I8VCBleHRlbmRzIE5vblNoYXJlZDxBcnJheUJ1ZmZlclZpZXc+ID0gTm9uU2hhcmVkPEFycmF5QnVmZmVyVmlldz4+IHtcbiAgYnVmZmVyOiBBcnJheUJ1ZmZlcjtcbiAgYnVmZmVyQnl0ZUxlbmd0aDogbnVtYmVyO1xuICBieXRlT2Zmc2V0OiBudW1iZXI7XG4gIGJ5dGVMZW5ndGg6IG51bWJlcjtcbiAgYnl0ZXNGaWxsZWQ6IG51bWJlcjtcbiAgbWluaW11bUZpbGw6IG51bWJlcjtcbiAgZWxlbWVudFNpemU6IG51bWJlcjtcbiAgdmlld0NvbnN0cnVjdG9yOiBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPjtcbiAgcmVhZGVyVHlwZTogJ2J5b2InIHwgJ25vbmUnO1xufVxuXG4vKipcbiAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgYnl0ZSBzdHJlYW19J3Mgc3RhdGUgYW5kIGludGVybmFsIHF1ZXVlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIge1xuICAvKiogQGludGVybmFsICovXG4gIF9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtITogUmVhZGFibGVCeXRlU3RyZWFtO1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZSE6IFNpbXBsZVF1ZXVlPEJ5dGVRdWV1ZUVsZW1lbnQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZVRvdGFsU2l6ZSE6IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RhcnRlZCE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlUmVxdWVzdGVkITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVsbEFnYWluITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVsbGluZyAhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdHJhdGVneUhXTSE6IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVsbEFsZ29yaXRobSE6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NhbmNlbEFsZ29yaXRobSE6IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXV0b0FsbG9jYXRlQ2h1bmtTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2J5b2JSZXF1ZXN0OiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHwgbnVsbDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcGVuZGluZ1B1bGxJbnRvcyE6IFNpbXBsZVF1ZXVlPFB1bGxJbnRvRGVzY3JpcHRvcj47XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBCWU9CIHB1bGwgcmVxdWVzdCwgb3IgYG51bGxgIGlmIHRoZXJlIGlzbid0IG9uZS5cbiAgICovXG4gIGdldCBieW9iUmVxdWVzdCgpOiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHwgbnVsbCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYnlvYlJlcXVlc3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBjb250cm9sbGVkIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpc1xuICAgKiBvdmVyLWZ1bGwuIEFuIHVuZGVybHlpbmcgYnl0ZSBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG4gICAqL1xuICBnZXQgZGVzaXJlZFNpemUoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuICAgKiB0aGUgc3RyZWFtLCBidXQgb25jZSB0aG9zZSBhcmUgcmVhZCwgdGhlIHN0cmVhbSB3aWxsIGJlY29tZSBjbG9zZWQuXG4gICAqL1xuICBjbG9zZSgpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZDsgZG8gbm90IGNsb3NlIGl0IGFnYWluIScpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgaWYgKHN0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApO1xuICAgIH1cblxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2h1bmsgY2h1bmsgaW4gdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLlxuICAgKiBUaGUgY2h1bmsgaGFzIHRvIGJlIGFuIGBBcnJheUJ1ZmZlclZpZXdgIGluc3RhbmNlLCBvciBlbHNlIGEgYFR5cGVFcnJvcmAgd2lsbCBiZSB0aHJvd24uXG4gICAqL1xuICBlbnF1ZXVlKGNodW5rOiBBcnJheUJ1ZmZlclZpZXcpOiB2b2lkO1xuICBlbnF1ZXVlKGNodW5rOiBOb25TaGFyZWQ8QXJyYXlCdWZmZXJWaWV3Pik6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgICB9XG5cbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGNodW5rLCAxLCAnZW5xdWV1ZScpO1xuICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KGNodW5rKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmsgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpO1xuICAgIH1cbiAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmsgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGgnKTtcbiAgICB9XG4gICAgaWYgKGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjaHVuaydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aGApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyZWFtIGlzIGNsb3NlZCBvciBkcmFpbmluZycpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgaWYgKHN0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGVucXVldWVkIHRvYCk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuICAgKi9cbiAgZXJyb3IoZTogYW55ID0gdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtDYW5jZWxTdGVwc10ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKHRoaXMpO1xuXG4gICAgUmVzZXRRdWV1ZSh0aGlzKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW1B1bGxTdGVwc10ocmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PE5vblNoYXJlZDxVaW50OEFycmF5Pj4pOiB2b2lkIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICAgIGFzc2VydChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSk7XG5cbiAgICBpZiAodGhpcy5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICAgICBhc3NlcnQoUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA9PT0gMCk7XG5cbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUmVhZFJlcXVlc3RGcm9tUXVldWUodGhpcywgcmVhZFJlcXVlc3QpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IHRoaXMuX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBidWZmZXI6IEFycmF5QnVmZmVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSk7XG4gICAgICB9IGNhdGNoIChidWZmZXJFKSB7XG4gICAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKGJ1ZmZlckUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvcjogRGVmYXVsdFB1bGxJbnRvRGVzY3JpcHRvciA9IHtcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICBidWZmZXJCeXRlTGVuZ3RoOiBhdXRvQWxsb2NhdGVDaHVua1NpemUsXG4gICAgICAgIGJ5dGVPZmZzZXQ6IDAsXG4gICAgICAgIGJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcbiAgICAgICAgYnl0ZXNGaWxsZWQ6IDAsXG4gICAgICAgIG1pbmltdW1GaWxsOiAxLFxuICAgICAgICBlbGVtZW50U2l6ZTogMSxcbiAgICAgICAgdmlld0NvbnN0cnVjdG9yOiBVaW50OEFycmF5LFxuICAgICAgICByZWFkZXJUeXBlOiAnZGVmYXVsdCdcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtSZWxlYXNlU3RlcHNdKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0UHVsbEludG8gPSB0aGlzLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICAgIGZpcnN0UHVsbEludG8ucmVhZGVyVHlwZSA9ICdub25lJztcblxuICAgICAgdGhpcy5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgdGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKGZpcnN0UHVsbEludG8pO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwge1xuICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGJ5b2JSZXF1ZXN0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbnNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5jbG9zZSwgJ2Nsb3NlJyk7XG5zZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZW5xdWV1ZSwgJ2VucXVldWUnKTtcbnNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5lcnJvciwgJ2Vycm9yJyk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIuXG5cbmV4cG9ydCBmdW5jdGlvbiBJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoeDogYW55KTogeCBpcyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcbn1cblxuZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHg6IGFueSk6IHggaXMgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0O1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKTogdm9pZCB7XG4gIGNvbnN0IHNob3VsZFB1bGwgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcik7XG4gIGlmICghc2hvdWxkUHVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250cm9sbGVyLl9wdWxsaW5nKSB7XG4gICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICBhc3NlcnQoIWNvbnRyb2xsZXIuX3B1bGxBZ2Fpbik7XG5cbiAgY29udHJvbGxlci5fcHVsbGluZyA9IHRydWU7XG5cbiAgLy8gVE9ETzogVGVzdCBjb250cm9sbGVyIGFyZ3VtZW50XG4gIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShcbiAgICBwdWxsUHJvbWlzZSxcbiAgICAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4pIHtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGUgPT4ge1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcbiAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yPFQgZXh0ZW5kcyBOb25TaGFyZWQ8QXJyYXlCdWZmZXJWaWV3Pj4oXG4gIHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtLFxuICBwdWxsSW50b0Rlc2NyaXB0b3I6IFB1bGxJbnRvRGVzY3JpcHRvcjxUPlxuKSB7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlICE9PSAnZXJyb3JlZCcpO1xuICBhc3NlcnQocHVsbEludG9EZXNjcmlwdG9yLnJlYWRlclR5cGUgIT09ICdub25lJyk7XG5cbiAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgYXNzZXJ0KHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZSA9PT0gMCk7XG4gICAgZG9uZSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3I8VD4ocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5yZWFkZXJUeXBlID09PSAnZGVmYXVsdCcpIHtcbiAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGZpbGxlZFZpZXcgYXMgdW5rbm93biBhcyBOb25TaGFyZWQ8VWludDhBcnJheT4sIGRvbmUpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChwdWxsSW50b0Rlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ2J5b2InKTtcbiAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBmaWxsZWRWaWV3LCBkb25lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvcjxUIGV4dGVuZHMgTm9uU2hhcmVkPEFycmF5QnVmZmVyVmlldz4+KFxuICBwdWxsSW50b0Rlc2NyaXB0b3I6IFB1bGxJbnRvRGVzY3JpcHRvcjxUPlxuKTogVCB7XG4gIGNvbnN0IGJ5dGVzRmlsbGVkID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICBjb25zdCBlbGVtZW50U2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcblxuICBhc3NlcnQoYnl0ZXNGaWxsZWQgPD0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGgpO1xuICBhc3NlcnQoYnl0ZXNGaWxsZWQgJSBlbGVtZW50U2l6ZSA9PT0gMCk7XG5cbiAgcmV0dXJuIG5ldyBwdWxsSW50b0Rlc2NyaXB0b3Iudmlld0NvbnN0cnVjdG9yKFxuICAgIHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCBieXRlc0ZpbGxlZCAvIGVsZW1lbnRTaXplKSBhcyBUO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGg6IG51bWJlcikge1xuICBjb250cm9sbGVyLl9xdWV1ZS5wdXNoKHsgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0pO1xuICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSArPSBieXRlTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNsb25lZENodW5rVG9RdWV1ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGg6IG51bWJlcikge1xuICBsZXQgY2xvbmVkQ2h1bms7XG4gIHRyeSB7XG4gICAgY2xvbmVkQ2h1bmsgPSBBcnJheUJ1ZmZlclNsaWNlKGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpO1xuICB9IGNhdGNoIChjbG9uZUUpIHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgY2xvbmVFKTtcbiAgICB0aHJvdyBjbG9uZUU7XG4gIH1cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgY2xvbmVkQ2h1bmssIDAsIGJ5dGVMZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZURldGFjaGVkUHVsbEludG9Ub1F1ZXVlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yKSB7XG4gIGFzc2VydChmaXJzdERlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ25vbmUnKTtcbiAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA+IDApIHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNsb25lZENodW5rVG9RdWV1ZShcbiAgICAgIGNvbnRyb2xsZXIsXG4gICAgICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyLFxuICAgICAgZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQsXG4gICAgICBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWRcbiAgICApO1xuICB9XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yKSB7XG4gIGNvbnN0IG1heEJ5dGVzVG9Db3B5ID0gTWF0aC5taW4oY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xuICBjb25zdCBtYXhCeXRlc0ZpbGxlZCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIG1heEJ5dGVzVG9Db3B5O1xuXG4gIGxldCB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID0gbWF4Qnl0ZXNUb0NvcHk7XG4gIGxldCByZWFkeSA9IGZhbHNlO1xuICBhc3NlcnQocHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIDwgcHVsbEludG9EZXNjcmlwdG9yLm1pbmltdW1GaWxsKTtcbiAgY29uc3QgcmVtYWluZGVyQnl0ZXMgPSBtYXhCeXRlc0ZpbGxlZCAlIHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcbiAgY29uc3QgbWF4QWxpZ25lZEJ5dGVzID0gbWF4Qnl0ZXNGaWxsZWQgLSByZW1haW5kZXJCeXRlcztcbiAgLy8gQSBkZXNjcmlwdG9yIGZvciBhIHJlYWQoKSByZXF1ZXN0IHRoYXQgaXMgbm90IHlldCBmaWxsZWQgdXAgdG8gaXRzIG1pbmltdW0gbGVuZ3RoIHdpbGwgc3RheSBhdCB0aGUgaGVhZFxuICAvLyBvZiB0aGUgcXVldWUsIHNvIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBjYW4ga2VlcCBmaWxsaW5nIGl0LlxuICBpZiAobWF4QWxpZ25lZEJ5dGVzID49IHB1bGxJbnRvRGVzY3JpcHRvci5taW5pbXVtRmlsbCkge1xuICAgIHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPSBtYXhBbGlnbmVkQnl0ZXMgLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICAgcmVhZHkgPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgcXVldWUgPSBjb250cm9sbGVyLl9xdWV1ZTtcblxuICB3aGlsZSAodG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA+IDApIHtcbiAgICBjb25zdCBoZWFkT2ZRdWV1ZSA9IHF1ZXVlLnBlZWsoKTtcblxuICAgIGNvbnN0IGJ5dGVzVG9Db3B5ID0gTWF0aC5taW4odG90YWxCeXRlc1RvQ29weVJlbWFpbmluZywgaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCk7XG5cbiAgICBjb25zdCBkZXN0U3RhcnQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICBDb3B5RGF0YUJsb2NrQnl0ZXMocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgZGVzdFN0YXJ0LCBoZWFkT2ZRdWV1ZS5idWZmZXIsIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQsIGJ5dGVzVG9Db3B5KTtcblxuICAgIGlmIChoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoID09PSBieXRlc1RvQ29weSkge1xuICAgICAgcXVldWUuc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZE9mUXVldWUuYnl0ZU9mZnNldCArPSBieXRlc1RvQ29weTtcbiAgICAgIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGggLT0gYnl0ZXNUb0NvcHk7XG4gICAgfVxuICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplIC09IGJ5dGVzVG9Db3B5O1xuXG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIGJ5dGVzVG9Db3B5LCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXG4gICAgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyAtPSBieXRlc1RvQ29weTtcbiAgfVxuXG4gIGlmICghcmVhZHkpIHtcbiAgICBhc3NlcnQoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDApO1xuICAgIGFzc2VydChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPiAwKTtcbiAgICBhc3NlcnQocHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIDwgcHVsbEludG9EZXNjcmlwdG9yLm1pbmltdW1GaWxsKTtcbiAgfVxuXG4gIHJldHVybiByZWFkeTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yKSB7XG4gIGFzc2VydChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA9PT0gMCB8fCBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKSA9PT0gcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsKTtcbiAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICs9IHNpemU7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcblxuICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDAgJiYgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2UoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIGlmIChjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0Ll9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0Ll92aWV3ID0gbnVsbCE7XG4gIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIGFzc2VydCghY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpO1xuXG4gIHdoaWxlIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICBhc3NlcnQocHVsbEludG9EZXNjcmlwdG9yLnJlYWRlclR5cGUgIT09ICdub25lJyk7XG5cbiAgICBpZiAoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSkge1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuXG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKFxuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLFxuICAgICAgICBwdWxsSW50b0Rlc2NyaXB0b3JcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUmVhZFJlcXVlc3RzVXNpbmdRdWV1ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIGNvbnN0IHJlYWRlciA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3JlYWRlcjtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpO1xuICB3aGlsZSAocmVhZGVyLl9yZWFkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWFkUmVxdWVzdCA9IHJlYWRlci5fcmVhZFJlcXVlc3RzLnNoaWZ0KCk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxSZWFkUmVxdWVzdEZyb21RdWV1ZShjb250cm9sbGVyLCByZWFkUmVxdWVzdCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50bzxUIGV4dGVuZHMgTm9uU2hhcmVkPEFycmF5QnVmZmVyVmlldz4+KFxuICBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICB2aWV3OiBULFxuICBtaW46IG51bWJlcixcbiAgcmVhZEludG9SZXF1ZXN0OiBSZWFkSW50b1JlcXVlc3Q8VD5cbik6IHZvaWQge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXG4gIGNvbnN0IGN0b3IgPSB2aWV3LmNvbnN0cnVjdG9yIGFzIEFycmF5QnVmZmVyVmlld0NvbnN0cnVjdG9yPFQ+O1xuICBjb25zdCBlbGVtZW50U2l6ZSA9IGFycmF5QnVmZmVyVmlld0VsZW1lbnRTaXplKGN0b3IpO1xuXG4gIGNvbnN0IHsgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCB9ID0gdmlldztcblxuICBjb25zdCBtaW5pbXVtRmlsbCA9IG1pbiAqIGVsZW1lbnRTaXplO1xuICBhc3NlcnQobWluaW11bUZpbGwgPj0gZWxlbWVudFNpemUgJiYgbWluaW11bUZpbGwgPD0gYnl0ZUxlbmd0aCk7XG4gIGFzc2VydChtaW5pbXVtRmlsbCAlIGVsZW1lbnRTaXplID09PSAwKTtcblxuICBsZXQgYnVmZmVyOiBBcnJheUJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBidWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKHZpZXcuYnVmZmVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3I6IEJZT0JQdWxsSW50b0Rlc2NyaXB0b3I8VD4gPSB7XG4gICAgYnVmZmVyLFxuICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgIGJ5dGVPZmZzZXQsXG4gICAgYnl0ZUxlbmd0aCxcbiAgICBieXRlc0ZpbGxlZDogMCxcbiAgICBtaW5pbXVtRmlsbCxcbiAgICBlbGVtZW50U2l6ZSxcbiAgICB2aWV3Q29uc3RydWN0b3I6IGN0b3IsXG4gICAgcmVhZGVyVHlwZTogJ2J5b2InXG4gIH07XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXG4gICAgLy8gTm8gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoKSBjYWxsIHNpbmNlOlxuICAgIC8vIC0gTm8gY2hhbmdlIGhhcHBlbnMgb24gZGVzaXJlZFNpemVcbiAgICAvLyAtIFRoZSBzb3VyY2UgaGFzIGFscmVhZHkgYmVlbiBub3RpZmllZCBvZiB0aGF0IHRoZXJlJ3MgYXQgbGVhc3QgMSBwZW5kaW5nIHJlYWQodmlldylcblxuICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBjb25zdCBlbXB0eVZpZXcgPSBuZXcgY3RvcihwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCwgMCk7XG4gICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKGVtcHR5Vmlldyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuICAgIGlmIChSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpKSB7XG4gICAgICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3I8VD4ocHVsbEludG9EZXNjcmlwdG9yKTtcblxuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcik7XG5cbiAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2h1bmtTdGVwcyhmaWxsZWRWaWV3KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG5cbiAgICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcblxuICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdDxUPihzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCk7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdERlc2NyaXB0b3I6IFB1bGxJbnRvRGVzY3JpcHRvcikge1xuICBhc3NlcnQoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgZmlyc3REZXNjcmlwdG9yLmVsZW1lbnRTaXplID09PSAwKTtcblxuICBpZiAoZmlyc3REZXNjcmlwdG9yLnJlYWRlclR5cGUgPT09ICdub25lJykge1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSkge1xuICAgIHdoaWxlIChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3Ioc3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNXcml0dGVuOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsSW50b0Rlc2NyaXB0b3I6IFB1bGxJbnRvRGVzY3JpcHRvcikge1xuICBhc3NlcnQocHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgYnl0ZXNXcml0dGVuIDw9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlTGVuZ3RoKTtcblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXG4gIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVEZXRhY2hlZFB1bGxJbnRvVG9RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA8IHB1bGxJbnRvRGVzY3JpcHRvci5taW5pbXVtRmlsbCkge1xuICAgIC8vIEEgZGVzY3JpcHRvciBmb3IgYSByZWFkKCkgcmVxdWVzdCB0aGF0IGlzIG5vdCB5ZXQgZmlsbGVkIHVwIHRvIGl0cyBtaW5pbXVtIGxlbmd0aCB3aWxsIHN0YXkgYXQgdGhlIGhlYWRcbiAgICAvLyBvZiB0aGUgcXVldWUsIHNvIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBjYW4ga2VlcCBmaWxsaW5nIGl0LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcblxuICBjb25zdCByZW1haW5kZXJTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuICBpZiAocmVtYWluZGVyU2l6ZSA+IDApIHtcbiAgICBjb25zdCBlbmQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNsb25lZENodW5rVG9RdWV1ZShcbiAgICAgIGNvbnRyb2xsZXIsXG4gICAgICBwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLFxuICAgICAgZW5kIC0gcmVtYWluZGVyU2l6ZSxcbiAgICAgIHJlbWFpbmRlclNpemVcbiAgICApO1xuICB9XG5cbiAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIC09IHJlbWFpbmRlclNpemU7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbjogbnVtYmVyKSB7XG4gIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICBhc3NlcnQoQ2FuVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdERlc2NyaXB0b3IuYnVmZmVyKSk7XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcblxuICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgYXNzZXJ0KGJ5dGVzV3JpdHRlbiA9PT0gMCk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXIsIGZpcnN0RGVzY3JpcHRvcik7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KHN0YXRlID09PSAncmVhZGFibGUnKTtcbiAgICBhc3NlcnQoYnl0ZXNXcml0dGVuID4gMCk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJblJlYWRhYmxlU3RhdGUoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBmaXJzdERlc2NyaXB0b3IpO1xuICB9XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhcbiAgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclxuKTogUHVsbEludG9EZXNjcmlwdG9yIHtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsKTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3Muc2hpZnQoKSE7XG4gIHJldHVybiBkZXNjcmlwdG9yO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcik6IGJvb2xlYW4ge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFjb250cm9sbGVyLl9zdGFydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBkZXNpcmVkU2l6ZSA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgYXNzZXJ0KGRlc2lyZWRTaXplICE9PSBudWxsKTtcbiAgaWYgKGRlc2lyZWRTaXplISA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xufVxuXG4vLyBBIGNsaWVudCBvZiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgaWYgKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ5dGVzRmlsbGVkICUgZmlyc3RQZW5kaW5nUHVsbEludG8uZWxlbWVudFNpemUgIT09IDApIHtcbiAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoXG4gIGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gIGNodW5rOiBOb25TaGFyZWQ8QXJyYXlCdWZmZXJWaWV3PlxuKSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7IGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCB9ID0gY2h1bms7XG4gIGlmIChJc0RldGFjaGVkQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVua1xcJ3MgYnVmZmVyIGlzIGRldGFjaGVkIGFuZCBzbyBjYW5ub3QgYmUgZW5xdWV1ZWQnKTtcbiAgfVxuICBjb25zdCB0cmFuc2ZlcnJlZEJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoYnVmZmVyKTtcblxuICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3RQZW5kaW5nUHVsbEludG8gPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIEJZT0IgcmVxdWVzdFxcJ3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkIGFuZCBzbyBjYW5ub3QgYmUgZmlsbGVkIHdpdGggYW4gZW5xdWV1ZWQgY2h1bmsnXG4gICAgICApO1xuICAgIH1cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuICAgIGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyKTtcbiAgICBpZiAoZmlyc3RQZW5kaW5nUHVsbEludG8ucmVhZGVyVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZURldGFjaGVkUHVsbEludG9Ub1F1ZXVlKGNvbnRyb2xsZXIsIGZpcnN0UGVuZGluZ1B1bGxJbnRvKTtcbiAgICB9XG4gIH1cblxuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkpIHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1JlYWRSZXF1ZXN0c1VzaW5nUXVldWUoY29udHJvbGxlcik7XG4gICAgaWYgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPT09IDApIHtcbiAgICAgIGFzc2VydChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA9PT0gMCk7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApO1xuICAgICAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICBhc3NlcnQoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCkucmVhZGVyVHlwZSA9PT0gJ2RlZmF1bHQnKTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNmZXJyZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCB0cmFuc2ZlcnJlZFZpZXcgYXMgTm9uU2hhcmVkPFVpbnQ4QXJyYXk+LCBmYWxzZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pKSB7XG4gICAgLy8gVE9ETzogSWRlYWxseSBpbiB0aGlzIGJyYW5jaCBkZXRhY2hpbmcgc2hvdWxkIGhhcHBlbiBvbmx5IGlmIHRoZSBidWZmZXIgaXMgbm90IGNvbnN1bWVkIGZ1bGx5LlxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydCghSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIH1cblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCBlOiBhbnkpIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MoY29udHJvbGxlcik7XG5cbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxSZWFkUmVxdWVzdEZyb21RdWV1ZShcbiAgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PE5vblNoYXJlZDxVaW50OEFycmF5Pj5cbikge1xuICBhc3NlcnQoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKTtcblxuICBjb25zdCBlbnRyeSA9IGNvbnRyb2xsZXIuX3F1ZXVlLnNoaWZ0KCk7XG4gIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplIC09IGVudHJ5LmJ5dGVMZW5ndGg7XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcik7XG5cbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGVudHJ5LmJ1ZmZlciwgZW50cnkuYnl0ZU9mZnNldCwgZW50cnkuYnl0ZUxlbmd0aCk7XG4gIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKHZpZXcgYXMgTm9uU2hhcmVkPFVpbnQ4QXJyYXk+KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChcbiAgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclxuKTogUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB8IG51bGwge1xuICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwgJiYgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGZpcnN0RGVzY3JpcHRvci5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG5cbiAgICBjb25zdCBieW9iUmVxdWVzdDogUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUpO1xuICAgIFNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdChieW9iUmVxdWVzdCwgY29udHJvbGxlciwgdmlldyBhcyBOb25TaGFyZWQ8VWludDhBcnJheT4pO1xuICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gYnlvYlJlcXVlc3Q7XG4gIH1cbiAgcmV0dXJuIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0O1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcik6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCBieXRlc1dyaXR0ZW46IG51bWJlcikge1xuICBhc3NlcnQoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKTtcblxuICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgaWYgKGJ5dGVzV3JpdHRlbiAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNXcml0dGVuIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgY2xvc2VkIHN0cmVhbScpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuICAgIGlmIChieXRlc1dyaXR0ZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzV3JpdHRlbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSByZWFkYWJsZSBzdHJlYW0nKTtcbiAgICB9XG4gICAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIGJ5dGVzV3JpdHRlbiA+IGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYnl0ZXNXcml0dGVuIG91dCBvZiByYW5nZScpO1xuICAgIH1cbiAgfVxuXG4gIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0RGVzY3JpcHRvci5idWZmZXIpO1xuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IE5vblNoYXJlZDxBcnJheUJ1ZmZlclZpZXc+KSB7XG4gIGFzc2VydChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApO1xuICBhc3NlcnQoIUlzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKTtcblxuICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgY2xvc2VkIHN0cmVhbScpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgdmlld1xcJ3MgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgcmVhZGFibGUgc3RyZWFtJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgIT09IHZpZXcuYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGRvZXMgbm90IG1hdGNoIGJ5b2JSZXF1ZXN0Jyk7XG4gIH1cbiAgaWYgKGZpcnN0RGVzY3JpcHRvci5idWZmZXJCeXRlTGVuZ3RoICE9PSB2aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBidWZmZXIgb2YgdmlldyBoYXMgZGlmZmVyZW50IGNhcGFjaXR5IHRoYW4gYnlvYlJlcXVlc3QnKTtcbiAgfVxuICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgdmlldy5ieXRlTGVuZ3RoID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdmlldyBpcyBsYXJnZXIgdGhhbiBieW9iUmVxdWVzdCcpO1xuICB9XG5cbiAgY29uc3Qgdmlld0J5dGVMZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGg7XG4gIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKHZpZXcuYnVmZmVyKTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCB2aWV3Qnl0ZUxlbmd0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkKSB7XG4gIGFzc2VydChzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKTtcbiAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXJ0KE51bWJlcklzSW50ZWdlcihhdXRvQWxsb2NhdGVDaHVua1NpemUpKTtcbiAgICBhc3NlcnQoYXV0b0FsbG9jYXRlQ2h1bmtTaXplID4gMCk7XG4gIH1cblxuICBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtID0gc3RyZWFtO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cbiAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuICBjb250cm9sbGVyLl9xdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkITtcbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcblxuICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG5cbiAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG5cbiAgY29udHJvbGxlci5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuXG4gIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcblxuICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cbiAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShcbiAgICBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSxcbiAgICAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgYXNzZXJ0KCFjb250cm9sbGVyLl9wdWxsaW5nKTtcbiAgICAgIGFzc2VydCghY29udHJvbGxlci5fcHVsbEFnYWluKTtcblxuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHIgPT4ge1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIHIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UoXG4gIHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtLFxuICB1bmRlcmx5aW5nQnl0ZVNvdXJjZTogVmFsaWRhdGVkVW5kZXJseWluZ0J5dGVTb3VyY2UsXG4gIGhpZ2hXYXRlck1hcms6IG51bWJlclxuKSB7XG4gIGNvbnN0IGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlKTtcblxuICBsZXQgc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPjtcbiAgbGV0IHB1bGxBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGxldCBjYW5jZWxBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQhKGNvbnRyb2xsZXIpO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nQnl0ZVNvdXJjZS5wdWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdWxsQWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ0J5dGVTb3VyY2UucHVsbCEoY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsIShyZWFzb24pO1xuICB9IGVsc2Uge1xuICAgIGNhbmNlbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGNvbnN0IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IHVuZGVybHlpbmdCeXRlU291cmNlLmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gIH1cblxuICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoXG4gICAgc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBhdXRvQWxsb2NhdGVDaHVua1NpemVcbiAgKTtcbn1cblxuZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHJlcXVlc3Q6IFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBOb25TaGFyZWQ8QXJyYXlCdWZmZXJWaWV3Pikge1xuICBhc3NlcnQoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKGNvbnRyb2xsZXIpKTtcbiAgYXNzZXJ0KHR5cGVvZiB2aWV3ID09PSAnb2JqZWN0Jyk7XG4gIGFzc2VydChBcnJheUJ1ZmZlci5pc1ZpZXcodmlldykpO1xuICBhc3NlcnQoIUlzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKTtcbiAgcmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICByZXF1ZXN0Ll92aWV3ID0gdmlldztcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QuXG5cbmZ1bmN0aW9uIGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdGApO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5cblxuZnVuY3Rpb24gYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyYCk7XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlIH0gZnJvbSAnLi9iYXNpYyc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWRPcHRpb25zLFxuICBSZWFkYWJsZVN0cmVhbUdldFJlYWRlck9wdGlvbnMsXG4gIFZhbGlkYXRlZFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWRPcHRpb25zXG59IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbS9yZWFkZXItb3B0aW9ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UmVhZGVyT3B0aW9ucyhvcHRpb25zOiBSZWFkYWJsZVN0cmVhbUdldFJlYWRlck9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFJlYWRhYmxlU3RyZWFtR2V0UmVhZGVyT3B0aW9ucyB7XG4gIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IG1vZGUgPSBvcHRpb25zPy5tb2RlO1xuICByZXR1cm4ge1xuICAgIG1vZGU6IG1vZGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnbW9kZScgdGhhdGApXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZTogc3RyaW5nLCBjb250ZXh0OiBzdHJpbmcpOiAnYnlvYicge1xuICBtb2RlID0gYCR7bW9kZX1gO1xuICBpZiAobW9kZSAhPT0gJ2J5b2InKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSAnJHttb2RlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZWApO1xuICB9XG4gIHJldHVybiBtb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydEJ5b2JSZWFkT3B0aW9ucyhcbiAgb3B0aW9uczogUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBjb250ZXh0OiBzdHJpbmdcbik6IFZhbGlkYXRlZFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWRPcHRpb25zIHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgY29uc3QgbWluID0gb3B0aW9ucz8ubWluID8/IDE7XG4gIHJldHVybiB7XG4gICAgbWluOiBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoXG4gICAgICBtaW4sXG4gICAgICBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdtaW4nIHRoYXRgXG4gICAgKVxuICB9O1xufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlLFxuICByZWFkZXJMb2NrRXhjZXB0aW9uXG59IGZyb20gJy4vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCwgdHlwZSBSZWFkYWJsZUJ5dGVTdHJlYW0sIHR5cGUgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHtcbiAgSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG9cbn0gZnJvbSAnLi9ieXRlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB7IHNldEZ1bmN0aW9uTmFtZSwgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IG5ld1Byb21pc2UsIHByb21pc2VSZWplY3RlZFdpdGggfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi4vdmFsaWRhdG9ycy9iYXNpYyc7XG5pbXBvcnQgeyBhc3NlcnRSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL3ZhbGlkYXRvcnMvcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IElzRGV0YWNoZWRCdWZmZXIgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvZWNtYXNjcmlwdCc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWRPcHRpb25zLFxuICBWYWxpZGF0ZWRSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkT3B0aW9uc1xufSBmcm9tICcuL3JlYWRlci1vcHRpb25zJztcbmltcG9ydCB7IGNvbnZlcnRCeW9iUmVhZE9wdGlvbnMgfSBmcm9tICcuLi92YWxpZGF0b3JzL3JlYWRlci1vcHRpb25zJztcbmltcG9ydCB7IGlzRGF0YVZpZXcsIHR5cGUgTm9uU2hhcmVkLCB0eXBlIFR5cGVkQXJyYXkgfSBmcm9tICcuLi9oZWxwZXJzL2FycmF5LWJ1ZmZlci12aWV3JztcblxuLyoqXG4gKiBBIHJlc3VsdCByZXR1cm5lZCBieSB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnJlYWR9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgUmVhZGFibGVTdHJlYW1CWU9CUmVhZFJlc3VsdDxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3PiA9IHtcbiAgZG9uZTogZmFsc2U7XG4gIHZhbHVlOiBUO1xufSB8IHtcbiAgZG9uZTogdHJ1ZTtcbiAgdmFsdWU6IFQgfCB1bmRlZmluZWQ7XG59O1xuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbmV4cG9ydCBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtKTogUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtIGFzIFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KTtcbn1cblxuLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Q8VCBleHRlbmRzIE5vblNoYXJlZDxBcnJheUJ1ZmZlclZpZXc+PihcbiAgc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIHJlYWRJbnRvUmVxdWVzdDogUmVhZEludG9SZXF1ZXN0PFQ+XG4pOiB2b2lkIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbS5fcmVhZGVyKSk7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnIHx8IHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKTtcblxuICAoc3RyZWFtLl9yZWFkZXIhIGFzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcikuX3JlYWRJbnRvUmVxdWVzdHMucHVzaChyZWFkSW50b1JlcXVlc3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogQXJyYXlCdWZmZXJWaWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBib29sZWFuKSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyIGFzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcblxuICBhc3NlcnQocmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aCA+IDApO1xuXG4gIGNvbnN0IHJlYWRJbnRvUmVxdWVzdCA9IHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5zaGlmdCgpITtcbiAgaWYgKGRvbmUpIHtcbiAgICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHMoY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIHJlYWRJbnRvUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSk6IG51bWJlciB7XG4gIHJldHVybiAoc3RyZWFtLl9yZWFkZXIgYXMgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKS5fcmVhZEludG9SZXF1ZXN0cy5sZW5ndGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0pOiBib29sZWFuIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cbiAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihyZWFkZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFJlYWRlcnNcblxuZXhwb3J0IGludGVyZmFjZSBSZWFkSW50b1JlcXVlc3Q8VCBleHRlbmRzIE5vblNoYXJlZDxBcnJheUJ1ZmZlclZpZXc+PiB7XG4gIF9jaHVua1N0ZXBzKGNodW5rOiBUKTogdm9pZDtcblxuICBfY2xvc2VTdGVwcyhjaHVuazogVCB8IHVuZGVmaW5lZCk6IHZvaWQ7XG5cbiAgX2Vycm9yU3RlcHMoZTogYW55KTogdm9pZDtcbn1cblxuLyoqXG4gKiBBIEJZT0IgcmVhZGVyIHZlbmRlZCBieSBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb3duZXJSZWFkYWJsZVN0cmVhbSE6IFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZSE6IFByb21pc2U8dW5kZWZpbmVkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZV9yZXNvbHZlPzogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlX3JlamVjdD86IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZEludG9SZXF1ZXN0czogU2ltcGxlUXVldWU8UmVhZEludG9SZXF1ZXN0PGFueT4+O1xuXG4gIGNvbnN0cnVjdG9yKHN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4pIHtcbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcicpO1xuICAgIGFzc2VydFJlYWRhYmxlU3RyZWFtKHN0cmVhbSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29uc3RydWN0IGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIGZvciBhIHN0cmVhbSBub3QgY29uc3RydWN0ZWQgd2l0aCBhIGJ5dGUgJyArXG4gICAgICAgICdzb3VyY2UnKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG5cbiAgICB0aGlzLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3JcbiAgICogdGhlIHJlYWRlcidzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cbiAgICovXG4gIGdldCBjbG9zZWQoKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBSZWFkYWJsZVN0cmVhbS5jYW5jZWwgfCBzdHJlYW0uY2FuY2VsKHJlYXNvbil9LlxuICAgKi9cbiAgY2FuY2VsKHJlYXNvbjogYW55ID0gdW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCh0aGlzLCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHJlYWRzIGJ5dGVzIGludG8gdmlldywgYW5kIHJldHVybnMgYSBwcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdC5cbiAgICpcbiAgICogSWYgcmVhZGluZyBhIGNodW5rIGNhdXNlcyB0aGUgcXVldWUgdG8gYmVjb21lIGVtcHR5LCBtb3JlIGRhdGEgd2lsbCBiZSBwdWxsZWQgZnJvbSB0aGUgdW5kZXJseWluZyBzb3VyY2UuXG4gICAqL1xuICByZWFkPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KFxuICAgIHZpZXc6IFQsXG4gICAgb3B0aW9ucz86IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWRPcHRpb25zXG4gICk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1CWU9CUmVhZFJlc3VsdDxUPj47XG4gIHJlYWQ8VCBleHRlbmRzIE5vblNoYXJlZDxBcnJheUJ1ZmZlclZpZXc+PihcbiAgICB2aWV3OiBULFxuICAgIHJhd09wdGlvbnM6IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWRPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9XG4gICk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1CWU9CUmVhZFJlc3VsdDxUPj4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkJykpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3IG11c3QgYmUgYW4gYXJyYXkgYnVmZmVyIHZpZXcnKSk7XG4gICAgfVxuICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXcgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGgnKSk7XG4gICAgfVxuICAgIGlmICh2aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGB2aWV3J3MgYnVmZmVyIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoYCkpO1xuICAgIH1cbiAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXdcXCdzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCcpKTtcbiAgICB9XG5cbiAgICBsZXQgb3B0aW9uczogVmFsaWRhdGVkUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZE9wdGlvbnM7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSBjb252ZXJ0QnlvYlJlYWRPcHRpb25zKHJhd09wdGlvbnMsICdvcHRpb25zJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IG9wdGlvbnMubWluO1xuICAgIGlmIChtaW4gPT09IDApIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubWluIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKSk7XG4gICAgfVxuICAgIGlmICghaXNEYXRhVmlldyh2aWV3KSkge1xuICAgICAgaWYgKG1pbiA+ICh2aWV3IGFzIHVua25vd24gYXMgVHlwZWRBcnJheSkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBSYW5nZUVycm9yKCdvcHRpb25zLm1pbiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB2aWV3XFwncyBsZW5ndGgnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtaW4gPiB2aWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBSYW5nZUVycm9yKCdvcHRpb25zLm1pbiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB2aWV3XFwncyBieXRlTGVuZ3RoJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ3JlYWQgZnJvbScpKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2UhOiAocmVzdWx0OiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkUmVzdWx0PFQ+KSA9PiB2b2lkO1xuICAgIGxldCByZWplY3RQcm9taXNlITogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlPFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHQ8VD4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgY29uc3QgcmVhZEludG9SZXF1ZXN0OiBSZWFkSW50b1JlcXVlc3Q8VD4gPSB7XG4gICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pLFxuICAgICAgX2Nsb3NlU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiB0cnVlIH0pLFxuICAgICAgX2Vycm9yU3RlcHM6IGUgPT4gcmVqZWN0UHJvbWlzZShlKVxuICAgIH07XG4gICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZCh0aGlzLCB2aWV3LCBtaW4sIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIHJlYWRlcidzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuICAgKlxuICAgKiBBIHJlYWRlcidzIGxvY2sgY2Fubm90IGJlIHJlbGVhc2VkIHdoaWxlIGl0IHN0aWxsIGhhcyBhIHBlbmRpbmcgcmVhZCByZXF1ZXN0LCBpLmUuLCBpZiBhIHByb21pc2UgcmV0dXJuZWQgYnlcbiAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xuICAgKiBkbyBzbyB3aWxsIHRocm93IGEgYFR5cGVFcnJvcmAgYW5kIGxlYXZlIHRoZSByZWFkZXIgbG9ja2VkIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICByZWxlYXNlTG9jaygpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVsZWFzZSh0aGlzKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLCB7XG4gIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlYWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUuY2FuY2VsLCAnY2FuY2VsJyk7XG5zZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS5yZWFkLCAncmVhZCcpO1xuc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUucmVsZWFzZUxvY2ssICdyZWxlYXNlTG9jaycpO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgcmVhZGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHg6IGFueSk6IHggaXMgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRJbnRvUmVxdWVzdHMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZDxUIGV4dGVuZHMgTm9uU2hhcmVkPEFycmF5QnVmZmVyVmlldz4+KFxuICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgdmlldzogVCxcbiAgbWluOiBudW1iZXIsXG4gIHJlYWRJbnRvUmVxdWVzdDogUmVhZEludG9SZXF1ZXN0PFQ+XG4pOiB2b2lkIHtcbiAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG5cbiAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvKFxuICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgYXMgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgIHZpZXcsXG4gICAgICBtaW4sXG4gICAgICByZWFkSW50b1JlcXVlc3RcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWxlYXNlKHJlYWRlcjogUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKSB7XG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgY29uc3QgZSA9IG5ldyBUeXBlRXJyb3IoJ1JlYWRlciB3YXMgcmVsZWFzZWQnKTtcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyRXJyb3JSZWFkSW50b1JlcXVlc3RzKHJlYWRlciwgZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJFcnJvclJlYWRJbnRvUmVxdWVzdHMocmVhZGVyOiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIsIGU6IGFueSkge1xuICBjb25zdCByZWFkSW50b1JlcXVlc3RzID0gcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzO1xuICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XG4gICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuICB9KTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5cblxuZnVuY3Rpb24gYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyYCk7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBRdWV1aW5nU3RyYXRlZ3ksIFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjayB9IGZyb20gJy4uL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IE51bWJlcklzTmFOIGZyb20gJy4uLy4uL3N0dWIvbnVtYmVyLWlzbmFuJztcblxuZXhwb3J0IGZ1bmN0aW9uIEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5OiBRdWV1aW5nU3RyYXRlZ3ksIGRlZmF1bHRIV006IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHsgaGlnaFdhdGVyTWFyayB9ID0gc3RyYXRlZ3k7XG5cbiAgaWYgKGhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBkZWZhdWx0SFdNO1xuICB9XG5cbiAgaWYgKE51bWJlcklzTmFOKGhpZ2hXYXRlck1hcmspIHx8IGhpZ2hXYXRlck1hcmsgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgaGlnaFdhdGVyTWFyaycpO1xuICB9XG5cbiAgcmV0dXJuIGhpZ2hXYXRlck1hcms7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFeHRyYWN0U2l6ZUFsZ29yaXRobTxUPihzdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5PFQ+KTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFQ+IHtcbiAgY29uc3QgeyBzaXplIH0gPSBzdHJhdGVneTtcblxuICBpZiAoIXNpemUpIHtcbiAgICByZXR1cm4gKCkgPT4gMTtcbiAgfVxuXG4gIHJldHVybiBzaXplO1xufVxuIiwgImltcG9ydCB0eXBlIHsgUXVldWluZ1N0cmF0ZWd5LCBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2sgfSBmcm9tICcuLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IGFzc2VydERpY3Rpb25hcnksIGFzc2VydEZ1bmN0aW9uLCBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlIH0gZnJvbSAnLi9iYXNpYyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5PFQ+KGluaXQ6IFF1ZXVpbmdTdHJhdGVneTxUPiB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBRdWV1aW5nU3RyYXRlZ3k8VD4ge1xuICBhc3NlcnREaWN0aW9uYXJ5KGluaXQsIGNvbnRleHQpO1xuICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gaW5pdD8uaGlnaFdhdGVyTWFyaztcbiAgY29uc3Qgc2l6ZSA9IGluaXQ/LnNpemU7XG4gIHJldHVybiB7XG4gICAgaGlnaFdhdGVyTWFyazogaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFVucmVzdHJpY3RlZERvdWJsZShoaWdoV2F0ZXJNYXJrKSxcbiAgICBzaXplOiBzaXplID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5U2l6ZShzaXplLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzaXplJyB0aGF0YClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemU8VD4oZm46IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxUPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIGNodW5rID0+IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoZm4oY2h1bmspKTtcbn1cbiIsICJpbXBvcnQgeyBhc3NlcnREaWN0aW9uYXJ5LCBhc3NlcnRGdW5jdGlvbiB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHsgcHJvbWlzZUNhbGwsIHJlZmxlY3RDYWxsIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHR5cGUge1xuICBVbmRlcmx5aW5nU2luayxcbiAgVW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrLFxuICBWYWxpZGF0ZWRVbmRlcmx5aW5nU2lua1xufSBmcm9tICcuLi93cml0YWJsZS1zdHJlYW0vdW5kZXJseWluZy1zaW5rJztcbmltcG9ydCB7IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgfSBmcm9tICcuLi93cml0YWJsZS1zdHJlYW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rPFc+KG9yaWdpbmFsOiBVbmRlcmx5aW5nU2luazxXPiB8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFZhbGlkYXRlZFVuZGVybHlpbmdTaW5rPFc+IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcmlnaW5hbCwgY29udGV4dCk7XG4gIGNvbnN0IGFib3J0ID0gb3JpZ2luYWw/LmFib3J0O1xuICBjb25zdCBjbG9zZSA9IG9yaWdpbmFsPy5jbG9zZTtcbiAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbD8uc3RhcnQ7XG4gIGNvbnN0IHR5cGUgPSBvcmlnaW5hbD8udHlwZTtcbiAgY29uc3Qgd3JpdGUgPSBvcmlnaW5hbD8ud3JpdGU7XG4gIHJldHVybiB7XG4gICAgYWJvcnQ6IGFib3J0ID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2soYWJvcnQsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYWJvcnQnIHRoYXRgKSxcbiAgICBjbG9zZTogY2xvc2UgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayhjbG9zZSwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdjbG9zZScgdGhhdGApLFxuICAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgd3JpdGU6IHdyaXRlID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2sod3JpdGUsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnd3JpdGUnIHRoYXRgKSxcbiAgICB0eXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2soXG4gIGZuOiBVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2ssXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nU2luayxcbiAgY29udGV4dDogc3RyaW5nXG4pOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAocmVhc29uOiBhbnkpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW3JlYXNvbl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKFxuICBmbjogVW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrLFxuICBvcmlnaW5hbDogVW5kZXJseWluZ1NpbmssXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogKCkgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuICgpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW10pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKFxuICBmbjogVW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrLFxuICBvcmlnaW5hbDogVW5kZXJseWluZ1NpbmssXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogVW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrIHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjazxXPihcbiAgZm46IFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjazxXPixcbiAgb3JpZ2luYWw6IFVuZGVybHlpbmdTaW5rPFc+LFxuICBjb250ZXh0OiBzdHJpbmdcbik6IChjaHVuazogVywgY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcikgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjaHVuazogVywgY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcbn1cbiIsICJpbXBvcnQgeyBJc1dyaXRhYmxlU3RyZWFtLCBXcml0YWJsZVN0cmVhbSB9IGZyb20gJy4uL3dyaXRhYmxlLXN0cmVhbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRXcml0YWJsZVN0cmVhbSh4OiB1bmtub3duLCBjb250ZXh0OiBzdHJpbmcpOiBhc3NlcnRzIHggaXMgV3JpdGFibGVTdHJlYW0ge1xuICBpZiAoIUlzV3JpdGFibGVTdHJlYW0oeCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIFdyaXRhYmxlU3RyZWFtLmApO1xuICB9XG59XG4iLCAiLyoqXG4gKiBBIHNpZ25hbCBvYmplY3QgdGhhdCBhbGxvd3MgeW91IHRvIGNvbW11bmljYXRlIHdpdGggYSByZXF1ZXN0IGFuZCBhYm9ydCBpdCBpZiByZXF1aXJlZFxuICogdmlhIGl0cyBhc3NvY2lhdGVkIGBBYm9ydENvbnRyb2xsZXJgIG9iamVjdC5cbiAqXG4gKiBAcmVtYXJrc1xuICogICBUaGlzIGludGVyZmFjZSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGBBYm9ydFNpZ25hbGAgaW50ZXJmYWNlIGRlZmluZWQgaW4gVHlwZVNjcmlwdCdzIERPTSB0eXBlcy5cbiAqICAgSXQgaXMgcmVkZWZpbmVkIGhlcmUsIHNvIGl0IGNhbiBiZSBwb2x5ZmlsbGVkIHdpdGhvdXQgYSBET00sIGZvciBleGFtcGxlIHdpdGhcbiAqICAge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbCB8IGFib3J0Y29udHJvbGxlci1wb2x5ZmlsbH0gaW4gYSBOb2RlIGVudmlyb25tZW50LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBYm9ydFNpZ25hbCB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIGFib3J0ZWQuXG4gICAqL1xuICByZWFkb25seSBhYm9ydGVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiBhYm9ydGVkLCByZXR1cm5zIHRoZSByZWFzb24gZm9yIGFib3J0aW5nLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVhc29uPzogYW55O1xuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBzaWduYWwgYmVjb21lcyBhYm9ydGVkLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlOiAnYWJvcnQnLCBsaXN0ZW5lcjogKCkgPT4gdm9pZCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciB0aGF0IHdhcyBwcmV2aW91c2x5IGFkZGVkIHdpdGgge0BsaW5rIEFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXJ9LlxuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlOiAnYWJvcnQnLCBsaXN0ZW5lcjogKCkgPT4gdm9pZCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fib3J0U2lnbmFsKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgQWJvcnRTaWduYWwge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgKHZhbHVlIGFzIEFib3J0U2lnbmFsKS5hYm9ydGVkID09PSAnYm9vbGVhbic7XG4gIH0gY2F0Y2gge1xuICAgIC8vIEFib3J0U2lnbmFsLnByb3RvdHlwZS5hYm9ydGVkIHRocm93cyBpZiBpdHMgYnJhbmQgY2hlY2sgZmFpbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbnRyb2xsZXIgb2JqZWN0IHRoYXQgYWxsb3dzIHlvdSB0byBhYm9ydCBhbiBgQWJvcnRTaWduYWxgIHdoZW4gZGVzaXJlZC5cbiAqXG4gKiBAcmVtYXJrc1xuICogICBUaGlzIGludGVyZmFjZSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGBBYm9ydENvbnRyb2xsZXJgIGludGVyZmFjZSBkZWZpbmVkIGluIFR5cGVTY3JpcHQncyBET00gdHlwZXMuXG4gKiAgIEl0IGlzIHJlZGVmaW5lZCBoZXJlLCBzbyBpdCBjYW4gYmUgcG9seWZpbGxlZCB3aXRob3V0IGEgRE9NLCBmb3IgZXhhbXBsZSB3aXRoXG4gKiAgIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwgfCBhYm9ydGNvbnRyb2xsZXItcG9seWZpbGx9IGluIGEgTm9kZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBYm9ydENvbnRyb2xsZXIge1xuICByZWFkb25seSBzaWduYWw6IEFib3J0U2lnbmFsO1xuXG4gIGFib3J0KHJlYXNvbj86IGFueSk6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBBYm9ydENvbnRyb2xsZXJDb25zdHJ1Y3RvciB7XG4gIG5ldygpOiBBYm9ydENvbnRyb2xsZXI7XG59XG5cbmNvbnN0IHN1cHBvcnRzQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIChBYm9ydENvbnRyb2xsZXIgYXMgYW55KSA9PT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBuZXcgQWJvcnRDb250cm9sbGVyLCBpZiBzdXBwb3J0ZWQgYnkgdGhlIHBsYXRmb3JtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKCk6IEFib3J0Q29udHJvbGxlciB8IHVuZGVmaW5lZCB7XG4gIGlmIChzdXBwb3J0c0Fib3J0Q29udHJvbGxlcikge1xuICAgIHJldHVybiBuZXcgKEFib3J0Q29udHJvbGxlciBhcyBBYm9ydENvbnRyb2xsZXJDb25zdHJ1Y3RvcikoKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHtcbiAgbmV3UHJvbWlzZSxcbiAgcHJvbWlzZVJlamVjdGVkV2l0aCxcbiAgcHJvbWlzZVJlc29sdmVkV2l0aCxcbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSxcbiAgdXBvblByb21pc2Vcbn0gZnJvbSAnLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQge1xuICBEZXF1ZXVlVmFsdWUsXG4gIEVucXVldWVWYWx1ZVdpdGhTaXplLFxuICBQZWVrUXVldWVWYWx1ZSxcbiAgdHlwZSBRdWV1ZVBhaXIsXG4gIFJlc2V0UXVldWVcbn0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvcXVldWUtd2l0aC1zaXplcyc7XG5pbXBvcnQgdHlwZSB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IFNpbXBsZVF1ZXVlIH0gZnJvbSAnLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHsgc2V0RnVuY3Rpb25OYW1lLCB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBBYm9ydFN0ZXBzLCBFcnJvclN0ZXBzIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBJc05vbk5lZ2F0aXZlTnVtYmVyIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBFeHRyYWN0SGlnaFdhdGVyTWFyaywgRXh0cmFjdFNpemVBbGdvcml0aG0gfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgdHlwZSB7XG4gIFVuZGVybHlpbmdTaW5rLFxuICBVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2ssXG4gIFZhbGlkYXRlZFVuZGVybHlpbmdTaW5rXG59IGZyb20gJy4vd3JpdGFibGUtc3RyZWFtL3VuZGVybHlpbmctc2luayc7XG5pbXBvcnQgeyBhc3NlcnRPYmplY3QsIGFzc2VydFJlcXVpcmVkQXJndW1lbnQgfSBmcm9tICcuL3ZhbGlkYXRvcnMvYmFzaWMnO1xuaW1wb3J0IHsgY29udmVydFVuZGVybHlpbmdTaW5rIH0gZnJvbSAnLi92YWxpZGF0b3JzL3VuZGVybHlpbmctc2luayc7XG5pbXBvcnQgeyBhc3NlcnRXcml0YWJsZVN0cmVhbSB9IGZyb20gJy4vdmFsaWRhdG9ycy93cml0YWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgdHlwZSBBYm9ydENvbnRyb2xsZXIsIHR5cGUgQWJvcnRTaWduYWwsIGNyZWF0ZUFib3J0Q29udHJvbGxlciB9IGZyb20gJy4vYWJvcnQtc2lnbmFsJztcblxudHlwZSBXcml0YWJsZVN0cmVhbVN0YXRlID0gJ3dyaXRhYmxlJyB8ICdjbG9zZWQnIHwgJ2Vycm9yaW5nJyB8ICdlcnJvcmVkJztcblxuaW50ZXJmYWNlIFdyaXRlT3JDbG9zZVJlcXVlc3Qge1xuICBfcmVzb2x2ZTogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBfcmVqZWN0OiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG59XG5cbnR5cGUgV3JpdGVSZXF1ZXN0ID0gV3JpdGVPckNsb3NlUmVxdWVzdDtcbnR5cGUgQ2xvc2VSZXF1ZXN0ID0gV3JpdGVPckNsb3NlUmVxdWVzdDtcblxuaW50ZXJmYWNlIFBlbmRpbmdBYm9ydFJlcXVlc3Qge1xuICBfcHJvbWlzZTogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICBfcmVzb2x2ZTogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBfcmVqZWN0OiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gIF9yZWFzb246IGFueTtcbiAgX3dhc0FscmVhZHlFcnJvcmluZzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBIHdyaXRhYmxlIHN0cmVhbSByZXByZXNlbnRzIGEgZGVzdGluYXRpb24gZm9yIGRhdGEsIGludG8gd2hpY2ggeW91IGNhbiB3cml0ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFdyaXRhYmxlU3RyZWFtPFcgPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RhdGUhOiBXcml0YWJsZVN0cmVhbVN0YXRlO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdG9yZWRFcnJvcjogYW55O1xuICAvKiogQGludGVybmFsICovXG4gIF93cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXPiB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyITogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfd3JpdGVSZXF1ZXN0cyE6IFNpbXBsZVF1ZXVlPFdyaXRlUmVxdWVzdD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2luRmxpZ2h0V3JpdGVSZXF1ZXN0OiBXcml0ZVJlcXVlc3QgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlUmVxdWVzdDogQ2xvc2VSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9pbkZsaWdodENsb3NlUmVxdWVzdDogQ2xvc2VSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9wZW5kaW5nQWJvcnRSZXF1ZXN0OiBQZW5kaW5nQWJvcnRSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9iYWNrcHJlc3N1cmUhOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHVuZGVybHlpbmdTaW5rPzogVW5kZXJseWluZ1Npbms8Vz4sIHN0cmF0ZWd5PzogUXVldWluZ1N0cmF0ZWd5PFc+KTtcbiAgY29uc3RydWN0b3IocmF3VW5kZXJseWluZ1Npbms6IFVuZGVybHlpbmdTaW5rPFc+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9LFxuICAgICAgICAgICAgICByYXdTdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5PFc+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9KSB7XG4gICAgaWYgKHJhd1VuZGVybHlpbmdTaW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhd1VuZGVybHlpbmdTaW5rID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgIGNvbnN0IHVuZGVybHlpbmdTaW5rID0gY29udmVydFVuZGVybHlpbmdTaW5rKHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0odGhpcyk7XG5cbiAgICBjb25zdCB0eXBlID0gdW5kZXJseWluZ1NpbmsudHlwZTtcbiAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlIGlzIHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XG4gICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAxKTtcblxuICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayh0aGlzLCB1bmRlcmx5aW5nU2luaywgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgd3JpdGFibGUgc3RyZWFtIGlzIGxvY2tlZCB0byBhIHdyaXRlci5cbiAgICovXG4gIGdldCBsb2NrZWQoKTogYm9vbGVhbiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdsb2NrZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYm9ydHMgdGhlIHN0cmVhbSwgc2lnbmFsaW5nIHRoYXQgdGhlIHByb2R1Y2VyIGNhbiBubyBsb25nZXIgc3VjY2Vzc2Z1bGx5IHdyaXRlIHRvIHRoZSBzdHJlYW0gYW5kIGl0IGlzIHRvIGJlXG4gICAqIGltbWVkaWF0ZWx5IG1vdmVkIHRvIGFuIGVycm9yZWQgc3RhdGUsIHdpdGggYW55IHF1ZXVlZC11cCB3cml0ZXMgZGlzY2FyZGVkLiBUaGlzIHdpbGwgYWxzbyBleGVjdXRlIGFueSBhYm9ydFxuICAgKiBtZWNoYW5pc20gb2YgdGhlIHVuZGVybHlpbmcgc2luay5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBmdWxmaWxsIGlmIHRoZSBzdHJlYW0gc2h1dHMgZG93biBzdWNjZXNzZnVsbHksIG9yIHJlamVjdCBpZiB0aGUgdW5kZXJseWluZyBzaW5rIHNpZ25hbGVkXG4gICAqIHRoYXQgdGhlcmUgd2FzIGFuIGVycm9yIGRvaW5nIHNvLiBBZGRpdGlvbmFsbHksIGl0IHdpbGwgcmVqZWN0IHdpdGggYSBgVHlwZUVycm9yYCAod2l0aG91dCBhdHRlbXB0aW5nIHRvIGNhbmNlbFxuICAgKiB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXG4gICAqL1xuICBhYm9ydChyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignYWJvcnQnKSk7XG4gICAgfVxuXG4gICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBhYm9ydCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgd3JpdGVyJykpO1xuICAgIH1cblxuICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzdHJlYW0uIFRoZSB1bmRlcmx5aW5nIHNpbmsgd2lsbCBmaW5pc2ggcHJvY2Vzc2luZyBhbnkgcHJldmlvdXNseS13cml0dGVuIGNodW5rcywgYmVmb3JlIGludm9raW5nIGl0c1xuICAgKiBjbG9zZSBiZWhhdmlvci4gRHVyaW5nIHRoaXMgdGltZSBhbnkgZnVydGhlciBhdHRlbXB0cyB0byB3cml0ZSB3aWxsIGZhaWwgKHdpdGhvdXQgZXJyb3JpbmcgdGhlIHN0cmVhbSkuXG4gICAqXG4gICAqIFRoZSBtZXRob2QgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgaWYgYWxsIHJlbWFpbmluZyBjaHVua3MgYXJlIHN1Y2Nlc3NmdWxseSB3cml0dGVuIGFuZCB0aGUgc3RyZWFtXG4gICAqIHN1Y2Nlc3NmdWxseSBjbG9zZXMsIG9yIHJlamVjdHMgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgZHVyaW5nIHRoaXMgcHJvY2Vzcy4gQWRkaXRpb25hbGx5LCBpdCB3aWxsIHJlamVjdCB3aXRoXG4gICAqIGEgYFR5cGVFcnJvcmAgKHdpdGhvdXQgYXR0ZW1wdGluZyB0byBjYW5jZWwgdGhlIHN0cmVhbSkgaWYgdGhlIHN0cmVhbSBpcyBjdXJyZW50bHkgbG9ja2VkLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpKTtcbiAgICB9XG5cbiAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSB3cml0ZXInKSk7XG4gICAgfVxuXG4gICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1DbG9zZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciB8IHdyaXRlcn0gYW5kIGxvY2tzIHRoZSBzdHJlYW0gdG8gdGhlIG5ldyB3cml0ZXIuIFdoaWxlIHRoZSBzdHJlYW1cbiAgICogaXMgbG9ja2VkLCBubyBvdGhlciB3cml0ZXIgY2FuIGJlIGFjcXVpcmVkIHVudGlsIHRoaXMgb25lIGlzIHJlbGVhc2VkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIGNyZWF0aW5nIGFic3RyYWN0aW9ucyB0aGF0IGRlc2lyZSB0aGUgYWJpbGl0eSB0byB3cml0ZSB0byBhIHN0cmVhbVxuICAgKiB3aXRob3V0IGludGVycnVwdGlvbiBvciBpbnRlcmxlYXZpbmcuIEJ5IGdldHRpbmcgYSB3cml0ZXIgZm9yIHRoZSBzdHJlYW0sIHlvdSBjYW4gZW5zdXJlIG5vYm9keSBlbHNlIGNhbiB3cml0ZSBhdFxuICAgKiB0aGUgc2FtZSB0aW1lLCB3aGljaCB3b3VsZCBjYXVzZSB0aGUgcmVzdWx0aW5nIHdyaXR0ZW4gZGF0YSB0byBiZSB1bnByZWRpY3RhYmxlIGFuZCBwcm9iYWJseSB1c2VsZXNzLlxuICAgKi9cbiAgZ2V0V3JpdGVyKCk6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdnZXRXcml0ZXInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGdldFdyaXRlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuc2V0RnVuY3Rpb25OYW1lKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5hYm9ydCwgJ2Fib3J0Jyk7XG5zZXRGdW5jdGlvbk5hbWUoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLmNsb3NlLCAnY2xvc2UnKTtcbnNldEZ1bmN0aW9uTmFtZShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuZ2V0V3JpdGVyLCAnZ2V0V3JpdGVyJyk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQge1xuICBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLFxuICBDcmVhdGVXcml0YWJsZVN0cmVhbSxcbiAgSXNXcml0YWJsZVN0cmVhbSxcbiAgSXNXcml0YWJsZVN0cmVhbUxvY2tlZCxcbiAgV3JpdGFibGVTdHJlYW0sXG4gIFdyaXRhYmxlU3RyZWFtQWJvcnQsXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkLFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uLFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlLFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSxcbiAgV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHRcbn07XG5cbmV4cG9ydCB0eXBlIHtcbiAgVW5kZXJseWluZ1NpbmssXG4gIFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFja1xufTtcblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtLlxuXG5mdW5jdGlvbiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFc+KHN0cmVhbTogV3JpdGFibGVTdHJlYW08Vz4pOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8Vz4ge1xuICByZXR1cm4gbmV3IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihzdHJlYW0pO1xufVxuXG4vLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuZnVuY3Rpb24gQ3JlYXRlV3JpdGFibGVTdHJlYW08Vz4oc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQWxnb3JpdGhtOiAoY2h1bms6IFcpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrID0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxXPiA9ICgpID0+IDEpIHtcbiAgYXNzZXJ0KElzTm9uTmVnYXRpdmVOdW1iZXIoaGlnaFdhdGVyTWFyaykpO1xuXG4gIGNvbnN0IHN0cmVhbTogV3JpdGFibGVTdHJlYW08Vz4gPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbShzdHJlYW0pO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4gPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblxuICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICByZXR1cm4gc3RyZWFtO1xufVxuXG5mdW5jdGlvbiBJbml0aWFsaXplV3JpdGFibGVTdHJlYW08Vz4oc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPikge1xuICBzdHJlYW0uX3N0YXRlID0gJ3dyaXRhYmxlJztcblxuICAvLyBUaGUgZXJyb3IgdGhhdCB3aWxsIGJlIHJlcG9ydGVkIGJ5IG5ldyBtZXRob2QgY2FsbHMgb25jZSB0aGUgc3RhdGUgYmVjb21lcyBlcnJvcmVkLiBPbmx5IHNldCB3aGVuIFtbc3RhdGVdXSBpc1xuICAvLyAnZXJyb3JpbmcnIG9yICdlcnJvcmVkJy4gTWF5IGJlIHNldCB0byBhbiB1bmRlZmluZWQgdmFsdWUuXG4gIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgc3RyZWFtLl93cml0ZXIgPSB1bmRlZmluZWQ7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0byB1bmRlZmluZWQgZmlyc3QgYmVjYXVzZSB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNvbnRyb2xsZXIgY2hlY2tzIHRoaXNcbiAgLy8gdmFyaWFibGUgdG8gdmFsaWRhdGUgdGhlIGNhbGxlci5cbiAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQhO1xuXG4gIC8vIFRoaXMgcXVldWUgaXMgcGxhY2VkIGhlcmUgaW5zdGVhZCBvZiB0aGUgd3JpdGVyIGNsYXNzIGluIG9yZGVyIHRvIGFsbG93IGZvciBwYXNzaW5nIGEgd3JpdGVyIHRvIHRoZSBuZXh0IGRhdGFcbiAgLy8gcHJvZHVjZXIgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgcXVldWVkIHdyaXRlcyB0byBmaW5pc2guXG4gIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXG4gIC8vIFdyaXRlIHJlcXVlc3RzIGFyZSByZW1vdmVkIGZyb20gX3dyaXRlUmVxdWVzdHMgd2hlbiB3cml0ZSgpIGlzIGNhbGxlZCBvbiB0aGUgdW5kZXJseWluZyBzaW5rLiBUaGlzIHByZXZlbnRzXG4gIC8vIHRoZW0gZnJvbSBiZWluZyBlcnJvbmVvdXNseSByZWplY3RlZCBvbiBlcnJvci4gSWYgYSB3cml0ZSgpIGNhbGwgaXMgaW4tZmxpZ2h0LCB0aGUgcmVxdWVzdCBpcyBzdG9yZWQgaGVyZS5cbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICAvLyBUaGUgcHJvbWlzZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHdyaXRlci5jbG9zZSgpLiBTdG9yZWQgaGVyZSBiZWNhdXNlIGl0IG1heSBiZSBmdWxmaWxsZWQgYWZ0ZXIgdGhlIHdyaXRlclxuICAvLyBoYXMgYmVlbiBkZXRhY2hlZC5cbiAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgLy8gQ2xvc2UgcmVxdWVzdCBpcyByZW1vdmVkIGZyb20gX2Nsb3NlUmVxdWVzdCB3aGVuIGNsb3NlKCkgaXMgY2FsbGVkIG9uIHRoZSB1bmRlcmx5aW5nIHNpbmsuIFRoaXMgcHJldmVudHMgaXRcbiAgLy8gZnJvbSBiZWluZyBlcnJvbmVvdXNseSByZWplY3RlZCBvbiBlcnJvci4gSWYgYSBjbG9zZSgpIGNhbGwgaXMgaW4tZmxpZ2h0LCB0aGUgcmVxdWVzdCBpcyBzdG9yZWQgaGVyZS5cbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICAvLyBUaGUgcHJvbWlzZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHdyaXRlci5hYm9ydCgpLiBUaGlzIG1heSBhbHNvIGJlIGZ1bGZpbGxlZCBhZnRlciB0aGUgd3JpdGVyIGhhcyBkZXRhY2hlZC5cbiAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXG4gIC8vIFRoZSBiYWNrcHJlc3N1cmUgc2lnbmFsIHNldCBieSB0aGUgY29udHJvbGxlci5cbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbSh4OiB1bmtub3duKTogeCBpcyBXcml0YWJsZVN0cmVhbSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ193cml0YWJsZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW07XG59XG5cbmZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSk6IGJvb2xlYW4ge1xuICBhc3NlcnQoSXNXcml0YWJsZVN0cmVhbShzdHJlYW0pKTtcblxuICBpZiAoc3RyZWFtLl93cml0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUFib3J0KHN0cmVhbTogV3JpdGFibGVTdHJlYW0sIHJlYXNvbjogYW55KTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnIHx8IHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIuX2Fib3J0UmVhc29uID0gcmVhc29uO1xuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyPy5hYm9ydChyZWFzb24pO1xuXG4gIC8vIFR5cGVTY3JpcHQgbmFycm93cyB0aGUgdHlwZSBvZiBgc3RyZWFtLl9zdGF0ZWAgZG93biB0byAnd3JpdGFibGUnIHwgJ2Vycm9yaW5nJyxcbiAgLy8gYnV0IGl0IGRvZXNuJ3Qga25vdyB0aGF0IHNpZ25hbGluZyBhYm9ydCBydW5zIGF1dGhvciBjb2RlIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHRoZSBzdGF0ZS5cbiAgLy8gV2lkZW4gdGhlIHR5cGUgYWdhaW4gYnkgY2FzdGluZyB0byBXcml0YWJsZVN0cmVhbVN0YXRlLlxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGUgYXMgV3JpdGFibGVTdHJlYW1TdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnIHx8IHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG4gIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Byb21pc2U7XG4gIH1cblxuICBhc3NlcnQoc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpO1xuXG4gIGxldCB3YXNBbHJlYWR5RXJyb3JpbmcgPSBmYWxzZTtcbiAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgd2FzQWxyZWFkeUVycm9yaW5nID0gdHJ1ZTtcbiAgICAvLyByZWFzb24gd2lsbCBub3QgYmUgdXNlZCwgc28gZG9uJ3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdC5cbiAgICByZWFzb24gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZTx1bmRlZmluZWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB7XG4gICAgICBfcHJvbWlzZTogdW5kZWZpbmVkISxcbiAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgICAgX3JlamVjdDogcmVqZWN0LFxuICAgICAgX3JlYXNvbjogcmVhc29uLFxuICAgICAgX3dhc0FscmVhZHlFcnJvcmluZzogd2FzQWxyZWFkeUVycm9yaW5nXG4gICAgfTtcbiAgfSk7XG4gIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCEuX3Byb21pc2UgPSBwcm9taXNlO1xuXG4gIGlmICghd2FzQWxyZWFkeUVycm9yaW5nKSB7XG4gICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgcmVhc29uKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbTogV3JpdGFibGVTdHJlYW08YW55Pik6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihcbiAgICAgIGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSB3cml0YWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApKTtcbiAgfVxuXG4gIGFzc2VydChzdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG4gIGFzc2VydCghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSk7XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2U8dW5kZWZpbmVkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgY2xvc2VSZXF1ZXN0OiBDbG9zZVJlcXVlc3QgPSB7XG4gICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgIF9yZWplY3Q6IHJlamVjdFxuICAgIH07XG5cbiAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IGNsb3NlUmVxdWVzdDtcbiAgfSk7XG5cbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gIH1cblxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2Uoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBXcml0YWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0KHN0cmVhbTogV3JpdGFibGVTdHJlYW0pOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBhc3NlcnQoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKTtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpO1xuXG4gIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlPHVuZGVmaW5lZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHdyaXRlUmVxdWVzdDogV3JpdGVSZXF1ZXN0ID0ge1xuICAgICAgX3Jlc29sdmU6IHJlc29sdmUsXG4gICAgICBfcmVqZWN0OiByZWplY3RcbiAgICB9O1xuXG4gICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLnB1c2god3JpdGVSZXF1ZXN0KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtOiBXcml0YWJsZVN0cmVhbSwgZXJyb3I6IGFueSkge1xuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG5cbiAgaWYgKHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzc2VydChzdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG4gIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbTogV3JpdGFibGVTdHJlYW0sIHJlYXNvbjogYW55KSB7XG4gIGFzc2VydChzdHJlYW0uX3N0b3JlZEVycm9yID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG5cbiAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyO1xuICBhc3NlcnQoY29udHJvbGxlciAhPT0gdW5kZWZpbmVkKTtcblxuICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yaW5nJztcbiAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbiAgfVxuXG4gIGlmICghV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW0pICYmIGNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW06IFdyaXRhYmxlU3RyZWFtKSB7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JpbmcnKTtcbiAgYXNzZXJ0KCFXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkpO1xuICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yZWQnO1xuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcltFcnJvclN0ZXBzXSgpO1xuXG4gIGNvbnN0IHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLmZvckVhY2god3JpdGVSZXF1ZXN0ID0+IHtcbiAgICB3cml0ZVJlcXVlc3QuX3JlamVjdChzdG9yZWRFcnJvcik7XG4gIH0pO1xuICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcblxuICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYWJvcnRSZXF1ZXN0ID0gc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0O1xuICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGFib3J0UmVxdWVzdC5fd2FzQWxyZWFkeUVycm9yaW5nKSB7XG4gICAgYWJvcnRSZXF1ZXN0Ll9yZWplY3Qoc3RvcmVkRXJyb3IpO1xuICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbQWJvcnRTdGVwc10oYWJvcnRSZXF1ZXN0Ll9yZWFzb24pO1xuICB1cG9uUHJvbWlzZShcbiAgICBwcm9taXNlLFxuICAgICgpID0+IHtcbiAgICAgIGFib3J0UmVxdWVzdC5fcmVzb2x2ZSgpO1xuICAgICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAocmVhc29uOiBhbnkpID0+IHtcbiAgICAgIGFib3J0UmVxdWVzdC5fcmVqZWN0KHJlYXNvbik7XG4gICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgIT09IHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QhLl9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW06IFdyaXRhYmxlU3RyZWFtLCBlcnJvcjogYW55KSB7XG4gIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ICE9PSB1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0IS5fcmVqZWN0KGVycm9yKTtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JpbmcnKTtcblxuICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2Uoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSkge1xuICBhc3NlcnQoc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCEuX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKTtcblxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAvLyBUaGUgZXJyb3Igd2FzIHRvbyBsYXRlIHRvIGRvIGFueXRoaW5nLCBzbyBpdCBpcyBpZ25vcmVkLlxuICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Jlc29sdmUoKTtcbiAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICB9XG5cbiAgYXNzZXJ0KHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RvcmVkRXJyb3IgPT09IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW06IFdyaXRhYmxlU3RyZWFtLCBlcnJvcjogYW55KSB7XG4gIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ICE9PSB1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0IS5fcmVqZWN0KGVycm9yKTtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JpbmcnKTtcblxuICAvLyBOZXZlciBleGVjdXRlIHNpbmsgYWJvcnQoKSBhZnRlciBzaW5rIGNsb3NlKCkuXG4gIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcbiAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIH1cbiAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcbn1cblxuLy8gVE9ETyhyaWNlYSk6IEZpeCBhbHBoYWJldGljYWwgb3JkZXIuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGlmIChzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbTogV3JpdGFibGVTdHJlYW0pOiBib29sZWFuIHtcbiAgaWYgKHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSkge1xuICBhc3NlcnQoc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHN0cmVhbS5fY2xvc2VSZXF1ZXN0ICE9PSB1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gc3RyZWFtLl9jbG9zZVJlcXVlc3Q7XG4gIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbU1hcmtGaXJzdFdyaXRlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChzdHJlYW0uX3dyaXRlUmVxdWVzdHMubGVuZ3RoICE9PSAwKTtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5zaGlmdCgpO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJyk7XG4gIGlmIChzdHJlYW0uX2Nsb3NlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCk7XG5cbiAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdC5fcmVqZWN0KHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbTogV3JpdGFibGVTdHJlYW0sIGJhY2twcmVzc3VyZTogYm9vbGVhbikge1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG4gIGFzc2VydCghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSk7XG5cbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBiYWNrcHJlc3N1cmUgIT09IHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgaWYgKGJhY2twcmVzc3VyZSkge1xuICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0KHdyaXRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCghYmFja3ByZXNzdXJlKTtcblxuICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgICB9XG4gIH1cblxuICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGJhY2twcmVzc3VyZTtcbn1cblxuLyoqXG4gKiBBIGRlZmF1bHQgd3JpdGVyIHZlbmRlZCBieSBhIHtAbGluayBXcml0YWJsZVN0cmVhbX0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFcgPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb3duZXJXcml0YWJsZVN0cmVhbTogV3JpdGFibGVTdHJlYW08Vz47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2UhOiBQcm9taXNlPHVuZGVmaW5lZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VfcmVzb2x2ZT86ICh2YWx1ZT86IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZV9yZWplY3Q/OiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VTdGF0ZSE6ICdwZW5kaW5nJyB8ICdyZXNvbHZlZCcgfCAncmVqZWN0ZWQnO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkeVByb21pc2UhOiBQcm9taXNlPHVuZGVmaW5lZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlYWR5UHJvbWlzZV9yZXNvbHZlPzogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkeVByb21pc2VfcmVqZWN0PzogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkeVByb21pc2VTdGF0ZSE6ICdwZW5kaW5nJyB8ICdmdWxmaWxsZWQnIHwgJ3JlamVjdGVkJztcblxuICBjb25zdHJ1Y3RvcihzdHJlYW06IFdyaXRhYmxlU3RyZWFtPFc+KSB7XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXInKTtcbiAgICBhc3NlcnRXcml0YWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgd3JpdGluZyBieSBhbm90aGVyIHdyaXRlcicpO1xuICAgIH1cblxuICAgIHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPSBzdHJlYW07XG4gICAgc3RyZWFtLl93cml0ZXIgPSB0aGlzO1xuXG4gICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXG4gICAgaWYgKHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcbiAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChzdGF0ZSA9PT0gJ2Vycm9yZWQnKTtcblxuICAgICAgY29uc3Qgc3RvcmVkRXJyb3IgPSBzdHJlYW0uX3N0b3JlZEVycm9yO1xuICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0b3JlZEVycm9yKTtcbiAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCwgb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvclxuICAgKiB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXG4gICAqL1xuICBnZXQgY2xvc2VkKCk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgc3RyZWFt4oCZcyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXMgb3Zlci1mdWxsLlxuICAgKiBBIHByb2R1Y2VyIGNhbiB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgdGhlIHJpZ2h0IGFtb3VudCBvZiBkYXRhIHRvIHdyaXRlLlxuICAgKlxuICAgKiBJdCB3aWxsIGJlIGBudWxsYCBpZiB0aGUgc3RyZWFtIGNhbm5vdCBiZSBzdWNjZXNzZnVsbHkgd3JpdHRlbiB0byAoZHVlIHRvIGVpdGhlciBiZWluZyBlcnJvcmVkLCBvciBoYXZpbmcgYW4gYWJvcnRcbiAgICogcXVldWVkIHVwKS4gSXQgd2lsbCByZXR1cm4gemVybyBpZiB0aGUgc3RyZWFtIGlzIGNsb3NlZC4gQW5kIHRoZSBnZXR0ZXIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgaW52b2tlZCB3aGVuXG4gICAqIHRoZSB3cml0ZXLigJlzIGxvY2sgaXMgcmVsZWFzZWQuXG4gICAqL1xuICBnZXQgZGVzaXJlZFNpemUoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHN0cmVhbeKAmXMgaW50ZXJuYWwgcXVldWUgdHJhbnNpdGlvbnNcbiAgICogZnJvbSBub24tcG9zaXRpdmUgdG8gcG9zaXRpdmUsIHNpZ25hbGluZyB0aGF0IGl0IGlzIG5vIGxvbmdlciBhcHBseWluZyBiYWNrcHJlc3N1cmUuIE9uY2UgdGhlIGRlc2lyZWQgc2l6ZSBkaXBzXG4gICAqIGJhY2sgdG8gemVybyBvciBiZWxvdywgdGhlIGdldHRlciB3aWxsIHJldHVybiBhIG5ldyBwcm9taXNlIHRoYXQgc3RheXMgcGVuZGluZyB1bnRpbCB0aGUgbmV4dCB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBJZiB0aGUgc3RyZWFtIGJlY29tZXMgZXJyb3JlZCBvciBhYm9ydGVkLCBvciB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlY29tZVxuICAgKiByZWplY3RlZC5cbiAgICovXG4gIGdldCByZWFkeSgpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkeScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZHlQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBXcml0YWJsZVN0cmVhbS5hYm9ydCB8IHN0cmVhbS5hYm9ydChyZWFzb24pfS5cbiAgICovXG4gIGFib3J0KHJlYXNvbjogYW55ID0gdW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Fib3J0JykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdhYm9ydCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQodGhpcywgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgV3JpdGFibGVTdHJlYW0uY2xvc2UgfCBzdHJlYW0uY2xvc2UoKX0uXG4gICAqL1xuICBjbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcblxuICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuICAgIH1cblxuICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2UodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIHdyaXRlcuKAmXMgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgd3JpdGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG4gICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSB3cml0ZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXkgZnJvbVxuICAgKiBub3cgb247IG90aGVyd2lzZSwgdGhlIHdyaXRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgbG9jayBjYW4gc3RpbGwgYmUgcmVsZWFzZWQgZXZlbiBpZiBzb21lIG9uZ29pbmcgd3JpdGVzIGhhdmUgbm90IHlldCBmaW5pc2hlZCAoaS5lLiBldmVuIGlmIHRoZVxuICAgKiBwcm9taXNlcyByZXR1cm5lZCBmcm9tIHByZXZpb3VzIGNhbGxzIHRvIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIud3JpdGUgfCB3cml0ZSgpfSBoYXZlIG5vdCB5ZXQgc2V0dGxlZCkuXG4gICAqIEl04oCZcyBub3QgbmVjZXNzYXJ5IHRvIGhvbGQgdGhlIGxvY2sgb24gdGhlIHdyaXRlciBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSB3cml0ZTsgdGhlIGxvY2sgaW5zdGVhZCBzaW1wbHkgcHJldmVudHNcbiAgICogb3RoZXIgcHJvZHVjZXJzIGZyb20gd3JpdGluZyBpbiBhbiBpbnRlcmxlYXZlZCBtYW5uZXIuXG4gICAqL1xuICByZWxlYXNlTG9jaygpOiB2b2lkIHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXG4gICAgaWYgKHN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXNzZXJ0KHN0cmVhbS5fd3JpdGVyICE9PSB1bmRlZmluZWQpO1xuXG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgdGhlIGdpdmVuIGNodW5rIHRvIHRoZSB3cml0YWJsZSBzdHJlYW0sIGJ5IHdhaXRpbmcgdW50aWwgYW55IHByZXZpb3VzIHdyaXRlcyBoYXZlIGZpbmlzaGVkIHN1Y2Nlc3NmdWxseSxcbiAgICogYW5kIHRoZW4gc2VuZGluZyB0aGUgY2h1bmsgdG8gdGhlIHVuZGVybHlpbmcgc2luaydzIHtAbGluayBVbmRlcmx5aW5nU2luay53cml0ZSB8IHdyaXRlKCl9IG1ldGhvZC4gSXQgd2lsbCByZXR1cm5cbiAgICogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB1bmRlZmluZWQgdXBvbiBhIHN1Y2Nlc3NmdWwgd3JpdGUsIG9yIHJlamVjdHMgaWYgdGhlIHdyaXRlIGZhaWxzIG9yIHN0cmVhbSBiZWNvbWVzXG4gICAqIGVycm9yZWQgYmVmb3JlIHRoZSB3cml0aW5nIHByb2Nlc3MgaXMgaW5pdGlhdGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgd2hhdCBcInN1Y2Nlc3NcIiBtZWFucyBpcyB1cCB0byB0aGUgdW5kZXJseWluZyBzaW5rOyBpdCBtaWdodCBpbmRpY2F0ZSBzaW1wbHkgdGhhdCB0aGUgY2h1bmsgaGFzIGJlZW5cbiAgICogYWNjZXB0ZWQsIGFuZCBub3QgbmVjZXNzYXJpbHkgdGhhdCBpdCBpcyBzYWZlbHkgc2F2ZWQgdG8gaXRzIHVsdGltYXRlIGRlc3RpbmF0aW9uLlxuICAgKi9cbiAgd3JpdGUoY2h1bms6IFcpOiBQcm9taXNlPHZvaWQ+O1xuICB3cml0ZShjaHVuazogVyA9IHVuZGVmaW5lZCEpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignd3JpdGUnKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ3dyaXRlIHRvJykpO1xuICAgIH1cblxuICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh0aGlzLCBjaHVuayk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwge1xuICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB3cml0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVhZHk6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbnNldEZ1bmN0aW9uTmFtZShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLmFib3J0LCAnYWJvcnQnKTtcbnNldEZ1bmN0aW9uTmFtZShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLmNsb3NlLCAnY2xvc2UnKTtcbnNldEZ1bmN0aW9uTmFtZShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLnJlbGVhc2VMb2NrLCAncmVsZWFzZUxvY2snKTtcbnNldEZ1bmN0aW9uTmFtZShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLndyaXRlLCAnd3JpdGUnKTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXInLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5cblxuZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8VyA9IGFueT4oeDogYW55KTogeCBpcyBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8Vz4ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfb3duZXJXcml0YWJsZVN0cmVhbScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI7XG59XG5cbi8vIEEgY2xpZW50IG9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0KHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cbiAgYXNzZXJ0KHN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcblxuICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChzdHJlYW0sIHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG5cbiAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcik6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cblxuICBhc3NlcnQoc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpO1xuXG4gIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh3cml0ZXIpO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIGVycm9yOiBhbnkpIHtcbiAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpIHtcbiAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgZXJyb3I6IGFueSkge1xuICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChzdHJlYW0uX3dyaXRlciA9PT0gd3JpdGVyKTtcblxuICBjb25zdCByZWxlYXNlZEVycm9yID0gbmV3IFR5cGVFcnJvcihcbiAgICBgV3JpdGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKTtcblxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlbGVhc2VkRXJyb3IpO1xuXG4gIC8vIFRoZSBzdGF0ZSB0cmFuc2l0aW9ucyB0byBcImVycm9yZWRcIiBiZWZvcmUgdGhlIHNpbmsgYWJvcnQoKSBtZXRob2QgcnVucywgYnV0IHRoZSB3cml0ZXIuY2xvc2VkIHByb21pc2UgaXMgbm90XG4gIC8vIHJlamVjdGVkIHVudGlsIGFmdGVyd2FyZHMuIFRoaXMgbWVhbnMgdGhhdCBzaW1wbHkgdGVzdGluZyBzdGF0ZSB3aWxsIG5vdCB3b3JrLlxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWxlYXNlZEVycm9yKTtcblxuICBzdHJlYW0uX3dyaXRlciA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtID0gdW5kZWZpbmVkITtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGU8Vz4od3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8Vz4sIGNodW5rOiBXKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG5cbiAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyO1xuXG4gIGNvbnN0IGNodW5rU2l6ZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUoY29udHJvbGxlciwgY2h1bmspO1xuXG4gIGlmIChzdHJlYW0gIT09IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxuICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB8fCBzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIGNsb3Npbmcgb3IgY2xvc2VkIGFuZCBjYW5ub3QgYmUgd3JpdHRlbiB0bycpKTtcbiAgfVxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxuXG4gIGFzc2VydChzdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG5cbiAgY29uc3QgcHJvbWlzZSA9IFdyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0KHN0cmVhbSk7XG5cbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5jb25zdCBjbG9zZVNlbnRpbmVsOiB1bmlxdWUgc3ltYm9sID0ge30gYXMgYW55O1xuXG50eXBlIFF1ZXVlUmVjb3JkPFc+ID0gVyB8IHR5cGVvZiBjbG9zZVNlbnRpbmVsO1xuXG4vKipcbiAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtIHwgd3JpdGFibGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFcgPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtITogV3JpdGFibGVTdHJlYW08Vz47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3F1ZXVlITogU2ltcGxlUXVldWU8UXVldWVQYWlyPFF1ZXVlUmVjb3JkPFc+Pj47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3F1ZXVlVG90YWxTaXplITogbnVtYmVyO1xuICAvKiogQGludGVybmFsICovXG4gIF9hYm9ydFJlYXNvbjogYW55O1xuICAvKiogQGludGVybmFsICovXG4gIF9hYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RhcnRlZCE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSE6IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxXPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RyYXRlZ3lIV00hOiBudW1iZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3dyaXRlQWxnb3JpdGhtITogKGNodW5rOiBXKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZUFsZ29yaXRobSE6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Fib3J0QWxnb3JpdGhtITogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZWFzb24gd2hpY2ggd2FzIHBhc3NlZCB0byBgV3JpdGFibGVTdHJlYW0uYWJvcnQocmVhc29uKWAgd2hlbiB0aGUgc3RyZWFtIHdhcyBhYm9ydGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiAgVGhpcyBwcm9wZXJ0eSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHNwZWNpZmljYXRpb24sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3N0cmVhbXMvcHVsbC8xMTc3LlxuICAgKiAgVXNlIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnNpZ25hbH0ncyBgcmVhc29uYCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGFib3J0UmVhc29uKCk6IGFueSB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYWJvcnRSZWFzb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Fib3J0UmVhc29uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGBBYm9ydFNpZ25hbGAgdGhhdCBjYW4gYmUgdXNlZCB0byBhYm9ydCB0aGUgcGVuZGluZyB3cml0ZSBvciBjbG9zZSBvcGVyYXRpb24gd2hlbiB0aGUgc3RyZWFtIGlzIGFib3J0ZWQuXG4gICAqL1xuICBnZXQgc2lnbmFsKCk6IEFib3J0U2lnbmFsIHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdzaWduYWwnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Fib3J0Q29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBPbGRlciBicm93c2VycyBvciBvbGRlciBOb2RlIHZlcnNpb25zIG1heSBub3Qgc3VwcG9ydCBgQWJvcnRDb250cm9sbGVyYCBvciBgQWJvcnRTaWduYWxgLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBidW5kbGUgYW5kIHNoaXAgYW4gYEFib3J0Q29udHJvbGxlcmAgcG9seWZpbGwgdG9nZXRoZXIgd2l0aCBvdXIgcG9seWZpbGwsXG4gICAgICAvLyBzbyBpbnN0ZWFkIHdlIG9ubHkgaW1wbGVtZW50IHN1cHBvcnQgZm9yIGBzaWduYWxgIGlmIHdlIGZpbmQgYSBnbG9iYWwgYEFib3J0Q29udHJvbGxlcmAgY29uc3RydWN0b3IuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5zaWduYWwgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgd3JpdGFibGUgc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZSBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgcmFyZWx5IHVzZWQsIHNpbmNlIHVzdWFsbHkgaXQgc3VmZmljZXMgdG8gcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBmcm9tIG9uZSBvZiB0aGUgdW5kZXJseWluZ1xuICAgKiBzaW5rJ3MgbWV0aG9kcy4gSG93ZXZlciwgaXQgY2FuIGJlIHVzZWZ1bCBmb3Igc3VkZGVubHkgc2h1dHRpbmcgZG93biBhIHN0cmVhbSBpbiByZXNwb25zZSB0byBhbiBldmVudCBvdXRzaWRlIHRoZVxuICAgKiBub3JtYWwgbGlmZWN5Y2xlIG9mIGludGVyYWN0aW9ucyB3aXRoIHRoZSB1bmRlcmx5aW5nIHNpbmsuXG4gICAqL1xuICBlcnJvcihlOiBhbnkgPSB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbS5fc3RhdGU7XG4gICAgaWYgKHN0YXRlICE9PSAnd3JpdGFibGUnKSB7XG4gICAgICAvLyBUaGUgc3RyZWFtIGlzIGNsb3NlZCwgZXJyb3JlZCBvciB3aWxsIGJlIHNvb24uIFRoZSBzaW5rIGNhbid0IGRvIGFueXRoaW5nIHVzZWZ1bCBpZiBpdCBnZXRzIGFuIGVycm9yIGhlcmUsIHNvXG4gICAgICAvLyBqdXN0IHRyZWF0IGl0IGFzIGEgbm8tb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBbQWJvcnRTdGVwc10ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9hYm9ydEFsZ29yaXRobShyZWFzb24pO1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW0Vycm9yU3RlcHNdKCkge1xuICAgIFJlc2V0UXVldWUodGhpcyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgYWJvcnRSZWFzb246IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBzaWduYWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgaW1wbGVtZW50aW5nIGludGVyZmFjZSByZXF1aXJlZCBieSB0aGUgV3JpdGFibGVTdHJlYW0uXG5cbmZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4OiBhbnkpOiB4IGlzIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PiB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkV3JpdGFibGVTdHJlYW0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbn1cblxuZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+KHN0cmVhbTogV3JpdGFibGVTdHJlYW08Vz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQWxnb3JpdGhtOiAoY2h1bms6IFcpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFc+KSB7XG4gIGFzc2VydChJc1dyaXRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICBhc3NlcnQoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCk7XG5cbiAgY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cbiAgLy8gTmVlZCB0byBzZXQgdGhlIHNsb3RzIHNvIHRoYXQgdGhlIGFzc2VydCBkb2Vzbid0IGZpcmUuIEluIHRoZSBzcGVjIHRoZSBzbG90cyBhbHJlYWR5IGV4aXN0IGltcGxpY2l0bHkuXG4gIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQhO1xuICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuXG4gIGNvbnRyb2xsZXIuX2Fib3J0UmVhc29uID0gdW5kZWZpbmVkO1xuICBjb250cm9sbGVyLl9hYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuXG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHNpemVBbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcblxuICBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobSA9IHdyaXRlQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSA9IGNsb3NlQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IGFib3J0QWxnb3JpdGhtO1xuXG4gIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcblxuICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpO1xuICB1cG9uUHJvbWlzZShcbiAgICBzdGFydFByb21pc2UsXG4gICAgKCkgPT4ge1xuICAgICAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG4gICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgciA9PiB7XG4gICAgICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JpbmcnKTtcbiAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIHIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1Npbms8Vz4oc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmx5aW5nU2luazogVmFsaWRhdGVkVW5kZXJseWluZ1Npbms8Vz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxXPikge1xuICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cbiAgbGV0IHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD47XG4gIGxldCB3cml0ZUFsZ29yaXRobTogKGNodW5rOiBXKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBsZXQgY2xvc2VBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGxldCBhYm9ydEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIGlmICh1bmRlcmx5aW5nU2luay5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU2luay5zdGFydCEoY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTaW5rLndyaXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB3cml0ZUFsZ29yaXRobSA9IGNodW5rID0+IHVuZGVybHlpbmdTaW5rLndyaXRlIShjaHVuaywgY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTaW5rLmNsb3NlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjbG9zZUFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTaW5rLmNsb3NlISgpO1xuICB9IGVsc2Uge1xuICAgIGNsb3NlQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nU2luay5hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYWJvcnRBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ1NpbmsuYWJvcnQhKHJlYXNvbik7XG4gIH0gZWxzZSB7XG4gICAgYWJvcnRBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cblxuICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoXG4gICAgc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobVxuICApO1xufVxuXG4vLyBDbGVhckFsZ29yaXRobXMgbWF5IGJlIGNhbGxlZCB0d2ljZS4gRXJyb3JpbmcgdGhlIHNhbWUgc3RyZWFtIGluIG11bHRpcGxlIHdheXMgd2lsbCBvZnRlbiByZXN1bHQgaW4gcmVkdW5kYW50IGNhbGxzLlxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pIHtcbiAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX2Fib3J0QWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlPFc+KGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4pIHtcbiAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2xvc2VTZW50aW5lbCwgMCk7XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldENodW5rU2l6ZTxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogVyk6IG51bWJlciB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG4gIH0gY2F0Y2ggKGNodW5rU2l6ZUUpIHtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBjaHVua1NpemVFKTtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KTogbnVtYmVyIHtcbiAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZTxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBXLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rU2l6ZTogbnVtYmVyKSB7XG4gIHRyeSB7XG4gICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG4gIH0gY2F0Y2ggKGVucXVldWVFKSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgfVxuXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZDxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcblxuICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBhc3NlcnQoc3RhdGUgIT09ICdjbG9zZWQnICYmIHN0YXRlICE9PSAnZXJyb3JlZCcpO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gUGVla1F1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gIGlmICh2YWx1ZSA9PT0gY2xvc2VTZW50aW5lbCkge1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZShjb250cm9sbGVyLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+LCBlcnJvcjogYW55KSB7XG4gIGlmIChjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pikge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cbiAgV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcblxuICBEZXF1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gIGFzc2VydChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApO1xuXG4gIGNvbnN0IHNpbmtDbG9zZVByb21pc2UgPSBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSgpO1xuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICB1cG9uUHJvbWlzZShcbiAgICBzaW5rQ2xvc2VQcm9taXNlLFxuICAgICgpID0+IHtcbiAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZShzdHJlYW0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZWFzb24gPT4ge1xuICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZTxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+LCBjaHVuazogVykge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cbiAgV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuXG4gIGNvbnN0IHNpbmtXcml0ZVByb21pc2UgPSBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobShjaHVuayk7XG4gIHVwb25Qcm9taXNlKFxuICAgIHNpbmtXcml0ZVByb21pc2UsXG4gICAgKCkgPT4ge1xuICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbSk7XG5cbiAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgIGFzc2VydChzdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG5cbiAgICAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcblxuICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgICAgIH1cblxuICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZWFzb24gPT4ge1xuICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KTogYm9vbGVhbiB7XG4gIGNvbnN0IGRlc2lyZWRTaXplID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICByZXR1cm4gZGVzaXJlZFNpemUgPD0gMDtcbn1cblxuLy8gQSBjbGllbnQgb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4sIGVycm9yOiBhbnkpIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKTtcblxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCBlcnJvcik7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbS5cblxuZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtYCk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbn1cblxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLlxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJgKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCAnICsgbmFtZSArICcgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCB3cml0ZXInKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKSB7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3BlbmRpbmcnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzc2VydCh3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKTtcblxuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fY2xvc2VkUHJvbWlzZSk7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QocmVhc29uKTtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3JlamVjdGVkJztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIHJlYXNvbjogYW55KSB7XG4gIGFzc2VydCh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydCh3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSAhPT0gJ3BlbmRpbmcnKTtcblxuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKSB7XG4gIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzc2VydCh3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKTtcblxuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncmVzb2x2ZWQnO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgfSk7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAncGVuZGluZyc7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fcmVhZHlQcm9taXNlKTtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBhc3NlcnQod3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKTtcblxuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBhc3NlcnQod3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKTtcblxuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAnZnVsZmlsbGVkJztcbn1cbiIsICIvLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuXG5mdW5jdGlvbiBnZXRHbG9iYWxzKCk6IHR5cGVvZiBnbG9iYWxUaGlzIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgY29uc3QgZ2xvYmFscyA9IGdldEdsb2JhbHMoKTtcbiIsICIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cIm5vZGVcIiAvPlxuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL2dsb2JhbHMnO1xuaW1wb3J0IHsgc2V0RnVuY3Rpb25OYW1lIH0gZnJvbSAnLi4vbGliL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5cbmludGVyZmFjZSBET01FeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWU6IHN0cmluZztcbiAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG50eXBlIERPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yID0gbmV3IChtZXNzYWdlPzogc3RyaW5nLCBuYW1lPzogc3RyaW5nKSA9PiBET01FeGNlcHRpb247XG5cbmZ1bmN0aW9uIGlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IoY3RvcjogdW5rbm93bik6IGN0b3IgaXMgRE9NRXhjZXB0aW9uQ29uc3RydWN0b3Ige1xuICBpZiAoISh0eXBlb2YgY3RvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY3RvciA9PT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoY3RvciBhcyBET01FeGNlcHRpb25Db25zdHJ1Y3RvcikubmFtZSAhPT0gJ0RPTUV4Y2VwdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBuZXcgKGN0b3IgYXMgRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IpKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFN1cHBvcnQ6XG4gKiAtIFdlYiBicm93c2Vyc1xuICogLSBOb2RlIDE4IGFuZCBoaWdoZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvZTRiMWZiNWU2NDIyYzFmZjE1MTIzNGJiOWRlNzkyZDQ1ZGQ4OGQ4NylcbiAqL1xuZnVuY3Rpb24gZ2V0RnJvbUdsb2JhbCgpOiBET01FeGNlcHRpb25Db25zdHJ1Y3RvciB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGN0b3IgPSBnbG9iYWxzPy5ET01FeGNlcHRpb247XG4gIHJldHVybiBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKGN0b3IpID8gY3RvciA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBTdXBwb3J0OlxuICogLSBBbGwgcGxhdGZvcm1zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvbHlmaWxsKCk6IERPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgY29uc3QgY3RvciA9IGZ1bmN0aW9uIERPTUV4Y2VwdGlvbih0aGlzOiBET01FeGNlcHRpb24sIG1lc3NhZ2U/OiBzdHJpbmcsIG5hbWU/OiBzdHJpbmcpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJ0Vycm9yJztcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgfSBhcyBhbnk7XG4gIHNldEZ1bmN0aW9uTmFtZShjdG9yLCAnRE9NRXhjZXB0aW9uJyk7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIHsgdmFsdWU6IGN0b3IsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIHJldHVybiBjdG9yO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZVxuY29uc3QgRE9NRXhjZXB0aW9uOiBET01FeGNlcHRpb25Db25zdHJ1Y3RvciA9IGdldEZyb21HbG9iYWwoKSB8fCBjcmVhdGVQb2x5ZmlsbCgpO1xuXG5leHBvcnQgeyBET01FeGNlcHRpb24gfTtcbiIsICJpbXBvcnQgeyBJc1JlYWRhYmxlU3RyZWFtLCBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkLCBSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGVTdHJlYW1DYW5jZWwgfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciwgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCB9IGZyb20gJy4vZGVmYXVsdC1yZWFkZXInO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSB9IGZyb20gJy4vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IHtcbiAgQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcixcbiAgSXNXcml0YWJsZVN0cmVhbSxcbiAgSXNXcml0YWJsZVN0cmVhbUxvY2tlZCxcbiAgV3JpdGFibGVTdHJlYW0sXG4gIFdyaXRhYmxlU3RyZWFtQWJvcnQsXG4gIFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0LFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uLFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlLFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZVxufSBmcm9tICcuLi93cml0YWJsZS1zdHJlYW0nO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQge1xuICBuZXdQcm9taXNlLFxuICBQZXJmb3JtUHJvbWlzZVRoZW4sXG4gIHByb21pc2VSZXNvbHZlZFdpdGgsXG4gIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUsXG4gIHVwb25GdWxmaWxsbWVudCxcbiAgdXBvblByb21pc2UsXG4gIHVwb25SZWplY3Rpb25cbn0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IHR5cGUgQWJvcnRTaWduYWwsIGlzQWJvcnRTaWduYWwgfSBmcm9tICcuLi9hYm9ydC1zaWduYWwnO1xuaW1wb3J0IHsgRE9NRXhjZXB0aW9uIH0gZnJvbSAnLi4vLi4vc3R1Yi9kb20tZXhjZXB0aW9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUGlwZVRvPFQ+KHNvdXJjZTogUmVhZGFibGVTdHJlYW08VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdDogV3JpdGFibGVTdHJlYW08VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudENsb3NlOiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRBYm9ydDogYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50Q2FuY2VsOiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwgfCB1bmRlZmluZWQpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbShzb3VyY2UpKTtcbiAgYXNzZXJ0KElzV3JpdGFibGVTdHJlYW0oZGVzdCkpO1xuICBhc3NlcnQodHlwZW9mIHByZXZlbnRDbG9zZSA9PT0gJ2Jvb2xlYW4nKTtcbiAgYXNzZXJ0KHR5cGVvZiBwcmV2ZW50QWJvcnQgPT09ICdib29sZWFuJyk7XG4gIGFzc2VydCh0eXBlb2YgcHJldmVudENhbmNlbCA9PT0gJ2Jvb2xlYW4nKTtcbiAgYXNzZXJ0KHNpZ25hbCA9PT0gdW5kZWZpbmVkIHx8IGlzQWJvcnRTaWduYWwoc2lnbmFsKSk7XG4gIGFzc2VydCghSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzb3VyY2UpKTtcbiAgYXNzZXJ0KCFJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKGRlc3QpKTtcblxuICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFQ+KHNvdXJjZSk7XG4gIGNvbnN0IHdyaXRlciA9IEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8VD4oZGVzdCk7XG5cbiAgc291cmNlLl9kaXN0dXJiZWQgPSB0cnVlO1xuXG4gIGxldCBzaHV0dGluZ0Rvd24gPSBmYWxzZTtcblxuICAvLyBUaGlzIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgc3BlYydzIHJlcXVpcmVtZW50IHRoYXQgd2Ugd2FpdCBmb3Igb25nb2luZyB3cml0ZXMgZHVyaW5nIHNodXRkb3duLlxuICBsZXQgY3VycmVudFdyaXRlID0gcHJvbWlzZVJlc29sdmVkV2l0aDx2b2lkPih1bmRlZmluZWQpO1xuXG4gIHJldHVybiBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgYWJvcnRBbGdvcml0aG06ICgpID0+IHZvaWQ7XG4gICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhYm9ydEFsZ29yaXRobSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBzaWduYWwucmVhc29uICE9PSB1bmRlZmluZWQgPyBzaWduYWwucmVhc29uIDogbmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJyk7XG4gICAgICAgIGNvbnN0IGFjdGlvbnM6IEFycmF5PCgpID0+IFByb21pc2U8dm9pZD4+ID0gW107XG4gICAgICAgIGlmICghcHJldmVudEFib3J0KSB7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChkZXN0LCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgICAgIGFjdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc291cmNlLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBQcm9taXNlLmFsbChhY3Rpb25zLm1hcChhY3Rpb24gPT4gYWN0aW9uKCkpKSwgdHJ1ZSwgZXJyb3IpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFib3J0QWxnb3JpdGhtKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbGdvcml0aG0pO1xuICAgIH1cblxuICAgIC8vIFVzaW5nIHJlYWRlciBhbmQgd3JpdGVyLCByZWFkIGFsbCBjaHVua3MgZnJvbSB0aGlzIGFuZCB3cml0ZSB0aGVtIHRvIGRlc3RcbiAgICAvLyAtIEJhY2twcmVzc3VyZSBtdXN0IGJlIGVuZm9yY2VkXG4gICAgLy8gLSBTaHV0ZG93biBtdXN0IHN0b3AgYWxsIGFjdGl2aXR5XG4gICAgZnVuY3Rpb24gcGlwZUxvb3AoKSB7XG4gICAgICByZXR1cm4gbmV3UHJvbWlzZTx2b2lkPigocmVzb2x2ZUxvb3AsIHJlamVjdExvb3ApID0+IHtcbiAgICAgICAgZnVuY3Rpb24gbmV4dChkb25lOiBib29sZWFuKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmVMb29wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVzZSBgUGVyZm9ybVByb21pc2VUaGVuYCBpbnN0ZWFkIG9mIGB1cG9uUHJvbWlzZWAgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIGFkZGluZyB1bm5lY2Vzc2FyeSBgLmNhdGNoKHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbilgIGhhbmRsZXJzXG4gICAgICAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4ocGlwZVN0ZXAoKSwgbmV4dCwgcmVqZWN0TG9vcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwaXBlU3RlcCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4od3JpdGVyLl9yZWFkeVByb21pc2UsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ld1Byb21pc2U8Ym9vbGVhbj4oKHJlc29sdmVSZWFkLCByZWplY3RSZWFkKSA9PiB7XG4gICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V3JpdGUgPSBQZXJmb3JtUHJvbWlzZVRoZW4oV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUod3JpdGVyLCBjaHVuayksIHVuZGVmaW5lZCwgbm9vcCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVJlYWQoZmFsc2UpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVJlYWQodHJ1ZSksXG4gICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiByZWplY3RSZWFkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcbiAgICBpc09yQmVjb21lc0Vycm9yZWQoc291cmNlLCByZWFkZXIuX2Nsb3NlZFByb21pc2UsIHN0b3JlZEVycm9yID0+IHtcbiAgICAgIGlmICghcHJldmVudEFib3J0KSB7XG4gICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG5cbiAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGJhY2t3YXJkXG4gICAgaXNPckJlY29tZXNFcnJvcmVkKGRlc3QsIHdyaXRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xuICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG5cbiAgICAvLyBDbG9zaW5nIG11c3QgYmUgcHJvcGFnYXRlZCBmb3J3YXJkXG4gICAgaXNPckJlY29tZXNDbG9zZWQoc291cmNlLCByZWFkZXIuX2Nsb3NlZFByb21pc2UsICgpID0+IHtcbiAgICAgIGlmICghcHJldmVudENsb3NlKSB7XG4gICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uKHdyaXRlcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2h1dGRvd24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuXG4gICAgLy8gQ2xvc2luZyBtdXN0IGJlIHByb3BhZ2F0ZWQgYmFja3dhcmRcbiAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkgfHwgZGVzdC5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICBjb25zdCBkZXN0Q2xvc2VkID0gbmV3IFR5cGVFcnJvcigndGhlIGRlc3RpbmF0aW9uIHdyaXRhYmxlIHN0cmVhbSBjbG9zZWQgYmVmb3JlIGFsbCBkYXRhIGNvdWxkIGJlIHBpcGVkIHRvIGl0Jyk7XG5cbiAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBkZXN0Q2xvc2VkKSwgdHJ1ZSwgZGVzdENsb3NlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaHV0ZG93bih0cnVlLCBkZXN0Q2xvc2VkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHBpcGVMb29wKCkpO1xuXG4gICAgZnVuY3Rpb24gd2FpdEZvcldyaXRlc1RvRmluaXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgLy8gQW5vdGhlciB3cml0ZSBtYXkgaGF2ZSBzdGFydGVkIHdoaWxlIHdlIHdlcmUgd2FpdGluZyBvbiB0aGlzIGN1cnJlbnRXcml0ZSwgc28gd2UgaGF2ZSB0byBiZSBzdXJlIHRvIHdhaXRcbiAgICAgIC8vIGZvciB0aGF0IHRvby5cbiAgICAgIGNvbnN0IG9sZEN1cnJlbnRXcml0ZSA9IGN1cnJlbnRXcml0ZTtcbiAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4oXG4gICAgICAgIGN1cnJlbnRXcml0ZSxcbiAgICAgICAgKCkgPT4gb2xkQ3VycmVudFdyaXRlICE9PSBjdXJyZW50V3JpdGUgPyB3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSA6IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09yQmVjb21lc0Vycm9yZWQoc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSB8IFdyaXRhYmxlU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IChyZWFzb246IGFueSkgPT4gbnVsbCkge1xuICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICBhY3Rpb24oc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cG9uUmVqZWN0aW9uKHByb21pc2UsIGFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPckJlY29tZXNDbG9zZWQoc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSB8IFdyaXRhYmxlU3RyZWFtLCBwcm9taXNlOiBQcm9taXNlPHZvaWQ+LCBhY3Rpb246ICgpID0+IG51bGwpIHtcbiAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICBhY3Rpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwb25GdWxmaWxsbWVudChwcm9taXNlLCBhY3Rpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNodXRkb3duV2l0aEFjdGlvbihhY3Rpb246ICgpID0+IFByb21pc2U8dW5rbm93bj4sIG9yaWdpbmFsSXNFcnJvcj86IGJvb2xlYW4sIG9yaWdpbmFsRXJyb3I/OiBhbnkpIHtcbiAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcblxuICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmICFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSkge1xuICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksIGRvVGhlUmVzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb1RoZVJlc3QoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZG9UaGVSZXN0KCk6IG51bGwge1xuICAgICAgICB1cG9uUHJvbWlzZShcbiAgICAgICAgICBhY3Rpb24oKSxcbiAgICAgICAgICAoKSA9PiBmaW5hbGl6ZShvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpLFxuICAgICAgICAgIG5ld0Vycm9yID0+IGZpbmFsaXplKHRydWUsIG5ld0Vycm9yKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaHV0ZG93bihpc0Vycm9yPzogYm9vbGVhbiwgZXJyb3I/OiBhbnkpIHtcbiAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcblxuICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmICFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSkge1xuICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksICgpID0+IGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluYWxpemUoaXNFcnJvcj86IGJvb2xlYW4sIGVycm9yPzogYW55KTogbnVsbCB7XG4gICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHdyaXRlcik7XG4gICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cbiAgICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFsZ29yaXRobSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0pO1xufVxuIiwgImltcG9ydCB0eXBlIHsgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IERlcXVldWVWYWx1ZSwgRW5xdWV1ZVZhbHVlV2l0aFNpemUsIHR5cGUgUXVldWVQYWlyLCBSZXNldFF1ZXVlIH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL3F1ZXVlLXdpdGgtc2l6ZXMnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdCxcbiAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3QsXG4gIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzLFxuICB0eXBlIFJlYWRSZXF1ZXN0XG59IGZyb20gJy4vZGVmYXVsdC1yZWFkZXInO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCwgUmVhZGFibGVTdHJlYW0sIFJlYWRhYmxlU3RyZWFtQ2xvc2UsIFJlYWRhYmxlU3RyZWFtRXJyb3IgfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHR5cGUgeyBWYWxpZGF0ZWRVbmRlcmx5aW5nU291cmNlIH0gZnJvbSAnLi91bmRlcmx5aW5nLXNvdXJjZSc7XG5pbXBvcnQgeyBzZXRGdW5jdGlvbk5hbWUsIHR5cGVJc09iamVjdCB9IGZyb20gJy4uL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBDYW5jZWxTdGVwcywgUHVsbFN0ZXBzLCBSZWxlYXNlU3RlcHMgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBwcm9taXNlUmVzb2x2ZWRXaXRoLCB1cG9uUHJvbWlzZSB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcblxuLyoqXG4gKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSE6IFJlYWRhYmxlU3RyZWFtPFI+O1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZSE6IFNpbXBsZVF1ZXVlPFF1ZXVlUGFpcjxSPj47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3F1ZXVlVG90YWxTaXplITogbnVtYmVyO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdGFydGVkITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VSZXF1ZXN0ZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9wdWxsQWdhaW4hOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9wdWxsaW5nICE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSE6IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxSPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RyYXRlZ3lIV00hOiBudW1iZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3B1bGxBbGdvcml0aG0hOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jYW5jZWxBbGdvcml0aG0hOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD47XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIGNvbnRyb2xsZWQgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzXG4gICAqIG92ZXItZnVsbC4gQW4gdW5kZXJseWluZyBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG4gICAqL1xuICBnZXQgZGVzaXJlZFNpemUoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuICAgKiB0aGUgc3RyZWFtLCBidXQgb25jZSB0aG9zZSBhcmUgcmVhZCwgdGhlIHN0cmVhbSB3aWxsIGJlY29tZSBjbG9zZWQuXG4gICAqL1xuICBjbG9zZSgpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpO1xuICAgIH1cblxuICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBjbG9zZScpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2h1bmsgYGNodW5rYCBpbiB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uXG4gICAqL1xuICBlbnF1ZXVlKGNodW5rOiBSKTogdm9pZDtcbiAgZW5xdWV1ZShjaHVuazogUiA9IHVuZGVmaW5lZCEpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlbnF1ZXVlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuICAgKi9cbiAgZXJyb3IoZTogYW55ID0gdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtDYW5jZWxTdGVwc10ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBSZXNldFF1ZXVlKHRoaXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW1B1bGxTdGVwc10ocmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+KTogdm9pZCB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gRGVxdWV1ZVZhbHVlKHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQgJiYgdGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtSZWxlYXNlU3RlcHNdKCk6IHZvaWQge1xuICAgIC8vIERvIG5vdGhpbmcuXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmNsb3NlLCAnY2xvc2UnKTtcbnNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5lbnF1ZXVlLCAnZW5xdWV1ZScpO1xuc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmVycm9yLCAnZXJyb3InKTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cblxuZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFIgPSBhbnk+KHg6IGFueSk6IHggaXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPiB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkUmVhZGFibGVTdHJlYW0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KTogdm9pZCB7XG4gIGNvbnN0IHNob3VsZFB1bGwgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcik7XG4gIGlmICghc2hvdWxkUHVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250cm9sbGVyLl9wdWxsaW5nKSB7XG4gICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICBhc3NlcnQoIWNvbnRyb2xsZXIuX3B1bGxBZ2Fpbik7XG5cbiAgY29udHJvbGxlci5fcHVsbGluZyA9IHRydWU7XG5cbiAgY29uc3QgcHVsbFByb21pc2UgPSBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtKCk7XG4gIHVwb25Qcm9taXNlKFxuICAgIHB1bGxQcm9taXNlLFxuICAgICgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxBZ2Fpbikge1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZSA9PiB7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pOiBib29sZWFuIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXG4gIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFjb250cm9sbGVyLl9zdGFydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgZGVzaXJlZFNpemUgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG4gIGFzc2VydChkZXNpcmVkU2l6ZSAhPT0gbnVsbCk7XG4gIGlmIChkZXNpcmVkU2l6ZSEgPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KSB7XG4gIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xufVxuXG4vLyBBIGNsaWVudCBvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pIHtcbiAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cbiAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuXG4gIGlmIChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWU8Uj4oXG4gIGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4sXG4gIGNodW5rOiBSXG4pOiB2b2lkIHtcbiAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cbiAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgY2h1bmtTaXplO1xuICAgIHRyeSB7XG4gICAgICBjaHVua1NpemUgPSBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0oY2h1bmspO1xuICAgIH0gY2F0Y2ggKGNodW5rU2l6ZUUpIHtcbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBjaHVua1NpemVFKTtcbiAgICAgIHRocm93IGNodW5rU2l6ZUU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICAgIH0gY2F0Y2ggKGVucXVldWVFKSB7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuICAgICAgdGhyb3cgZW5xdWV1ZUU7XG4gICAgfVxuICB9XG5cbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+LCBlOiBhbnkpIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcblxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICBSZWFkYWJsZVN0cmVhbUVycm9yKHN0cmVhbSwgZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoXG4gIGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PlxuKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgaW4gdGhlIGltcGxlbWVudGF0aW9uIG9mIFRyYW5zZm9ybVN0cmVhbS5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlKFxuICBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT5cbik6IGJvb2xlYW4ge1xuICBpZiAoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoXG4gIGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PlxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoIWNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkICYmIHN0YXRlID09PSAncmVhZGFibGUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFI+KSB7XG4gIGFzc2VydChzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKTtcblxuICBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0gPSBzdHJlYW07XG5cbiAgY29udHJvbGxlci5fcXVldWUgPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZCE7XG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cbiAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHNpemVBbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcblxuICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gcHVsbEFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gY2FuY2VsQWxnb3JpdGhtO1xuXG4gIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gIHVwb25Qcm9taXNlKFxuICAgIHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpLFxuICAgICgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICBhc3NlcnQoIWNvbnRyb2xsZXIuX3B1bGxpbmcpO1xuICAgICAgYXNzZXJ0KCFjb250cm9sbGVyLl9wdWxsQWdhaW4pO1xuXG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgciA9PiB7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZTxSPihcbiAgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPixcbiAgdW5kZXJseWluZ1NvdXJjZTogVmFsaWRhdGVkVW5kZXJseWluZ1NvdXJjZTxSPixcbiAgaGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICBzaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Uj5cbikge1xuICBjb25zdCBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cbiAgbGV0IHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD47XG4gIGxldCBwdWxsQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBsZXQgY2FuY2VsQWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD47XG5cbiAgaWYgKHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NvdXJjZS5zdGFydCEoY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTb3VyY2UucHVsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTb3VyY2UucHVsbCEoY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuICBpZiAodW5kZXJseWluZ1NvdXJjZS5jYW5jZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGNhbmNlbEFsZ29yaXRobSA9IHJlYXNvbiA9PiB1bmRlcmx5aW5nU291cmNlLmNhbmNlbCEocmVhc29uKTtcbiAgfSBlbHNlIHtcbiAgICBjYW5jZWxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cblxuICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoXG4gICAgc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtXG4gICk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbn1cbiIsICJpbXBvcnQge1xuICBDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIENyZWF0ZVJlYWRhYmxlU3RyZWFtLFxuICB0eXBlIERlZmF1bHRSZWFkYWJsZVN0cmVhbSxcbiAgSXNSZWFkYWJsZVN0cmVhbSxcbiAgdHlwZSBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIFJlYWRhYmxlU3RyZWFtLFxuICBSZWFkYWJsZVN0cmVhbUNhbmNlbCxcbiAgdHlwZSBSZWFkYWJsZVN0cmVhbVJlYWRlclxufSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSB9IGZyb20gJy4vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IHtcbiAgQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQsXG4gIHR5cGUgUmVhZFJlcXVlc3Rcbn0gZnJvbSAnLi9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQge1xuICBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFxuICBJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZCxcbiAgdHlwZSBSZWFkSW50b1JlcXVlc3Rcbn0gZnJvbSAnLi9ieW9iLXJlYWRlcic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IG5ld1Byb21pc2UsIHByb21pc2VSZXNvbHZlZFdpdGgsIHF1ZXVlTWljcm90YXNrLCB1cG9uUmVqZWN0aW9uIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yXG59IGZyb20gJy4vZGVmYXVsdC1jb250cm9sbGVyJztcbmltcG9ydCB7XG4gIElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZSxcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3XG59IGZyb20gJy4vYnl0ZS1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgeyBDcmVhdGVBcnJheUZyb21MaXN0IH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL2VjbWFzY3JpcHQnO1xuaW1wb3J0IHsgQ2xvbmVBc1VpbnQ4QXJyYXkgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgdHlwZSB7IE5vblNoYXJlZCB9IGZyb20gJy4uL2hlbHBlcnMvYXJyYXktYnVmZmVyLXZpZXcnO1xuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1UZWU8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZUZvckJyYW5jaDI6IGJvb2xlYW4pOiBbUmVhZGFibGVTdHJlYW08Uj4sIFJlYWRhYmxlU3RyZWFtPFI+XSB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICBhc3NlcnQodHlwZW9mIGNsb25lRm9yQnJhbmNoMiA9PT0gJ2Jvb2xlYW4nKTtcbiAgaWYgKElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpIHtcbiAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbSBhcyB1bmtub3duIGFzIFJlYWRhYmxlQnl0ZVN0cmVhbSkgYXNcbiAgICAgIHVua25vd24gYXMgW1JlYWRhYmxlU3RyZWFtPFI+LCBSZWFkYWJsZVN0cmVhbTxSPl07XG4gIH1cbiAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZShzdHJlYW0sIGNsb25lRm9yQnJhbmNoMik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWU8Uj4oXG4gIHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sXG4gIGNsb25lRm9yQnJhbmNoMjogYm9vbGVhblxuKTogW0RlZmF1bHRSZWFkYWJsZVN0cmVhbTxSPiwgRGVmYXVsdFJlYWRhYmxlU3RyZWFtPFI+XSB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICBhc3NlcnQodHlwZW9mIGNsb25lRm9yQnJhbmNoMiA9PT0gJ2Jvb2xlYW4nKTtcblxuICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KHN0cmVhbSk7XG5cbiAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgbGV0IHJlYWRBZ2FpbiA9IGZhbHNlO1xuICBsZXQgY2FuY2VsZWQxID0gZmFsc2U7XG4gIGxldCBjYW5jZWxlZDIgPSBmYWxzZTtcbiAgbGV0IHJlYXNvbjE6IGFueTtcbiAgbGV0IHJlYXNvbjI6IGFueTtcbiAgbGV0IGJyYW5jaDE6IERlZmF1bHRSZWFkYWJsZVN0cmVhbTxSPjtcbiAgbGV0IGJyYW5jaDI6IERlZmF1bHRSZWFkYWJsZVN0cmVhbTxSPjtcblxuICBsZXQgcmVzb2x2ZUNhbmNlbFByb21pc2U6ICh2YWx1ZTogdW5kZWZpbmVkIHwgUHJvbWlzZTx1bmRlZmluZWQ+KSA9PiB2b2lkO1xuICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZTx1bmRlZmluZWQ+KHJlc29sdmUgPT4ge1xuICAgIHJlc29sdmVDYW5jZWxQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAocmVhZGluZykge1xuICAgICAgcmVhZEFnYWluID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmVhZGluZyA9IHRydWU7XG5cbiAgICBjb25zdCByZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8Uj4gPSB7XG4gICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuICAgICAgICAvLyByZWFkZXIuX2Nsb3NlZFByb21pc2UgYmVsb3cpLCBhbmQgd2Ugd2FudCBlcnJvcnMgaW4gc3RyZWFtIHRvIGVycm9yIGJvdGggYnJhbmNoZXMgaW1tZWRpYXRlbHkuIFdlIGNhbm5vdCBsZXRcbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgIHJlYWRBZ2FpbiA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGNodW5rMSA9IGNodW5rO1xuICAgICAgICAgIGNvbnN0IGNodW5rMiA9IGNodW5rO1xuXG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGFjY2VzcyB0aGUgY2xvbmluZyBjb2RlIHJpZ2h0IG5vdyBpbiB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIC8vIElmIHdlIGFkZCBvbmUgdGhlbiB3ZSdsbCBuZWVkIGFuIGltcGxlbWVudGF0aW9uIGZvciBzZXJpYWxpemFibGUgb2JqZWN0cy5cbiAgICAgICAgICAvLyBpZiAoIWNhbmNlbGVkMiAmJiBjbG9uZUZvckJyYW5jaDIpIHtcbiAgICAgICAgICAvLyAgIGNodW5rMiA9IFN0cnVjdHVyZWREZXNlcmlhbGl6ZShTdHJ1Y3R1cmVkU2VyaWFsaXplKGNodW5rMikpO1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChyZWFkQWdhaW4pIHtcbiAgICAgICAgICAgIHB1bGxBbGdvcml0aG0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG4gICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xuXG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjYW5jZWxlZDEgPSB0cnVlO1xuICAgIHJlYXNvbjEgPSByZWFzb247XG4gICAgaWYgKGNhbmNlbGVkMikge1xuICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwyQWxnb3JpdGhtKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY2FuY2VsZWQyID0gdHJ1ZTtcbiAgICByZWFzb24yID0gcmVhc29uO1xuICAgIGlmIChjYW5jZWxlZDEpIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwxQWxnb3JpdGhtKTtcbiAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwyQWxnb3JpdGhtKTtcblxuICB1cG9uUmVqZWN0aW9uKHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgKHI6IGFueSkgPT4ge1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcblxuICByZXR1cm4gW2JyYW5jaDEsIGJyYW5jaDJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtKTogW1JlYWRhYmxlQnl0ZVN0cmVhbSwgUmVhZGFibGVCeXRlU3RyZWFtXSB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICBhc3NlcnQoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSk7XG5cbiAgbGV0IHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8Tm9uU2hhcmVkPFVpbnQ4QXJyYXk+PiA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgbGV0IHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcbiAgbGV0IHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcbiAgbGV0IGNhbmNlbGVkMSA9IGZhbHNlO1xuICBsZXQgY2FuY2VsZWQyID0gZmFsc2U7XG4gIGxldCByZWFzb24xOiBhbnk7XG4gIGxldCByZWFzb24yOiBhbnk7XG4gIGxldCBicmFuY2gxOiBSZWFkYWJsZUJ5dGVTdHJlYW07XG4gIGxldCBicmFuY2gyOiBSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlOiAodmFsdWU6IHVuZGVmaW5lZCB8IFByb21pc2U8dW5kZWZpbmVkPikgPT4gdm9pZDtcbiAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IG5ld1Byb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgcmVzb2x2ZUNhbmNlbFByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICBmdW5jdGlvbiBmb3J3YXJkUmVhZGVyRXJyb3IodGhpc1JlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8Tm9uU2hhcmVkPFVpbnQ4QXJyYXk+Pikge1xuICAgIHVwb25SZWplY3Rpb24odGhpc1JlYWRlci5fY2xvc2VkUHJvbWlzZSwgciA9PiB7XG4gICAgICBpZiAodGhpc1JlYWRlciAhPT0gcmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCkge1xuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihyZWFkZXIpKSB7XG4gICAgICBhc3NlcnQocmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aCA9PT0gMCk7XG4gICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cbiAgICAgIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgICAgIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRSZXF1ZXN0OiBSZWFkUmVxdWVzdDxOb25TaGFyZWQ8VWludDhBcnJheT4+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG4gICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgY2h1bmsxID0gY2h1bms7XG4gICAgICAgICAgbGV0IGNodW5rMiA9IGNodW5rO1xuICAgICAgICAgIGlmICghY2FuY2VsZWQxICYmICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNodW5rMiA9IENsb25lQXNVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGNsb25lRSkge1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNsb25lRSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDEpIHtcbiAgICAgICAgICAgIHB1bGwxQWxnb3JpdGhtKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gyKSB7XG4gICAgICAgICAgICBwdWxsMkFsZ29yaXRobSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1bGxXaXRoQllPQlJlYWRlcih2aWV3OiBOb25TaGFyZWQ8QXJyYXlCdWZmZXJWaWV3PiwgZm9yQnJhbmNoMjogYm9vbGVhbikge1xuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxOb25TaGFyZWQ8VWludDhBcnJheT4+KHJlYWRlcikpIHtcbiAgICAgIGFzc2VydChyZWFkZXIuX3JlYWRSZXF1ZXN0cy5sZW5ndGggPT09IDApO1xuICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXG4gICAgICByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSk7XG4gICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBieW9iQnJhbmNoID0gZm9yQnJhbmNoMiA/IGJyYW5jaDIgOiBicmFuY2gxO1xuICAgIGNvbnN0IG90aGVyQnJhbmNoID0gZm9yQnJhbmNoMiA/IGJyYW5jaDEgOiBicmFuY2gyO1xuXG4gICAgY29uc3QgcmVhZEludG9SZXF1ZXN0OiBSZWFkSW50b1JlcXVlc3Q8Tm9uU2hhcmVkPEFycmF5QnVmZmVyVmlldz4+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG4gICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgYnlvYkNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMiA6IGNhbmNlbGVkMTtcbiAgICAgICAgICBjb25zdCBvdGhlckNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMSA6IGNhbmNlbGVkMjtcblxuICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCkge1xuICAgICAgICAgICAgbGV0IGNsb25lZENodW5rO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2xvbmVkQ2h1bmsgPSBDbG9uZUFzVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgICB9IGNhdGNoIChjbG9uZUUpIHtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY2xvbmVFKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZWRDaHVuayk7XG4gICAgICAgICAgfSBlbHNlIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xuICAgICAgICAgICAgcHVsbDFBbGdvcml0aG0oKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDIpIHtcbiAgICAgICAgICAgIHB1bGwyQWxnb3JpdGhtKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBfY2xvc2VTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgYnlvYkNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMiA6IGNhbmNlbGVkMTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XG5cbiAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQpIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2Uob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFzc2VydChjaHVuay5ieXRlTGVuZ3RoID09PSAwKTtcblxuICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQgJiYgb3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCB8fCAhb3RoZXJDYW5jZWxlZCkge1xuICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHJlYWRlciwgdmlldywgMSwgcmVhZEludG9SZXF1ZXN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1bGwxQWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmVhZGluZyA9IHRydWU7XG5cbiAgICBjb25zdCBieW9iUmVxdWVzdCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIGlmIChieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldyEsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVsbDJBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZWFkaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0IGJ5b2JSZXF1ZXN0ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgaWYgKGJ5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVsbFdpdGhCWU9CUmVhZGVyKGJ5b2JSZXF1ZXN0Ll92aWV3ISwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjYW5jZWxlZDEgPSB0cnVlO1xuICAgIHJlYXNvbjEgPSByZWFzb247XG4gICAgaWYgKGNhbmNlbGVkMikge1xuICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwyQWxnb3JpdGhtKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY2FuY2VsZWQyID0gdHJ1ZTtcbiAgICByZWFzb24yID0gcmVhc29uO1xuICAgIGlmIChjYW5jZWxlZDEpIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKTogdm9pZCB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDFBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsMkFsZ29yaXRobSwgY2FuY2VsMkFsZ29yaXRobSk7XG5cbiAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG5cbiAgcmV0dXJuIFticmFuY2gxLCBicmFuY2gyXTtcbn1cbiIsICJpbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHR5cGUgeyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0IH0gZnJvbSAnLi9kZWZhdWx0LXJlYWRlcic7XG5cbi8qKlxuICogQSBjb21tb24gaW50ZXJmYWNlIGZvciBhIGBSZWFkYWRhYmxlU3RyZWFtYCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVhZGFibGVTdHJlYW1MaWtlPFIgPSBhbnk+IHtcbiAgcmVhZG9ubHkgbG9ja2VkOiBib29sZWFuO1xuXG4gIGdldFJlYWRlcigpOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJMaWtlPFI+O1xufVxuXG4vKipcbiAqIEEgY29tbW9uIGludGVyZmFjZSBmb3IgYSBgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyYCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyTGlrZTxSID0gYW55PiB7XG4gIHJlYWRvbmx5IGNsb3NlZDogUHJvbWlzZTx1bmRlZmluZWQ+O1xuXG4gIGNhbmNlbChyZWFzb24/OiBhbnkpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIHJlYWQoKTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+PjtcblxuICByZWxlYXNlTG9jaygpOiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbUxpa2U8Uj4oc3RyZWFtOiB1bmtub3duKTogc3RyZWFtIGlzIFJlYWRhYmxlU3RyZWFtTGlrZTxSPiB7XG4gIHJldHVybiB0eXBlSXNPYmplY3Qoc3RyZWFtKSAmJiB0eXBlb2YgKHN0cmVhbSBhcyBSZWFkYWJsZVN0cmVhbUxpa2U8Uj4pLmdldFJlYWRlciAhPT0gJ3VuZGVmaW5lZCc7XG59XG4iLCAiaW1wb3J0IHsgQ3JlYXRlUmVhZGFibGVTdHJlYW0sIHR5cGUgRGVmYXVsdFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7XG4gIGlzUmVhZGFibGVTdHJlYW1MaWtlLFxuICB0eXBlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlckxpa2UsXG4gIHR5cGUgUmVhZGFibGVTdHJlYW1MaWtlXG59IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtLWxpa2UnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlLCBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSB9IGZyb20gJy4vZGVmYXVsdC1jb250cm9sbGVyJztcbmltcG9ydCB7IEdldEl0ZXJhdG9yLCBHZXRNZXRob2QsIEl0ZXJhdG9yQ29tcGxldGUsIEl0ZXJhdG9yTmV4dCwgSXRlcmF0b3JWYWx1ZSB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9lY21hc2NyaXB0JztcbmltcG9ydCB7IHByb21pc2VSZWplY3RlZFdpdGgsIHByb21pc2VSZXNvbHZlZFdpdGgsIHJlZmxlY3RDYWxsLCB0cmFuc2Zvcm1Qcm9taXNlV2l0aCB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4uL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tPFI+KFxuICBzb3VyY2U6IEl0ZXJhYmxlPFI+IHwgQXN5bmNJdGVyYWJsZTxSPiB8IFJlYWRhYmxlU3RyZWFtTGlrZTxSPlxuKTogRGVmYXVsdFJlYWRhYmxlU3RyZWFtPFI+IHtcbiAgaWYgKGlzUmVhZGFibGVTdHJlYW1MaWtlKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1Gcm9tRGVmYXVsdFJlYWRlcihzb3VyY2UuZ2V0UmVhZGVyKCkpO1xuICB9XG4gIHJldHVybiBSZWFkYWJsZVN0cmVhbUZyb21JdGVyYWJsZShzb3VyY2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tSXRlcmFibGU8Uj4oYXN5bmNJdGVyYWJsZTogSXRlcmFibGU8Uj4gfCBBc3luY0l0ZXJhYmxlPFI+KTogRGVmYXVsdFJlYWRhYmxlU3RyZWFtPFI+IHtcbiAgbGV0IHN0cmVhbTogRGVmYXVsdFJlYWRhYmxlU3RyZWFtPFI+O1xuICBjb25zdCBpdGVyYXRvclJlY29yZCA9IEdldEl0ZXJhdG9yKGFzeW5jSXRlcmFibGUsICdhc3luYycpO1xuXG4gIGNvbnN0IHN0YXJ0QWxnb3JpdGhtID0gbm9vcDtcblxuICBmdW5jdGlvbiBwdWxsQWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBuZXh0UmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBuZXh0UmVzdWx0ID0gSXRlcmF0b3JOZXh0KGl0ZXJhdG9yUmVjb3JkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChlKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKG5leHRSZXN1bHQpO1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChuZXh0UHJvbWlzZSwgaXRlclJlc3VsdCA9PiB7XG4gICAgICBpZiAoIXR5cGVJc09iamVjdChpdGVyUmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgaXRlcmF0b3IubmV4dCgpIG1ldGhvZCBtdXN0IGZ1bGZpbGwgd2l0aCBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRvbmUgPSBJdGVyYXRvckNvbXBsZXRlKGl0ZXJSZXN1bHQpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gSXRlcmF0b3JWYWx1ZShpdGVyUmVzdWx0KTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFsZ29yaXRobShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gaXRlcmF0b3JSZWNvcmQuaXRlcmF0b3I7XG4gICAgbGV0IHJldHVybk1ldGhvZDogKHR5cGVvZiBpdGVyYXRvcilbJ3JldHVybiddIHwgdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm5NZXRob2QgPSBHZXRNZXRob2QoaXRlcmF0b3IsICdyZXR1cm4nKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChlKTtcbiAgICB9XG4gICAgaWYgKHJldHVybk1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBsZXQgcmV0dXJuUmVzdWx0OiBJdGVyYXRvclJlc3VsdDxSPiB8IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8Uj4+O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm5SZXN1bHQgPSByZWZsZWN0Q2FsbChyZXR1cm5NZXRob2QsIGl0ZXJhdG9yLCBbcmVhc29uXSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XG4gICAgfVxuICAgIGNvbnN0IHJldHVyblByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHJldHVyblJlc3VsdCk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHJldHVyblByb21pc2UsIGl0ZXJSZXN1bHQgPT4ge1xuICAgICAgaWYgKCF0eXBlSXNPYmplY3QoaXRlclJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGl0ZXJhdG9yLnJldHVybigpIG1ldGhvZCBtdXN0IGZ1bGZpbGwgd2l0aCBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cblxuICBzdHJlYW0gPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCAwKTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnJvbURlZmF1bHRSZWFkZXI8Uj4oXG4gIHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyTGlrZTxSPlxuKTogRGVmYXVsdFJlYWRhYmxlU3RyZWFtPFI+IHtcbiAgbGV0IHN0cmVhbTogRGVmYXVsdFJlYWRhYmxlU3RyZWFtPFI+O1xuXG4gIGNvbnN0IHN0YXJ0QWxnb3JpdGhtID0gbm9vcDtcblxuICBmdW5jdGlvbiBwdWxsQWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCByZWFkUHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgcmVhZFByb21pc2UgPSByZWFkZXIucmVhZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgocmVhZFByb21pc2UsIHJlYWRSZXN1bHQgPT4ge1xuICAgICAgaWYgKCF0eXBlSXNPYmplY3QocmVhZFJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIHJlYWRlci5yZWFkKCkgbWV0aG9kIG11c3QgZnVsZmlsbCB3aXRoIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWRSZXN1bHQuZG9uZSkge1xuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2Uoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZWFkUmVzdWx0LnZhbHVlO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsQWxnb3JpdGhtKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHJlYWRlci5jYW5jZWwocmVhc29uKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XG4gICAgfVxuICB9XG5cbiAgc3RyZWFtID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgMCk7XG4gIHJldHVybiBzdHJlYW07XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0RnVuY3Rpb24sIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHR5cGUge1xuICBSZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsXG4gIFVuZGVybHlpbmdCeXRlU291cmNlLFxuICBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZSxcbiAgVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2VQdWxsQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZSxcbiAgVW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrLFxuICBWYWxpZGF0ZWRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZVxufSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0vdW5kZXJseWluZy1zb3VyY2UnO1xuaW1wb3J0IHsgcHJvbWlzZUNhbGwsIHJlZmxlY3RDYWxsIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlPFI+KFxuICBzb3VyY2U6IFVuZGVybHlpbmdTb3VyY2U8Uj4gfCBVbmRlcmx5aW5nQnl0ZVNvdXJjZSB8IG51bGwsXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogVmFsaWRhdGVkVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2U8Uj4ge1xuICBhc3NlcnREaWN0aW9uYXJ5KHNvdXJjZSwgY29udGV4dCk7XG4gIGNvbnN0IG9yaWdpbmFsID0gc291cmNlIGFzIChVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZTxSPiB8IG51bGwpO1xuICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSBvcmlnaW5hbD8uYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICBjb25zdCBjYW5jZWwgPSBvcmlnaW5hbD8uY2FuY2VsO1xuICBjb25zdCBwdWxsID0gb3JpZ2luYWw/LnB1bGw7XG4gIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWw/LnN0YXJ0O1xuICBjb25zdCB0eXBlID0gb3JpZ2luYWw/LnR5cGU7XG4gIHJldHVybiB7XG4gICAgYXV0b0FsbG9jYXRlQ2h1bmtTaXplOiBhdXRvQWxsb2NhdGVDaHVua1NpemUgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKFxuICAgICAgICBhdXRvQWxsb2NhdGVDaHVua1NpemUsXG4gICAgICAgIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZScgdGhhdGBcbiAgICAgICksXG4gICAgY2FuY2VsOiBjYW5jZWwgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayhjYW5jZWwsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCksXG4gICAgcHVsbDogcHVsbCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayhwdWxsLCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3B1bGwnIHRoYXRgKSxcbiAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgdHlwZTogdHlwZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSh0eXBlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd0eXBlJyB0aGF0YClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayhcbiAgZm46IFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayxcbiAgb3JpZ2luYWw6IFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlLFxuICBjb250ZXh0OiBzdHJpbmdcbik6IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChyZWFzb246IGFueSkgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbcmVhc29uXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrPFI+KFxuICBmbjogVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2VQdWxsQ2FsbGJhY2s8Uj4sXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZTxSPixcbiAgY29udGV4dDogc3RyaW5nXG4pOiAoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFI+KSA9PiBQcm9taXNlPHZvaWQ+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxSPikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2s8Uj4oXG4gIGZuOiBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZVN0YXJ0Q2FsbGJhY2s8Uj4sXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZTxSPixcbiAgY29udGV4dDogc3RyaW5nXG4pOiBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZVN0YXJ0Q2FsbGJhY2s8Uj4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFI+KSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVR5cGUodHlwZTogc3RyaW5nLCBjb250ZXh0OiBzdHJpbmcpOiAnYnl0ZXMnIHtcbiAgdHlwZSA9IGAke3R5cGV9YDtcbiAgaWYgKHR5cGUgIT09ICdieXRlcycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9ICcke3R5cGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1UeXBlYCk7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHR5cGUge1xuICBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyxcbiAgVmFsaWRhdGVkUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnNcbn0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtL2l0ZXJhdG9yLW9wdGlvbnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhvcHRpb25zOiBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBWYWxpZGF0ZWRSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyB7XG4gIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IHByZXZlbnRDYW5jZWwgPSBvcHRpb25zPy5wcmV2ZW50Q2FuY2VsO1xuICByZXR1cm4geyBwcmV2ZW50Q2FuY2VsOiBCb29sZWFuKHByZXZlbnRDYW5jZWwpIH07XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHR5cGUgeyBTdHJlYW1QaXBlT3B0aW9ucywgVmFsaWRhdGVkU3RyZWFtUGlwZU9wdGlvbnMgfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0vcGlwZS1vcHRpb25zJztcbmltcG9ydCB7IHR5cGUgQWJvcnRTaWduYWwsIGlzQWJvcnRTaWduYWwgfSBmcm9tICcuLi9hYm9ydC1zaWduYWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFBpcGVPcHRpb25zKG9wdGlvbnM6IFN0cmVhbVBpcGVPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogVmFsaWRhdGVkU3RyZWFtUGlwZU9wdGlvbnMge1xuICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuICBjb25zdCBwcmV2ZW50QWJvcnQgPSBvcHRpb25zPy5wcmV2ZW50QWJvcnQ7XG4gIGNvbnN0IHByZXZlbnRDYW5jZWwgPSBvcHRpb25zPy5wcmV2ZW50Q2FuY2VsO1xuICBjb25zdCBwcmV2ZW50Q2xvc2UgPSBvcHRpb25zPy5wcmV2ZW50Q2xvc2U7XG4gIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXJ0QWJvcnRTaWduYWwoc2lnbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzaWduYWwnIHRoYXRgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByZXZlbnRBYm9ydDogQm9vbGVhbihwcmV2ZW50QWJvcnQpLFxuICAgIHByZXZlbnRDYW5jZWw6IEJvb2xlYW4ocHJldmVudENhbmNlbCksXG4gICAgcHJldmVudENsb3NlOiBCb29sZWFuKHByZXZlbnRDbG9zZSksXG4gICAgc2lnbmFsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbDogdW5rbm93biwgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyBzaWduYWwgaXMgQWJvcnRTaWduYWwge1xuICBpZiAoIWlzQWJvcnRTaWduYWwoc2lnbmFsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIEFib3J0U2lnbmFsLmApO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0UmVxdWlyZWRGaWVsZCB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgV3JpdGFibGVTdHJlYW0gfSBmcm9tICcuLi93cml0YWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgYXNzZXJ0UmVhZGFibGVTdHJlYW0gfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBhc3NlcnRXcml0YWJsZVN0cmVhbSB9IGZyb20gJy4vd3JpdGFibGUtc3RyZWFtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcjxSUyBleHRlbmRzIFJlYWRhYmxlU3RyZWFtLCBXUyBleHRlbmRzIFdyaXRhYmxlU3RyZWFtPihcbiAgcGFpcjogeyByZWFkYWJsZTogUlM7IHdyaXRhYmxlOiBXUyB9IHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgY29udGV4dDogc3RyaW5nXG4pOiB7IHJlYWRhYmxlOiBSUzsgd3JpdGFibGU6IFdTIH0ge1xuICBhc3NlcnREaWN0aW9uYXJ5KHBhaXIsIGNvbnRleHQpO1xuXG4gIGNvbnN0IHJlYWRhYmxlID0gcGFpcj8ucmVhZGFibGU7XG4gIGFzc2VydFJlcXVpcmVkRmllbGQocmVhZGFibGUsICdyZWFkYWJsZScsICdSZWFkYWJsZVdyaXRhYmxlUGFpcicpO1xuICBhc3NlcnRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAncmVhZGFibGUnIHRoYXRgKTtcblxuICBjb25zdCB3cml0YWJsZSA9IHBhaXI/LndyaXRhYmxlO1xuICBhc3NlcnRSZXF1aXJlZEZpZWxkKHdyaXRhYmxlLCAnd3JpdGFibGUnLCAnUmVhZGFibGVXcml0YWJsZVBhaXInKTtcbiAgYXNzZXJ0V3JpdGFibGVTdHJlYW0od3JpdGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3dyaXRhYmxlJyB0aGF0YCk7XG5cbiAgcmV0dXJuIHsgcmVhZGFibGUsIHdyaXRhYmxlIH07XG59XG4iLCAiaW1wb3J0IGFzc2VydCBmcm9tICcuLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQge1xuICBwcm9taXNlUmVqZWN0ZWRXaXRoLFxuICBwcm9taXNlUmVzb2x2ZWRXaXRoLFxuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlLFxuICB0cmFuc2Zvcm1Qcm9taXNlV2l0aFxufSBmcm9tICcuL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB0eXBlIHsgUXVldWluZ1N0cmF0ZWd5LCBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2sgfSBmcm9tICcuL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciwgdHlwZSBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9hc3luYy1pdGVyYXRvcic7XG5pbXBvcnQgeyBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdCwgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IHtcbiAgQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyRXJyb3JSZWFkUmVxdWVzdHMsXG4gIHR5cGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdFxufSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQge1xuICBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFxuICBJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJFcnJvclJlYWRJbnRvUmVxdWVzdHMsXG4gIHR5cGUgUmVhZGFibGVTdHJlYW1CWU9CUmVhZFJlc3VsdFxufSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9ieW9iLXJlYWRlcic7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbVBpcGVUbyB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3BpcGUnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1UZWUgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS90ZWUnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1Gcm9tIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vZnJvbSc7XG5pbXBvcnQgeyBJc1dyaXRhYmxlU3RyZWFtLCBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkLCBXcml0YWJsZVN0cmVhbSB9IGZyb20gJy4vd3JpdGFibGUtc3RyZWFtJztcbmltcG9ydCB7IFNpbXBsZVF1ZXVlIH0gZnJvbSAnLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCxcbiAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZVxufSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9ieXRlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIsXG4gIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Vcbn0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vZGVmYXVsdC1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIHtcbiAgVW5kZXJseWluZ0J5dGVTb3VyY2UsXG4gIFVuZGVybHlpbmdCeXRlU291cmNlUHVsbENhbGxiYWNrLFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZVN0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTb3VyY2UsXG4gIFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2tcbn0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vdW5kZXJseWluZy1zb3VyY2UnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHNldEZ1bmN0aW9uTmFtZSwgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgQ3JlYXRlQXJyYXlGcm9tTGlzdCwgU3ltYm9sQXN5bmNJdGVyYXRvciB9IGZyb20gJy4vYWJzdHJhY3Qtb3BzL2VjbWFzY3JpcHQnO1xuaW1wb3J0IHsgQ2FuY2VsU3RlcHMgfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9pbnRlcm5hbC1tZXRob2RzJztcbmltcG9ydCB7IElzTm9uTmVnYXRpdmVOdW1iZXIgfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IGFzc2VydE9iamVjdCwgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCB9IGZyb20gJy4vdmFsaWRhdG9ycy9iYXNpYyc7XG5pbXBvcnQgeyBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5IH0gZnJvbSAnLi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgRXh0cmFjdEhpZ2hXYXRlck1hcmssIEV4dHJhY3RTaXplQWxnb3JpdGhtIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2UgfSBmcm9tICcuL3ZhbGlkYXRvcnMvdW5kZXJseWluZy1zb3VyY2UnO1xuaW1wb3J0IHR5cGUge1xuICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkT3B0aW9ucyxcbiAgUmVhZGFibGVTdHJlYW1HZXRSZWFkZXJPcHRpb25zXG59IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3JlYWRlci1vcHRpb25zJztcbmltcG9ydCB7IGNvbnZlcnRSZWFkZXJPcHRpb25zIH0gZnJvbSAnLi92YWxpZGF0b3JzL3JlYWRlci1vcHRpb25zJztcbmltcG9ydCB0eXBlIHsgU3RyZWFtUGlwZU9wdGlvbnMsIFZhbGlkYXRlZFN0cmVhbVBpcGVPcHRpb25zIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vcGlwZS1vcHRpb25zJztcbmltcG9ydCB0eXBlIHsgUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9pdGVyYXRvci1vcHRpb25zJztcbmltcG9ydCB7IGNvbnZlcnRJdGVyYXRvck9wdGlvbnMgfSBmcm9tICcuL3ZhbGlkYXRvcnMvaXRlcmF0b3Itb3B0aW9ucyc7XG5pbXBvcnQgeyBjb252ZXJ0UGlwZU9wdGlvbnMgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcGlwZS1vcHRpb25zJztcbmltcG9ydCB0eXBlIHsgUmVhZGFibGVXcml0YWJsZVBhaXIgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS13cml0YWJsZS1wYWlyJztcbmltcG9ydCB7IGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpciB9IGZyb20gJy4vdmFsaWRhdG9ycy9yZWFkYWJsZS13cml0YWJsZS1wYWlyJztcbmltcG9ydCB0eXBlIHsgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyTGlrZSwgUmVhZGFibGVTdHJlYW1MaWtlIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtc3RyZWFtLWxpa2UnO1xuaW1wb3J0IHR5cGUgeyBOb25TaGFyZWQgfSBmcm9tICcuL2hlbHBlcnMvYXJyYXktYnVmZmVyLXZpZXcnO1xuXG5leHBvcnQgdHlwZSBEZWZhdWx0UmVhZGFibGVTdHJlYW08UiA9IGFueT4gPSBSZWFkYWJsZVN0cmVhbTxSPiAmIHtcbiAgX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPlxufTtcblxuZXhwb3J0IHR5cGUgUmVhZGFibGVCeXRlU3RyZWFtID0gUmVhZGFibGVTdHJlYW08Tm9uU2hhcmVkPFVpbnQ4QXJyYXk+PiAmIHtcbiAgX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclxufTtcblxudHlwZSBSZWFkYWJsZVN0cmVhbVN0YXRlID0gJ3JlYWRhYmxlJyB8ICdjbG9zZWQnIHwgJ2Vycm9yZWQnO1xuXG4vKipcbiAqIEEgcmVhZGFibGUgc3RyZWFtIHJlcHJlc2VudHMgYSBzb3VyY2Ugb2YgZGF0YSwgZnJvbSB3aGljaCB5b3UgY2FuIHJlYWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW08UiA9IGFueT4gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPFI+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RhdGUhOiBSZWFkYWJsZVN0cmVhbVN0YXRlO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPFI+IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdG9yZWRFcnJvcjogYW55O1xuICAvKiogQGludGVybmFsICovXG4gIF9kaXN0dXJiZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIhOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+IHwgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcblxuICBjb25zdHJ1Y3Rvcih1bmRlcmx5aW5nU291cmNlOiBVbmRlcmx5aW5nQnl0ZVNvdXJjZSwgc3RyYXRlZ3k/OiB7IGhpZ2hXYXRlck1hcms/OiBudW1iZXI7IHNpemU/OiB1bmRlZmluZWQgfSk7XG4gIGNvbnN0cnVjdG9yKHVuZGVybHlpbmdTb3VyY2U/OiBVbmRlcmx5aW5nU291cmNlPFI+LCBzdHJhdGVneT86IFF1ZXVpbmdTdHJhdGVneTxSPik7XG4gIGNvbnN0cnVjdG9yKHJhd1VuZGVybHlpbmdTb3VyY2U6IFVuZGVybHlpbmdTb3VyY2U8Uj4gfCBVbmRlcmx5aW5nQnl0ZVNvdXJjZSB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSxcbiAgICAgICAgICAgICAgcmF3U3RyYXRlZ3k6IFF1ZXVpbmdTdHJhdGVneTxSPiB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSkge1xuICAgIGlmIChyYXdVbmRlcmx5aW5nU291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhd1VuZGVybHlpbmdTb3VyY2UgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnRPYmplY3QocmF3VW5kZXJseWluZ1NvdXJjZSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICBjb25zdCB1bmRlcmx5aW5nU291cmNlID0gY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlKHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbSh0aGlzKTtcblxuICAgIGlmICh1bmRlcmx5aW5nU291cmNlLnR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgIGlmIChzdHJhdGVneS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBzdHJhdGVneSBmb3IgYSBieXRlIHN0cmVhbSBjYW5ub3QgaGF2ZSBhIHNpemUgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMCk7XG4gICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShcbiAgICAgICAgdGhpcyBhcyB1bmtub3duIGFzIFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgICAgICAgdW5kZXJseWluZ1NvdXJjZSxcbiAgICAgICAgaGlnaFdhdGVyTWFya1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHVuZGVybHlpbmdTb3VyY2UudHlwZSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XG4gICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHVuZGVybHlpbmdTb3VyY2UsXG4gICAgICAgIGhpZ2hXYXRlck1hcmssXG4gICAgICAgIHNpemVBbGdvcml0aG1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSByZWFkYWJsZSBzdHJlYW0gaXMgbG9ja2VkIHRvIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciB8IHJlYWRlcn0uXG4gICAqL1xuICBnZXQgbG9ja2VkKCk6IGJvb2xlYW4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignbG9ja2VkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyB0aGUgc3RyZWFtLCBzaWduYWxpbmcgYSBsb3NzIG9mIGludGVyZXN0IGluIHRoZSBzdHJlYW0gYnkgYSBjb25zdW1lci5cbiAgICpcbiAgICogVGhlIHN1cHBsaWVkIGByZWFzb25gIGFyZ3VtZW50IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIHVuZGVybHlpbmcgc291cmNlJ3Mge0BsaW5rIFVuZGVybHlpbmdTb3VyY2UuY2FuY2VsIHwgY2FuY2VsKCl9XG4gICAqIG1ldGhvZCwgd2hpY2ggbWlnaHQgb3IgbWlnaHQgbm90IHVzZSBpdC5cbiAgICovXG4gIGNhbmNlbChyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgIH1cblxuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FuY2VsIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSByZWFkZXInKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJ9IGFuZCBsb2NrcyB0aGUgc3RyZWFtIHRvIHRoZSBuZXcgcmVhZGVyLlxuICAgKlxuICAgKiBUaGlzIGNhbGwgYmVoYXZlcyB0aGUgc2FtZSB3YXkgYXMgdGhlIG5vLWFyZ3VtZW50IHZhcmlhbnQsIGV4Y2VwdCB0aGF0IGl0IG9ubHkgd29ya3Mgb24gcmVhZGFibGUgYnl0ZSBzdHJlYW1zLFxuICAgKiBpLmUuIHN0cmVhbXMgd2hpY2ggd2VyZSBjb25zdHJ1Y3RlZCBzcGVjaWZpY2FsbHkgd2l0aCB0aGUgYWJpbGl0eSB0byBoYW5kbGUgXCJicmluZyB5b3VyIG93biBidWZmZXJcIiByZWFkaW5nLlxuICAgKiBUaGUgcmV0dXJuZWQgQllPQiByZWFkZXIgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gZGlyZWN0bHkgcmVhZCBpbmRpdmlkdWFsIGNodW5rcyBmcm9tIHRoZSBzdHJlYW0gdmlhIGl0c1xuICAgKiB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnJlYWQgfCByZWFkKCl9IG1ldGhvZCwgaW50byBkZXZlbG9wZXItc3VwcGxpZWQgYnVmZmVycywgYWxsb3dpbmcgbW9yZSBwcmVjaXNlXG4gICAqIGNvbnRyb2wgb3ZlciBhbGxvY2F0aW9uLlxuICAgKi9cbiAgZ2V0UmVhZGVyKHsgbW9kZSB9OiB7IG1vZGU6ICdieW9iJyB9KTogUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJ9IGFuZCBsb2NrcyB0aGUgc3RyZWFtIHRvIHRoZSBuZXcgcmVhZGVyLlxuICAgKiBXaGlsZSB0aGUgc3RyZWFtIGlzIGxvY2tlZCwgbm8gb3RoZXIgcmVhZGVyIGNhbiBiZSBhY3F1aXJlZCB1bnRpbCB0aGlzIG9uZSBpcyByZWxlYXNlZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbmFsaXR5IGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBjcmVhdGluZyBhYnN0cmFjdGlvbnMgdGhhdCBkZXNpcmUgdGhlIGFiaWxpdHkgdG8gY29uc3VtZSBhIHN0cmVhbVxuICAgKiBpbiBpdHMgZW50aXJldHkuIEJ5IGdldHRpbmcgYSByZWFkZXIgZm9yIHRoZSBzdHJlYW0sIHlvdSBjYW4gZW5zdXJlIG5vYm9keSBlbHNlIGNhbiBpbnRlcmxlYXZlIHJlYWRzIHdpdGggeW91cnNcbiAgICogb3IgY2FuY2VsIHRoZSBzdHJlYW0sIHdoaWNoIHdvdWxkIGludGVyZmVyZSB3aXRoIHlvdXIgYWJzdHJhY3Rpb24uXG4gICAqL1xuICBnZXRSZWFkZXIoKTogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+O1xuICBnZXRSZWFkZXIoXG4gICAgcmF3T3B0aW9uczogUmVhZGFibGVTdHJlYW1HZXRSZWFkZXJPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICApOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4gfCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignZ2V0UmVhZGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbnZlcnRSZWFkZXJPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIGlmIChvcHRpb25zLm1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0KG9wdGlvbnMubW9kZSA9PT0gJ2J5b2InKTtcbiAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzIGFzIHVua25vd24gYXMgUmVhZGFibGVCeXRlU3RyZWFtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGNvbnZlbmllbnQsIGNoYWluYWJsZSB3YXkgb2YgcGlwaW5nIHRoaXMgcmVhZGFibGUgc3RyZWFtIHRocm91Z2ggYSB0cmFuc2Zvcm0gc3RyZWFtXG4gICAqIChvciBhbnkgb3RoZXIgYHsgd3JpdGFibGUsIHJlYWRhYmxlIH1gIHBhaXIpLiBJdCBzaW1wbHkge0BsaW5rIFJlYWRhYmxlU3RyZWFtLnBpcGVUbyB8IHBpcGVzfSB0aGUgc3RyZWFtXG4gICAqIGludG8gdGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIHN1cHBsaWVkIHBhaXIsIGFuZCByZXR1cm5zIHRoZSByZWFkYWJsZSBzaWRlIGZvciBmdXJ0aGVyIHVzZS5cbiAgICpcbiAgICogUGlwaW5nIGEgc3RyZWFtIHdpbGwgbG9jayBpdCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBwaXBlLCBwcmV2ZW50aW5nIGFueSBvdGhlciBjb25zdW1lciBmcm9tIGFjcXVpcmluZyBhIHJlYWRlci5cbiAgICovXG4gIHBpcGVUaHJvdWdoPFJTIGV4dGVuZHMgUmVhZGFibGVTdHJlYW0+KFxuICAgIHRyYW5zZm9ybTogeyByZWFkYWJsZTogUlM7IHdyaXRhYmxlOiBXcml0YWJsZVN0cmVhbTxSPiB9LFxuICAgIG9wdGlvbnM/OiBTdHJlYW1QaXBlT3B0aW9uc1xuICApOiBSUztcbiAgcGlwZVRocm91Z2g8UlMgZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbT4oXG4gICAgcmF3VHJhbnNmb3JtOiB7IHJlYWRhYmxlOiBSUzsgd3JpdGFibGU6IFdyaXRhYmxlU3RyZWFtPFI+IH0gfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIHJhd09wdGlvbnM6IFN0cmVhbVBpcGVPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9XG4gICk6IFJTIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3BpcGVUaHJvdWdoJyk7XG4gICAgfVxuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQocmF3VHJhbnNmb3JtLCAxLCAncGlwZVRocm91Z2gnKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihyYXdUcmFuc2Zvcm0sICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICBjb25zdCBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG5cbiAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJyk7XG4gICAgfVxuICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRyYW5zZm9ybS53cml0YWJsZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVGhyb3VnaCBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbScpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2UgPSBSZWFkYWJsZVN0cmVhbVBpcGVUbyhcbiAgICAgIHRoaXMsIHRyYW5zZm9ybS53cml0YWJsZSwgb3B0aW9ucy5wcmV2ZW50Q2xvc2UsIG9wdGlvbnMucHJldmVudEFib3J0LCBvcHRpb25zLnByZXZlbnRDYW5jZWwsIG9wdGlvbnMuc2lnbmFsXG4gICAgKTtcblxuICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZSk7XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtLnJlYWRhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBpcGVzIHRoaXMgcmVhZGFibGUgc3RyZWFtIHRvIGEgZ2l2ZW4gd3JpdGFibGUgc3RyZWFtLiBUaGUgd2F5IGluIHdoaWNoIHRoZSBwaXBpbmcgcHJvY2VzcyBiZWhhdmVzIHVuZGVyXG4gICAqIHZhcmlvdXMgZXJyb3IgY29uZGl0aW9ucyBjYW4gYmUgY3VzdG9taXplZCB3aXRoIGEgbnVtYmVyIG9mIHBhc3NlZCBvcHRpb25zLiBJdCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzXG4gICAqIHdoZW4gdGhlIHBpcGluZyBwcm9jZXNzIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHksIG9yIHJlamVjdHMgaWYgYW55IGVycm9ycyB3ZXJlIGVuY291bnRlcmVkLlxuICAgKlxuICAgKiBQaXBpbmcgYSBzdHJlYW0gd2lsbCBsb2NrIGl0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHBpcGUsIHByZXZlbnRpbmcgYW55IG90aGVyIGNvbnN1bWVyIGZyb20gYWNxdWlyaW5nIGEgcmVhZGVyLlxuICAgKi9cbiAgcGlwZVRvKGRlc3RpbmF0aW9uOiBXcml0YWJsZVN0cmVhbTxSPiwgb3B0aW9ucz86IFN0cmVhbVBpcGVPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcbiAgcGlwZVRvKGRlc3RpbmF0aW9uOiBXcml0YWJsZVN0cmVhbTxSPiB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICByYXdPcHRpb25zOiBTdHJlYW1QaXBlT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbigncGlwZVRvJykpO1xuICAgIH1cblxuICAgIGlmIChkZXN0aW5hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChgUGFyYW1ldGVyIDEgaXMgcmVxdWlyZWQgaW4gJ3BpcGVUbycuYCk7XG4gICAgfVxuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbShkZXN0aW5hdGlvbikpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKFxuICAgICAgICBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFdyaXRhYmxlU3RyZWFtYClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbnM6IFZhbGlkYXRlZFN0cmVhbVBpcGVPcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XG4gICAgfVxuXG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKFxuICAgICAgICBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJylcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKGRlc3RpbmF0aW9uKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoXG4gICAgICAgIG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW0nKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1QaXBlVG88Uj4oXG4gICAgICB0aGlzLCBkZXN0aW5hdGlvbiwgb3B0aW9ucy5wcmV2ZW50Q2xvc2UsIG9wdGlvbnMucHJldmVudEFib3J0LCBvcHRpb25zLnByZXZlbnRDYW5jZWwsIG9wdGlvbnMuc2lnbmFsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWVzIHRoaXMgcmVhZGFibGUgc3RyZWFtLCByZXR1cm5pbmcgYSB0d28tZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSB0d28gcmVzdWx0aW5nIGJyYW5jaGVzIGFzXG4gICAqIG5ldyB7QGxpbmsgUmVhZGFibGVTdHJlYW19IGluc3RhbmNlcy5cbiAgICpcbiAgICogVGVlaW5nIGEgc3RyZWFtIHdpbGwgbG9jayBpdCwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG4gICAqIFRvIGNhbmNlbCB0aGUgc3RyZWFtLCBjYW5jZWwgYm90aCBvZiB0aGUgcmVzdWx0aW5nIGJyYW5jaGVzOyBhIGNvbXBvc2l0ZSBjYW5jZWxsYXRpb24gcmVhc29uIHdpbGwgdGhlbiBiZVxuICAgKiBwcm9wYWdhdGVkIHRvIHRoZSBzdHJlYW0ncyB1bmRlcmx5aW5nIHNvdXJjZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjaHVua3Mgc2VlbiBpbiBlYWNoIGJyYW5jaCB3aWxsIGJlIHRoZSBzYW1lIG9iamVjdC4gSWYgdGhlIGNodW5rcyBhcmUgbm90IGltbXV0YWJsZSxcbiAgICogdGhpcyBjb3VsZCBhbGxvdyBpbnRlcmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGJyYW5jaGVzLlxuICAgKi9cbiAgdGVlKCk6IFtSZWFkYWJsZVN0cmVhbTxSPiwgUmVhZGFibGVTdHJlYW08Uj5dIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3RlZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGJyYW5jaGVzID0gUmVhZGFibGVTdHJlYW1UZWUodGhpcywgZmFsc2UpO1xuICAgIHJldHVybiBDcmVhdGVBcnJheUZyb21MaXN0KGJyYW5jaGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBpdGVyYXRlcyBvdmVyIHRoZSBjaHVua3MgaW4gdGhlIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLlxuICAgKlxuICAgKiBBc3luY2hyb25vdXNseSBpdGVyYXRpbmcgb3ZlciB0aGUgc3RyZWFtIHdpbGwgbG9jayBpdCwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG4gICAqIFRoZSBsb2NrIHdpbGwgYmUgcmVsZWFzZWQgaWYgdGhlIGFzeW5jIGl0ZXJhdG9yJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci5yZXR1cm4gfCByZXR1cm4oKX0gbWV0aG9kXG4gICAqIGlzIGNhbGxlZCwgZS5nLiBieSBicmVha2luZyBvdXQgb2YgdGhlIGxvb3AuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGNhbGxpbmcgdGhlIGFzeW5jIGl0ZXJhdG9yJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci5yZXR1cm4gfCByZXR1cm4oKX0gbWV0aG9kIHdpbGwgYWxzb1xuICAgKiBjYW5jZWwgdGhlIHN0cmVhbS4gVG8gcHJldmVudCB0aGlzLCB1c2UgdGhlIHN0cmVhbSdzIHtAbGluayBSZWFkYWJsZVN0cmVhbS52YWx1ZXMgfCB2YWx1ZXMoKX0gbWV0aG9kLCBwYXNzaW5nXG4gICAqIGB0cnVlYCBmb3IgdGhlIGBwcmV2ZW50Q2FuY2VsYCBvcHRpb24uXG4gICAqL1xuICB2YWx1ZXMob3B0aW9ucz86IFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zKTogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+O1xuICB2YWx1ZXMocmF3T3B0aW9uczogUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkKTogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3ZhbHVlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPih0aGlzLCBvcHRpb25zLnByZXZlbnRDYW5jZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAaW5oZXJpdERvYyBSZWFkYWJsZVN0cmVhbS52YWx1ZXN9XG4gICAqL1xuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKG9wdGlvbnM/OiBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyk6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPjtcblxuICBbU3ltYm9sQXN5bmNJdGVyYXRvcl0ob3B0aW9ucz86IFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zKTogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+IHtcbiAgICAvLyBTdHViIGltcGxlbWVudGF0aW9uLCBvdmVycmlkZGVuIGJlbG93XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUmVhZGFibGVTdHJlYW0gd3JhcHBpbmcgdGhlIHByb3ZpZGVkIGl0ZXJhYmxlIG9yIGFzeW5jIGl0ZXJhYmxlLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGFkYXB0IHZhcmlvdXMga2luZHMgb2Ygb2JqZWN0cyBpbnRvIGEgcmVhZGFibGUgc3RyZWFtLFxuICAgKiBzdWNoIGFzIGFuIGFycmF5LCBhbiBhc3luYyBnZW5lcmF0b3IsIG9yIGEgTm9kZS5qcyByZWFkYWJsZSBzdHJlYW0uXG4gICAqL1xuICBzdGF0aWMgZnJvbTxSPihhc3luY0l0ZXJhYmxlOiBJdGVyYWJsZTxSPiB8IEFzeW5jSXRlcmFibGU8Uj4gfCBSZWFkYWJsZVN0cmVhbUxpa2U8Uj4pOiBSZWFkYWJsZVN0cmVhbTxSPiB7XG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRnJvbShhc3luY0l0ZXJhYmxlKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbSwge1xuICBmcm9tOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZ2V0UmVhZGVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcGlwZVRocm91Z2g6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBwaXBlVG86IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB0ZWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB2YWx1ZXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBsb2NrZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbnNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbS5mcm9tLCAnZnJvbScpO1xuc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5jYW5jZWwsICdjYW5jZWwnKTtcbnNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuZ2V0UmVhZGVyLCAnZ2V0UmVhZGVyJyk7XG5zZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoLCAncGlwZVRocm91Z2gnKTtcbnNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvLCAncGlwZVRvJyk7XG5zZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnRlZSwgJ3RlZScpO1xuc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMsICd2YWx1ZXMnKTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xBc3luY0l0ZXJhdG9yLCB7XG4gIHZhbHVlOiBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUudmFsdWVzLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuZXhwb3J0IHR5cGUge1xuICBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHQsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWRPcHRpb25zLFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZSxcbiAgVW5kZXJseWluZ1NvdXJjZSxcbiAgVW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayxcbiAgVW5kZXJseWluZ0J5dGVTb3VyY2VTdGFydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZVB1bGxDYWxsYmFjayxcbiAgU3RyZWFtUGlwZU9wdGlvbnMsXG4gIFJlYWRhYmxlV3JpdGFibGVQYWlyLFxuICBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyxcbiAgUmVhZGFibGVTdHJlYW1MaWtlLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJMaWtlXG59O1xuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbi8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVTdHJlYW08Uj4oXG4gIHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gIHB1bGxBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gIGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+LFxuICBoaWdoV2F0ZXJNYXJrID0gMSxcbiAgc2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFI+ID0gKCkgPT4gMVxuKTogRGVmYXVsdFJlYWRhYmxlU3RyZWFtPFI+IHtcbiAgYXNzZXJ0KElzTm9uTmVnYXRpdmVOdW1iZXIoaGlnaFdhdGVyTWFyaykpO1xuXG4gIGNvbnN0IHN0cmVhbTogRGVmYXVsdFJlYWRhYmxlU3RyZWFtPFI+ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcblxuICBjb25zdCBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihcbiAgICBzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG1cbiAgKTtcblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG4vLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShcbiAgc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgcHVsbEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbiAgY2FuY2VsQWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD5cbik6IFJlYWRhYmxlQnl0ZVN0cmVhbSB7XG4gIGNvbnN0IHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcblxuICBjb25zdCBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSk7XG4gIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIDAsIHVuZGVmaW5lZCk7XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuZnVuY3Rpb24gSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pIHtcbiAgc3RyZWFtLl9zdGF0ZSA9ICdyZWFkYWJsZSc7XG4gIHN0cmVhbS5fcmVhZGVyID0gdW5kZWZpbmVkO1xuICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICBzdHJlYW0uX2Rpc3R1cmJlZCA9IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbSh4OiB1bmtub3duKTogeCBpcyBSZWFkYWJsZVN0cmVhbSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGlzdHVyYmVkKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBib29sZWFuIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG5cbiAgcmV0dXJuIHN0cmVhbS5fZGlzdHVyYmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuXG4gIGlmIChzdHJlYW0uX3JlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2FuY2VsPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sIHJlYXNvbjogYW55KTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG5cbiAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuXG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICBpZiAocmVhZGVyICE9PSB1bmRlZmluZWQgJiYgSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdHMgPSByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHM7XG4gICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XG4gICAgICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHModW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNvdXJjZUNhbmNlbFByb21pc2UgPSBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltDYW5jZWxTdGVwc10ocmVhc29uKTtcbiAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHNvdXJjZUNhbmNlbFByb21pc2UsIG5vb3ApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DbG9zZTxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+KTogdm9pZCB7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcblxuICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cbiAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcik7XG5cbiAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KHJlYWRlcikpIHtcbiAgICBjb25zdCByZWFkUmVxdWVzdHMgPSByZWFkZXIuX3JlYWRSZXF1ZXN0cztcbiAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgIHJlYWRSZXF1ZXN0cy5mb3JFYWNoKHJlYWRSZXF1ZXN0ID0+IHtcbiAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRXJyb3I8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPiwgZTogYW55KTogdm9pZCB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJyk7XG5cbiAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmVkJztcbiAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IGU7XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cbiAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCBlKTtcblxuICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4ocmVhZGVyKSkge1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlckVycm9yUmVhZFJlcXVlc3RzKHJlYWRlciwgZSk7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpO1xuICAgIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlckVycm9yUmVhZEludG9SZXF1ZXN0cyhyZWFkZXIsIGUpO1xuICB9XG59XG5cbi8vIFJlYWRlcnNcblxuZXhwb3J0IHR5cGUgUmVhZGFibGVTdHJlYW1SZWFkZXI8Uj4gPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4gfCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXI7XG5cbmV4cG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyXG59O1xuXG4vLyBDb250cm9sbGVyc1xuXG5leHBvcnQge1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyXG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbmZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbWApO1xufVxuIiwgImltcG9ydCB0eXBlIHsgUXVldWluZ1N0cmF0ZWd5SW5pdCB9IGZyb20gJy4uL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0UmVxdWlyZWRGaWVsZCwgY29udmVydFVucmVzdHJpY3RlZERvdWJsZSB9IGZyb20gJy4vYmFzaWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQoaW5pdDogUXVldWluZ1N0cmF0ZWd5SW5pdCB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogUXVldWluZ1N0cmF0ZWd5SW5pdCB7XG4gIGFzc2VydERpY3Rpb25hcnkoaW5pdCwgY29udGV4dCk7XG4gIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBpbml0Py5oaWdoV2F0ZXJNYXJrO1xuICBhc3NlcnRSZXF1aXJlZEZpZWxkKGhpZ2hXYXRlck1hcmssICdoaWdoV2F0ZXJNYXJrJywgJ1F1ZXVpbmdTdHJhdGVneUluaXQnKTtcbiAgcmV0dXJuIHtcbiAgICBoaWdoV2F0ZXJNYXJrOiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGhpZ2hXYXRlck1hcmspXG4gIH07XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBRdWV1aW5nU3RyYXRlZ3ksIFF1ZXVpbmdTdHJhdGVneUluaXQgfSBmcm9tICcuL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgc2V0RnVuY3Rpb25OYW1lLCB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0IH0gZnJvbSAnLi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3ktaW5pdCc7XG5cbi8vIFRoZSBzaXplIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgbm9yIGJlIGEgY29uc3RydWN0b3JcbmNvbnN0IGJ5dGVMZW5ndGhTaXplRnVuY3Rpb24gPSAoY2h1bms6IEFycmF5QnVmZmVyVmlldyk6IG51bWJlciA9PiB7XG4gIHJldHVybiBjaHVuay5ieXRlTGVuZ3RoO1xufTtcbnNldEZ1bmN0aW9uTmFtZShieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uLCAnc2l6ZScpO1xuXG4vKipcbiAqIEEgcXVldWluZyBzdHJhdGVneSB0aGF0IGNvdW50cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIGVhY2ggY2h1bmsuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IGltcGxlbWVudHMgUXVldWluZ1N0cmF0ZWd5PEFycmF5QnVmZmVyVmlldz4ge1xuICAvKiogQGludGVybmFsICovXG4gIHJlYWRvbmx5IF9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyazogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFF1ZXVpbmdTdHJhdGVneUluaXQpIHtcbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KG9wdGlvbnMsIDEsICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5Jyk7XG4gICAgb3B0aW9ucyA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KG9wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICB0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaWdoIHdhdGVyIG1hcmsgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgZ2V0IGhpZ2hXYXRlck1hcmsoKTogbnVtYmVyIHtcbiAgICBpZiAoIUlzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICAgdGhyb3cgYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24oJ2hpZ2hXYXRlck1hcmsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lYXN1cmVzIHRoZSBzaXplIG9mIGBjaHVua2AgYnkgcmV0dXJuaW5nIHRoZSB2YWx1ZSBvZiBpdHMgYGJ5dGVMZW5ndGhgIHByb3BlcnR5LlxuICAgKi9cbiAgZ2V0IHNpemUoKTogKGNodW5rOiBBcnJheUJ1ZmZlclZpZXcpID0+IG51bWJlciB7XG4gICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKCdzaXplJyk7XG4gICAgfVxuICAgIHJldHVybiBieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCB7XG4gIGhpZ2hXYXRlck1hcms6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3knLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kuXG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKGBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5YCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3koeDogYW55KTogeCBpcyBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3k7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBRdWV1aW5nU3RyYXRlZ3ksIFF1ZXVpbmdTdHJhdGVneUluaXQgfSBmcm9tICcuL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgc2V0RnVuY3Rpb25OYW1lLCB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0IH0gZnJvbSAnLi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3ktaW5pdCc7XG5cbi8vIFRoZSBzaXplIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgbm9yIGJlIGEgY29uc3RydWN0b3JcbmNvbnN0IGNvdW50U2l6ZUZ1bmN0aW9uID0gKCk6IDEgPT4ge1xuICByZXR1cm4gMTtcbn07XG5zZXRGdW5jdGlvbk5hbWUoY291bnRTaXplRnVuY3Rpb24sICdzaXplJyk7XG5cbi8qKlxuICogQSBxdWV1aW5nIHN0cmF0ZWd5IHRoYXQgY291bnRzIHRoZSBudW1iZXIgb2YgY2h1bmtzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ291bnRRdWV1aW5nU3RyYXRlZ3kgaW1wbGVtZW50cyBRdWV1aW5nU3RyYXRlZ3k8YW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmVhZG9ubHkgX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayE6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBRdWV1aW5nU3RyYXRlZ3lJbml0KSB7XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChvcHRpb25zLCAxLCAnQ291bnRRdWV1aW5nU3RyYXRlZ3knKTtcbiAgICBvcHRpb25zID0gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQob3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIHRoaXMuX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaWdoIHdhdGVyIG1hcmsgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgZ2V0IGhpZ2hXYXRlck1hcmsoKTogbnVtYmVyIHtcbiAgICBpZiAoIUlzQ291bnRRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgIHRocm93IGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbignaGlnaFdhdGVyTWFyaycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lYXN1cmVzIHRoZSBzaXplIG9mIGBjaHVua2AgYnkgYWx3YXlzIHJldHVybmluZyAxLlxuICAgKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdG90YWwgcXVldWUgc2l6ZSBpcyBhIGNvdW50IG9mIHRoZSBudW1iZXIgb2YgY2h1bmtzIGluIHRoZSBxdWV1ZS5cbiAgICovXG4gIGdldCBzaXplKCk6IChjaHVuazogYW55KSA9PiAxIHtcbiAgICBpZiAoIUlzQ291bnRRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgIHRocm93IGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xuICAgIH1cbiAgICByZXR1cm4gY291bnRTaXplRnVuY3Rpb247XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCB7XG4gIGhpZ2hXYXRlck1hcms6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdDb3VudFF1ZXVpbmdTdHJhdGVneScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgQ291bnRRdWV1aW5nU3RyYXRlZ3kuXG5cbmZ1bmN0aW9uIGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIENvdW50UXVldWluZ1N0cmF0ZWd5YCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHg6IGFueSk6IHggaXMgQ291bnRRdWV1aW5nU3RyYXRlZ3kge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIENvdW50UXVldWluZ1N0cmF0ZWd5O1xufVxuIiwgImltcG9ydCB7IGFzc2VydERpY3Rpb25hcnksIGFzc2VydEZ1bmN0aW9uIH0gZnJvbSAnLi9iYXNpYyc7XG5pbXBvcnQgeyBwcm9taXNlQ2FsbCwgcmVmbGVjdENhbGwgfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQgdHlwZSB7XG4gIFRyYW5zZm9ybWVyLFxuICBUcmFuc2Zvcm1lckNhbmNlbENhbGxiYWNrLFxuICBUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayxcbiAgVHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayxcbiAgVmFsaWRhdGVkVHJhbnNmb3JtZXJcbn0gZnJvbSAnLi4vdHJhbnNmb3JtLXN0cmVhbS90cmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciB9IGZyb20gJy4uL3RyYW5zZm9ybS1zdHJlYW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyPEksIE8+KG9yaWdpbmFsOiBUcmFuc2Zvcm1lcjxJLCBPPiB8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFZhbGlkYXRlZFRyYW5zZm9ybWVyPEksIE8+IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcmlnaW5hbCwgY29udGV4dCk7XG4gIGNvbnN0IGNhbmNlbCA9IG9yaWdpbmFsPy5jYW5jZWw7XG4gIGNvbnN0IGZsdXNoID0gb3JpZ2luYWw/LmZsdXNoO1xuICBjb25zdCByZWFkYWJsZVR5cGUgPSBvcmlnaW5hbD8ucmVhZGFibGVUeXBlO1xuICBjb25zdCBzdGFydCA9IG9yaWdpbmFsPy5zdGFydDtcbiAgY29uc3QgdHJhbnNmb3JtID0gb3JpZ2luYWw/LnRyYW5zZm9ybTtcbiAgY29uc3Qgd3JpdGFibGVUeXBlID0gb3JpZ2luYWw/LndyaXRhYmxlVHlwZTtcbiAgcmV0dXJuIHtcbiAgICBjYW5jZWw6IGNhbmNlbCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VHJhbnNmb3JtZXJDYW5jZWxDYWxsYmFjayhjYW5jZWwsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCksXG4gICAgZmx1c2g6IGZsdXNoID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2soZmx1c2gsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnZmx1c2gnIHRoYXRgKSxcbiAgICByZWFkYWJsZVR5cGUsXG4gICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2soc3RhcnQsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayh0cmFuc2Zvcm0sIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAndHJhbnNmb3JtJyB0aGF0YCksXG4gICAgd3JpdGFibGVUeXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2s8SSwgTz4oXG4gIGZuOiBUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2s8Tz4sXG4gIG9yaWdpbmFsOiBUcmFuc2Zvcm1lcjxJLCBPPixcbiAgY29udGV4dDogc3RyaW5nXG4pOiAoY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAoY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjazxJLCBPPihcbiAgZm46IFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjazxPPixcbiAgb3JpZ2luYWw6IFRyYW5zZm9ybWVyPEksIE8+LFxuICBjb250ZXh0OiBzdHJpbmdcbik6IFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjazxPPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjazxJLCBPPihcbiAgZm46IFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2s8SSwgTz4sXG4gIG9yaWdpbmFsOiBUcmFuc2Zvcm1lcjxJLCBPPixcbiAgY29udGV4dDogc3RyaW5nXG4pOiAoY2h1bms6IEksIGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KSA9PiBQcm9taXNlPHZvaWQ+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNodW5rOiBJLCBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyQ2FuY2VsQ2FsbGJhY2s8SSwgTz4oXG4gIGZuOiBUcmFuc2Zvcm1lckNhbmNlbENhbGxiYWNrLFxuICBvcmlnaW5hbDogVHJhbnNmb3JtZXI8SSwgTz4sXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKHJlYXNvbjogYW55KSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcbn1cbiIsICJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7XG4gIG5ld1Byb21pc2UsXG4gIHByb21pc2VSZWplY3RlZFdpdGgsXG4gIHByb21pc2VSZXNvbHZlZFdpdGgsXG4gIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUsXG4gIHRyYW5zZm9ybVByb21pc2VXaXRoLFxuICB1cG9uUHJvbWlzZVxufSBmcm9tICcuL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IENyZWF0ZVJlYWRhYmxlU3RyZWFtLCB0eXBlIERlZmF1bHRSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlXG59IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2RlZmF1bHQtY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IENyZWF0ZVdyaXRhYmxlU3RyZWFtLCBXcml0YWJsZVN0cmVhbSwgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQgfSBmcm9tICcuL3dyaXRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBzZXRGdW5jdGlvbk5hbWUsIHR5cGVJc09iamVjdCB9IGZyb20gJy4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IElzTm9uTmVnYXRpdmVOdW1iZXIgfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBFeHRyYWN0SGlnaFdhdGVyTWFyaywgRXh0cmFjdFNpemVBbGdvcml0aG0gfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB0eXBlIHtcbiAgVHJhbnNmb3JtZXIsXG4gIFRyYW5zZm9ybWVyQ2FuY2VsQ2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayxcbiAgVHJhbnNmb3JtZXJTdGFydENhbGxiYWNrLFxuICBUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrLFxuICBWYWxpZGF0ZWRUcmFuc2Zvcm1lclxufSBmcm9tICcuL3RyYW5zZm9ybS1zdHJlYW0vdHJhbnNmb3JtZXInO1xuaW1wb3J0IHsgY29udmVydFRyYW5zZm9ybWVyIH0gZnJvbSAnLi92YWxpZGF0b3JzL3RyYW5zZm9ybWVyJztcblxuLy8gQ2xhc3MgVHJhbnNmb3JtU3RyZWFtXG5cbi8qKlxuICogQSB0cmFuc2Zvcm0gc3RyZWFtIGNvbnNpc3RzIG9mIGEgcGFpciBvZiBzdHJlYW1zOiBhIHtAbGluayBXcml0YWJsZVN0cmVhbSB8IHdyaXRhYmxlIHN0cmVhbX0sXG4gKiBrbm93biBhcyBpdHMgd3JpdGFibGUgc2lkZSwgYW5kIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgc3RyZWFtfSwga25vd24gYXMgaXRzIHJlYWRhYmxlIHNpZGUuXG4gKiBJbiBhIG1hbm5lciBzcGVjaWZpYyB0byB0aGUgdHJhbnNmb3JtIHN0cmVhbSBpbiBxdWVzdGlvbiwgd3JpdGVzIHRvIHRoZSB3cml0YWJsZSBzaWRlIHJlc3VsdCBpbiBuZXcgZGF0YSBiZWluZ1xuICogbWFkZSBhdmFpbGFibGUgZm9yIHJlYWRpbmcgZnJvbSB0aGUgcmVhZGFibGUgc2lkZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2Zvcm1TdHJlYW08SSA9IGFueSwgTyA9IGFueT4ge1xuICAvKiogQGludGVybmFsICovXG4gIF93cml0YWJsZSE6IFdyaXRhYmxlU3RyZWFtPEk+O1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkYWJsZSE6IERlZmF1bHRSZWFkYWJsZVN0cmVhbTxPPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYmFja3ByZXNzdXJlITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSE6IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSE6ICgpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIhOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB0cmFuc2Zvcm1lcj86IFRyYW5zZm9ybWVyPEksIE8+LFxuICAgIHdyaXRhYmxlU3RyYXRlZ3k/OiBRdWV1aW5nU3RyYXRlZ3k8ST4sXG4gICAgcmVhZGFibGVTdHJhdGVneT86IFF1ZXVpbmdTdHJhdGVneTxPPlxuICApO1xuICBjb25zdHJ1Y3RvcihyYXdUcmFuc2Zvcm1lcjogVHJhbnNmb3JtZXI8SSwgTz4gfCBudWxsIHwgdW5kZWZpbmVkID0ge30sXG4gICAgICAgICAgICAgIHJhd1dyaXRhYmxlU3RyYXRlZ3k6IFF1ZXVpbmdTdHJhdGVneTxJPiB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSxcbiAgICAgICAgICAgICAgcmF3UmVhZGFibGVTdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5PE8+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9KSB7XG4gICAgaWYgKHJhd1RyYW5zZm9ybWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhd1RyYW5zZm9ybWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB3cml0YWJsZVN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdXcml0YWJsZVN0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgIGNvbnN0IHJlYWRhYmxlU3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1JlYWRhYmxlU3RyYXRlZ3ksICdUaGlyZCBwYXJhbWV0ZXInKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gY29udmVydFRyYW5zZm9ybWVyKHJhd1RyYW5zZm9ybWVyLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgaWYgKHRyYW5zZm9ybWVyLnJlYWRhYmxlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCByZWFkYWJsZVR5cGUgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1lci53cml0YWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgd3JpdGFibGVUeXBlIHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHJlYWRhYmxlU3RyYXRlZ3ksIDApO1xuICAgIGNvbnN0IHJlYWRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHJlYWRhYmxlU3RyYXRlZ3kpO1xuICAgIGNvbnN0IHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHdyaXRhYmxlU3RyYXRlZ3ksIDEpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHdyaXRhYmxlU3RyYXRlZ3kpO1xuXG4gICAgbGV0IHN0YXJ0UHJvbWlzZV9yZXNvbHZlITogKHZhbHVlOiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pID0+IHZvaWQ7XG4gICAgY29uc3Qgc3RhcnRQcm9taXNlID0gbmV3UHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0oXG4gICAgICB0aGlzLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobVxuICAgICk7XG4gICAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcih0aGlzLCB0cmFuc2Zvcm1lcik7XG5cbiAgICBpZiAodHJhbnNmb3JtZXIuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodHJhbnNmb3JtZXIuc3RhcnQodGhpcy5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgdHJhbnNmb3JtIHN0cmVhbS5cbiAgICovXG4gIGdldCByZWFkYWJsZSgpOiBSZWFkYWJsZVN0cmVhbTxPPiB7XG4gICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZGFibGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAqL1xuICBnZXQgd3JpdGFibGUoKTogV3JpdGFibGVTdHJlYW08ST4ge1xuICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRhYmxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgcmVhZGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB3cml0YWJsZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1RyYW5zZm9ybVN0cmVhbScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQgdHlwZSB7XG4gIFRyYW5zZm9ybWVyLFxuICBUcmFuc2Zvcm1lckNhbmNlbENhbGxiYWNrLFxuICBUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayxcbiAgVHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFja1xufTtcblxuLy8gVHJhbnNmb3JtIFN0cmVhbSBBYnN0cmFjdCBPcGVyYXRpb25zXG5cbmV4cG9ydCBmdW5jdGlvbiBDcmVhdGVUcmFuc2Zvcm1TdHJlYW08SSwgTz4oc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQWxnb3JpdGhtOiAoY2h1bms6IEkpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrID0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGVTaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8ST4gPSAoKSA9PiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkYWJsZUhpZ2hXYXRlck1hcmsgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkYWJsZVNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxPPiA9ICgpID0+IDEpIHtcbiAgYXNzZXJ0KElzTm9uTmVnYXRpdmVOdW1iZXIod3JpdGFibGVIaWdoV2F0ZXJNYXJrKSk7XG4gIGFzc2VydChJc05vbk5lZ2F0aXZlTnVtYmVyKHJlYWRhYmxlSGlnaFdhdGVyTWFyaykpO1xuXG4gIGNvbnN0IHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+ID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlKTtcblxuICBsZXQgc3RhcnRQcm9taXNlX3Jlc29sdmUhOiAodmFsdWU6IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPikgPT4gdm9pZDtcbiAgY29uc3Qgc3RhcnRQcm9taXNlID0gbmV3UHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICBzdGFydFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcblxuICBjb25zdCBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblxuICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtKTtcblxuICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gIHN0YXJ0UHJvbWlzZV9yZXNvbHZlKHN0YXJ0UmVzdWx0KTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuZnVuY3Rpb24gSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbTxJLCBPPihzdHJlYW06IFRyYW5zZm9ybVN0cmVhbTxJLCBPPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlOiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZUhpZ2hXYXRlck1hcms6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGVTaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8ST4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRhYmxlSGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkYWJsZVNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxPPikge1xuICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gc3RhcnRQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVBbGdvcml0aG0oY2h1bms6IEkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0QWxnb3JpdGhtKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0oc3RyZWFtKTtcbiAgfVxuXG4gIHN0cmVhbS5fd3JpdGFibGUgPSBDcmVhdGVXcml0YWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtKTtcblxuICBmdW5jdGlvbiBwdWxsQWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobShzdHJlYW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsQWxnb3JpdGhtKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VDYW5jZWxBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pO1xuICB9XG5cbiAgc3RyZWFtLl9yZWFkYWJsZSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG5cbiAgLy8gVGhlIFtbYmFja3ByZXNzdXJlXV0gc2xvdCBpcyBzZXQgdG8gdW5kZWZpbmVkIHNvIHRoYXQgaXQgY2FuIGJlIGluaXRpYWxpc2VkIGJ5IFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZS5cbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSB1bmRlZmluZWQhO1xuICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSB1bmRlZmluZWQhO1xuICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZCE7XG4gIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIHRydWUpO1xuXG4gIHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZCE7XG59XG5cbmZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtKHg6IHVua25vd24pOiB4IGlzIFRyYW5zZm9ybVN0cmVhbSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ190cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFRyYW5zZm9ybVN0cmVhbTtcbn1cblxuLy8gVGhpcyBpcyBhIG5vLW9wIGlmIGJvdGggc2lkZXMgYXJlIGFscmVhZHkgZXJyb3JlZC5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtLCBlOiBhbnkpIHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgZSk7XG4gIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW06IFRyYW5zZm9ybVN0cmVhbSwgZTogYW55KSB7XG4gIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcik7XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKHN0cmVhbS5fd3JpdGFibGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciwgZSk7XG4gIFRyYW5zZm9ybVN0cmVhbVVuYmxvY2tXcml0ZShzdHJlYW0pO1xufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1VbmJsb2NrV3JpdGUoc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW0pIHtcbiAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgLy8gUHJldGVuZCB0aGF0IHB1bGwoKSB3YXMgY2FsbGVkIHRvIHBlcm1pdCBhbnkgcGVuZGluZyB3cml0ZSgpIGNhbGxzIHRvIGNvbXBsZXRlLiBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoKVxuICAgIC8vIGNhbm5vdCBiZSBjYWxsZWQgZnJvbSBlbnF1ZXVlKCkgb3IgcHVsbCgpIG9uY2UgdGhlIFJlYWRhYmxlU3RyZWFtIGlzIGVycm9yZWQsIHNvIHRoaXMgd2lsbCB3aWxsIGJlIHRoZSBmaW5hbCB0aW1lXG4gICAgLy8gX2JhY2twcmVzc3VyZSBpcyBzZXQuXG4gICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW06IFRyYW5zZm9ybVN0cmVhbSwgYmFja3ByZXNzdXJlOiBib29sZWFuKSB7XG4gIC8vIFBhc3NlcyBhbHNvIHdoZW4gY2FsbGVkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXG4gIGFzc2VydChzdHJlYW0uX2JhY2twcmVzc3VyZSAhPT0gYmFja3ByZXNzdXJlKTtcblxuICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSgpO1xuICB9XG5cbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gYmFja3ByZXNzdXJlO1xufVxuXG4vLyBDbGFzcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclxuXG4vKipcbiAqIEFsbG93cyBjb250cm9sIG9mIHRoZSB7QGxpbmsgUmVhZGFibGVTdHJlYW19IGFuZCB7QGxpbmsgV3JpdGFibGVTdHJlYW19IG9mIHRoZSBhc3NvY2lhdGVkIHtAbGluayBUcmFuc2Zvcm1TdHJlYW19LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPGFueSwgTz47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2ZpbmlzaFByb21pc2U6IFByb21pc2U8dW5kZWZpbmVkPiB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZmluaXNoUHJvbWlzZV9yZXNvbHZlPzogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9maW5pc2hQcm9taXNlX3JlamVjdD86IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdHJhbnNmb3JtQWxnb3JpdGhtOiAoY2h1bms6IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZmx1c2hBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSByZWFkYWJsZSBzaWRl4oCZcyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXMgb3Zlci1mdWxsLlxuICAgKi9cbiAgZ2V0IGRlc2lyZWRTaXplKCk6IG51bWJlciB8IG51bGwge1xuICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHRoZSBnaXZlbiBjaHVuayBgY2h1bmtgIGluIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAqL1xuICBlbnF1ZXVlKGNodW5rOiBPKTogdm9pZDtcbiAgZW5xdWV1ZShjaHVuazogTyA9IHVuZGVmaW5lZCEpOiB2b2lkIHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZW5xdWV1ZScpO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gIH1cblxuICAvKipcbiAgICogRXJyb3JzIGJvdGggdGhlIHJlYWRhYmxlIHNpZGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlXG4gICAqIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLiBBbnkgY2h1bmtzIHF1ZXVlZCBmb3IgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSBkaXNjYXJkZWQuXG4gICAqL1xuICBlcnJvcihyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHJlYWRhYmxlIHNpZGUgYW5kIGVycm9ycyB0aGUgd3JpdGFibGUgc2lkZSBvZiB0aGUgY29udHJvbGxlZCB0cmFuc2Zvcm0gc3RyZWFtLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHRoZVxuICAgKiB0cmFuc2Zvcm1lciBvbmx5IG5lZWRzIHRvIGNvbnN1bWUgYSBwb3J0aW9uIG9mIHRoZSBjaHVua3Mgd3JpdHRlbiB0byB0aGUgd3JpdGFibGUgc2lkZS5cbiAgICovXG4gIHRlcm1pbmF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbigndGVybWluYXRlJyk7XG4gICAgfVxuXG4gICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUodGhpcyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHRlcm1pbmF0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5zZXRGdW5jdGlvbk5hbWUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmVucXVldWUsICdlbnF1ZXVlJyk7XG5zZXRGdW5jdGlvbk5hbWUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmVycm9yLCAnZXJyb3InKTtcbnNldEZ1bmN0aW9uTmFtZShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUudGVybWluYXRlLCAndGVybWluYXRlJyk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBUcmFuc2Zvcm0gU3RyZWFtIERlZmF1bHQgQ29udHJvbGxlciBBYnN0cmFjdCBPcGVyYXRpb25zXG5cbmZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8TyA9IGFueT4oeDogYW55KTogeCBpcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xufVxuXG5mdW5jdGlvbiBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPEksIE8+KHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQWxnb3JpdGhtOiAoY2h1bms6IEkpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPikge1xuICBhc3NlcnQoSXNUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtKSk7XG4gIGFzc2VydChzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCk7XG5cbiAgY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSA9IHN0cmVhbTtcbiAgc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB0cmFuc2Zvcm1BbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gZmx1c2hBbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IGNhbmNlbEFsZ29yaXRobTtcblxuICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlID0gdW5kZWZpbmVkO1xuICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyPEksIE8+KHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lcjogVmFsaWRhdGVkVHJhbnNmb3JtZXI8SSwgTz4pIHtcbiAgY29uc3QgY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4gPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cbiAgbGV0IHRyYW5zZm9ybUFsZ29yaXRobTogKGNodW5rOiBJKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBsZXQgZmx1c2hBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGxldCBjYW5jZWxBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICBpZiAodHJhbnNmb3JtZXIudHJhbnNmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICB0cmFuc2Zvcm1BbGdvcml0aG0gPSBjaHVuayA9PiB0cmFuc2Zvcm1lci50cmFuc2Zvcm0hKGNodW5rLCBjb250cm9sbGVyKTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2Zvcm1BbGdvcml0aG0gPSBjaHVuayA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmsgYXMgdW5rbm93biBhcyBPKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgIH0gY2F0Y2ggKHRyYW5zZm9ybVJlc3VsdEUpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodHJhbnNmb3JtUmVzdWx0RSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0cmFuc2Zvcm1lci5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZmx1c2hBbGdvcml0aG0gPSAoKSA9PiB0cmFuc2Zvcm1lci5mbHVzaCEoY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICAgZmx1c2hBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cblxuICBpZiAodHJhbnNmb3JtZXIuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdHJhbnNmb3JtZXIuY2FuY2VsIShyZWFzb24pO1xuICB9IGVsc2Uge1xuICAgIGNhbmNlbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuXG4gIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0pO1xufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KSB7XG4gIGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlPE8+KGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+LCBjaHVuazogTykge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xuICBjb25zdCByZWFkYWJsZUNvbnRyb2xsZXIgPSBzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHJlYWRhYmxlQ29udHJvbGxlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZSBzaWRlIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlJyk7XG4gIH1cblxuICAvLyBXZSB0aHJvdHRsZSB0cmFuc2Zvcm0gaW52b2NhdGlvbnMgYmFzZWQgb24gdGhlIGJhY2twcmVzc3VyZSBvZiB0aGUgUmVhZGFibGVTdHJlYW0sIGJ1dCB3ZSBzdGlsbFxuICAvLyBhY2NlcHQgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKCkgY2FsbHMuXG5cbiAgdHJ5IHtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIHJlYWRhYmxlU3RyYXRlZ3kuc2l6ZSgpIHRocm93cy5cbiAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSk7XG5cbiAgICB0aHJvdyBzdHJlYW0uX3JlYWRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgfVxuXG4gIGNvbnN0IGJhY2twcmVzc3VyZSA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUocmVhZGFibGVDb250cm9sbGVyKTtcbiAgaWYgKGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICBhc3NlcnQoYmFja3ByZXNzdXJlKTtcbiAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4sIGU6IGFueSkge1xuICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCBlKTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtPEksIE8+KGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBJKSB7XG4gIGNvbnN0IHRyYW5zZm9ybVByb21pc2UgPSBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0oY2h1bmspO1xuICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgodHJhbnNmb3JtUHJvbWlzZSwgdW5kZWZpbmVkLCByID0+IHtcbiAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCByKTtcbiAgICB0aHJvdyByO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGU8Tz4oY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcbiAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuXG4gIGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcignVHJhbnNmb3JtU3RyZWFtIHRlcm1pbmF0ZWQnKTtcbiAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGVycm9yKTtcbn1cblxuLy8gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmsgQWxnb3JpdGhtc1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtPEksIE8+KHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+LCBjaHVuazogSSk6IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnQoc3RyZWFtLl93cml0YWJsZS5fc3RhdGUgPT09ICd3cml0YWJsZScpO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG5cbiAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgY29uc3QgYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcbiAgICBhc3NlcnQoYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgY29uc3Qgd3JpdGFibGUgPSBzdHJlYW0uX3dyaXRhYmxlO1xuICAgICAgY29uc3Qgc3RhdGUgPSB3cml0YWJsZS5fc3RhdGU7XG4gICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgICAgdGhyb3cgd3JpdGFibGUuX3N0b3JlZEVycm9yO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnKTtcbiAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm08SSwgTz4oY29udHJvbGxlciwgY2h1bmspO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybTxJLCBPPihjb250cm9sbGVyLCBjaHVuayk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG08SSwgTz4oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08SSwgTz4sIHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG4gIGlmIChjb250cm9sbGVyLl9maW5pc2hQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29udHJvbGxlci5fZmluaXNoUHJvbWlzZTtcbiAgfVxuXG4gIC8vIHN0cmVhbS5fcmVhZGFibGUgY2Fubm90IGNoYW5nZSBhZnRlciBjb25zdHJ1Y3Rpb24sIHNvIGNhY2hpbmcgaXQgYWNyb3NzIGEgY2FsbCB0byB1c2VyIGNvZGUgaXMgc2FmZS5cbiAgY29uc3QgcmVhZGFibGUgPSBzdHJlYW0uX3JlYWRhYmxlO1xuXG4gIC8vIEFzc2lnbiB0aGUgX2ZpbmlzaFByb21pc2Ugbm93IHNvIHRoYXQgaWYgX2NhbmNlbEFsZ29yaXRobSBjYWxscyByZWFkYWJsZS5jYW5jZWwoKSBpbnRlcm5hbGx5LFxuICAvLyB3ZSBkb24ndCBydW4gdGhlIF9jYW5jZWxBbGdvcml0aG0gYWdhaW4uXG4gIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcblxuICBjb25zdCBjYW5jZWxQcm9taXNlID0gY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtKHJlYXNvbik7XG4gIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXG4gIHVwb25Qcm9taXNlKGNhbmNlbFByb21pc2UsICgpID0+IHtcbiAgICBpZiAocmVhZGFibGUuX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlamVjdChjb250cm9sbGVyLCByZWFkYWJsZS5fc3RvcmVkRXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcmVhc29uKTtcbiAgICAgIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlc29sdmUoY29udHJvbGxlcik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LCByID0+IHtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHIpO1xuICAgIHJldHVybiBudWxsO1xuICB9KTtcblxuICByZXR1cm4gY29udHJvbGxlci5fZmluaXNoUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtDbG9zZUFsZ29yaXRobTxJLCBPPihzdHJlYW06IFRyYW5zZm9ybVN0cmVhbTxJLCBPPik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO1xuICBpZiAoY29udHJvbGxlci5fZmluaXNoUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2U7XG4gIH1cblxuICAvLyBzdHJlYW0uX3JlYWRhYmxlIGNhbm5vdCBjaGFuZ2UgYWZ0ZXIgY29uc3RydWN0aW9uLCBzbyBjYWNoaW5nIGl0IGFjcm9zcyBhIGNhbGwgdG8gdXNlciBjb2RlIGlzIHNhZmUuXG4gIGNvbnN0IHJlYWRhYmxlID0gc3RyZWFtLl9yZWFkYWJsZTtcblxuICAvLyBBc3NpZ24gdGhlIF9maW5pc2hQcm9taXNlIG5vdyBzbyB0aGF0IGlmIF9mbHVzaEFsZ29yaXRobSBjYWxscyByZWFkYWJsZS5jYW5jZWwoKSBpbnRlcm5hbGx5LFxuICAvLyB3ZSBkb24ndCBhbHNvIHJ1biB0aGUgX2NhbmNlbEFsZ29yaXRobS5cbiAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gIH0pO1xuXG4gIGNvbnN0IGZsdXNoUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtKCk7XG4gIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXG4gIHVwb25Qcm9taXNlKGZsdXNoUHJvbWlzZSwgKCkgPT4ge1xuICAgIGlmIChyZWFkYWJsZS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHJlYWRhYmxlLl9zdG9yZWRFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlc29sdmUoY29udHJvbGxlcik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LCByID0+IHtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHIpO1xuICAgIHJldHVybiBudWxsO1xuICB9KTtcblxuICByZXR1cm4gY29udHJvbGxlci5fZmluaXNoUHJvbWlzZTtcbn1cblxuLy8gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZSBBbGdvcml0aG1zXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIEludmFyaWFudC4gRW5mb3JjZWQgYnkgdGhlIHByb21pc2VzIHJldHVybmVkIGJ5IHN0YXJ0KCkgYW5kIHB1bGwoKS5cbiAgYXNzZXJ0KHN0cmVhbS5fYmFja3ByZXNzdXJlKTtcblxuICBhc3NlcnQoc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlICE9PSB1bmRlZmluZWQpO1xuXG4gIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGZhbHNlKTtcblxuICAvLyBQcmV2ZW50IHRoZSBuZXh0IHB1bGwoKSBjYWxsIHVudGlsIHRoZXJlIGlzIGJhY2twcmVzc3VyZS5cbiAgcmV0dXJuIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZUNhbmNlbEFsZ29yaXRobTxJLCBPPihzdHJlYW06IFRyYW5zZm9ybVN0cmVhbTxJLCBPPiwgcmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcbiAgaWYgKGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlO1xuICB9XG5cbiAgLy8gc3RyZWFtLl93cml0YWJsZSBjYW5ub3QgY2hhbmdlIGFmdGVyIGNvbnN0cnVjdGlvbiwgc28gY2FjaGluZyBpdCBhY3Jvc3MgYSBjYWxsIHRvIHVzZXIgY29kZSBpcyBzYWZlLlxuICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS5fd3JpdGFibGU7XG5cbiAgLy8gQXNzaWduIHRoZSBfZmluaXNoUHJvbWlzZSBub3cgc28gdGhhdCBpZiBfZmx1c2hBbGdvcml0aG0gY2FsbHMgd3JpdGFibGUuYWJvcnQoKSBvclxuICAvLyB3cml0YWJsZS5jYW5jZWwoKSBpbnRlcm5hbGx5LCB3ZSBkb24ndCBydW4gdGhlIF9jYW5jZWxBbGdvcml0aG0gYWdhaW4sIG9yIGFsc28gcnVuIHRoZVxuICAvLyBfZmx1c2hBbGdvcml0aG0uXG4gIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcblxuICBjb25zdCBjYW5jZWxQcm9taXNlID0gY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtKHJlYXNvbik7XG4gIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXG4gIHVwb25Qcm9taXNlKGNhbmNlbFByb21pc2UsICgpID0+IHtcbiAgICBpZiAod3JpdGFibGUuX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlamVjdChjb250cm9sbGVyLCB3cml0YWJsZS5fc3RvcmVkRXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZCh3cml0YWJsZS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLCByZWFzb24pO1xuICAgICAgVHJhbnNmb3JtU3RyZWFtVW5ibG9ja1dyaXRlKHN0cmVhbSk7XG4gICAgICBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZXNvbHZlKGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSwgciA9PiB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQod3JpdGFibGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICAgVHJhbnNmb3JtU3RyZWFtVW5ibG9ja1dyaXRlKHN0cmVhbSk7XG4gICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHIpO1xuICAgIHJldHVybiBudWxsO1xuICB9KTtcblxuICByZXR1cm4gY29udHJvbGxlci5fZmluaXNoUHJvbWlzZTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcmApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVzb2x2ZShjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KSB7XG4gIGlmIChjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSgpO1xuICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4sIHJlYXNvbjogYW55KSB7XG4gIGlmIChjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShjb250cm9sbGVyLl9maW5pc2hQcm9taXNlISk7XG4gIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW0uXG5cbmZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtYCk7XG59XG4iLCAiLyogYzggaWdub3JlIHN0YXJ0ICovXG4vLyA2NCBLaUIgKHNhbWUgc2l6ZSBjaHJvbWUgc2xpY2UgdGhlaXJzIGJsb2IgaW50byBVaW50OGFycmF5J3MpXG5jb25zdCBQT09MX1NJWkUgPSA2NTUzNlxuXG5pZiAoIWdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0pIHtcbiAgLy8gYG5vZGU6c3RyZWFtL3dlYmAgZ290IGludHJvZHVjZWQgaW4gdjE2LjUuMCBhcyBleHBlcmltZW50YWxcbiAgLy8gYW5kIGl0J3MgcHJlZmVycmVkIG92ZXIgdGhlIHBvbHlmaWxsZWQgdmVyc2lvbi4gU28gd2UgYWxzb1xuICAvLyBzdXBwcmVzcyB0aGUgd2FybmluZyB0aGF0IGdldHMgZW1pdHRlZCBieSBOb2RlSlMgZm9yIHVzaW5nIGl0LlxuICB0cnkge1xuICAgIGNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdub2RlOnByb2Nlc3MnKVxuICAgIGNvbnN0IHsgZW1pdFdhcm5pbmcgfSA9IHByb2Nlc3NcbiAgICB0cnkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyA9ICgpID0+IHt9XG4gICAgICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHJlcXVpcmUoJ25vZGU6c3RyZWFtL3dlYicpKVxuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyA9IGVtaXRXYXJuaW5nXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcgPSBlbWl0V2FybmluZ1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gcG9seWZpbGwgaW1wbGVtZW50YXRpb25cbiAgICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHJlcXVpcmUoJ3dlYi1zdHJlYW1zLXBvbHlmaWxsL2Rpc3QvcG9ueWZpbGwuZXMyMDE4LmpzJykpXG4gIH1cbn1cblxudHJ5IHtcbiAgLy8gRG9uJ3QgdXNlIG5vZGU6IHByZWZpeCBmb3IgdGhpcywgcmVxdWlyZStub2RlOiBpcyBub3Qgc3VwcG9ydGVkIHVudGlsIG5vZGUgdjE0LjE0XG4gIC8vIE9ubHkgYGltcG9ydCgpYCBjYW4gdXNlIHByZWZpeCBpbiAxMi4yMCBhbmQgbGF0ZXJcbiAgY29uc3QgeyBCbG9iIH0gPSByZXF1aXJlKCdidWZmZXInKVxuICBpZiAoQmxvYiAmJiAhQmxvYi5wcm90b3R5cGUuc3RyZWFtKSB7XG4gICAgQmxvYi5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24gbmFtZSAocGFyYW1zKSB7XG4gICAgICBsZXQgcG9zaXRpb24gPSAwXG4gICAgICBjb25zdCBibG9iID0gdGhpc1xuXG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgYXN5bmMgcHVsbCAoY3RybCkge1xuICAgICAgICAgIGNvbnN0IGNodW5rID0gYmxvYi5zbGljZShwb3NpdGlvbiwgTWF0aC5taW4oYmxvYi5zaXplLCBwb3NpdGlvbiArIFBPT0xfU0laRSkpXG4gICAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY2h1bmsuYXJyYXlCdWZmZXIoKVxuICAgICAgICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgICAgY3RybC5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpXG5cbiAgICAgICAgICBpZiAocG9zaXRpb24gPT09IGJsb2Iuc2l6ZSkge1xuICAgICAgICAgICAgY3RybC5jbG9zZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSBjYXRjaCAoZXJyb3IpIHt9XG4vKiBjOCBpZ25vcmUgZW5kICovXG4iLCAiLyohIGZldGNoLWJsb2IuIE1JVCBMaWNlbnNlLiBKaW1teSBXXHUwMEU0cnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL1xuXG4vLyBUT0RPIChqaW1teXdhcnRpbmcpOiBpbiB0aGUgZmVhdHVyZSB1c2UgY29uZGl0aW9uYWwgbG9hZGluZyB3aXRoIHRvcCBsZXZlbCBhd2FpdCAocmVxdWlyZXMgMTQueClcbi8vIE5vZGUgaGFzIHJlY2VudGx5IGFkZGVkIHdoYXR3ZyBzdHJlYW0gaW50byBjb3JlXG5cbmltcG9ydCAnLi9zdHJlYW1zLmNqcydcblxuLy8gNjQgS2lCIChzYW1lIHNpemUgY2hyb21lIHNsaWNlIHRoZWlycyBibG9iIGludG8gVWludDhhcnJheSdzKVxuY29uc3QgUE9PTF9TSVpFID0gNjU1MzZcblxuLyoqIEBwYXJhbSB7KEJsb2IgfCBVaW50OEFycmF5KVtdfSBwYXJ0cyAqL1xuYXN5bmMgZnVuY3Rpb24gKiB0b0l0ZXJhdG9yIChwYXJ0cywgY2xvbmUgPSB0cnVlKSB7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmICgnc3RyZWFtJyBpbiBwYXJ0KSB7XG4gICAgICB5aWVsZCAqICgvKiogQHR5cGUge0FzeW5jSXRlcmFibGVJdGVyYXRvcjxVaW50OEFycmF5Pn0gKi8gKHBhcnQuc3RyZWFtKCkpKVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpKSB7XG4gICAgICBpZiAoY2xvbmUpIHtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydC5ieXRlT2Zmc2V0XG4gICAgICAgIGNvbnN0IGVuZCA9IHBhcnQuYnl0ZU9mZnNldCArIHBhcnQuYnl0ZUxlbmd0aFxuICAgICAgICB3aGlsZSAocG9zaXRpb24gIT09IGVuZCkge1xuICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbihlbmQgLSBwb3NpdGlvbiwgUE9PTF9TSVpFKVxuICAgICAgICAgIGNvbnN0IGNodW5rID0gcGFydC5idWZmZXIuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgc2l6ZSlcbiAgICAgICAgICBwb3NpdGlvbiArPSBjaHVuay5ieXRlTGVuZ3RoXG4gICAgICAgICAgeWllbGQgbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHBhcnRcbiAgICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAxMCAqL1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYmxvYnMgdGhhdCBoYXZlIGFycmF5QnVmZmVyIGJ1dCBubyBzdHJlYW0gbWV0aG9kIChub2RlcyBidWZmZXIuQmxvYilcbiAgICAgIGxldCBwb3NpdGlvbiA9IDAsIGIgPSAoLyoqIEB0eXBlIHtCbG9ifSAqLyAocGFydCkpXG4gICAgICB3aGlsZSAocG9zaXRpb24gIT09IGIuc2l6ZSkge1xuICAgICAgICBjb25zdCBjaHVuayA9IGIuc2xpY2UocG9zaXRpb24sIE1hdGgubWluKGIuc2l6ZSwgcG9zaXRpb24gKyBQT09MX1NJWkUpKVxuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjaHVuay5hcnJheUJ1ZmZlcigpXG4gICAgICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgIHlpZWxkIG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgX0Jsb2IgPSBjbGFzcyBCbG9iIHtcbiAgLyoqIEB0eXBlIHtBcnJheS48KEJsb2J8VWludDhBcnJheSk+fSAqL1xuICAjcGFydHMgPSBbXVxuICAjdHlwZSA9ICcnXG4gICNzaXplID0gMFxuICAjZW5kaW5ncyA9ICd0cmFuc3BhcmVudCdcblxuICAvKipcbiAgICogVGhlIEJsb2IoKSBjb25zdHJ1Y3RvciByZXR1cm5zIGEgbmV3IEJsb2Igb2JqZWN0LiBUaGUgY29udGVudFxuICAgKiBvZiB0aGUgYmxvYiBjb25zaXN0cyBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgdmFsdWVzIGdpdmVuXG4gICAqIGluIHRoZSBwYXJhbWV0ZXIgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYmxvYlBhcnRzXG4gICAqIEBwYXJhbSB7eyB0eXBlPzogc3RyaW5nLCBlbmRpbmdzPzogc3RyaW5nIH19IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGJsb2JQYXJ0cyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGJsb2JQYXJ0cyAhPT0gJ29iamVjdCcgfHwgYmxvYlBhcnRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0Jsb2JcXCc6IFRoZSBwcm92aWRlZCB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgc2VxdWVuY2UuJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGJsb2JQYXJ0c1tTeW1ib2wuaXRlcmF0b3JdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0Jsb2JcXCc6IFRoZSBvYmplY3QgbXVzdCBoYXZlIGEgY2FsbGFibGUgQEBpdGVyYXRvciBwcm9wZXJ0eS4nKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnQmxvYlxcJzogcGFyYW1ldGVyIDIgY2Fubm90IGNvbnZlcnQgdG8gZGljdGlvbmFyeS4nKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09PSBudWxsKSBvcHRpb25zID0ge31cblxuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBibG9iUGFydHMpIHtcbiAgICAgIGxldCBwYXJ0XG4gICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGVsZW1lbnQpKSB7XG4gICAgICAgIHBhcnQgPSBuZXcgVWludDhBcnJheShlbGVtZW50LmJ1ZmZlci5zbGljZShlbGVtZW50LmJ5dGVPZmZzZXQsIGVsZW1lbnQuYnl0ZU9mZnNldCArIGVsZW1lbnQuYnl0ZUxlbmd0aCkpXG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBwYXJ0ID0gbmV3IFVpbnQ4QXJyYXkoZWxlbWVudC5zbGljZSgwKSlcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgcGFydCA9IGVsZW1lbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnQgPSBlbmNvZGVyLmVuY29kZShgJHtlbGVtZW50fWApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI3NpemUgKz0gQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpID8gcGFydC5ieXRlTGVuZ3RoIDogcGFydC5zaXplXG4gICAgICB0aGlzLiNwYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuXG4gICAgdGhpcy4jZW5kaW5ncyA9IGAke29wdGlvbnMuZW5kaW5ncyA9PT0gdW5kZWZpbmVkID8gJ3RyYW5zcGFyZW50JyA6IG9wdGlvbnMuZW5kaW5nc31gXG4gICAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcob3B0aW9ucy50eXBlKVxuICAgIHRoaXMuI3R5cGUgPSAvXltcXHgyMC1cXHg3RV0qJC8udGVzdCh0eXBlKSA/IHR5cGUgOiAnJ1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBCbG9iIGludGVyZmFjZSdzIHNpemUgcHJvcGVydHkgcmV0dXJucyB0aGVcbiAgICogc2l6ZSBvZiB0aGUgQmxvYiBpbiBieXRlcy5cbiAgICovXG4gIGdldCBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2l6ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIHByb3BlcnR5IG9mIGEgQmxvYiBvYmplY3QgcmV0dXJucyB0aGUgTUlNRSB0eXBlIG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLiN0eXBlXG4gIH1cblxuICAvKipcbiAgICogVGhlIHRleHQoKSBtZXRob2QgaW4gdGhlIEJsb2IgaW50ZXJmYWNlIHJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHN0cmluZyBjb250YWluaW5nIHRoZSBjb250ZW50cyBvZlxuICAgKiB0aGUgYmxvYiwgaW50ZXJwcmV0ZWQgYXMgVVRGLTguXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICovXG4gIGFzeW5jIHRleHQgKCkge1xuICAgIC8vIE1vcmUgb3B0aW1pemVkIHRoYW4gdXNpbmcgdGhpcy5hcnJheUJ1ZmZlcigpXG4gICAgLy8gdGhhdCByZXF1aXJlcyB0d2ljZSBhcyBtdWNoIHJhbVxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICAgIGxldCBzdHIgPSAnJ1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiB0b0l0ZXJhdG9yKHRoaXMuI3BhcnRzLCBmYWxzZSkpIHtcbiAgICAgIHN0ciArPSBkZWNvZGVyLmRlY29kZShwYXJ0LCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgIH1cbiAgICAvLyBSZW1haW5pbmdcbiAgICBzdHIgKz0gZGVjb2Rlci5kZWNvZGUoKVxuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgaW4gdGhlIEJsb2IgaW50ZXJmYWNlIHJldHVybnMgYVxuICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGJsb2IgYXNcbiAgICogYmluYXJ5IGRhdGEgY29udGFpbmVkIGluIGFuIEFycmF5QnVmZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGFzeW5jIGFycmF5QnVmZmVyICgpIHtcbiAgICAvLyBFYXNpZXIgd2F5Li4uIEp1c3QgYSB1bm5lY2Vzc2FyeSBvdmVyaGVhZFxuICAgIC8vIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemUpO1xuICAgIC8vIGF3YWl0IHRoaXMuc3RyZWFtKCkuZ2V0UmVhZGVyKHttb2RlOiAnYnlvYid9KS5yZWFkKHZpZXcpO1xuICAgIC8vIHJldHVybiB2aWV3LmJ1ZmZlcjtcblxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemUpXG4gICAgbGV0IG9mZnNldCA9IDBcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRvSXRlcmF0b3IodGhpcy4jcGFydHMsIGZhbHNlKSkge1xuICAgICAgZGF0YS5zZXQoY2h1bmssIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5idWZmZXJcbiAgfVxuXG4gIHN0cmVhbSAoKSB7XG4gICAgY29uc3QgaXQgPSB0b0l0ZXJhdG9yKHRoaXMuI3BhcnRzLCB0cnVlKVxuXG4gICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICBhc3luYyBwdWxsIChjdHJsKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgaXQubmV4dCgpXG4gICAgICAgIGNodW5rLmRvbmUgPyBjdHJsLmNsb3NlKCkgOiBjdHJsLmVucXVldWUoY2h1bmsudmFsdWUpXG4gICAgICB9LFxuXG4gICAgICBhc3luYyBjYW5jZWwgKCkge1xuICAgICAgICBhd2FpdCBpdC5yZXR1cm4oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVGhlIEJsb2IgaW50ZXJmYWNlJ3Mgc2xpY2UoKSBtZXRob2QgY3JlYXRlcyBhbmQgcmV0dXJucyBhXG4gICAqIG5ldyBCbG9iIG9iamVjdCB3aGljaCBjb250YWlucyBkYXRhIGZyb20gYSBzdWJzZXQgb2YgdGhlXG4gICAqIGJsb2Igb24gd2hpY2ggaXQncyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdXG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLnNpemUsIHR5cGUgPSAnJykge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gdGhpc1xuXG4gICAgbGV0IHJlbGF0aXZlU3RhcnQgPSBzdGFydCA8IDAgPyBNYXRoLm1heChzaXplICsgc3RhcnQsIDApIDogTWF0aC5taW4oc3RhcnQsIHNpemUpXG4gICAgbGV0IHJlbGF0aXZlRW5kID0gZW5kIDwgMCA/IE1hdGgubWF4KHNpemUgKyBlbmQsIDApIDogTWF0aC5taW4oZW5kLCBzaXplKVxuXG4gICAgY29uc3Qgc3BhbiA9IE1hdGgubWF4KHJlbGF0aXZlRW5kIC0gcmVsYXRpdmVTdGFydCwgMClcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMuI3BhcnRzXG4gICAgY29uc3QgYmxvYlBhcnRzID0gW11cbiAgICBsZXQgYWRkZWQgPSAwXG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIC8vIGRvbid0IGFkZCB0aGUgb3ZlcmZsb3cgdG8gbmV3IGJsb2JQYXJ0c1xuICAgICAgaWYgKGFkZGVkID49IHNwYW4pIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2l6ZSA9IEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSA/IHBhcnQuYnl0ZUxlbmd0aCA6IHBhcnQuc2l6ZVxuICAgICAgaWYgKHJlbGF0aXZlU3RhcnQgJiYgc2l6ZSA8PSByZWxhdGl2ZVN0YXJ0KSB7XG4gICAgICAgIC8vIFNraXAgdGhlIGJlZ2lubmluZyBhbmQgY2hhbmdlIHRoZSByZWxhdGl2ZVxuICAgICAgICAvLyBzdGFydCAmIGVuZCBwb3NpdGlvbiBhcyB3ZSBza2lwIHRoZSB1bndhbnRlZCBwYXJ0c1xuICAgICAgICByZWxhdGl2ZVN0YXJ0IC09IHNpemVcbiAgICAgICAgcmVsYXRpdmVFbmQgLT0gc2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNodW5rXG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcbiAgICAgICAgICBjaHVuayA9IHBhcnQuc3ViYXJyYXkocmVsYXRpdmVTdGFydCwgTWF0aC5taW4oc2l6ZSwgcmVsYXRpdmVFbmQpKVxuICAgICAgICAgIGFkZGVkICs9IGNodW5rLmJ5dGVMZW5ndGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVuayA9IHBhcnQuc2xpY2UocmVsYXRpdmVTdGFydCwgTWF0aC5taW4oc2l6ZSwgcmVsYXRpdmVFbmQpKVxuICAgICAgICAgIGFkZGVkICs9IGNodW5rLnNpemVcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZUVuZCAtPSBzaXplXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rKVxuICAgICAgICByZWxhdGl2ZVN0YXJ0ID0gMCAvLyBBbGwgbmV4dCBzZXF1ZW50aWFsIHBhcnRzIHNob3VsZCBzdGFydCBhdCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtdLCB7IHR5cGU6IFN0cmluZyh0eXBlKS50b0xvd2VyQ2FzZSgpIH0pXG4gICAgYmxvYi4jc2l6ZSA9IHNwYW5cbiAgICBibG9iLiNwYXJ0cyA9IGJsb2JQYXJ0c1xuXG4gICAgcmV0dXJuIGJsb2JcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdCbG9iJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChvYmplY3QpIHtcbiAgICByZXR1cm4gKFxuICAgICAgb2JqZWN0ICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKFxuICAgICAgICB0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nXG4gICAgICApICYmXG4gICAgICAvXihCbG9ifEZpbGUpJC8udGVzdChvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSlcbiAgICApXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX0Jsb2IucHJvdG90eXBlLCB7XG4gIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB0eXBlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2xpY2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KVxuXG4vKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzLkJsb2J9ICovXG5leHBvcnQgY29uc3QgQmxvYiA9IF9CbG9iXG5leHBvcnQgZGVmYXVsdCBCbG9iXG4iLCAiaW1wb3J0IEJsb2IgZnJvbSAnLi9pbmRleC5qcydcblxuY29uc3QgX0ZpbGUgPSBjbGFzcyBGaWxlIGV4dGVuZHMgQmxvYiB7XG4gICNsYXN0TW9kaWZpZWQgPSAwXG4gICNuYW1lID0gJydcblxuICAvKipcbiAgICogQHBhcmFtIHsqW119IGZpbGVCaXRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlTmFtZVxuICAgKiBAcGFyYW0ge3tsYXN0TW9kaWZpZWQ/OiBudW1iZXIsIHR5cGU/OiBzdHJpbmd9fSBvcHRpb25zXG4gICAqLy8vIEB0cy1pZ25vcmVcbiAgY29uc3RydWN0b3IgKGZpbGVCaXRzLCBmaWxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gY29uc3RydWN0ICdGaWxlJzogMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gKVxuICAgIH1cbiAgICBzdXBlcihmaWxlQml0cywgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zID09PSBudWxsKSBvcHRpb25zID0ge31cblxuICAgIC8vIFNpbXVsYXRlIFdlYklETCB0eXBlIGNhc3RpbmcgZm9yIE5hTiB2YWx1ZSBpbiBsYXN0TW9kaWZpZWQgb3B0aW9uLlxuICAgIGNvbnN0IGxhc3RNb2RpZmllZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkID09PSB1bmRlZmluZWQgPyBEYXRlLm5vdygpIDogTnVtYmVyKG9wdGlvbnMubGFzdE1vZGlmaWVkKVxuICAgIGlmICghTnVtYmVyLmlzTmFOKGxhc3RNb2RpZmllZCkpIHtcbiAgICAgIHRoaXMuI2xhc3RNb2RpZmllZCA9IGxhc3RNb2RpZmllZFxuICAgIH1cblxuICAgIHRoaXMuI25hbWUgPSBTdHJpbmcoZmlsZU5hbWUpXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI25hbWVcbiAgfVxuXG4gIGdldCBsYXN0TW9kaWZpZWQgKCkge1xuICAgIHJldHVybiB0aGlzLiNsYXN0TW9kaWZpZWRcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdGaWxlJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChvYmplY3QpIHtcbiAgICByZXR1cm4gISFvYmplY3QgJiYgb2JqZWN0IGluc3RhbmNlb2YgQmxvYiAmJlxuICAgICAgL14oRmlsZSkkLy50ZXN0KG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddKVxuICB9XG59XG5cbi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXMuRmlsZX0gKi8vLyBAdHMtaWdub3JlXG5leHBvcnQgY29uc3QgRmlsZSA9IF9GaWxlXG5leHBvcnQgZGVmYXVsdCBGaWxlXG4iLCAiLyohIGZvcm1kYXRhLXBvbHlmaWxsLiBNSVQgTGljZW5zZS4gSmltbXkgV1x1MDBFNHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cblxuaW1wb3J0IEMgZnJvbSAnZmV0Y2gtYmxvYidcbmltcG9ydCBGIGZyb20gJ2ZldGNoLWJsb2IvZmlsZS5qcydcblxudmFyIHt0b1N0cmluZ1RhZzp0LGl0ZXJhdG9yOmksaGFzSW5zdGFuY2U6aH09U3ltYm9sLFxucj1NYXRoLnJhbmRvbSxcbm09J2FwcGVuZCxzZXQsZ2V0LGdldEFsbCxkZWxldGUsa2V5cyx2YWx1ZXMsZW50cmllcyxmb3JFYWNoLGNvbnN0cnVjdG9yJy5zcGxpdCgnLCcpLFxuZj0oYSxiLGMpPT4oYSs9JycsL14oQmxvYnxGaWxlKSQvLnRlc3QoYiAmJiBiW3RdKT9bKGM9YyE9PXZvaWQgMD9jKycnOmJbdF09PSdGaWxlJz9iLm5hbWU6J2Jsb2InLGEpLGIubmFtZSE9PWN8fGJbdF09PSdibG9iJz9uZXcgRihbYl0sYyxiKTpiXTpbYSxiKycnXSksXG5lPShjLGYpPT4oZj9jOmMucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywnXFxyXFxuJykpLnJlcGxhY2UoL1xcbi9nLCclMEEnKS5yZXBsYWNlKC9cXHIvZywnJTBEJykucmVwbGFjZSgvXCIvZywnJTIyJyksXG54PShuLCBhLCBlKT0+e2lmKGEubGVuZ3RoPGUpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICcke259JyBvbiAnRm9ybURhdGEnOiAke2V9IGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthLmxlbmd0aH0gcHJlc2VudC5gKX19XG5cbmV4cG9ydCBjb25zdCBGaWxlID0gRlxuXG4vKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzLkZvcm1EYXRhfSAqL1xuZXhwb3J0IGNvbnN0IEZvcm1EYXRhID0gY2xhc3MgRm9ybURhdGEge1xuI2Q9W107XG5jb25zdHJ1Y3RvciguLi5hKXtpZihhLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gY29uc3RydWN0ICdGb3JtRGF0YSc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdIVE1MRm9ybUVsZW1lbnQnLmApfVxuZ2V0IFt0XSgpIHtyZXR1cm4gJ0Zvcm1EYXRhJ31cbltpXSgpe3JldHVybiB0aGlzLmVudHJpZXMoKX1cbnN0YXRpYyBbaF0obykge3JldHVybiBvJiZ0eXBlb2Ygbz09PSdvYmplY3QnJiZvW3RdPT09J0Zvcm1EYXRhJyYmIW0uc29tZShtPT50eXBlb2Ygb1ttXSE9J2Z1bmN0aW9uJyl9XG5hcHBlbmQoLi4uYSl7eCgnYXBwZW5kJyxhcmd1bWVudHMsMik7dGhpcy4jZC5wdXNoKGYoLi4uYSkpfVxuZGVsZXRlKGEpe3goJ2RlbGV0ZScsYXJndW1lbnRzLDEpO2ErPScnO3RoaXMuI2Q9dGhpcy4jZC5maWx0ZXIoKFtiXSk9PmIhPT1hKX1cbmdldChhKXt4KCdnZXQnLGFyZ3VtZW50cywxKTthKz0nJztmb3IodmFyIGI9dGhpcy4jZCxsPWIubGVuZ3RoLGM9MDtjPGw7YysrKWlmKGJbY11bMF09PT1hKXJldHVybiBiW2NdWzFdO3JldHVybiBudWxsfVxuZ2V0QWxsKGEsYil7eCgnZ2V0QWxsJyxhcmd1bWVudHMsMSk7Yj1bXTthKz0nJzt0aGlzLiNkLmZvckVhY2goYz0+Y1swXT09PWEmJmIucHVzaChjWzFdKSk7cmV0dXJuIGJ9XG5oYXMoYSl7eCgnaGFzJyxhcmd1bWVudHMsMSk7YSs9Jyc7cmV0dXJuIHRoaXMuI2Quc29tZShiPT5iWzBdPT09YSl9XG5mb3JFYWNoKGEsYil7eCgnZm9yRWFjaCcsYXJndW1lbnRzLDEpO2Zvcih2YXIgW2MsZF1vZiB0aGlzKWEuY2FsbChiLGQsYyx0aGlzKX1cbnNldCguLi5hKXt4KCdzZXQnLGFyZ3VtZW50cywyKTt2YXIgYj1bXSxjPSEwO2E9ZiguLi5hKTt0aGlzLiNkLmZvckVhY2goZD0+e2RbMF09PT1hWzBdP2MmJihjPSFiLnB1c2goYSkpOmIucHVzaChkKX0pO2MmJmIucHVzaChhKTt0aGlzLiNkPWJ9XG4qZW50cmllcygpe3lpZWxkKnRoaXMuI2R9XG4qa2V5cygpe2Zvcih2YXJbYV1vZiB0aGlzKXlpZWxkIGF9XG4qdmFsdWVzKCl7Zm9yKHZhclssYV1vZiB0aGlzKXlpZWxkIGF9fVxuXG4vKiogQHBhcmFtIHtGb3JtRGF0YX0gRiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1EYXRhVG9CbG9iIChGLEI9Qyl7XG52YXIgYj1gJHtyKCl9JHtyKCl9YC5yZXBsYWNlKC9cXC4vZywgJycpLnNsaWNlKC0yOCkucGFkU3RhcnQoMzIsICctJyksYz1bXSxwPWAtLSR7Yn1cXHJcXG5Db250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCJgXG5GLmZvckVhY2goKHYsbik9PnR5cGVvZiB2PT0nc3RyaW5nJ1xuP2MucHVzaChwK2UobikrYFwiXFxyXFxuXFxyXFxuJHt2LnJlcGxhY2UoL1xccig/IVxcbil8KD88IVxccilcXG4vZywgJ1xcclxcbicpfVxcclxcbmApXG46Yy5wdXNoKHArZShuKStgXCI7IGZpbGVuYW1lPVwiJHtlKHYubmFtZSwgMSl9XCJcXHJcXG5Db250ZW50LVR5cGU6ICR7di50eXBlfHxcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifVxcclxcblxcclxcbmAsIHYsICdcXHJcXG4nKSlcbmMucHVzaChgLS0ke2J9LS1gKVxucmV0dXJuIG5ldyBCKGMse3R5cGU6XCJtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT1cIitifSl9XG4iLCAiLyohIG5vZGUtZG9tZXhjZXB0aW9uLiBNSVQgTGljZW5zZS4gSmltbXkgV1x1MDBFNHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cblxuaWYgKCFnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbikge1xuICB0cnkge1xuICAgIGNvbnN0IHsgTWVzc2FnZUNoYW5uZWwgfSA9IHJlcXVpcmUoJ3dvcmtlcl90aHJlYWRzJyksXG4gICAgcG9ydCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLFxuICAgIGFiID0gbmV3IEFycmF5QnVmZmVyKClcbiAgICBwb3J0LnBvc3RNZXNzYWdlKGFiLCBbYWIsIGFiXSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdET01FeGNlcHRpb24nICYmIChcbiAgICAgIGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uID0gZXJyLmNvbnN0cnVjdG9yXG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsVGhpcy5ET01FeGNlcHRpb25cbiIsICJpbXBvcnQgeyBzdGF0U3luYywgY3JlYXRlUmVhZFN0cmVhbSwgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgYmFzZW5hbWUgfSBmcm9tICdub2RlOnBhdGgnXG5pbXBvcnQgRE9NRXhjZXB0aW9uIGZyb20gJ25vZGUtZG9tZXhjZXB0aW9uJ1xuXG5pbXBvcnQgRmlsZSBmcm9tICcuL2ZpbGUuanMnXG5pbXBvcnQgQmxvYiBmcm9tICcuL2luZGV4LmpzJ1xuXG5jb25zdCB7IHN0YXQgfSA9IGZzXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZmlsZXBhdGggb24gdGhlIGRpc2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gbWltZXR5cGUgdG8gdXNlXG4gKi9cbmNvbnN0IGJsb2JGcm9tU3luYyA9IChwYXRoLCB0eXBlKSA9PiBmcm9tQmxvYihzdGF0U3luYyhwYXRoKSwgcGF0aCwgdHlwZSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlcGF0aCBvbiB0aGUgZGlza1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBtaW1ldHlwZSB0byB1c2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPEJsb2I+fVxuICovXG5jb25zdCBibG9iRnJvbSA9IChwYXRoLCB0eXBlKSA9PiBzdGF0KHBhdGgpLnRoZW4oc3RhdCA9PiBmcm9tQmxvYihzdGF0LCBwYXRoLCB0eXBlKSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlcGF0aCBvbiB0aGUgZGlza1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBtaW1ldHlwZSB0byB1c2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPEZpbGU+fVxuICovXG5jb25zdCBmaWxlRnJvbSA9IChwYXRoLCB0eXBlKSA9PiBzdGF0KHBhdGgpLnRoZW4oc3RhdCA9PiBmcm9tRmlsZShzdGF0LCBwYXRoLCB0eXBlKSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlcGF0aCBvbiB0aGUgZGlza1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBtaW1ldHlwZSB0byB1c2VcbiAqL1xuY29uc3QgZmlsZUZyb21TeW5jID0gKHBhdGgsIHR5cGUpID0+IGZyb21GaWxlKHN0YXRTeW5jKHBhdGgpLCBwYXRoLCB0eXBlKVxuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBmcm9tQmxvYiA9IChzdGF0LCBwYXRoLCB0eXBlID0gJycpID0+IG5ldyBCbG9iKFtuZXcgQmxvYkRhdGFJdGVtKHtcbiAgcGF0aCxcbiAgc2l6ZTogc3RhdC5zaXplLFxuICBsYXN0TW9kaWZpZWQ6IHN0YXQubXRpbWVNcyxcbiAgc3RhcnQ6IDBcbn0pXSwgeyB0eXBlIH0pXG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGZyb21GaWxlID0gKHN0YXQsIHBhdGgsIHR5cGUgPSAnJykgPT4gbmV3IEZpbGUoW25ldyBCbG9iRGF0YUl0ZW0oe1xuICBwYXRoLFxuICBzaXplOiBzdGF0LnNpemUsXG4gIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zLFxuICBzdGFydDogMFxufSldLCBiYXNlbmFtZShwYXRoKSwgeyB0eXBlLCBsYXN0TW9kaWZpZWQ6IHN0YXQubXRpbWVNcyB9KVxuXG4vKipcbiAqIFRoaXMgaXMgYSBibG9iIGJhY2tlZCB1cCBieSBhIGZpbGUgb24gdGhlIGRpc2tcbiAqIHdpdGggbWluaXVtIHJlcXVpcmVtZW50LiBJdHMgd3JhcHBlZCBhcm91bmQgYSBCbG9iIGFzIGEgYmxvYlBhcnRcbiAqIHNvIHlvdSBoYXZlIG5vIGRpcmVjdCBhY2Nlc3MgdG8gdGhpcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBCbG9iRGF0YUl0ZW0ge1xuICAjcGF0aFxuICAjc3RhcnRcblxuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMuI3BhdGggPSBvcHRpb25zLnBhdGhcbiAgICB0aGlzLiNzdGFydCA9IG9wdGlvbnMuc3RhcnRcbiAgICB0aGlzLnNpemUgPSBvcHRpb25zLnNpemVcbiAgICB0aGlzLmxhc3RNb2RpZmllZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkXG4gIH1cblxuICAvKipcbiAgICogU2xpY2luZyBhcmd1bWVudHMgaXMgZmlyc3QgdmFsaWRhdGVkIGFuZCBmb3JtYXR0ZWRcbiAgICogdG8gbm90IGJlIG91dCBvZiByYW5nZSBieSBCbG9iLnByb3RvdHlwZS5zbGljZVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gbmV3IEJsb2JEYXRhSXRlbSh7XG4gICAgICBwYXRoOiB0aGlzLiNwYXRoLFxuICAgICAgbGFzdE1vZGlmaWVkOiB0aGlzLmxhc3RNb2RpZmllZCxcbiAgICAgIHNpemU6IGVuZCAtIHN0YXJ0LFxuICAgICAgc3RhcnQ6IHRoaXMuI3N0YXJ0ICsgc3RhcnRcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgKiBzdHJlYW0gKCkge1xuICAgIGNvbnN0IHsgbXRpbWVNcyB9ID0gYXdhaXQgc3RhdCh0aGlzLiNwYXRoKVxuICAgIGlmIChtdGltZU1zID4gdGhpcy5sYXN0TW9kaWZpZWQpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSByZXF1ZXN0ZWQgZmlsZSBjb3VsZCBub3QgYmUgcmVhZCwgdHlwaWNhbGx5IGR1ZSB0byBwZXJtaXNzaW9uIHByb2JsZW1zIHRoYXQgaGF2ZSBvY2N1cnJlZCBhZnRlciBhIHJlZmVyZW5jZSB0byBhIGZpbGUgd2FzIGFjcXVpcmVkLicsICdOb3RSZWFkYWJsZUVycm9yJylcbiAgICB9XG4gICAgeWllbGQgKiBjcmVhdGVSZWFkU3RyZWFtKHRoaXMuI3BhdGgsIHtcbiAgICAgIHN0YXJ0OiB0aGlzLiNzdGFydCxcbiAgICAgIGVuZDogdGhpcy4jc3RhcnQgKyB0aGlzLnNpemUgLSAxXG4gICAgfSlcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdCbG9iJ1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJsb2JGcm9tU3luY1xuZXhwb3J0IHsgRmlsZSwgQmxvYiwgYmxvYkZyb20sIGJsb2JGcm9tU3luYywgZmlsZUZyb20sIGZpbGVGcm9tU3luYyB9XG4iLCAiaW1wb3J0IHtGaWxlfSBmcm9tICdmZXRjaC1ibG9iL2Zyb20uanMnO1xuaW1wb3J0IHtGb3JtRGF0YX0gZnJvbSAnZm9ybWRhdGEtcG9seWZpbGwvZXNtLm1pbi5qcyc7XG5cbmxldCBzID0gMDtcbmNvbnN0IFMgPSB7XG5cdFNUQVJUX0JPVU5EQVJZOiBzKyssXG5cdEhFQURFUl9GSUVMRF9TVEFSVDogcysrLFxuXHRIRUFERVJfRklFTEQ6IHMrKyxcblx0SEVBREVSX1ZBTFVFX1NUQVJUOiBzKyssXG5cdEhFQURFUl9WQUxVRTogcysrLFxuXHRIRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6IHMrKyxcblx0SEVBREVSU19BTE1PU1RfRE9ORTogcysrLFxuXHRQQVJUX0RBVEFfU1RBUlQ6IHMrKyxcblx0UEFSVF9EQVRBOiBzKyssXG5cdEVORDogcysrXG59O1xuXG5sZXQgZiA9IDE7XG5jb25zdCBGID0ge1xuXHRQQVJUX0JPVU5EQVJZOiBmLFxuXHRMQVNUX0JPVU5EQVJZOiBmICo9IDJcbn07XG5cbmNvbnN0IExGID0gMTA7XG5jb25zdCBDUiA9IDEzO1xuY29uc3QgU1BBQ0UgPSAzMjtcbmNvbnN0IEhZUEhFTiA9IDQ1O1xuY29uc3QgQ09MT04gPSA1ODtcbmNvbnN0IEEgPSA5NztcbmNvbnN0IFogPSAxMjI7XG5cbmNvbnN0IGxvd2VyID0gYyA9PiBjIHwgMHgyMDtcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5jbGFzcyBNdWx0aXBhcnRQYXJzZXIge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kYXJ5XG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihib3VuZGFyeSkge1xuXHRcdHRoaXMuaW5kZXggPSAwO1xuXHRcdHRoaXMuZmxhZ3MgPSAwO1xuXG5cdFx0dGhpcy5vbkhlYWRlckVuZCA9IG5vb3A7XG5cdFx0dGhpcy5vbkhlYWRlckZpZWxkID0gbm9vcDtcblx0XHR0aGlzLm9uSGVhZGVyc0VuZCA9IG5vb3A7XG5cdFx0dGhpcy5vbkhlYWRlclZhbHVlID0gbm9vcDtcblx0XHR0aGlzLm9uUGFydEJlZ2luID0gbm9vcDtcblx0XHR0aGlzLm9uUGFydERhdGEgPSBub29wO1xuXHRcdHRoaXMub25QYXJ0RW5kID0gbm9vcDtcblxuXHRcdHRoaXMuYm91bmRhcnlDaGFycyA9IHt9O1xuXG5cdFx0Ym91bmRhcnkgPSAnXFxyXFxuLS0nICsgYm91bmRhcnk7XG5cdFx0Y29uc3QgdWk4YSA9IG5ldyBVaW50OEFycmF5KGJvdW5kYXJ5Lmxlbmd0aCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZGFyeS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dWk4YVtpXSA9IGJvdW5kYXJ5LmNoYXJDb2RlQXQoaSk7XG5cdFx0XHR0aGlzLmJvdW5kYXJ5Q2hhcnNbdWk4YVtpXV0gPSB0cnVlO1xuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRhcnkgPSB1aThhO1xuXHRcdHRoaXMubG9va2JlaGluZCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYm91bmRhcnkubGVuZ3RoICsgOCk7XG5cdFx0dGhpcy5zdGF0ZSA9IFMuU1RBUlRfQk9VTkRBUlk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG5cdCAqL1xuXHR3cml0ZShkYXRhKSB7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGNvbnN0IGxlbmd0aF8gPSBkYXRhLmxlbmd0aDtcblx0XHRsZXQgcHJldmlvdXNJbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0bGV0IHtsb29rYmVoaW5kLCBib3VuZGFyeSwgYm91bmRhcnlDaGFycywgaW5kZXgsIHN0YXRlLCBmbGFnc30gPSB0aGlzO1xuXHRcdGNvbnN0IGJvdW5kYXJ5TGVuZ3RoID0gdGhpcy5ib3VuZGFyeS5sZW5ndGg7XG5cdFx0Y29uc3QgYm91bmRhcnlFbmQgPSBib3VuZGFyeUxlbmd0aCAtIDE7XG5cdFx0Y29uc3QgYnVmZmVyTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cdFx0bGV0IGM7XG5cdFx0bGV0IGNsO1xuXG5cdFx0Y29uc3QgbWFyayA9IG5hbWUgPT4ge1xuXHRcdFx0dGhpc1tuYW1lICsgJ01hcmsnXSA9IGk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IGNsZWFyID0gbmFtZSA9PiB7XG5cdFx0XHRkZWxldGUgdGhpc1tuYW1lICsgJ01hcmsnXTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgY2FsbGJhY2sgPSAoY2FsbGJhY2tTeW1ib2wsIHN0YXJ0LCBlbmQsIHVpOGEpID0+IHtcblx0XHRcdGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0ICE9PSBlbmQpIHtcblx0XHRcdFx0dGhpc1tjYWxsYmFja1N5bWJvbF0odWk4YSAmJiB1aThhLnN1YmFycmF5KHN0YXJ0LCBlbmQpKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3QgZGF0YUNhbGxiYWNrID0gKG5hbWUsIGNsZWFyKSA9PiB7XG5cdFx0XHRjb25zdCBtYXJrU3ltYm9sID0gbmFtZSArICdNYXJrJztcblx0XHRcdGlmICghKG1hcmtTeW1ib2wgaW4gdGhpcykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xlYXIpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmFtZSwgdGhpc1ttYXJrU3ltYm9sXSwgaSwgZGF0YSk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzW21hcmtTeW1ib2xdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sobmFtZSwgdGhpc1ttYXJrU3ltYm9sXSwgZGF0YS5sZW5ndGgsIGRhdGEpO1xuXHRcdFx0XHR0aGlzW21hcmtTeW1ib2xdID0gMDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aF87IGkrKykge1xuXHRcdFx0YyA9IGRhdGFbaV07XG5cblx0XHRcdHN3aXRjaCAoc3RhdGUpIHtcblx0XHRcdFx0Y2FzZSBTLlNUQVJUX0JPVU5EQVJZOlxuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gYm91bmRhcnkubGVuZ3RoIC0gMikge1xuXHRcdFx0XHRcdFx0aWYgKGMgPT09IEhZUEhFTikge1xuXHRcdFx0XHRcdFx0XHRmbGFncyB8PSBGLkxBU1RfQk9VTkRBUlk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgIT09IENSKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggLSAxID09PSBib3VuZGFyeS5sZW5ndGggLSAyKSB7XG5cdFx0XHRcdFx0XHRpZiAoZmxhZ3MgJiBGLkxBU1RfQk9VTkRBUlkgJiYgYyA9PT0gSFlQSEVOKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gUy5FTkQ7XG5cdFx0XHRcdFx0XHRcdGZsYWdzID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIShmbGFncyAmIEYuTEFTVF9CT1VOREFSWSkgJiYgYyA9PT0gTEYpIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjaygnb25QYXJ0QmVnaW4nKTtcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgIT09IGJvdW5kYXJ5W2luZGV4ICsgMl0pIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gLTI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgPT09IGJvdW5kYXJ5W2luZGV4ICsgMl0pIHtcblx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5IRUFERVJfRklFTERfU1RBUlQ6XG5cdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRDtcblx0XHRcdFx0XHRtYXJrKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdC8vIGZhbGxzIHRocm91Z2hcblx0XHRcdFx0Y2FzZSBTLkhFQURFUl9GSUVMRDpcblx0XHRcdFx0XHRpZiAoYyA9PT0gQ1IpIHtcblx0XHRcdFx0XHRcdGNsZWFyKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFMuSEVBREVSU19BTE1PU1RfRE9ORTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0aWYgKGMgPT09IEhZUEhFTikge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgPT09IENPTE9OKSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5kZXggPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0Ly8gZW1wdHkgaGVhZGVyIGZpZWxkXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlckZpZWxkJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFMuSEVBREVSX1ZBTFVFX1NUQVJUO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2wgPSBsb3dlcihjKTtcblx0XHRcdFx0XHRpZiAoY2wgPCBBIHx8IGNsID4gWikge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFMuSEVBREVSX1ZBTFVFX1NUQVJUOlxuXHRcdFx0XHRcdGlmIChjID09PSBTUEFDRSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWFyaygnb25IZWFkZXJWYWx1ZScpO1xuXHRcdFx0XHRcdHN0YXRlID0gUy5IRUFERVJfVkFMVUU7XG5cdFx0XHRcdFx0Ly8gZmFsbHMgdGhyb3VnaFxuXHRcdFx0XHRjYXNlIFMuSEVBREVSX1ZBTFVFOlxuXHRcdFx0XHRcdGlmIChjID09PSBDUikge1xuXHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlclZhbHVlJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygnb25IZWFkZXJFbmQnKTtcblx0XHRcdFx0XHRcdHN0YXRlID0gUy5IRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5IRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6XG5cdFx0XHRcdFx0aWYgKGMgIT09IExGKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBTLkhFQURFUlNfQUxNT1NUX0RPTkU6XG5cdFx0XHRcdFx0aWYgKGMgIT09IExGKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FsbGJhY2soJ29uSGVhZGVyc0VuZCcpO1xuXHRcdFx0XHRcdHN0YXRlID0gUy5QQVJUX0RBVEFfU1RBUlQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5QQVJUX0RBVEFfU1RBUlQ6XG5cdFx0XHRcdFx0c3RhdGUgPSBTLlBBUlRfREFUQTtcblx0XHRcdFx0XHRtYXJrKCdvblBhcnREYXRhJyk7XG5cdFx0XHRcdFx0Ly8gZmFsbHMgdGhyb3VnaFxuXHRcdFx0XHRjYXNlIFMuUEFSVF9EQVRBOlxuXHRcdFx0XHRcdHByZXZpb3VzSW5kZXggPSBpbmRleDtcblxuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Ly8gYm95ZXItbW9vcmUgZGVycml2ZWQgYWxnb3JpdGhtIHRvIHNhZmVseSBza2lwIG5vbi1ib3VuZGFyeSBkYXRhXG5cdFx0XHRcdFx0XHRpICs9IGJvdW5kYXJ5RW5kO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBidWZmZXJMZW5ndGggJiYgIShkYXRhW2ldIGluIGJvdW5kYXJ5Q2hhcnMpKSB7XG5cdFx0XHRcdFx0XHRcdGkgKz0gYm91bmRhcnlMZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGkgLT0gYm91bmRhcnlFbmQ7XG5cdFx0XHRcdFx0XHRjID0gZGF0YVtpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaW5kZXggPCBib3VuZGFyeS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChib3VuZGFyeVtpbmRleF0gPT09IGMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvblBhcnREYXRhJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IGJvdW5kYXJ5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdGlmIChjID09PSBDUikge1xuXHRcdFx0XHRcdFx0XHQvLyBDUiA9IHBhcnQgYm91bmRhcnlcblx0XHRcdFx0XHRcdFx0ZmxhZ3MgfD0gRi5QQVJUX0JPVU5EQVJZO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBIWVBIRU4pIHtcblx0XHRcdFx0XHRcdFx0Ly8gSFlQSEVOID0gZW5kIGJvdW5kYXJ5XG5cdFx0XHRcdFx0XHRcdGZsYWdzIHw9IEYuTEFTVF9CT1VOREFSWTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGluZGV4IC0gMSA9PT0gYm91bmRhcnkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoZmxhZ3MgJiBGLlBBUlRfQk9VTkRBUlkpIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRpZiAoYyA9PT0gTEYpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB1bnNldCB0aGUgUEFSVF9CT1VOREFSWSBmbGFnXG5cdFx0XHRcdFx0XHRcdFx0ZmxhZ3MgJj0gfkYuUEFSVF9CT1VOREFSWTtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjaygnb25QYXJ0RW5kJyk7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soJ29uUGFydEJlZ2luJyk7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChmbGFncyAmIEYuTEFTVF9CT1VOREFSWSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYyA9PT0gSFlQSEVOKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soJ29uUGFydEVuZCcpO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlID0gUy5FTkQ7XG5cdFx0XHRcdFx0XHRcdFx0ZmxhZ3MgPSAwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpbmRleCA+IDApIHtcblx0XHRcdFx0XHRcdC8vIHdoZW4gbWF0Y2hpbmcgYSBwb3NzaWJsZSBib3VuZGFyeSwga2VlcCBhIGxvb2tiZWhpbmQgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHQvLyBpbiBjYXNlIGl0IHR1cm5zIG91dCB0byBiZSBhIGZhbHNlIGxlYWRcblx0XHRcdFx0XHRcdGxvb2tiZWhpbmRbaW5kZXggLSAxXSA9IGM7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwcmV2aW91c0luZGV4ID4gMCkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgb3VyIGJvdW5kYXJ5IHR1cm5lZCBvdXQgdG8gYmUgcnViYmlzaCwgdGhlIGNhcHR1cmVkIGxvb2tiZWhpbmRcblx0XHRcdFx0XHRcdC8vIGJlbG9uZ3MgdG8gcGFydERhdGFcblx0XHRcdFx0XHRcdGNvbnN0IF9sb29rYmVoaW5kID0gbmV3IFVpbnQ4QXJyYXkobG9va2JlaGluZC5idWZmZXIsIGxvb2tiZWhpbmQuYnl0ZU9mZnNldCwgbG9va2JlaGluZC5ieXRlTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCdvblBhcnREYXRhJywgMCwgcHJldmlvdXNJbmRleCwgX2xvb2tiZWhpbmQpO1xuXHRcdFx0XHRcdFx0cHJldmlvdXNJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRtYXJrKCdvblBhcnREYXRhJyk7XG5cblx0XHRcdFx0XHRcdC8vIHJlY29uc2lkZXIgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGV2ZW4gc28gaXQgaW50ZXJydXB0ZWQgdGhlIHNlcXVlbmNlXG5cdFx0XHRcdFx0XHQvLyBpdCBjb3VsZCBiZSB0aGUgYmVnaW5uaW5nIG9mIGEgbmV3IHNlcXVlbmNlXG5cdFx0XHRcdFx0XHRpLS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5FTkQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHN0YXRlIGVudGVyZWQ6ICR7c3RhdGV9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlclZhbHVlJyk7XG5cdFx0ZGF0YUNhbGxiYWNrKCdvblBhcnREYXRhJyk7XG5cblx0XHQvLyBVcGRhdGUgcHJvcGVydGllcyBmb3IgdGhlIG5leHQgY2FsbFxuXHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cdFx0dGhpcy5mbGFncyA9IGZsYWdzO1xuXHR9XG5cblx0ZW5kKCkge1xuXHRcdGlmICgodGhpcy5zdGF0ZSA9PT0gUy5IRUFERVJfRklFTERfU1RBUlQgJiYgdGhpcy5pbmRleCA9PT0gMCkgfHxcblx0XHRcdCh0aGlzLnN0YXRlID09PSBTLlBBUlRfREFUQSAmJiB0aGlzLmluZGV4ID09PSB0aGlzLmJvdW5kYXJ5Lmxlbmd0aCkpIHtcblx0XHRcdHRoaXMub25QYXJ0RW5kKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN0YXRlICE9PSBTLkVORCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdWx0aXBhcnRQYXJzZXIuZW5kKCk6IHN0cmVhbSBlbmRlZCB1bmV4cGVjdGVkbHknKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gX2ZpbGVOYW1lKGhlYWRlclZhbHVlKSB7XG5cdC8vIG1hdGNoZXMgZWl0aGVyIGEgcXVvdGVkLXN0cmluZyBvciBhIHRva2VuIChSRkMgMjYxNiBzZWN0aW9uIDE5LjUuMSlcblx0Y29uc3QgbSA9IGhlYWRlclZhbHVlLm1hdGNoKC9cXGJmaWxlbmFtZT0oXCIoLio/KVwifChbXigpPD5ALDs6XFxcXFwiL1tcXF0/PXt9XFxzXFx0XSspKSgkfDtcXHMpL2kpO1xuXHRpZiAoIW0pIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBtYXRjaCA9IG1bMl0gfHwgbVszXSB8fCAnJztcblx0bGV0IGZpbGVuYW1lID0gbWF0Y2guc2xpY2UobWF0Y2gubGFzdEluZGV4T2YoJ1xcXFwnKSArIDEpO1xuXHRmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoLyUyMi9nLCAnXCInKTtcblx0ZmlsZW5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKC8mIyhcXGR7NH0pOy9nLCAobSwgY29kZSkgPT4ge1xuXHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXHR9KTtcblx0cmV0dXJuIGZpbGVuYW1lO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9Gb3JtRGF0YShCb2R5LCBjdCkge1xuXHRpZiAoIS9tdWx0aXBhcnQvaS50ZXN0KGN0KSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCcpO1xuXHR9XG5cblx0Y29uc3QgbSA9IGN0Lm1hdGNoKC9ib3VuZGFyeT0oPzpcIihbXlwiXSspXCJ8KFteO10rKSkvaSk7XG5cblx0aWYgKCFtKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignbm8gb3IgYmFkIGNvbnRlbnQtdHlwZSBoZWFkZXIsIG5vIG11bHRpcGFydCBib3VuZGFyeScpO1xuXHR9XG5cblx0Y29uc3QgcGFyc2VyID0gbmV3IE11bHRpcGFydFBhcnNlcihtWzFdIHx8IG1bMl0pO1xuXG5cdGxldCBoZWFkZXJGaWVsZDtcblx0bGV0IGhlYWRlclZhbHVlO1xuXHRsZXQgZW50cnlWYWx1ZTtcblx0bGV0IGVudHJ5TmFtZTtcblx0bGV0IGNvbnRlbnRUeXBlO1xuXHRsZXQgZmlsZW5hbWU7XG5cdGNvbnN0IGVudHJ5Q2h1bmtzID0gW107XG5cdGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cblx0Y29uc3Qgb25QYXJ0RGF0YSA9IHVpOGEgPT4ge1xuXHRcdGVudHJ5VmFsdWUgKz0gZGVjb2Rlci5kZWNvZGUodWk4YSwge3N0cmVhbTogdHJ1ZX0pO1xuXHR9O1xuXG5cdGNvbnN0IGFwcGVuZFRvRmlsZSA9IHVpOGEgPT4ge1xuXHRcdGVudHJ5Q2h1bmtzLnB1c2godWk4YSk7XG5cdH07XG5cblx0Y29uc3QgYXBwZW5kRmlsZVRvRm9ybURhdGEgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZmlsZSA9IG5ldyBGaWxlKGVudHJ5Q2h1bmtzLCBmaWxlbmFtZSwge3R5cGU6IGNvbnRlbnRUeXBlfSk7XG5cdFx0Zm9ybURhdGEuYXBwZW5kKGVudHJ5TmFtZSwgZmlsZSk7XG5cdH07XG5cblx0Y29uc3QgYXBwZW5kRW50cnlUb0Zvcm1EYXRhID0gKCkgPT4ge1xuXHRcdGZvcm1EYXRhLmFwcGVuZChlbnRyeU5hbWUsIGVudHJ5VmFsdWUpO1xuXHR9O1xuXG5cdGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG5cdGRlY29kZXIuZGVjb2RlKCk7XG5cblx0cGFyc2VyLm9uUGFydEJlZ2luID0gZnVuY3Rpb24gKCkge1xuXHRcdHBhcnNlci5vblBhcnREYXRhID0gb25QYXJ0RGF0YTtcblx0XHRwYXJzZXIub25QYXJ0RW5kID0gYXBwZW5kRW50cnlUb0Zvcm1EYXRhO1xuXG5cdFx0aGVhZGVyRmllbGQgPSAnJztcblx0XHRoZWFkZXJWYWx1ZSA9ICcnO1xuXHRcdGVudHJ5VmFsdWUgPSAnJztcblx0XHRlbnRyeU5hbWUgPSAnJztcblx0XHRjb250ZW50VHlwZSA9ICcnO1xuXHRcdGZpbGVuYW1lID0gbnVsbDtcblx0XHRlbnRyeUNodW5rcy5sZW5ndGggPSAwO1xuXHR9O1xuXG5cdHBhcnNlci5vbkhlYWRlckZpZWxkID0gZnVuY3Rpb24gKHVpOGEpIHtcblx0XHRoZWFkZXJGaWVsZCArPSBkZWNvZGVyLmRlY29kZSh1aThhLCB7c3RyZWFtOiB0cnVlfSk7XG5cdH07XG5cblx0cGFyc2VyLm9uSGVhZGVyVmFsdWUgPSBmdW5jdGlvbiAodWk4YSkge1xuXHRcdGhlYWRlclZhbHVlICs9IGRlY29kZXIuZGVjb2RlKHVpOGEsIHtzdHJlYW06IHRydWV9KTtcblx0fTtcblxuXHRwYXJzZXIub25IZWFkZXJFbmQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aGVhZGVyVmFsdWUgKz0gZGVjb2Rlci5kZWNvZGUoKTtcblx0XHRoZWFkZXJGaWVsZCA9IGhlYWRlckZpZWxkLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoaGVhZGVyRmllbGQgPT09ICdjb250ZW50LWRpc3Bvc2l0aW9uJykge1xuXHRcdFx0Ly8gbWF0Y2hlcyBlaXRoZXIgYSBxdW90ZWQtc3RyaW5nIG9yIGEgdG9rZW4gKFJGQyAyNjE2IHNlY3Rpb24gMTkuNS4xKVxuXHRcdFx0Y29uc3QgbSA9IGhlYWRlclZhbHVlLm1hdGNoKC9cXGJuYW1lPShcIihbXlwiXSopXCJ8KFteKCk8PkAsOzpcXFxcXCIvW1xcXT89e31cXHNcXHRdKykpL2kpO1xuXG5cdFx0XHRpZiAobSkge1xuXHRcdFx0XHRlbnRyeU5hbWUgPSBtWzJdIHx8IG1bM10gfHwgJyc7XG5cdFx0XHR9XG5cblx0XHRcdGZpbGVuYW1lID0gX2ZpbGVOYW1lKGhlYWRlclZhbHVlKTtcblxuXHRcdFx0aWYgKGZpbGVuYW1lKSB7XG5cdFx0XHRcdHBhcnNlci5vblBhcnREYXRhID0gYXBwZW5kVG9GaWxlO1xuXHRcdFx0XHRwYXJzZXIub25QYXJ0RW5kID0gYXBwZW5kRmlsZVRvRm9ybURhdGE7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChoZWFkZXJGaWVsZCA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcblx0XHRcdGNvbnRlbnRUeXBlID0gaGVhZGVyVmFsdWU7XG5cdFx0fVxuXG5cdFx0aGVhZGVyVmFsdWUgPSAnJztcblx0XHRoZWFkZXJGaWVsZCA9ICcnO1xuXHR9O1xuXG5cdGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgQm9keSkge1xuXHRcdHBhcnNlci53cml0ZShjaHVuayk7XG5cdH1cblxuXHRwYXJzZXIuZW5kKCk7XG5cblx0cmV0dXJuIGZvcm1EYXRhO1xufVxuIiwgIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qIFRoZSBsb2NhbCBmaWxlIGhlYWRlciAqL1xuICAgIExPQ0hEUiAgICAgICAgICAgOiAzMCwgLy8gTE9DIGhlYWRlciBzaXplXG4gICAgTE9DU0lHICAgICAgICAgICA6IDB4MDQwMzRiNTAsIC8vIFwiUEtcXDAwM1xcMDA0XCJcbiAgICBMT0NWRVIgICAgICAgICAgIDogNCxcdC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBMT0NGTEcgICAgICAgICAgIDogNiwgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgTE9DSE9XICAgICAgICAgICA6IDgsIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgIExPQ1RJTSAgICAgICAgICAgOiAxMCwgLy8gbW9kaWZpY2F0aW9uIHRpbWUgKDIgYnl0ZXMgdGltZSwgMiBieXRlcyBkYXRlKVxuICAgIExPQ0NSQyAgICAgICAgICAgOiAxNCwgLy8gdW5jb21wcmVzc2VkIGZpbGUgY3JjLTMyIHZhbHVlXG4gICAgTE9DU0laICAgICAgICAgICA6IDE4LCAvLyBjb21wcmVzc2VkIHNpemVcbiAgICBMT0NMRU4gICAgICAgICAgIDogMjIsIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgTE9DTkFNICAgICAgICAgICA6IDI2LCAvLyBmaWxlbmFtZSBsZW5ndGhcbiAgICBMT0NFWFQgICAgICAgICAgIDogMjgsIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuXG4gICAgLyogVGhlIERhdGEgZGVzY3JpcHRvciAqL1xuICAgIEVYVFNJRyAgICAgICAgICAgOiAweDA4MDc0YjUwLCAvLyBcIlBLXFwwMDdcXDAwOFwiXG4gICAgRVhUSERSICAgICAgICAgICA6IDE2LCAvLyBFWFQgaGVhZGVyIHNpemVcbiAgICBFWFRDUkMgICAgICAgICAgIDogNCwgLy8gdW5jb21wcmVzc2VkIGZpbGUgY3JjLTMyIHZhbHVlXG4gICAgRVhUU0laICAgICAgICAgICA6IDgsIC8vIGNvbXByZXNzZWQgc2l6ZVxuICAgIEVYVExFTiAgICAgICAgICAgOiAxMiwgLy8gdW5jb21wcmVzc2VkIHNpemVcblxuICAgIC8qIFRoZSBjZW50cmFsIGRpcmVjdG9yeSBmaWxlIGhlYWRlciAqL1xuICAgIENFTkhEUiAgICAgICAgICAgOiA0NiwgLy8gQ0VOIGhlYWRlciBzaXplXG4gICAgQ0VOU0lHICAgICAgICAgICA6IDB4MDIwMTRiNTAsIC8vIFwiUEtcXDAwMVxcMDAyXCJcbiAgICBDRU5WRU0gICAgICAgICAgIDogNCwgLy8gdmVyc2lvbiBtYWRlIGJ5XG4gICAgQ0VOVkVSICAgICAgICAgICA6IDYsIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBDRU5GTEcgICAgICAgICAgIDogOCwgLy8gZW5jcnlwdCwgZGVjcnlwdCBmbGFnc1xuICAgIENFTkhPVyAgICAgICAgICAgOiAxMCwgLy8gY29tcHJlc3Npb24gbWV0aG9kXG4gICAgQ0VOVElNICAgICAgICAgICA6IDEyLCAvLyBtb2RpZmljYXRpb24gdGltZSAoMiBieXRlcyB0aW1lLCAyIGJ5dGVzIGRhdGUpXG4gICAgQ0VOQ1JDICAgICAgICAgICA6IDE2LCAvLyB1bmNvbXByZXNzZWQgZmlsZSBjcmMtMzIgdmFsdWVcbiAgICBDRU5TSVogICAgICAgICAgIDogMjAsIC8vIGNvbXByZXNzZWQgc2l6ZVxuICAgIENFTkxFTiAgICAgICAgICAgOiAyNCwgLy8gdW5jb21wcmVzc2VkIHNpemVcbiAgICBDRU5OQU0gICAgICAgICAgIDogMjgsIC8vIGZpbGVuYW1lIGxlbmd0aFxuICAgIENFTkVYVCAgICAgICAgICAgOiAzMCwgLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG4gICAgQ0VOQ09NICAgICAgICAgICA6IDMyLCAvLyBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgQ0VORFNLICAgICAgICAgICA6IDM0LCAvLyB2b2x1bWUgbnVtYmVyIHN0YXJ0XG4gICAgQ0VOQVRUICAgICAgICAgICA6IDM2LCAvLyBpbnRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICBDRU5BVFggICAgICAgICAgIDogMzgsIC8vIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcyAoaG9zdCBzeXN0ZW0gZGVwZW5kZW50KVxuICAgIENFTk9GRiAgICAgICAgICAgOiA0MiwgLy8gTE9DIGhlYWRlciBvZmZzZXRcblxuICAgIC8qIFRoZSBlbnRyaWVzIGluIHRoZSBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgKi9cbiAgICBFTkRIRFIgICAgICAgICAgIDogMjIsIC8vIEVORCBoZWFkZXIgc2l6ZVxuICAgIEVORFNJRyAgICAgICAgICAgOiAweDA2MDU0YjUwLCAvLyBcIlBLXFwwMDVcXDAwNlwiXG4gICAgRU5EU1VCICAgICAgICAgICA6IDgsIC8vIG51bWJlciBvZiBlbnRyaWVzIG9uIHRoaXMgZGlza1xuICAgIEVORFRPVCAgICAgICAgICAgOiAxMCwgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXNcbiAgICBFTkRTSVogICAgICAgICAgIDogMTIsIC8vIGNlbnRyYWwgZGlyZWN0b3J5IHNpemUgaW4gYnl0ZXNcbiAgICBFTkRPRkYgICAgICAgICAgIDogMTYsIC8vIG9mZnNldCBvZiBmaXJzdCBDRU4gaGVhZGVyXG4gICAgRU5EQ09NICAgICAgICAgICA6IDIwLCAvLyB6aXAgZmlsZSBjb21tZW50IGxlbmd0aFxuXG4gICAgRU5ENjRIRFIgICAgICAgICA6IDIwLCAvLyB6aXA2NCBFTkQgaGVhZGVyIHNpemVcbiAgICBFTkQ2NFNJRyAgICAgICAgIDogMHgwNzA2NGI1MCwgLy8gemlwNjQgTG9jYXRvciBzaWduYXR1cmUsIFwiUEtcXDAwNlxcMDA3XCJcbiAgICBFTkQ2NFNUQVJUICAgICAgIDogNCwgLy8gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSB6aXA2NFxuICAgIEVORDY0T0ZGICAgICAgICAgOiA4LCAvLyByZWxhdGl2ZSBvZmZzZXQgb2YgdGhlIHppcDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVxuICAgIEVORDY0TlVNRElTS1MgICAgOiAxNiwgLy8gdG90YWwgbnVtYmVyIG9mIGRpc2tzXG5cbiAgICBaSVA2NFNJRyAgICAgICAgIDogMHgwNjA2NGI1MCwgLy8gemlwNjQgc2lnbmF0dXJlLCBcIlBLXFwwMDZcXDAwNlwiXG4gICAgWklQNjRIRFIgICAgICAgICA6IDU2LCAvLyB6aXA2NCByZWNvcmQgbWluaW11bSBzaXplXG4gICAgWklQNjRMRUFEICAgICAgICA6IDEyLCAvLyBsZWFkaW5nIGJ5dGVzIGF0IHRoZSBzdGFydCBvZiB0aGUgcmVjb3JkLCBub3QgY291bnRlZCBieSB0aGUgdmFsdWUgc3RvcmVkIGluIFpJUDY0U0laRVxuICAgIFpJUDY0U0laRSAgICAgICAgOiA0LCAvLyB6aXA2NCBzaXplIG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmRcbiAgICBaSVA2NFZFTSAgICAgICAgIDogMTIsIC8vIHppcDY0IHZlcnNpb24gbWFkZSBieVxuICAgIFpJUDY0VkVSICAgICAgICAgOiAxNCwgLy8gemlwNjQgdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgIFpJUDY0RFNLICAgICAgICAgOiAxNiwgLy8gemlwNjQgbnVtYmVyIG9mIHRoaXMgZGlza1xuICAgIFpJUDY0RFNLRElSICAgICAgOiAyMCwgLy8gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSByZWNvcmQgZGlyZWN0b3J5XG4gICAgWklQNjRTVUIgICAgICAgICA6IDI0LCAvLyBudW1iZXIgb2YgZW50cmllcyBvbiB0aGlzIGRpc2tcbiAgICBaSVA2NFRPVCAgICAgICAgIDogMzIsIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzXG4gICAgWklQNjRTSVpCICAgICAgICA6IDQwLCAvLyB6aXA2NCBjZW50cmFsIGRpcmVjdG9yeSBzaXplIGluIGJ5dGVzXG4gICAgWklQNjRPRkYgICAgICAgICA6IDQ4LCAvLyBvZmZzZXQgb2Ygc3RhcnQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgd2l0aCByZXNwZWN0IHRvIHRoZSBzdGFydGluZyBkaXNrIG51bWJlclxuICAgIFpJUDY0RVhUUkEgICAgICAgOiA1NiwgLy8gZXh0ZW5zaWJsZSBkYXRhIHNlY3RvclxuXG4gICAgLyogQ29tcHJlc3Npb24gbWV0aG9kcyAqL1xuICAgIFNUT1JFRCAgICAgICAgICAgOiAwLCAvLyBubyBjb21wcmVzc2lvblxuICAgIFNIUlVOSyAgICAgICAgICAgOiAxLCAvLyBzaHJ1bmtcbiAgICBSRURVQ0VEMSAgICAgICAgIDogMiwgLy8gcmVkdWNlZCB3aXRoIGNvbXByZXNzaW9uIGZhY3RvciAxXG4gICAgUkVEVUNFRDIgICAgICAgICA6IDMsIC8vIHJlZHVjZWQgd2l0aCBjb21wcmVzc2lvbiBmYWN0b3IgMlxuICAgIFJFRFVDRUQzICAgICAgICAgOiA0LCAvLyByZWR1Y2VkIHdpdGggY29tcHJlc3Npb24gZmFjdG9yIDNcbiAgICBSRURVQ0VENCAgICAgICAgIDogNSwgLy8gcmVkdWNlZCB3aXRoIGNvbXByZXNzaW9uIGZhY3RvciA0XG4gICAgSU1QTE9ERUQgICAgICAgICA6IDYsIC8vIGltcGxvZGVkXG4gICAgLy8gNyByZXNlcnZlZCBmb3IgVG9rZW5pemluZyBjb21wcmVzc2lvbiBhbGdvcml0aG1cbiAgICBERUZMQVRFRCAgICAgICAgIDogOCwgLy8gZGVmbGF0ZWRcbiAgICBFTkhBTkNFRF9ERUZMQVRFRDogOSwgLy8gZW5oYW5jZWQgZGVmbGF0ZWRcbiAgICBQS1dBUkUgICAgICAgICAgIDogMTAsLy8gUEtXYXJlIERDTCBpbXBsb2RlZFxuICAgIC8vIDExIHJlc2VydmVkIGJ5IFBLV0FSRVxuICAgIEJaSVAyICAgICAgICAgICAgOiAxMiwgLy8gIGNvbXByZXNzZWQgdXNpbmcgQlpJUDJcbiAgICAvLyAxMyByZXNlcnZlZCBieSBQS1dBUkVcbiAgICBMWk1BICAgICAgICAgICAgIDogMTQsIC8vIExaTUFcbiAgICAvLyAxNS0xNyByZXNlcnZlZCBieSBQS1dBUkVcbiAgICBJQk1fVEVSU0UgICAgICAgIDogMTgsIC8vIGNvbXByZXNzZWQgdXNpbmcgSUJNIFRFUlNFXG4gICAgSUJNX0xaNzcgICAgICAgICA6IDE5LCAvLyBJQk0gTFo3NyB6XG4gICAgQUVTX0VOQ1JZUFQgICAgICA6IDk5LCAvLyBXaW5aSVAgQUVTIGVuY3J5cHRpb24gbWV0aG9kXG5cbiAgICAvKiBHZW5lcmFsIHB1cnBvc2UgYml0IGZsYWcgKi9cbiAgICAvLyB2YWx1ZXMgY2FuIG9idGFpbmVkIHdpdGggZXhwcmVzc2lvbiAyKipiaXRuclxuICAgIEZMR19FTkMgICAgICAgICAgOiAxLCAgICAvLyBCaXQgMDogZW5jcnlwdGVkIGZpbGVcbiAgICBGTEdfQ09NUDEgICAgICAgIDogMiwgICAgLy8gQml0IDEsIGNvbXByZXNzaW9uIG9wdGlvblxuICAgIEZMR19DT01QMiAgICAgICAgOiA0LCAgICAvLyBCaXQgMiwgY29tcHJlc3Npb24gb3B0aW9uXG4gICAgRkxHX0RFU0MgICAgICAgICA6IDgsICAgIC8vIEJpdCAzLCBkYXRhIGRlc2NyaXB0b3JcbiAgICBGTEdfRU5IICAgICAgICAgIDogMTYsICAgLy8gQml0IDQsIGVuaGFuY2VkIGRlZmxhdGluZ1xuICAgIEZMR19QQVRDSCAgICAgICAgOiAzMiwgICAvLyBCaXQgNSwgaW5kaWNhdGVzIHRoYXQgdGhlIGZpbGUgaXMgY29tcHJlc3NlZCBwYXRjaGVkIGRhdGEuXG4gICAgRkxHX1NUUiAgICAgICAgICA6IDY0LCAgIC8vIEJpdCA2LCBzdHJvbmcgZW5jcnlwdGlvbiAocGF0ZW50ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJpdHMgNy0xMDogQ3VycmVudGx5IHVudXNlZC5cbiAgICBGTEdfRUZTICAgICAgICAgIDogMjA0OCwgLy8gQml0IDExOiBMYW5ndWFnZSBlbmNvZGluZyBmbGFnIChFRlMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJpdCAxMjogUmVzZXJ2ZWQgYnkgUEtXQVJFIGZvciBlbmhhbmNlZCBjb21wcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQml0IDEzOiBlbmNyeXB0ZWQgdGhlIENlbnRyYWwgRGlyZWN0b3J5IChwYXRlbnRlZCkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJpdHMgMTQtMTU6IFJlc2VydmVkIGJ5IFBLV0FSRS5cbiAgICBGTEdfTVNLICAgICAgICAgIDogNDA5NiwgLy8gbWFzayBoZWFkZXIgdmFsdWVzXG5cbiAgICAvKiBMb2FkIHR5cGUgKi9cbiAgICBGSUxFICAgICAgICAgICAgIDogMixcbiAgICBCVUZGRVIgICAgICAgICAgIDogMSxcbiAgICBOT05FICAgICAgICAgICAgIDogMCxcblxuICAgIC8qIDQuNSBFeHRlbnNpYmxlIGRhdGEgZmllbGRzICovXG4gICAgRUZfSUQgICAgICAgICAgICA6IDAsXG4gICAgRUZfU0laRSAgICAgICAgICA6IDIsXG5cbiAgICAvKiBIZWFkZXIgSURzICovXG4gICAgSURfWklQNjQgICAgICAgICA6IDB4MDAwMSxcbiAgICBJRF9BVklORk8gICAgICAgIDogMHgwMDA3LFxuICAgIElEX1BGUyAgICAgICAgICAgOiAweDAwMDgsXG4gICAgSURfT1MyICAgICAgICAgICA6IDB4MDAwOSxcbiAgICBJRF9OVEZTICAgICAgICAgIDogMHgwMDBhLFxuICAgIElEX09QRU5WTVMgICAgICAgOiAweDAwMGMsXG4gICAgSURfVU5JWCAgICAgICAgICA6IDB4MDAwZCxcbiAgICBJRF9GT1JLICAgICAgICAgIDogMHgwMDBlLFxuICAgIElEX1BBVENIICAgICAgICAgOiAweDAwMGYsXG4gICAgSURfWDUwOV9QS0NTNyAgICA6IDB4MDAxNCxcbiAgICBJRF9YNTA5X0NFUlRJRF9GIDogMHgwMDE1LFxuICAgIElEX1g1MDlfQ0VSVElEX0MgOiAweDAwMTYsXG4gICAgSURfU1RST05HRU5DICAgICA6IDB4MDAxNyxcbiAgICBJRF9SRUNPUkRfTUdUICAgIDogMHgwMDE4LFxuICAgIElEX1g1MDlfUEtDUzdfUkwgOiAweDAwMTksXG4gICAgSURfSUJNMSAgICAgICAgICA6IDB4MDA2NSxcbiAgICBJRF9JQk0yICAgICAgICAgIDogMHgwMDY2LFxuICAgIElEX1BPU1pJUCAgICAgICAgOiAweDQ2OTAsXG5cbiAgICBFRl9aSVA2NF9PUl8zMiAgIDogMHhmZmZmZmZmZixcbiAgICBFRl9aSVA2NF9PUl8xNiAgIDogMHhmZmZmLFxuICAgIEVGX1pJUDY0X1NVTkNPTVAgOiAwLFxuICAgIEVGX1pJUDY0X1NDT01QICAgOiA4LFxuICAgIEVGX1pJUDY0X1JITyAgICAgOiAxNixcbiAgICBFRl9aSVA2NF9EU04gICAgIDogMjRcbn07XG4iLCAiY29uc3QgZXJyb3JzID0ge1xuICAgIC8qIEhlYWRlciBlcnJvciBtZXNzYWdlcyAqL1xuICAgIElOVkFMSURfTE9DOiBcIkludmFsaWQgTE9DIGhlYWRlciAoYmFkIHNpZ25hdHVyZSlcIixcbiAgICBJTlZBTElEX0NFTjogXCJJbnZhbGlkIENFTiBoZWFkZXIgKGJhZCBzaWduYXR1cmUpXCIsXG4gICAgSU5WQUxJRF9FTkQ6IFwiSW52YWxpZCBFTkQgaGVhZGVyIChiYWQgc2lnbmF0dXJlKVwiLFxuXG4gICAgLyogRGVzY3JpcHRvciAqL1xuICAgIERFU0NSSVBUT1JfTk9UX0VYSVNUOiBcIk5vIGRlc2NyaXB0b3IgcHJlc2VudFwiLFxuICAgIERFU0NSSVBUT1JfVU5LTk9XTjogXCJVbmtub3duIGRlc2NyaXB0b3IgZm9ybWF0XCIsXG4gICAgREVTQ1JJUFRPUl9GQVVMVFk6IFwiRGVzY3JpcHRvciBkYXRhIGlzIG1hbGZvcm1lZFwiLFxuXG4gICAgLyogWmlwRW50cnkgZXJyb3IgbWVzc2FnZXMqL1xuICAgIE5PX0RBVEE6IFwiTm90aGluZyB0byBkZWNvbXByZXNzXCIsXG4gICAgQkFEX0NSQzogXCJDUkMzMiBjaGVja3N1bSBmYWlsZWQgezB9XCIsXG4gICAgRklMRV9JTl9USEVfV0FZOiBcIlRoZXJlIGlzIGEgZmlsZSBpbiB0aGUgd2F5OiB7MH1cIixcbiAgICBVTktOT1dOX01FVEhPRDogXCJJbnZhbGlkL3Vuc3VwcG9ydGVkIGNvbXByZXNzaW9uIG1ldGhvZFwiLFxuXG4gICAgLyogSW5mbGF0ZXIgZXJyb3IgbWVzc2FnZXMgKi9cbiAgICBBVkFJTF9EQVRBOiBcImluZmxhdGU6OkF2YWlsYWJsZSBpbmZsYXRlIGRhdGEgZGlkIG5vdCB0ZXJtaW5hdGVcIixcbiAgICBJTlZBTElEX0RJU1RBTkNFOiBcImluZmxhdGU6OkludmFsaWQgbGl0ZXJhbC9sZW5ndGggb3IgZGlzdGFuY2UgY29kZSBpbiBmaXhlZCBvciBkeW5hbWljIGJsb2NrXCIsXG4gICAgVE9fTUFOWV9DT0RFUzogXCJpbmZsYXRlOjpEeW5hbWljIGJsb2NrIGNvZGUgZGVzY3JpcHRpb246IHRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBjb2Rlc1wiLFxuICAgIElOVkFMSURfUkVQRUFUX0xFTjogXCJpbmZsYXRlOjpEeW5hbWljIGJsb2NrIGNvZGUgZGVzY3JpcHRpb246IHJlcGVhdCBtb3JlIHRoYW4gc3BlY2lmaWVkIGxlbmd0aHNcIixcbiAgICBJTlZBTElEX1JFUEVBVF9GSVJTVDogXCJpbmZsYXRlOjpEeW5hbWljIGJsb2NrIGNvZGUgZGVzY3JpcHRpb246IHJlcGVhdCBsZW5ndGhzIHdpdGggbm8gZmlyc3QgbGVuZ3RoXCIsXG4gICAgSU5DT01QTEVURV9DT0RFUzogXCJpbmZsYXRlOjpEeW5hbWljIGJsb2NrIGNvZGUgZGVzY3JpcHRpb246IGNvZGUgbGVuZ3RocyBjb2RlcyBpbmNvbXBsZXRlXCIsXG4gICAgSU5WQUxJRF9EWU5fRElTVEFOQ0U6IFwiaW5mbGF0ZTo6RHluYW1pYyBibG9jayBjb2RlIGRlc2NyaXB0aW9uOiBpbnZhbGlkIGRpc3RhbmNlIGNvZGUgbGVuZ3Roc1wiLFxuICAgIElOVkFMSURfQ09ERVNfTEVOOiBcImluZmxhdGU6OkR5bmFtaWMgYmxvY2sgY29kZSBkZXNjcmlwdGlvbjogaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIGxlbmd0aHNcIixcbiAgICBJTlZBTElEX1NUT1JFX0JMT0NLOiBcImluZmxhdGU6OlN0b3JlZCBibG9jayBsZW5ndGggZGlkIG5vdCBtYXRjaCBvbmUncyBjb21wbGVtZW50XCIsXG4gICAgSU5WQUxJRF9CTE9DS19UWVBFOiBcImluZmxhdGU6OkludmFsaWQgYmxvY2sgdHlwZSAodHlwZSA9PSAzKVwiLFxuXG4gICAgLyogQURNLVpJUCBlcnJvciBtZXNzYWdlcyAqL1xuICAgIENBTlRfRVhUUkFDVF9GSUxFOiBcIkNvdWxkIG5vdCBleHRyYWN0IHRoZSBmaWxlXCIsXG4gICAgQ0FOVF9PVkVSUklERTogXCJUYXJnZXQgZmlsZSBhbHJlYWR5IGV4aXN0c1wiLFxuICAgIERJU0tfRU5UUllfVE9PX0xBUkdFOiBcIk51bWJlciBvZiBkaXNrIGVudHJpZXMgaXMgdG9vIGxhcmdlXCIsXG4gICAgTk9fWklQOiBcIk5vIHppcCBmaWxlIHdhcyBsb2FkZWRcIixcbiAgICBOT19FTlRSWTogXCJFbnRyeSBkb2Vzbid0IGV4aXN0XCIsXG4gICAgRElSRUNUT1JZX0NPTlRFTlRfRVJST1I6IFwiQSBkaXJlY3RvcnkgY2Fubm90IGhhdmUgY29udGVudFwiLFxuICAgIEZJTEVfTk9UX0ZPVU5EOiAnRmlsZSBub3QgZm91bmQ6IFwiezB9XCInLFxuICAgIE5PVF9JTVBMRU1FTlRFRDogXCJOb3QgaW1wbGVtZW50ZWRcIixcbiAgICBJTlZBTElEX0ZJTEVOQU1FOiBcIkludmFsaWQgZmlsZW5hbWVcIixcbiAgICBJTlZBTElEX0ZPUk1BVDogXCJJbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHppcCBmb3JtYXQuIE5vIEVORCBoZWFkZXIgZm91bmRcIixcbiAgICBJTlZBTElEX1BBU1NfUEFSQU06IFwiSW5jb21wYXRpYmxlIHBhc3N3b3JkIHBhcmFtZXRlclwiLFxuICAgIFdST05HX1BBU1NXT1JEOiBcIldyb25nIFBhc3N3b3JkXCIsXG5cbiAgICAvKiBBRE0tWklQICovXG4gICAgQ09NTUVOVF9UT09fTE9ORzogXCJDb21tZW50IGlzIHRvbyBsb25nXCIsIC8vIENvbW1lbnQgY2FuIGJlIG1heCA2NTUzNSBieXRlcyBsb25nIChOT1RFOiBzb21lIG5vbi1VUyBjaGFyYWN0ZXJzIG1heSB0YWtlIG1vcmUgc3BhY2UpXG4gICAgRVhUUkFfRklFTERfUEFSU0VfRVJST1I6IFwiRXh0cmEgZmllbGQgcGFyc2luZyBlcnJvclwiXG59O1xuXG4vLyB0ZW1wbGF0ZVxuZnVuY3Rpb24gRShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCkgeyAvLyBBbGxvdyB7MH0gLi4gezl9IGFyZ3VtZW50cyBpbiBlcnJvciBtZXNzYWdlLCBiYXNlZCBvbiBhcmd1bWVudCBudW1iZXJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoL1xceyhcXGQpXFx9L2csIChfLCBuKSA9PiBhcmdzW25dIHx8ICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FETS1aSVA6ICcgKyBtZXNzYWdlKTtcbiAgICB9O1xufVxuXG4vLyBJbml0IGVycm9ycyB3aXRoIHRlbXBsYXRlXG5mb3IgKGNvbnN0IG1zZyBvZiBPYmplY3Qua2V5cyhlcnJvcnMpKSB7XG4gICAgZXhwb3J0c1ttc2ddID0gRShlcnJvcnNbbXNnXSk7XG59XG4iLCAiY29uc3QgZnN5c3RlbSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHB0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgQ29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgaXNXaW4gPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBcIndpbjMyXCIgPT09IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IGlzX09iaiA9IChvYmopID0+IHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsO1xuXG4vLyBnZW5lcmF0ZSBDUkMzMiBsb29rdXAgdGFibGVcbmNvbnN0IGNyY1RhYmxlID0gbmV3IFVpbnQzMkFycmF5KDI1NikubWFwKCh0LCBjKSA9PiB7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgICAgaWYgKChjICYgMSkgIT09IDApIHtcbiAgICAgICAgICAgIGMgPSAweGVkYjg4MzIwIF4gKGMgPj4+IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYyA+Pj49IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGMgPj4+IDA7XG59KTtcblxuLy8gVVRJTFMgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIFV0aWxzKG9wdHMpIHtcbiAgICB0aGlzLnNlcCA9IHB0aC5zZXA7XG4gICAgdGhpcy5mcyA9IGZzeXN0ZW07XG5cbiAgICBpZiAoaXNfT2JqKG9wdHMpKSB7XG4gICAgICAgIC8vIGN1c3RvbSBmaWxlc3lzdGVtXG4gICAgICAgIGlmIChpc19PYmoob3B0cy5mcykgJiYgdHlwZW9mIG9wdHMuZnMuc3RhdFN5bmMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5mcyA9IG9wdHMuZnM7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cbi8vIElOU1RBTlRJQUJMRSBmdW5jdGlvbnNcblxuVXRpbHMucHJvdG90eXBlLm1ha2VEaXIgPSBmdW5jdGlvbiAoLypTdHJpbmcqLyBmb2xkZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIFN5bmMgLSBtYWtlIGRpcmVjdG9yaWVzIHRyZWVcbiAgICBmdW5jdGlvbiBta2RpclN5bmMoLypTdHJpbmcqLyBmcGF0aCkge1xuICAgICAgICBsZXQgcmVzb2x2ZWRQYXRoID0gZnBhdGguc3BsaXQoc2VsZi5zZXApWzBdO1xuICAgICAgICBmcGF0aC5zcGxpdChzZWxmLnNlcCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUuc3Vic3RyKC0xLCAxKSA9PT0gXCI6XCIpIHJldHVybjtcbiAgICAgICAgICAgIHJlc29sdmVkUGF0aCArPSBzZWxmLnNlcCArIG5hbWU7XG4gICAgICAgICAgICB2YXIgc3RhdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdCA9IHNlbGYuZnMuc3RhdFN5bmMocmVzb2x2ZWRQYXRoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZzLm1rZGlyU3luYyhyZXNvbHZlZFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXQgJiYgc3RhdC5pc0ZpbGUoKSkgdGhyb3cgRXJyb3JzLkZJTEVfSU5fVEhFX1dBWShgXCIke3Jlc29sdmVkUGF0aH1cImApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBta2RpclN5bmMoZm9sZGVyKTtcbn07XG5cblV0aWxzLnByb3RvdHlwZS53cml0ZUZpbGVUbyA9IGZ1bmN0aW9uICgvKlN0cmluZyovIHBhdGgsIC8qQnVmZmVyKi8gY29udGVudCwgLypCb29sZWFuKi8gb3ZlcndyaXRlLCAvKk51bWJlciovIGF0dHIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5mcy5leGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgICAgIGlmICghb3ZlcndyaXRlKSByZXR1cm4gZmFsc2U7IC8vIGNhbm5vdCBvdmVyd3JpdGVcblxuICAgICAgICB2YXIgc3RhdCA9IHNlbGYuZnMuc3RhdFN5bmMocGF0aCk7XG4gICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZm9sZGVyID0gcHRoLmRpcm5hbWUocGF0aCk7XG4gICAgaWYgKCFzZWxmLmZzLmV4aXN0c1N5bmMoZm9sZGVyKSkge1xuICAgICAgICBzZWxmLm1ha2VEaXIoZm9sZGVyKTtcbiAgICB9XG5cbiAgICB2YXIgZmQ7XG4gICAgdHJ5IHtcbiAgICAgICAgZmQgPSBzZWxmLmZzLm9wZW5TeW5jKHBhdGgsIFwid1wiLCAwbzY2Nik7IC8vIDA2NjZcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYuZnMuY2htb2RTeW5jKHBhdGgsIDBvNjY2KTtcbiAgICAgICAgZmQgPSBzZWxmLmZzLm9wZW5TeW5jKHBhdGgsIFwid1wiLCAwbzY2Nik7XG4gICAgfVxuICAgIGlmIChmZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VsZi5mcy53cml0ZVN5bmMoZmQsIGNvbnRlbnQsIDAsIGNvbnRlbnQubGVuZ3RoLCAwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNlbGYuZnMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxmLmZzLmNobW9kU3luYyhwYXRoLCBhdHRyIHx8IDBvNjY2KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblV0aWxzLnByb3RvdHlwZS53cml0ZUZpbGVUb0FzeW5jID0gZnVuY3Rpb24gKC8qU3RyaW5nKi8gcGF0aCwgLypCdWZmZXIqLyBjb250ZW50LCAvKkJvb2xlYW4qLyBvdmVyd3JpdGUsIC8qTnVtYmVyKi8gYXR0ciwgLypGdW5jdGlvbiovIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhdHRyO1xuICAgICAgICBhdHRyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgc2VsZi5mcy5leGlzdHMocGF0aCwgZnVuY3Rpb24gKGV4aXN0KSB7XG4gICAgICAgIGlmIChleGlzdCAmJiAhb3ZlcndyaXRlKSByZXR1cm4gY2FsbGJhY2soZmFsc2UpO1xuXG4gICAgICAgIHNlbGYuZnMuc3RhdChwYXRoLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgICAgICAgICBpZiAoZXhpc3QgJiYgc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZvbGRlciA9IHB0aC5kaXJuYW1lKHBhdGgpO1xuICAgICAgICAgICAgc2VsZi5mcy5leGlzdHMoZm9sZGVyLCBmdW5jdGlvbiAoZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHNlbGYubWFrZURpcihmb2xkZXIpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5mcy5vcGVuKHBhdGgsIFwid1wiLCAwbzY2NiwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy5jaG1vZChwYXRoLCAwbzY2NiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMub3BlbihwYXRoLCBcIndcIiwgMG82NjYsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMud3JpdGUoZmQsIGNvbnRlbnQsIDAsIGNvbnRlbnQubGVuZ3RoLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZzLmNsb3NlKGZkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy5jaG1vZChwYXRoLCBhdHRyIHx8IDBvNjY2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMud3JpdGUoZmQsIGNvbnRlbnQsIDAsIGNvbnRlbnQubGVuZ3RoLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy5jbG9zZShmZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZzLmNobW9kKHBhdGgsIGF0dHIgfHwgMG82NjYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy5jaG1vZChwYXRoLCBhdHRyIHx8IDBvNjY2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuVXRpbHMucHJvdG90eXBlLmZpbmRGaWxlcyA9IGZ1bmN0aW9uICgvKlN0cmluZyovIHBhdGgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmRTeW5jKC8qU3RyaW5nKi8gZGlyLCAvKlJlZ0V4cCovIHBhdHRlcm4sIC8qQm9vbGVhbiovIHJlY3Vyc2l2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZWN1cnNpdmUgPSBwYXR0ZXJuO1xuICAgICAgICAgICAgcGF0dGVybiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmlsZXMgPSBbXTtcbiAgICAgICAgc2VsZi5mcy5yZWFkZGlyU3luYyhkaXIpLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBwdGguam9pbihkaXIsIGZpbGUpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdCA9IHNlbGYuZnMuc3RhdFN5bmMocGF0aCk7XG5cbiAgICAgICAgICAgIGlmICghcGF0dGVybiB8fCBwYXR0ZXJuLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKHB0aC5ub3JtYWxpemUocGF0aCkgKyAoc3RhdC5pc0RpcmVjdG9yeSgpID8gc2VsZi5zZXAgOiBcIlwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkgJiYgcmVjdXJzaXZlKSBmaWxlcyA9IGZpbGVzLmNvbmNhdChmaW5kU3luYyhwYXRoLCBwYXR0ZXJuLCByZWN1cnNpdmUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWxlcztcbiAgICB9XG5cbiAgICByZXR1cm4gZmluZFN5bmMocGF0aCwgdW5kZWZpbmVkLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHNob3dpbmcgaWYgZXZlcnl0aGluZyB3YXMgZG9uZS5cbiAqXG4gKiBAY2FsbGJhY2sgZmlsZWxpc3RDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBsaXN0IC0gd2FzIHJlcXVlc3QgZnVsbHkgY29tcGxldGVkXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRpclxuICogQHBhcmFtIHtmaWxlbGlzdENhbGxiYWNrfSBjYlxuICovXG5VdGlscy5wcm90b3R5cGUuZmluZEZpbGVzQXN5bmMgPSBmdW5jdGlvbiAoZGlyLCBjYikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgc2VsZi5mcy5yZWFkZGlyKGRpciwgZnVuY3Rpb24gKGVyciwgbGlzdCkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgbGV0IGxpc3RfbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIGlmICghbGlzdF9sZW5ndGgpIHJldHVybiBjYihudWxsLCByZXN1bHRzKTtcbiAgICAgICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICBmaWxlID0gcHRoLmpvaW4oZGlyLCBmaWxlKTtcbiAgICAgICAgICAgIHNlbGYuZnMuc3RhdChmaWxlLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHB0aC5ub3JtYWxpemUoZmlsZSkgKyAoc3RhdC5pc0RpcmVjdG9yeSgpID8gc2VsZi5zZXAgOiBcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmluZEZpbGVzQXN5bmMoZmlsZSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWxpc3RfbGVuZ3RoKSBjYihudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWxpc3RfbGVuZ3RoKSBjYihudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cblV0aWxzLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge307XG5cblV0aWxzLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFNUQVRJQyBmdW5jdGlvbnNcblxuLy8gY3JjMzIgc2luZ2xlIHVwZGF0ZSAoaXQgaXMgcGFydCBvZiBjcmMzMilcblV0aWxzLmNyYzMydXBkYXRlID0gZnVuY3Rpb24gKGNyYywgYnl0ZSkge1xuICAgIHJldHVybiBjcmNUYWJsZVsoY3JjIF4gYnl0ZSkgJiAweGZmXSBeIChjcmMgPj4+IDgpO1xufTtcblxuVXRpbHMuY3JjMzIgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgaWYgKHR5cGVvZiBidWYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmLCBcInV0ZjhcIik7XG4gICAgfVxuXG4gICAgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgbGV0IGNyYyA9IH4wO1xuICAgIGZvciAobGV0IG9mZiA9IDA7IG9mZiA8IGxlbjsgKSBjcmMgPSBVdGlscy5jcmMzMnVwZGF0ZShjcmMsIGJ1ZltvZmYrK10pO1xuICAgIC8vIHhvciBhbmQgY2FzdCBhcyB1aW50MzIgbnVtYmVyXG4gICAgcmV0dXJuIH5jcmMgPj4+IDA7XG59O1xuXG5VdGlscy5tZXRob2RUb1N0cmluZyA9IGZ1bmN0aW9uICgvKk51bWJlciovIG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgQ29uc3RhbnRzLlNUT1JFRDpcbiAgICAgICAgICAgIHJldHVybiBcIlNUT1JFRCAoXCIgKyBtZXRob2QgKyBcIilcIjtcbiAgICAgICAgY2FzZSBDb25zdGFudHMuREVGTEFURUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJERUZMQVRFRCAoXCIgKyBtZXRob2QgKyBcIilcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOU1VQUE9SVEVEIChcIiArIG1ldGhvZCArIFwiKVwiO1xuICAgIH1cbn07XG5cbi8qKlxuICogcmVtb3ZlcyBcIi4uXCIgc3R5bGUgcGF0aCBlbGVtZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBmaXhhYmxlIHBhdGhcbiAqIEByZXR1cm5zIHN0cmluZyAtIGZpeGVkIGZpbGVwYXRoXG4gKi9cblV0aWxzLmNhbm9uaWNhbCA9IGZ1bmN0aW9uICgvKnN0cmluZyovIHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBcIlwiO1xuICAgIC8vIHRyaWNrIG5vcm1hbGl6ZSB0aGluayBwYXRoIGlzIGFic29sdXRlXG4gICAgY29uc3Qgc2FmZVN1ZmZpeCA9IHB0aC5wb3NpeC5ub3JtYWxpemUoXCIvXCIgKyBwYXRoLnNwbGl0KFwiXFxcXFwiKS5qb2luKFwiL1wiKSk7XG4gICAgcmV0dXJuIHB0aC5qb2luKFwiLlwiLCBzYWZlU3VmZml4KTtcbn07XG5cbi8qKlxuICogZml4IGZpbGUgbmFtZXMgaW4gYWNoaXZlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGZpeGFibGUgcGF0aFxuICogQHJldHVybnMgc3RyaW5nIC0gZml4ZWQgZmlsZXBhdGhcbiAqL1xuXG5VdGlscy56aXBuYW1lZml4ID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBcIlwiO1xuICAgIC8vIHRyaWNrIG5vcm1hbGl6ZSB0aGluayBwYXRoIGlzIGFic29sdXRlXG4gICAgY29uc3Qgc2FmZVN1ZmZpeCA9IHB0aC5wb3NpeC5ub3JtYWxpemUoXCIvXCIgKyBwYXRoLnNwbGl0KFwiXFxcXFwiKS5qb2luKFwiL1wiKSk7XG4gICAgcmV0dXJuIHB0aC5wb3NpeC5qb2luKFwiLlwiLCBzYWZlU3VmZml4KTtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zXG4gKi9cblV0aWxzLmZpbmRMYXN0ID0gZnVuY3Rpb24gKGFyciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyciBpcyBub3QgYXJyYXlcIik7XG5cbiAgICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoID4+PiAwO1xuICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2soYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG59O1xuXG4vLyBtYWtlIGFib2x1dGUgcGF0aHMgdGFraW5nIHByZWZpeCBhcyByb290IGZvbGRlclxuVXRpbHMuc2FuaXRpemUgPSBmdW5jdGlvbiAoLypzdHJpbmcqLyBwcmVmaXgsIC8qc3RyaW5nKi8gbmFtZSkge1xuICAgIHByZWZpeCA9IHB0aC5yZXNvbHZlKHB0aC5ub3JtYWxpemUocHJlZml4KSk7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdChcIi9cIik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBwdGgubm9ybWFsaXplKHB0aC5qb2luKHByZWZpeCwgcGFydHMuc2xpY2UoaSwgbCkuam9pbihwdGguc2VwKSkpO1xuICAgICAgICBpZiAocGF0aC5pbmRleE9mKHByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwdGgubm9ybWFsaXplKHB0aC5qb2luKHByZWZpeCwgcHRoLmJhc2VuYW1lKG5hbWUpKSk7XG59O1xuXG4vLyBjb252ZXJ0cyBidWZmZXIsIFVpbnQ4QXJyYXksIHN0cmluZyB0eXBlcyB0byBidWZmZXJcblV0aWxzLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIoLypidWZmZXIsIFVpbnQ4QXJyYXksIHN0cmluZyovIGlucHV0LCAvKiBmdW5jdGlvbiAqLyBlbmNvZGVyKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXhwZWN0IHN0cmluZyBhbGwgb3RoZXIgdmFsdWVzIGFyZSBpbnZhbGlkIGFuZCByZXR1cm4gZW1wdHkgYnVmZmVyXG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBlbmNvZGVyKGlucHV0KSA6IEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG59O1xuXG5VdGlscy5yZWFkQmlnVUludDY0TEUgPSBmdW5jdGlvbiAoLypCdWZmZXIqLyBidWZmZXIsIC8qaW50Ki8gaW5kZXgpIHtcbiAgICB2YXIgc2xpY2UgPSBCdWZmZXIuZnJvbShidWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgOCkpO1xuICAgIHNsaWNlLnN3YXA2NCgpO1xuXG4gICAgcmV0dXJuIHBhcnNlSW50KGAweCR7c2xpY2UudG9TdHJpbmcoXCJoZXhcIil9YCk7XG59O1xuXG5VdGlscy5mcm9tRE9TMkRhdGUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCgodmFsID4+IDI1KSAmIDB4N2YpICsgMTk4MCwgTWF0aC5tYXgoKCh2YWwgPj4gMjEpICYgMHgwZikgLSAxLCAwKSwgTWF0aC5tYXgoKHZhbCA+PiAxNikgJiAweDFmLCAxKSwgKHZhbCA+PiAxMSkgJiAweDFmLCAodmFsID4+IDUpICYgMHgzZiwgKHZhbCAmIDB4MWYpIDw8IDEpO1xufTtcblxuVXRpbHMuZnJvbURhdGUyRE9TID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIGxldCBkYXRlID0gMDtcbiAgICBsZXQgdGltZSA9IDA7XG4gICAgaWYgKHZhbC5nZXRGdWxsWWVhcigpID4gMTk3OSkge1xuICAgICAgICBkYXRlID0gKCgodmFsLmdldEZ1bGxZZWFyKCkgLSAxOTgwKSAmIDB4N2YpIDw8IDkpIHwgKCh2YWwuZ2V0TW9udGgoKSArIDEpIDw8IDUpIHwgdmFsLmdldERhdGUoKTtcbiAgICAgICAgdGltZSA9ICh2YWwuZ2V0SG91cnMoKSA8PCAxMSkgfCAodmFsLmdldE1pbnV0ZXMoKSA8PCA1KSB8ICh2YWwuZ2V0U2Vjb25kcygpID4+IDEpO1xuICAgIH1cbiAgICByZXR1cm4gKGRhdGUgPDwgMTYpIHwgdGltZTtcbn07XG5cblV0aWxzLmlzV2luID0gaXNXaW47IC8vIERvIHdlIGhhdmUgd2luZG93cyBzeXN0ZW1cblV0aWxzLmNyY1RhYmxlID0gY3JjVGFibGU7XG4iLCAiY29uc3QgcHRoID0gcmVxdWlyZShcInBhdGhcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qU3RyaW5nKi8gcGF0aCwgLypVdGlscyBvYmplY3QqLyB7IGZzIH0pIHtcbiAgICB2YXIgX3BhdGggPSBwYXRoIHx8IFwiXCIsXG4gICAgICAgIF9vYmogPSBuZXdBdHRyKCksXG4gICAgICAgIF9zdGF0ID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIG5ld0F0dHIoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXJlY3Rvcnk6IGZhbHNlLFxuICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICAgIGV4ZWN1dGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgbXRpbWU6IDAsXG4gICAgICAgICAgICBhdGltZTogMFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmIChfcGF0aCAmJiBmcy5leGlzdHNTeW5jKF9wYXRoKSkge1xuICAgICAgICBfc3RhdCA9IGZzLnN0YXRTeW5jKF9wYXRoKTtcbiAgICAgICAgX29iai5kaXJlY3RvcnkgPSBfc3RhdC5pc0RpcmVjdG9yeSgpO1xuICAgICAgICBfb2JqLm10aW1lID0gX3N0YXQubXRpbWU7XG4gICAgICAgIF9vYmouYXRpbWUgPSBfc3RhdC5hdGltZTtcbiAgICAgICAgX29iai5leGVjdXRhYmxlID0gKDBvMTExICYgX3N0YXQubW9kZSkgIT09IDA7IC8vIGZpbGUgaXMgZXhlY3V0YWJsZSB3aG8gZXZlciBoYXIgcmlnaHQgbm90IGp1c3Qgb3duZXJcbiAgICAgICAgX29iai5yZWFkb25seSA9ICgwbzIwMCAmIF9zdGF0Lm1vZGUpID09PSAwOyAvLyByZWFkb25seSBpZiBvd25lciBoYXMgbm8gd3JpdGUgcmlnaHRcbiAgICAgICAgX29iai5oaWRkZW4gPSBwdGguYmFzZW5hbWUoX3BhdGgpWzBdID09PSBcIi5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHBhdGg6IFwiICsgX3BhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBkaXJlY3RvcnkoKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iai5kaXJlY3Rvcnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IHJlYWRPbmx5KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmoucmVhZG9ubHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGhpZGRlbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqLmhpZGRlbjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgbXRpbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iai5tdGltZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgYXRpbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iai5hdGltZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZXhlY3V0YWJsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqLmV4ZWN1dGFibGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVjb2RlQXR0cmlidXRlczogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgZW5jb2RlQXR0cmlidXRlczogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgICAgICAgIGlzRGlyZWN0b3J5OiBfb2JqLmRpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICBpc1JlYWRPbmx5OiBfb2JqLnJlYWRvbmx5LFxuICAgICAgICAgICAgICAgIGlzSGlkZGVuOiBfb2JqLmhpZGRlbixcbiAgICAgICAgICAgICAgICBpc0V4ZWN1dGFibGU6IF9vYmouZXhlY3V0YWJsZSxcbiAgICAgICAgICAgICAgICBtVGltZTogX29iai5tdGltZSxcbiAgICAgICAgICAgICAgICBhVGltZTogX29iai5hdGltZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksIG51bGwsIFwiXFx0XCIpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCAibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZWZzOiB0cnVlLFxuICAgIGVuY29kZTogKGRhdGEpID0+IEJ1ZmZlci5mcm9tKGRhdGEsIFwidXRmOFwiKSxcbiAgICBkZWNvZGU6IChkYXRhKSA9PiBkYXRhLnRvU3RyaW5nKFwidXRmOFwiKVxufTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xubW9kdWxlLmV4cG9ydHMuQ29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xubW9kdWxlLmV4cG9ydHMuRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xubW9kdWxlLmV4cG9ydHMuRmlsZUF0dHIgPSByZXF1aXJlKFwiLi9mYXR0clwiKTtcbm1vZHVsZS5leHBvcnRzLmRlY29kZXIgPSByZXF1aXJlKFwiLi9kZWNvZGVyXCIpO1xuIiwgInZhciBVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsXCIpLFxuICAgIENvbnN0YW50cyA9IFV0aWxzLkNvbnN0YW50cztcblxuLyogVGhlIGNlbnRyYWwgZGlyZWN0b3J5IGZpbGUgaGVhZGVyICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3Zlck1hZGUgPSAyMCwgLy8gdjIuMFxuICAgICAgICBfdmVyc2lvbiA9IDEwLCAvLyB2MS4wXG4gICAgICAgIF9mbGFncyA9IDAsXG4gICAgICAgIF9tZXRob2QgPSAwLFxuICAgICAgICBfdGltZSA9IDAsXG4gICAgICAgIF9jcmMgPSAwLFxuICAgICAgICBfY29tcHJlc3NlZFNpemUgPSAwLFxuICAgICAgICBfc2l6ZSA9IDAsXG4gICAgICAgIF9mbmFtZUxlbiA9IDAsXG4gICAgICAgIF9leHRyYUxlbiA9IDAsXG4gICAgICAgIF9jb21MZW4gPSAwLFxuICAgICAgICBfZGlza1N0YXJ0ID0gMCxcbiAgICAgICAgX2luYXR0ciA9IDAsXG4gICAgICAgIF9hdHRyID0gMCxcbiAgICAgICAgX29mZnNldCA9IDA7XG5cbiAgICBfdmVyTWFkZSB8PSBVdGlscy5pc1dpbiA/IDB4MGEwMCA6IDB4MDMwMDtcblxuICAgIC8vIFNldCBFRlMgZmxhZyBzaW5jZSBmaWxlbmFtZSBhbmQgY29tbWVudCBmaWVsZHMgYXJlIGFsbCBieSBkZWZhdWx0IGVuY29kZWQgdXNpbmcgVVRGLTguXG4gICAgLy8gV2l0aG91dCBpdCBmaWxlIG5hbWVzIG1heSBiZSBjb3JydXB0ZWQgZm9yIG90aGVyIGFwcHMgd2hlbiBmaWxlIG5hbWVzIHVzZSB1bmljb2RlIGNoYXJzXG4gICAgX2ZsYWdzIHw9IENvbnN0YW50cy5GTEdfRUZTO1xuXG4gICAgY29uc3QgX2xvY2FsSGVhZGVyID0ge1xuICAgICAgICBleHRyYUxlbjogMFxuICAgIH07XG5cbiAgICAvLyBjYXN0aW5nXG4gICAgY29uc3QgdWludDMyID0gKHZhbCkgPT4gTWF0aC5tYXgoMCwgdmFsKSA+Pj4gMDtcbiAgICBjb25zdCB1aW50MTYgPSAodmFsKSA9PiBNYXRoLm1heCgwLCB2YWwpICYgMHhmZmZmO1xuICAgIGNvbnN0IHVpbnQ4ID0gKHZhbCkgPT4gTWF0aC5tYXgoMCwgdmFsKSAmIDB4ZmY7XG5cbiAgICBfdGltZSA9IFV0aWxzLmZyb21EYXRlMkRPUyhuZXcgRGF0ZSgpKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBtYWRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIF92ZXJNYWRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgbWFkZSh2YWwpIHtcbiAgICAgICAgICAgIF92ZXJNYWRlID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF92ZXJzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgdmVyc2lvbih2YWwpIHtcbiAgICAgICAgICAgIF92ZXJzaW9uID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBmbGFncygpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBmbGFncyh2YWwpIHtcbiAgICAgICAgICAgIF9mbGFncyA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZmxhZ3NfZWZzKCkge1xuICAgICAgICAgICAgcmV0dXJuIChfZmxhZ3MgJiBDb25zdGFudHMuRkxHX0VGUykgPiAwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgZmxhZ3NfZWZzKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIF9mbGFncyB8PSBDb25zdGFudHMuRkxHX0VGUztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2ZsYWdzICY9IH5Db25zdGFudHMuRkxHX0VGUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZmxhZ3NfZGVzYygpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2ZsYWdzICYgQ29uc3RhbnRzLkZMR19ERVNDKSA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBmbGFnc19kZXNjKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIF9mbGFncyB8PSBDb25zdGFudHMuRkxHX0RFU0M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9mbGFncyAmPSB+Q29uc3RhbnRzLkZMR19ERVNDO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBtZXRob2QoKSB7XG4gICAgICAgICAgICByZXR1cm4gX21ldGhvZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IG1ldGhvZCh2YWwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmFsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHMuU1RPUkVEOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZlcnNpb24gPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5ERUZMQVRFRDpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZlcnNpb24gPSAyMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9tZXRob2QgPSB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IHRpbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuZnJvbURPUzJEYXRlKHRoaXMudGltZXZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB0aW1lKHZhbCkge1xuICAgICAgICAgICAgdGhpcy50aW1ldmFsID0gVXRpbHMuZnJvbURhdGUyRE9TKHZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IHRpbWV2YWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RpbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB0aW1ldmFsKHZhbCkge1xuICAgICAgICAgICAgX3RpbWUgPSB1aW50MzIodmFsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgdGltZUhpZ2hCeXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVpbnQ4KF90aW1lID4+PiA4KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNyYygpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3JjO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgY3JjKHZhbCkge1xuICAgICAgICAgICAgX2NyYyA9IHVpbnQzMih2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBjb21wcmVzc2VkU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29tcHJlc3NlZFNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBjb21wcmVzc2VkU2l6ZSh2YWwpIHtcbiAgICAgICAgICAgIF9jb21wcmVzc2VkU2l6ZSA9IHVpbnQzMih2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBzaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgc2l6ZSh2YWwpIHtcbiAgICAgICAgICAgIF9zaXplID0gdWludDMyKHZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGZpbGVOYW1lTGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9mbmFtZUxlbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGZpbGVOYW1lTGVuZ3RoKHZhbCkge1xuICAgICAgICAgICAgX2ZuYW1lTGVuID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBleHRyYUxlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXh0cmFMZW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBleHRyYUxlbmd0aCh2YWwpIHtcbiAgICAgICAgICAgIF9leHRyYUxlbiA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZXh0cmFMb2NhbExlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfbG9jYWxIZWFkZXIuZXh0cmFMZW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBleHRyYUxvY2FsTGVuZ3RoKHZhbCkge1xuICAgICAgICAgICAgX2xvY2FsSGVhZGVyLmV4dHJhTGVuID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBjb21tZW50TGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb21MZW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBjb21tZW50TGVuZ3RoKHZhbCkge1xuICAgICAgICAgICAgX2NvbUxlbiA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZGlza051bVN0YXJ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9kaXNrU3RhcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBkaXNrTnVtU3RhcnQodmFsKSB7XG4gICAgICAgICAgICBfZGlza1N0YXJ0ID0gdWludDMyKHZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGluQXR0cigpIHtcbiAgICAgICAgICAgIHJldHVybiBfaW5hdHRyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgaW5BdHRyKHZhbCkge1xuICAgICAgICAgICAgX2luYXR0ciA9IHVpbnQzMih2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBhdHRyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9hdHRyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgYXR0cih2YWwpIHtcbiAgICAgICAgICAgIF9hdHRyID0gdWludDMyKHZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZ2V0IFVuaXggZmlsZSBwZXJtaXNzaW9uc1xuICAgICAgICBnZXQgZmlsZUF0dHIoKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9hdHRyIHx8IDApID4+IDE2ICYgMHhmZmY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2Zmc2V0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQgb2Zmc2V0KHZhbCkge1xuICAgICAgICAgICAgX29mZnNldCA9IHVpbnQzMih2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBlbmNyeXB0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9mbGFncyAmIENvbnN0YW50cy5GTEdfRU5DKSA9PT0gQ29uc3RhbnRzLkZMR19FTkM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGNlbnRyYWxIZWFkZXJTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50cy5DRU5IRFIgKyBfZm5hbWVMZW4gKyBfZXh0cmFMZW4gKyBfY29tTGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCByZWFsRGF0YU9mZnNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2Zmc2V0ICsgQ29uc3RhbnRzLkxPQ0hEUiArIF9sb2NhbEhlYWRlci5mbmFtZUxlbiArIF9sb2NhbEhlYWRlci5leHRyYUxlbjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgbG9jYWxIZWFkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2xvY2FsSGVhZGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxvYWRMb2NhbEhlYWRlckZyb21CaW5hcnk6IGZ1bmN0aW9uICgvKkJ1ZmZlciovIGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGlucHV0LnNsaWNlKF9vZmZzZXQsIF9vZmZzZXQgKyBDb25zdGFudHMuTE9DSERSKTtcbiAgICAgICAgICAgIC8vIDMwIGJ5dGVzIGFuZCBzaG91bGQgc3RhcnQgd2l0aCBcIlBLXFwwMDNcXDAwNFwiXG4gICAgICAgICAgICBpZiAoZGF0YS5yZWFkVUludDMyTEUoMCkgIT09IENvbnN0YW50cy5MT0NTSUcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9MT0MoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgICAgICAgICAgX2xvY2FsSGVhZGVyLnZlcnNpb24gPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuTE9DVkVSKTtcbiAgICAgICAgICAgIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICAgICAgICAgICAgX2xvY2FsSGVhZGVyLmZsYWdzID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkxPQ0ZMRyk7XG4gICAgICAgICAgICAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICAgICAgICAgIF9sb2NhbEhlYWRlci5tZXRob2QgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuTE9DSE9XKTtcbiAgICAgICAgICAgIC8vIG1vZGlmaWNhdGlvbiB0aW1lICgyIGJ5dGVzIHRpbWUsIDIgYnl0ZXMgZGF0ZSlcbiAgICAgICAgICAgIF9sb2NhbEhlYWRlci50aW1lID0gZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkxPQ1RJTSk7XG4gICAgICAgICAgICAvLyB1bmNvbXByZXNzZWQgZmlsZSBjcmMtMzIgdmFsdVxuICAgICAgICAgICAgX2xvY2FsSGVhZGVyLmNyYyA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5MT0NDUkMpO1xuICAgICAgICAgICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBfbG9jYWxIZWFkZXIuY29tcHJlc3NlZFNpemUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuTE9DU0laKTtcbiAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBfbG9jYWxIZWFkZXIuc2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5MT0NMRU4pO1xuICAgICAgICAgICAgLy8gZmlsZW5hbWUgbGVuZ3RoXG4gICAgICAgICAgICBfbG9jYWxIZWFkZXIuZm5hbWVMZW4gPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuTE9DTkFNKTtcbiAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgICAgICAgICAgX2xvY2FsSGVhZGVyLmV4dHJhTGVuID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkxPQ0VYVCk7XG5cbiAgICAgICAgICAgIC8vIHJlYWQgZXh0cmEgZGF0YVxuICAgICAgICAgICAgY29uc3QgZXh0cmFTdGFydCA9IF9vZmZzZXQgKyBDb25zdGFudHMuTE9DSERSICsgX2xvY2FsSGVhZGVyLmZuYW1lTGVuO1xuICAgICAgICAgICAgY29uc3QgZXh0cmFFbmQgPSBleHRyYVN0YXJ0ICsgX2xvY2FsSGVhZGVyLmV4dHJhTGVuO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKGV4dHJhU3RhcnQsIGV4dHJhRW5kKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsb2FkRnJvbUJpbmFyeTogZnVuY3Rpb24gKC8qQnVmZmVyKi8gZGF0YSkge1xuICAgICAgICAgICAgLy8gZGF0YSBzaG91bGQgYmUgNDYgYnl0ZXMgYW5kIHN0YXJ0IHdpdGggXCJQSyAwMSAwMlwiXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IENvbnN0YW50cy5DRU5IRFIgfHwgZGF0YS5yZWFkVUludDMyTEUoMCkgIT09IENvbnN0YW50cy5DRU5TSUcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9DRU4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZlcnNpb24gbWFkZSBieVxuICAgICAgICAgICAgX3Zlck1hZGUgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VOVkVNKTtcbiAgICAgICAgICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICAgICAgICAgIF92ZXJzaW9uID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTlZFUik7XG4gICAgICAgICAgICAvLyBlbmNyeXB0LCBkZWNyeXB0IGZsYWdzXG4gICAgICAgICAgICBfZmxhZ3MgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VORkxHKTtcbiAgICAgICAgICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgICAgICAgICAgX21ldGhvZCA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5DRU5IT1cpO1xuICAgICAgICAgICAgLy8gbW9kaWZpY2F0aW9uIHRpbWUgKDIgYnl0ZXMgdGltZSwgMiBieXRlcyBkYXRlKVxuICAgICAgICAgICAgX3RpbWUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOVElNKTtcbiAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBmaWxlIGNyYy0zMiB2YWx1ZVxuICAgICAgICAgICAgX2NyYyA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5DRU5DUkMpO1xuICAgICAgICAgICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBfY29tcHJlc3NlZFNpemUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOU0laKTtcbiAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBfc2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5DRU5MRU4pO1xuICAgICAgICAgICAgLy8gZmlsZW5hbWUgbGVuZ3RoXG4gICAgICAgICAgICBfZm5hbWVMZW4gPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VOTkFNKTtcbiAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgICAgICAgICAgX2V4dHJhTGVuID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTkVYVCk7XG4gICAgICAgICAgICAvLyBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgICAgICBfY29tTGVuID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTkNPTSk7XG4gICAgICAgICAgICAvLyB2b2x1bWUgbnVtYmVyIHN0YXJ0XG4gICAgICAgICAgICBfZGlza1N0YXJ0ID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTkRTSyk7XG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIF9pbmF0dHIgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VOQVRUKTtcbiAgICAgICAgICAgIC8vIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgX2F0dHIgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOQVRYKTtcbiAgICAgICAgICAgIC8vIExPQyBoZWFkZXIgb2Zmc2V0XG4gICAgICAgICAgICBfb2Zmc2V0ID0gZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkNFTk9GRik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9jYWxIZWFkZXJUb0JpbmFyeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTE9DIGhlYWRlciBzaXplICgzMCBieXRlcylcbiAgICAgICAgICAgIHZhciBkYXRhID0gQnVmZmVyLmFsbG9jKENvbnN0YW50cy5MT0NIRFIpO1xuICAgICAgICAgICAgLy8gXCJQS1xcMDAzXFwwMDRcIlxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKENvbnN0YW50cy5MT0NTSUcsIDApO1xuICAgICAgICAgICAgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF92ZXJzaW9uLCBDb25zdGFudHMuTE9DVkVSKTtcbiAgICAgICAgICAgIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF9mbGFncywgQ29uc3RhbnRzLkxPQ0ZMRyk7XG4gICAgICAgICAgICAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfbWV0aG9kLCBDb25zdGFudHMuTE9DSE9XKTtcbiAgICAgICAgICAgIC8vIG1vZGlmaWNhdGlvbiB0aW1lICgyIGJ5dGVzIHRpbWUsIDIgYnl0ZXMgZGF0ZSlcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfdGltZSwgQ29uc3RhbnRzLkxPQ1RJTSk7XG4gICAgICAgICAgICAvLyB1bmNvbXByZXNzZWQgZmlsZSBjcmMtMzIgdmFsdWVcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfY3JjLCBDb25zdGFudHMuTE9DQ1JDKTtcbiAgICAgICAgICAgIC8vIGNvbXByZXNzZWQgc2l6ZVxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKF9jb21wcmVzc2VkU2l6ZSwgQ29uc3RhbnRzLkxPQ1NJWik7XG4gICAgICAgICAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKF9zaXplLCBDb25zdGFudHMuTE9DTEVOKTtcbiAgICAgICAgICAgIC8vIGZpbGVuYW1lIGxlbmd0aFxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF9mbmFtZUxlbiwgQ29uc3RhbnRzLkxPQ05BTSk7XG4gICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfbG9jYWxIZWFkZXIuZXh0cmFMZW4sIENvbnN0YW50cy5MT0NFWFQpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2VudHJhbEhlYWRlclRvQmluYXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDRU4gaGVhZGVyIHNpemUgKDQ2IGJ5dGVzKVxuICAgICAgICAgICAgdmFyIGRhdGEgPSBCdWZmZXIuYWxsb2MoQ29uc3RhbnRzLkNFTkhEUiArIF9mbmFtZUxlbiArIF9leHRyYUxlbiArIF9jb21MZW4pO1xuICAgICAgICAgICAgLy8gXCJQS1xcMDAxXFwwMDJcIlxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKENvbnN0YW50cy5DRU5TSUcsIDApO1xuICAgICAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5XG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX3Zlck1hZGUsIENvbnN0YW50cy5DRU5WRU0pO1xuICAgICAgICAgICAgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF92ZXJzaW9uLCBDb25zdGFudHMuQ0VOVkVSKTtcbiAgICAgICAgICAgIC8vIGVuY3J5cHQsIGRlY3J5cHQgZmxhZ3NcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZmxhZ3MsIENvbnN0YW50cy5DRU5GTEcpO1xuICAgICAgICAgICAgLy8gY29tcHJlc3Npb24gbWV0aG9kXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX21ldGhvZCwgQ29uc3RhbnRzLkNFTkhPVyk7XG4gICAgICAgICAgICAvLyBtb2RpZmljYXRpb24gdGltZSAoMiBieXRlcyB0aW1lLCAyIGJ5dGVzIGRhdGUpXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX3RpbWUsIENvbnN0YW50cy5DRU5USU0pO1xuICAgICAgICAgICAgLy8gdW5jb21wcmVzc2VkIGZpbGUgY3JjLTMyIHZhbHVlXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX2NyYywgQ29uc3RhbnRzLkNFTkNSQyk7XG4gICAgICAgICAgICAvLyBjb21wcmVzc2VkIHNpemVcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfY29tcHJlc3NlZFNpemUsIENvbnN0YW50cy5DRU5TSVopO1xuICAgICAgICAgICAgLy8gdW5jb21wcmVzc2VkIHNpemVcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfc2l6ZSwgQ29uc3RhbnRzLkNFTkxFTik7XG4gICAgICAgICAgICAvLyBmaWxlbmFtZSBsZW5ndGhcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZm5hbWVMZW4sIENvbnN0YW50cy5DRU5OQU0pO1xuICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX2V4dHJhTGVuLCBDb25zdGFudHMuQ0VORVhUKTtcbiAgICAgICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfY29tTGVuLCBDb25zdGFudHMuQ0VOQ09NKTtcbiAgICAgICAgICAgIC8vIHZvbHVtZSBudW1iZXIgc3RhcnRcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZGlza1N0YXJ0LCBDb25zdGFudHMuQ0VORFNLKTtcbiAgICAgICAgICAgIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF9pbmF0dHIsIENvbnN0YW50cy5DRU5BVFQpO1xuICAgICAgICAgICAgLy8gZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX2F0dHIsIENvbnN0YW50cy5DRU5BVFgpO1xuICAgICAgICAgICAgLy8gTE9DIGhlYWRlciBvZmZzZXRcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfb2Zmc2V0LCBDb25zdGFudHMuQ0VOT0ZGKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBmdW5jdGlvbiAobnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnIgKyBcIiBieXRlc1wiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYWRlOiBfdmVyTWFkZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBfdmVyc2lvbixcbiAgICAgICAgICAgICAgICBmbGFnczogX2ZsYWdzLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogVXRpbHMubWV0aG9kVG9TdHJpbmcoX21ldGhvZCksXG4gICAgICAgICAgICAgICAgdGltZTogdGhpcy50aW1lLFxuICAgICAgICAgICAgICAgIGNyYzogXCIweFwiICsgX2NyYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2VkU2l6ZTogYnl0ZXMoX2NvbXByZXNzZWRTaXplKSxcbiAgICAgICAgICAgICAgICBzaXplOiBieXRlcyhfc2l6ZSksXG4gICAgICAgICAgICAgICAgZmlsZU5hbWVMZW5ndGg6IGJ5dGVzKF9mbmFtZUxlbiksXG4gICAgICAgICAgICAgICAgZXh0cmFMZW5ndGg6IGJ5dGVzKF9leHRyYUxlbiksXG4gICAgICAgICAgICAgICAgY29tbWVudExlbmd0aDogYnl0ZXMoX2NvbUxlbiksXG4gICAgICAgICAgICAgICAgZGlza051bVN0YXJ0OiBfZGlza1N0YXJ0LFxuICAgICAgICAgICAgICAgIGluQXR0cjogX2luYXR0cixcbiAgICAgICAgICAgICAgICBhdHRyOiBfYXR0cixcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG4gICAgICAgICAgICAgICAgY2VudHJhbEhlYWRlclNpemU6IGJ5dGVzKENvbnN0YW50cy5DRU5IRFIgKyBfZm5hbWVMZW4gKyBfZXh0cmFMZW4gKyBfY29tTGVuKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksIG51bGwsIFwiXFx0XCIpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCAidmFyIFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxcIiksXG4gICAgQ29uc3RhbnRzID0gVXRpbHMuQ29uc3RhbnRzO1xuXG4vKiBUaGUgZW50cmllcyBpbiB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZvbHVtZUVudHJpZXMgPSAwLFxuICAgICAgICBfdG90YWxFbnRyaWVzID0gMCxcbiAgICAgICAgX3NpemUgPSAwLFxuICAgICAgICBfb2Zmc2V0ID0gMCxcbiAgICAgICAgX2NvbW1lbnRMZW5ndGggPSAwO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IGRpc2tFbnRyaWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF92b2x1bWVFbnRyaWVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgZGlza0VudHJpZXMoLypOdW1iZXIqLyB2YWwpIHtcbiAgICAgICAgICAgIF92b2x1bWVFbnRyaWVzID0gX3RvdGFsRW50cmllcyA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgdG90YWxFbnRyaWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90b3RhbEVudHJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB0b3RhbEVudHJpZXMoLypOdW1iZXIqLyB2YWwpIHtcbiAgICAgICAgICAgIF90b3RhbEVudHJpZXMgPSBfdm9sdW1lRW50cmllcyA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHNpemUoLypOdW1iZXIqLyB2YWwpIHtcbiAgICAgICAgICAgIF9zaXplID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX29mZnNldDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IG9mZnNldCgvKk51bWJlciovIHZhbCkge1xuICAgICAgICAgICAgX29mZnNldCA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgY29tbWVudExlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29tbWVudExlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGNvbW1lbnRMZW5ndGgoLypOdW1iZXIqLyB2YWwpIHtcbiAgICAgICAgICAgIF9jb21tZW50TGVuZ3RoID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBtYWluSGVhZGVyU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25zdGFudHMuRU5ESERSICsgX2NvbW1lbnRMZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9hZEZyb21CaW5hcnk6IGZ1bmN0aW9uICgvKkJ1ZmZlciovIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIGRhdGEgc2hvdWxkIGJlIDIyIGJ5dGVzIGFuZCBzdGFydCB3aXRoIFwiUEsgMDUgMDZcIlxuICAgICAgICAgICAgLy8gb3IgYmUgNTYrIGJ5dGVzIGFuZCBzdGFydCB3aXRoIFwiUEsgMDYgMDZcIiBmb3IgWmlwNjRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZGF0YS5sZW5ndGggIT09IENvbnN0YW50cy5FTkRIRFIgfHwgZGF0YS5yZWFkVUludDMyTEUoMCkgIT09IENvbnN0YW50cy5FTkRTSUcpICYmXG4gICAgICAgICAgICAgICAgKGRhdGEubGVuZ3RoIDwgQ29uc3RhbnRzLlpJUDY0SERSIHx8IGRhdGEucmVhZFVJbnQzMkxFKDApICE9PSBDb25zdGFudHMuWklQNjRTSUcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9FTkQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEucmVhZFVJbnQzMkxFKDApID09PSBDb25zdGFudHMuRU5EU0lHKSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGVudHJpZXMgb24gdGhpcyB2b2x1bWVcbiAgICAgICAgICAgICAgICBfdm9sdW1lRW50cmllcyA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5FTkRTVUIpO1xuICAgICAgICAgICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgICAgICAgICAgX3RvdGFsRW50cmllcyA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5FTkRUT1QpO1xuICAgICAgICAgICAgICAgIC8vIGNlbnRyYWwgZGlyZWN0b3J5IHNpemUgaW4gYnl0ZXNcbiAgICAgICAgICAgICAgICBfc2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5FTkRTSVopO1xuICAgICAgICAgICAgICAgIC8vIG9mZnNldCBvZiBmaXJzdCBDRU4gaGVhZGVyXG4gICAgICAgICAgICAgICAgX29mZnNldCA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5FTkRPRkYpO1xuICAgICAgICAgICAgICAgIC8vIHppcCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgICAgICAgICAgX2NvbW1lbnRMZW5ndGggPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuRU5EQ09NKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGVudHJpZXMgb24gdGhpcyB2b2x1bWVcbiAgICAgICAgICAgICAgICBfdm9sdW1lRW50cmllcyA9IFV0aWxzLnJlYWRCaWdVSW50NjRMRShkYXRhLCBDb25zdGFudHMuWklQNjRTVUIpO1xuICAgICAgICAgICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgICAgICAgICAgX3RvdGFsRW50cmllcyA9IFV0aWxzLnJlYWRCaWdVSW50NjRMRShkYXRhLCBDb25zdGFudHMuWklQNjRUT1QpO1xuICAgICAgICAgICAgICAgIC8vIGNlbnRyYWwgZGlyZWN0b3J5IHNpemUgaW4gYnl0ZXNcbiAgICAgICAgICAgICAgICBfc2l6ZSA9IFV0aWxzLnJlYWRCaWdVSW50NjRMRShkYXRhLCBDb25zdGFudHMuWklQNjRTSVpFKTtcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXQgb2YgZmlyc3QgQ0VOIGhlYWRlclxuICAgICAgICAgICAgICAgIF9vZmZzZXQgPSBVdGlscy5yZWFkQmlnVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLlpJUDY0T0ZGKTtcblxuICAgICAgICAgICAgICAgIF9jb21tZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b0JpbmFyeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGIgPSBCdWZmZXIuYWxsb2MoQ29uc3RhbnRzLkVOREhEUiArIF9jb21tZW50TGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIFwiUEsgMDUgMDZcIiBzaWduYXR1cmVcbiAgICAgICAgICAgIGIud3JpdGVVSW50MzJMRShDb25zdGFudHMuRU5EU0lHLCAwKTtcbiAgICAgICAgICAgIGIud3JpdGVVSW50MzJMRSgwLCA0KTtcbiAgICAgICAgICAgIC8vIG51bWJlciBvZiBlbnRyaWVzIG9uIHRoaXMgdm9sdW1lXG4gICAgICAgICAgICBiLndyaXRlVUludDE2TEUoX3ZvbHVtZUVudHJpZXMsIENvbnN0YW50cy5FTkRTVUIpO1xuICAgICAgICAgICAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXNcbiAgICAgICAgICAgIGIud3JpdGVVSW50MTZMRShfdG90YWxFbnRyaWVzLCBDb25zdGFudHMuRU5EVE9UKTtcbiAgICAgICAgICAgIC8vIGNlbnRyYWwgZGlyZWN0b3J5IHNpemUgaW4gYnl0ZXNcbiAgICAgICAgICAgIGIud3JpdGVVSW50MzJMRShfc2l6ZSwgQ29uc3RhbnRzLkVORFNJWik7XG4gICAgICAgICAgICAvLyBvZmZzZXQgb2YgZmlyc3QgQ0VOIGhlYWRlclxuICAgICAgICAgICAgYi53cml0ZVVJbnQzMkxFKF9vZmZzZXQsIENvbnN0YW50cy5FTkRPRkYpO1xuICAgICAgICAgICAgLy8gemlwIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgICAgIGIud3JpdGVVSW50MTZMRShfY29tbWVudExlbmd0aCwgQ29uc3RhbnRzLkVORENPTSk7XG4gICAgICAgICAgICAvLyBmaWxsIGNvbW1lbnQgbWVtb3J5IHdpdGggc3BhY2VzIHNvIG5vIGdhcmJhZ2UgaXMgbGVmdCB0aGVyZVxuICAgICAgICAgICAgYi5maWxsKFwiIFwiLCBDb25zdGFudHMuRU5ESERSKTtcblxuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGVzIDB4MDAwMCBzdHlsZSBvdXRwdXRcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGZ1bmN0aW9uIChuciwgbGVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9mZnMgPSBuci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAob2Zmcy5sZW5ndGggPCBsZW4pIG9mZnMgPSBcIjBcIiArIG9mZnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIG9mZnM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc2tFbnRyaWVzOiBfdm9sdW1lRW50cmllcyxcbiAgICAgICAgICAgICAgICB0b3RhbEVudHJpZXM6IF90b3RhbEVudHJpZXMsXG4gICAgICAgICAgICAgICAgc2l6ZTogX3NpemUgKyBcIiBieXRlc1wiLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0KF9vZmZzZXQsIDQpLFxuICAgICAgICAgICAgICAgIGNvbW1lbnRMZW5ndGg6IF9jb21tZW50TGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgXCJcXHRcIik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8vIE1pc3NwZWxsZWRcbiIsICJleHBvcnRzLkVudHJ5SGVhZGVyID0gcmVxdWlyZShcIi4vZW50cnlIZWFkZXJcIik7XG5leHBvcnRzLk1haW5IZWFkZXIgPSByZXF1aXJlKFwiLi9tYWluSGVhZGVyXCIpO1xuIiwgIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qQnVmZmVyKi8gaW5idWYpIHtcbiAgICB2YXIgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuXG4gICAgdmFyIG9wdHMgPSB7IGNodW5rU2l6ZTogKHBhcnNlSW50KGluYnVmLmxlbmd0aCAvIDEwMjQpICsgMSkgKiAxMDI0IH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gemxpYi5kZWZsYXRlUmF3U3luYyhpbmJ1Ziwgb3B0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmbGF0ZUFzeW5jOiBmdW5jdGlvbiAoLypGdW5jdGlvbiovIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KG9wdHMpLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgICAgICAgICAgdG90YWwgPSAwO1xuICAgICAgICAgICAgdG1wLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRtcC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyh0b3RhbCksXG4gICAgICAgICAgICAgICAgICAgIHdyaXR0ZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJ1Zi5maWxsKDApO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5jb3B5KGJ1Ziwgd3JpdHRlbik7XG4gICAgICAgICAgICAgICAgICAgIHdyaXR0ZW4gKz0gcGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGJ1Zik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRtcC5lbmQoaW5idWYpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCAiY29uc3QgdmVyc2lvbiA9ICsocHJvY2Vzcy52ZXJzaW9ucyA/IHByb2Nlc3MudmVyc2lvbnMubm9kZSA6IFwiXCIpLnNwbGl0KFwiLlwiKVswXSB8fCAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgvKkJ1ZmZlciovIGluYnVmLCAvKm51bWJlciovIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgdmFyIHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcbiAgICBjb25zdCBvcHRpb24gPSB2ZXJzaW9uID49IDE1ICYmIGV4cGVjdGVkTGVuZ3RoID4gMCA/IHsgbWF4T3V0cHV0TGVuZ3RoOiBleHBlY3RlZExlbmd0aCB9IDoge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpbmZsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gemxpYi5pbmZsYXRlUmF3U3luYyhpbmJ1Ziwgb3B0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbmZsYXRlQXN5bmM6IGZ1bmN0aW9uICgvKkZ1bmN0aW9uKi8gY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcob3B0aW9uKSxcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IFtdLFxuICAgICAgICAgICAgICAgIHRvdGFsID0gMDtcbiAgICAgICAgICAgIHRtcC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0bXAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2ModG90YWwpLFxuICAgICAgICAgICAgICAgICAgICB3cml0dGVuID0gMDtcbiAgICAgICAgICAgICAgICBidWYuZmlsbCgwKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHBhcnQuY29weShidWYsIHdyaXR0ZW4pO1xuICAgICAgICAgICAgICAgICAgICB3cml0dGVuICs9IHBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhidWYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0bXAuZW5kKGluYnVmKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4vLyBub2RlIGNyeXB0LCB3ZSB1c2UgaXQgZm9yIGdlbmVyYXRlIHNhbHRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKFwiLi4vdXRpbC9lcnJvcnNcIik7XG5cbi8vIGdlbmVyYXRlIENSQzMyIGxvb2t1cCB0YWJsZVxuY29uc3QgY3JjdGFibGUgPSBuZXcgVWludDMyQXJyYXkoMjU2KS5tYXAoKHQsIGNyYykgPT4ge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAgIGlmICgwICE9PSAoY3JjICYgMSkpIHtcbiAgICAgICAgICAgIGNyYyA9IChjcmMgPj4+IDEpIF4gMHhlZGI4ODMyMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNyYyA+Pj49IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyYyA+Pj4gMDtcbn0pO1xuXG4vLyBDLXN0eWxlIHVJbnQzMiBNdWx0aXBseSAoZGlzY2FyZHMgaGlnaGVyIGJpdHMsIHdoZW4gSlMgbXVsdGlwbHkgZGlzY2FyZHMgbG93ZXIgYml0cylcbmNvbnN0IHVNdWwgPSAoYSwgYikgPT4gTWF0aC5pbXVsKGEsIGIpID4+PiAwO1xuXG4vLyBjcmMzMiBieXRlIHNpbmdsZSB1cGRhdGUgKGFjdHVhbGx5IHNhbWUgZnVuY3Rpb24gaXMgcGFydCBvZiB1dGlscy5jcmMzMiBmdW5jdGlvbiA6KSApXG5jb25zdCBjcmMzMnVwZGF0ZSA9IChwQ3JjMzIsIGJ2YWwpID0+IHtcbiAgICByZXR1cm4gY3JjdGFibGVbKHBDcmMzMiBeIGJ2YWwpICYgMHhmZl0gXiAocENyYzMyID4+PiA4KTtcbn07XG5cbi8vIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIHNhbHQgZm9yIGVuY3J5dGlvbiBoZWFkZXJcbmNvbnN0IGdlblNhbHQgPSAoKSA9PiB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJhbmRvbUZpbGxTeW5jKSB7XG4gICAgICAgIHJldHVybiByYW5kb21GaWxsU3luYyhCdWZmZXIuYWxsb2MoMTIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmYWxsYmFjayBpZiBmdW5jdGlvbiBpcyBub3QgZGVmaW5lZFxuICAgICAgICByZXR1cm4gZ2VuU2FsdC5ub2RlKCk7XG4gICAgfVxufTtcblxuLy8gc2FsdCBnZW5lcmF0aW9uIHdpdGggbm9kZSByYW5kb20gZnVuY3Rpb24gKG1haW5seSBhcyBmYWxsYmFjaylcbmdlblNhbHQubm9kZSA9ICgpID0+IHtcbiAgICBjb25zdCBzYWx0ID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgICBjb25zdCBsZW4gPSBzYWx0Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSBzYWx0W2ldID0gKE1hdGgucmFuZG9tKCkgKiAyNTYpICYgMHhmZjtcbiAgICByZXR1cm4gc2FsdDtcbn07XG5cbi8vIGdlbmVyYWwgY29uZmlnXG5jb25zdCBjb25maWcgPSB7XG4gICAgZ2VuU2FsdFxufTtcblxuLy8gQ2xhc3MgSW5pdGtleXMgaGFuZGxlcyBzYW1lIGJhc2ljIG9wcyB3aXRoIGtleXNcbmZ1bmN0aW9uIEluaXRrZXlzKHB3KSB7XG4gICAgY29uc3QgcGFzcyA9IEJ1ZmZlci5pc0J1ZmZlcihwdykgPyBwdyA6IEJ1ZmZlci5mcm9tKHB3KTtcbiAgICB0aGlzLmtleXMgPSBuZXcgVWludDMyQXJyYXkoWzB4MTIzNDU2NzgsIDB4MjM0NTY3ODksIDB4MzQ1Njc4OTBdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy51cGRhdGVLZXlzKHBhc3NbaV0pO1xuICAgIH1cbn1cblxuSW5pdGtleXMucHJvdG90eXBlLnVwZGF0ZUtleXMgPSBmdW5jdGlvbiAoYnl0ZVZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cztcbiAgICBrZXlzWzBdID0gY3JjMzJ1cGRhdGUoa2V5c1swXSwgYnl0ZVZhbHVlKTtcbiAgICBrZXlzWzFdICs9IGtleXNbMF0gJiAweGZmO1xuICAgIGtleXNbMV0gPSB1TXVsKGtleXNbMV0sIDEzNDc3NTgxMykgKyAxO1xuICAgIGtleXNbMl0gPSBjcmMzMnVwZGF0ZShrZXlzWzJdLCBrZXlzWzFdID4+PiAyNCk7XG4gICAgcmV0dXJuIGJ5dGVWYWx1ZTtcbn07XG5cbkluaXRrZXlzLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGsgPSAodGhpcy5rZXlzWzJdIHwgMikgPj4+IDA7IC8vIGtleVxuICAgIHJldHVybiAodU11bChrLCBrIF4gMSkgPj4gOCkgJiAweGZmOyAvLyBkZWNvZGVcbn07XG5cbmZ1bmN0aW9uIG1ha2VfZGVjcnlwdGVyKC8qQnVmZmVyKi8gcHdkKSB7XG4gICAgLy8gMS4gU3RhZ2UgaW5pdGlhbGl6ZSBrZXlcbiAgICBjb25zdCBrZXlzID0gbmV3IEluaXRrZXlzKHB3ZCk7XG5cbiAgICAvLyByZXR1cm4gZGVjcnlwdGVyIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgvKkJ1ZmZlciovIGRhdGEpIHtcbiAgICAgICAgLy8gcmVzdWx0IC0gd2UgY3JlYXRlIG5ldyBCdWZmZXIgZm9yIHJlc3VsdHNcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKGRhdGEubGVuZ3RoKTtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIC8vIHByb2Nlc3MgaW5wdXQgZGF0YVxuICAgICAgICBmb3IgKGxldCBjIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIC8vYyBePSBrZXlzLm5leHQoKTtcbiAgICAgICAgICAgIC8vcmVzdWx0W3BvcysrXSA9IGM7IC8vIGRlY29kZSAmIFNhdmUgVmFsdWVcbiAgICAgICAgICAgIHJlc3VsdFtwb3MrK10gPSBrZXlzLnVwZGF0ZUtleXMoYyBeIGtleXMubmV4dCgpKTsgLy8gdXBkYXRlIGtleXMgd2l0aCBkZWNvZGVkIGJ5dGVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfZW5jcnlwdGVyKC8qQnVmZmVyKi8gcHdkKSB7XG4gICAgLy8gMS4gU3RhZ2UgaW5pdGlhbGl6ZSBrZXlcbiAgICBjb25zdCBrZXlzID0gbmV3IEluaXRrZXlzKHB3ZCk7XG5cbiAgICAvLyByZXR1cm4gZW5jcnlwdGluZyBmdW5jdGlvbiwgcmVzdWx0IGFuZCBwb3MgaXMgaGVyZSBzbyB3ZSBkb250IGhhdmUgdG8gbWVyZ2UgYnVmZmVycyBsYXRlclxuICAgIHJldHVybiBmdW5jdGlvbiAoLypCdWZmZXIqLyBkYXRhLCAvKkJ1ZmZlciovIHJlc3VsdCwgLyogTnVtYmVyICovIHBvcyA9IDApIHtcbiAgICAgICAgLy8gcmVzdWx0IC0gd2UgY3JlYXRlIG5ldyBCdWZmZXIgZm9yIHJlc3VsdHNcbiAgICAgICAgaWYgKCFyZXN1bHQpIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhkYXRhLmxlbmd0aCk7XG4gICAgICAgIC8vIHByb2Nlc3MgaW5wdXQgZGF0YVxuICAgICAgICBmb3IgKGxldCBjIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBrZXlzLm5leHQoKTsgLy8gc2F2ZSBrZXkgYnl0ZVxuICAgICAgICAgICAgcmVzdWx0W3BvcysrXSA9IGMgXiBrOyAvLyBzYXZlIHZhbFxuICAgICAgICAgICAga2V5cy51cGRhdGVLZXlzKGMpOyAvLyB1cGRhdGUga2V5cyB3aXRoIGRlY29kZWQgYnl0ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGVjcnlwdCgvKkJ1ZmZlciovIGRhdGEsIC8qT2JqZWN0Ki8gaGVhZGVyLCAvKlN0cmluZywgQnVmZmVyKi8gcHdkKSB7XG4gICAgaWYgKCFkYXRhIHx8ICFCdWZmZXIuaXNCdWZmZXIoZGF0YSkgfHwgZGF0YS5sZW5ndGggPCAxMikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIH1cblxuICAgIC8vIDEuIFdlIEluaXRpYWxpemUgYW5kIGdlbmVyYXRlIGRlY3J5cHRpbmcgZnVuY3Rpb25cbiAgICBjb25zdCBkZWNyeXB0ZXIgPSBtYWtlX2RlY3J5cHRlcihwd2QpO1xuXG4gICAgLy8gMi4gZGVjcnlwdCBzYWx0IHdoYXQgaXMgYWx3YXlzIDEyIGJ5dGVzIGFuZCBpcyBhIHBhcnQgb2YgZmlsZSBjb250ZW50XG4gICAgY29uc3Qgc2FsdCA9IGRlY3J5cHRlcihkYXRhLnNsaWNlKDAsIDEyKSk7XG5cbiAgICAvLyBpZiBiaXQgMyAoMHgwOCkgb2YgdGhlIGdlbmVyYWwtcHVycG9zZSBmbGFncyBmaWVsZCBpcyBzZXQsIGNoZWNrIHNhbHRbMTFdIHdpdGggdGhlIGhpZ2ggYnl0ZSBvZiB0aGUgaGVhZGVyIHRpbWVcbiAgICAvLyAyIGJ5dGUgZGF0YSBibG9jayAoYXMgcGVyIEluZm8tWmlwIHNwZWMpLCBvdGhlcndpc2UgY2hlY2sgd2l0aCB0aGUgaGlnaCBieXRlIG9mIHRoZSBoZWFkZXIgZW50cnlcbiAgICBjb25zdCB2ZXJpZnlCeXRlID0gKGhlYWRlci5mbGFncyAmIDB4OCkgPT09IDB4OCA/IGhlYWRlci50aW1lSGlnaEJ5dGUgOiBoZWFkZXIuY3JjID4+PiAyNDtcblxuICAgIC8vMy4gZG9lcyBwYXNzd29yZCBtZWV0IGV4cGVjdGF0aW9uc1xuICAgIGlmIChzYWx0WzExXSAhPT0gdmVyaWZ5Qnl0ZSkge1xuICAgICAgICB0aHJvdyBFcnJvcnMuV1JPTkdfUEFTU1dPUkQoKTtcbiAgICB9XG5cbiAgICAvLyA0LiBkZWNvZGUgY29udGVudFxuICAgIHJldHVybiBkZWNyeXB0ZXIoZGF0YS5zbGljZSgxMikpO1xufVxuXG4vLyBsZXRzIGFkZCB3YXkgdG8gcG9wdWxhdGUgc2FsdCwgTk9UIFJFQ09NTUVOREVEIGZvciBwcm9kdWN0aW9uIGJ1dCBtYXliZSB1c2VmdWwgZm9yIHRlc3RpbmcgZ2VuZXJhbCBmdW5jdGlvbmFsaXR5XG5mdW5jdGlvbiBfc2FsdGVyKGRhdGEpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIGRhdGEubGVuZ3RoID49IDEyKSB7XG4gICAgICAgIC8vIGJlIGF3YXJlIC0gY3VycmVudGx5IHNhbHRpbmcgYnVmZmVyIGRhdGEgaXMgbW9kaWZpZWRcbiAgICAgICAgY29uZmlnLmdlblNhbHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5zbGljZSgwLCAxMik7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSBcIm5vZGVcIikge1xuICAgICAgICAvLyB0ZXN0IHNhbHQgZ2VuZXJhdGlvbiB3aXRoIG5vZGUgcmFuZG9tIGZ1bmN0aW9uXG4gICAgICAgIGNvbmZpZy5nZW5TYWx0ID0gZ2VuU2FsdC5ub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHZhbHVlIGlzIG5vdCBhY2NlcHRhYmxlIGNvbmZpZyBnZXRzIHJlc2V0LlxuICAgICAgICBjb25maWcuZ2VuU2FsdCA9IGdlblNhbHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBlbmNyeXB0KC8qQnVmZmVyKi8gZGF0YSwgLypPYmplY3QqLyBoZWFkZXIsIC8qU3RyaW5nLCBCdWZmZXIqLyBwd2QsIC8qQm9vbGVhbiovIG9sZGxpa2UgPSBmYWxzZSkge1xuICAgIC8vIDEuIHRlc3QgZGF0YSBpZiBkYXRhIGlzIG5vdCBCdWZmZXIgd2UgbWFrZSBidWZmZXIgZnJvbSBpdFxuICAgIGlmIChkYXRhID09IG51bGwpIGRhdGEgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgLy8gaWYgZGF0YSBpcyBub3QgYnVmZmVyIGJlIG1ha2UgYnVmZmVyIGZyb20gaXRcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEudG9TdHJpbmcoKSk7XG5cbiAgICAvLyAyLiBXZSBJbml0aWFsaXplIGFuZCBnZW5lcmF0ZSBlbmNyeXB0aW5nIGZ1bmN0aW9uXG4gICAgY29uc3QgZW5jcnlwdGVyID0gbWFrZV9lbmNyeXB0ZXIocHdkKTtcblxuICAgIC8vIDMuIGdlbmVyYXRlIHNhbHQgKDEyLWJ5dGVzIG9mIHJhbmRvbSBkYXRhKVxuICAgIGNvbnN0IHNhbHQgPSBjb25maWcuZ2VuU2FsdCgpO1xuICAgIHNhbHRbMTFdID0gKGhlYWRlci5jcmMgPj4+IDI0KSAmIDB4ZmY7XG5cbiAgICAvLyBvbGQgaW1wbGVtZW50YXRpb25zIChiZWZvcmUgUEtaaXAgMi4wNGcpIHVzZWQgdHdvIGJ5dGUgY2hlY2tcbiAgICBpZiAob2xkbGlrZSkgc2FsdFsxMF0gPSAoaGVhZGVyLmNyYyA+Pj4gMTYpICYgMHhmZjtcblxuICAgIC8vIDQuIGNyZWF0ZSBvdXRwdXRcbiAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuYWxsb2MoZGF0YS5sZW5ndGggKyAxMik7XG4gICAgZW5jcnlwdGVyKHNhbHQsIHJlc3VsdCk7XG5cbiAgICAvLyBmaW5hbGx5IGVuY29kZSBjb250ZW50XG4gICAgcmV0dXJuIGVuY3J5cHRlcihkYXRhLCByZXN1bHQsIDEyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGRlY3J5cHQsIGVuY3J5cHQsIF9zYWx0ZXIgfTtcbiIsICJleHBvcnRzLkRlZmxhdGVyID0gcmVxdWlyZShcIi4vZGVmbGF0ZXJcIik7XG5leHBvcnRzLkluZmxhdGVyID0gcmVxdWlyZShcIi4vaW5mbGF0ZXJcIik7XG5leHBvcnRzLlppcENyeXB0byA9IHJlcXVpcmUoXCIuL3ppcGNyeXB0b1wiKTtcbiIsICJ2YXIgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxuICAgIEhlYWRlcnMgPSByZXF1aXJlKFwiLi9oZWFkZXJzXCIpLFxuICAgIENvbnN0YW50cyA9IFV0aWxzLkNvbnN0YW50cyxcbiAgICBNZXRob2RzID0gcmVxdWlyZShcIi4vbWV0aG9kc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLyoqIG9iamVjdCAqLyBvcHRpb25zLCAvKkJ1ZmZlciovIGlucHV0KSB7XG4gICAgdmFyIF9jZW50cmFsSGVhZGVyID0gbmV3IEhlYWRlcnMuRW50cnlIZWFkZXIoKSxcbiAgICAgICAgX2VudHJ5TmFtZSA9IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgX2NvbW1lbnQgPSBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIF9pc0RpcmVjdG9yeSA9IGZhbHNlLFxuICAgICAgICB1bmNvbXByZXNzZWREYXRhID0gbnVsbCxcbiAgICAgICAgX2V4dHJhID0gQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBfZXh0cmFsb2NhbCA9IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgX2VmcyA9IHRydWU7XG5cbiAgICAvLyBhc3NpZ24gb3B0aW9uc1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zO1xuXG4gICAgY29uc3QgZGVjb2RlciA9IHR5cGVvZiBvcHRzLmRlY29kZXIgPT09IFwib2JqZWN0XCIgPyBvcHRzLmRlY29kZXIgOiBVdGlscy5kZWNvZGVyO1xuICAgIF9lZnMgPSBkZWNvZGVyLmhhc093blByb3BlcnR5KFwiZWZzXCIpID8gZGVjb2Rlci5lZnMgOiBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGdldENvbXByZXNzZWREYXRhRnJvbVppcCgpIHtcbiAgICAgICAgLy9pZiAoIWlucHV0IHx8ICFCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgIGlmICghaW5wdXQgfHwgIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB9XG4gICAgICAgIF9leHRyYWxvY2FsID0gX2NlbnRyYWxIZWFkZXIubG9hZExvY2FsSGVhZGVyRnJvbUJpbmFyeShpbnB1dCk7XG4gICAgICAgIHJldHVybiBpbnB1dC5zbGljZShfY2VudHJhbEhlYWRlci5yZWFsRGF0YU9mZnNldCwgX2NlbnRyYWxIZWFkZXIucmVhbERhdGFPZmZzZXQgKyBfY2VudHJhbEhlYWRlci5jb21wcmVzc2VkU2l6ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JjMzJPSyhkYXRhKSB7XG4gICAgICAgIC8vIGlmIGJpdCAzICgweDA4KSBvZiB0aGUgZ2VuZXJhbC1wdXJwb3NlIGZsYWdzIGZpZWxkIGlzIHNldCwgdGhlbiB0aGUgQ1JDLTMyIGFuZCBmaWxlIHNpemVzIGFyZSBub3Qga25vd24gd2hlbiB0aGUgbG9jYWwgaGVhZGVyIGlzIHdyaXR0ZW5cbiAgICAgICAgaWYgKCFfY2VudHJhbEhlYWRlci5mbGFnc19kZXNjKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuY3JjMzIoZGF0YSkgIT09IF9jZW50cmFsSGVhZGVyLmxvY2FsSGVhZGVyLmNyYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFFbmRPZmZzZXQgPSBfY2VudHJhbEhlYWRlci5yZWFsRGF0YU9mZnNldCArIF9jZW50cmFsSGVhZGVyLmNvbXByZXNzZWRTaXplO1xuICAgICAgICAgICAgLy8gbm8gZGVzY3JpcHRvciBhZnRlciBjb21wcmVzc2VkIGRhdGEsIGluc3RlYWQgbmV3IGxvY2FsIGhlYWRlclxuICAgICAgICAgICAgaWYgKGlucHV0LnJlYWRVSW50MzJMRShkYXRhRW5kT2Zmc2V0KSA9PSBDb25zdGFudHMuTE9DU0lHIHx8IGlucHV0LnJlYWRVSW50MzJMRShkYXRhRW5kT2Zmc2V0KSA9PSBDb25zdGFudHMuQ0VOU0lHKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkRFU0NSSVBUT1JfTk9UX0VYSVNUKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGdldCBkZWNyaXB0b3IgZGF0YVxuICAgICAgICAgICAgaWYgKGlucHV0LnJlYWRVSW50MzJMRShkYXRhRW5kT2Zmc2V0KSA9PSBDb25zdGFudHMuRVhUU0lHKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVzY3JpcHRvciB3aXRoIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuY3JjID0gaW5wdXQucmVhZFVJbnQzMkxFKGRhdGFFbmRPZmZzZXQgKyBDb25zdGFudHMuRVhUQ1JDKTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbXByZXNzZWRTaXplID0gaW5wdXQucmVhZFVJbnQzMkxFKGRhdGFFbmRPZmZzZXQgKyBDb25zdGFudHMuRVhUU0laKTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNpemUgPSBpbnB1dC5yZWFkVUludDMyTEUoZGF0YUVuZE9mZnNldCArIENvbnN0YW50cy5FWFRMRU4pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5yZWFkVUludDE2TEUoZGF0YUVuZE9mZnNldCArIDEyKSA9PT0gMHg0YjUwKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVzY3JpcHRvciB3aXRob3V0IHNpZ25hdHVyZSAod2UgY2hlY2sgaXMgbmV3IGhlYWRlciBzdGFydGluZyB3aGVyZSB3ZSBleHBlY3QpXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5jcmMgPSBpbnB1dC5yZWFkVUludDMyTEUoZGF0YUVuZE9mZnNldCArIENvbnN0YW50cy5FWFRDUkMgLSA0KTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbXByZXNzZWRTaXplID0gaW5wdXQucmVhZFVJbnQzMkxFKGRhdGFFbmRPZmZzZXQgKyBDb25zdGFudHMuRVhUU0laIC0gNCk7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5zaXplID0gaW5wdXQucmVhZFVJbnQzMkxFKGRhdGFFbmRPZmZzZXQgKyBDb25zdGFudHMuRVhUTEVOIC0gNCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5ERVNDUklQVE9SX1VOS05PV04oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZGF0YSBpbnRlZ3JpdHlcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmNvbXByZXNzZWRTaXplICE9PSBfY2VudHJhbEhlYWRlci5jb21wcmVzc2VkU2l6ZSB8fCBkZXNjcmlwdG9yLnNpemUgIT09IF9jZW50cmFsSGVhZGVyLnNpemUgfHwgZGVzY3JpcHRvci5jcmMgIT09IF9jZW50cmFsSGVhZGVyLmNyYykge1xuICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5ERVNDUklQVE9SX0ZBVUxUWSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFV0aWxzLmNyYzMyKGRhdGEpICE9PSBkZXNjcmlwdG9yLmNyYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQFRPRE86IHppcDY0IGJpdCBkZXNjcmlwdG9yIGZpZWxkc1xuICAgICAgICAgICAgLy8gaWYgYml0IDMgaXMgc2V0IGFuZCBhbnkgdmFsdWUgaW4gbG9jYWwgaGVhZGVyIFwiemlwNjQgRXh0ZW5kZWQgaW5mb3JtYXRpb25cIiBleHRyYSBmaWVsZCBhcmUgc2V0IDAgKHBsYWNlIGhvbGRlcilcbiAgICAgICAgICAgIC8vIHRoZW4gNjQtYml0IGRlc2NyaXB0b3IgZm9ybWF0IGlzIHVzZWQgaW5zdGVhZCBvZiAzMi1iaXRcbiAgICAgICAgICAgIC8vIGNlbnRyYWwgaGVhZGVyIC0gXCJ6aXA2NCBFeHRlbmRlZCBpbmZvcm1hdGlvblwiIGV4dHJhIGZpZWxkIHNob3VsZCBzdG9yZSByZWFsIHZhbHVlcyBhbmQgbm90IHBsYWNlIGhvbGRlcnNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWNvbXByZXNzKC8qQm9vbGVhbiovIGFzeW5jLCAvKkZ1bmN0aW9uKi8gY2FsbGJhY2ssIC8qU3RyaW5nLCBCdWZmZXIqLyBwYXNzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFzeW5jID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXNzID0gYXN5bmM7XG4gICAgICAgICAgICBhc3luYyA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2lzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhCdWZmZXIuYWxsb2MoMCksIFV0aWxzLkVycm9ycy5ESVJFQ1RPUllfQ09OVEVOVF9FUlJPUigpKTsgLy9zaSBhZGRlZCBlcnJvci5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcHJlc3NlZERhdGEgPSBnZXRDb21wcmVzc2VkRGF0YUZyb21aaXAoKTtcblxuICAgICAgICBpZiAoY29tcHJlc3NlZERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBGaWxlIGlzIGVtcHR5LCBub3RoaW5nIHRvIGRlY29tcHJlc3MuXG4gICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIGNhbGxiYWNrKGNvbXByZXNzZWREYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2VkRGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfY2VudHJhbEhlYWRlci5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgcGFzcyAmJiAhQnVmZmVyLmlzQnVmZmVyKHBhc3MpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLklOVkFMSURfUEFTU19QQVJBTSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcHJlc3NlZERhdGEgPSBNZXRob2RzLlppcENyeXB0by5kZWNyeXB0KGNvbXByZXNzZWREYXRhLCBfY2VudHJhbEhlYWRlciwgcGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IEJ1ZmZlci5hbGxvYyhfY2VudHJhbEhlYWRlci5zaXplKTtcblxuICAgICAgICBzd2l0Y2ggKF9jZW50cmFsSGVhZGVyLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBVdGlscy5Db25zdGFudHMuU1RPUkVEOlxuICAgICAgICAgICAgICAgIGNvbXByZXNzZWREYXRhLmNvcHkoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjcmMzMk9LKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3luYyAmJiBjYWxsYmFjaykgY2FsbGJhY2soZGF0YSwgVXRpbHMuRXJyb3JzLkJBRF9DUkMoKSk7IC8vc2kgYWRkZWQgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkJBRF9DUkMoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL3NpIGFkZGVkIG90aGVyd2lzZSBkaWQgbm90IHNlZW0gdG8gcmV0dXJuIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3luYyAmJiBjYWxsYmFjaykgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVXRpbHMuQ29uc3RhbnRzLkRFRkxBVEVEOlxuICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlciA9IG5ldyBNZXRob2RzLkluZmxhdGVyKGNvbXByZXNzZWREYXRhLCBfY2VudHJhbEhlYWRlci5zaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGluZmxhdGVyLmluZmxhdGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb3B5KGRhdGEsIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNyYzMyT0soZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5CQURfQ1JDKGBcIiR7ZGVjb2Rlci5kZWNvZGUoX2VudHJ5TmFtZSl9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmZsYXRlci5pbmZsYXRlQXN5bmMoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvcHkocmVzdWx0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3JjMzJPSyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCwgVXRpbHMuRXJyb3JzLkJBRF9DUkMoKSk7IC8vc2kgYWRkZWQgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIGNhbGxiYWNrKEJ1ZmZlci5hbGxvYygwKSwgVXRpbHMuRXJyb3JzLlVOS05PV05fTUVUSE9EKCkpO1xuICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5VTktOT1dOX01FVEhPRCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHJlc3MoLypCb29sZWFuKi8gYXN5bmMsIC8qRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuICAgICAgICBpZiAoKCF1bmNvbXByZXNzZWREYXRhIHx8ICF1bmNvbXByZXNzZWREYXRhLmxlbmd0aCkgJiYgQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gbm8gZGF0YSBzZXQgb3IgdGhlIGRhdGEgd2Fzbid0IGNoYW5nZWQgdG8gcmVxdWlyZSByZWNvbXByZXNzaW9uXG4gICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIGNhbGxiYWNrKGdldENvbXByZXNzZWREYXRhRnJvbVppcCgpKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wcmVzc2VkRGF0YUZyb21aaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCAmJiAhX2lzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZERhdGE7XG4gICAgICAgICAgICAvLyBMb2NhbCBmaWxlIGhlYWRlclxuICAgICAgICAgICAgc3dpdGNoIChfY2VudHJhbEhlYWRlci5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFV0aWxzLkNvbnN0YW50cy5TVE9SRUQ6XG4gICAgICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmNvbXByZXNzZWRTaXplID0gX2NlbnRyYWxIZWFkZXIuc2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2VkRGF0YSA9IEJ1ZmZlci5hbGxvYyh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHVuY29tcHJlc3NlZERhdGEuY29weShjb21wcmVzc2VkRGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzeW5jICYmIGNhbGxiYWNrKSBjYWxsYmFjayhjb21wcmVzc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2VkRGF0YTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNhc2UgVXRpbHMuQ29uc3RhbnRzLkRFRkxBVEVEOlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmbGF0ZXIgPSBuZXcgTWV0aG9kcy5EZWZsYXRlcih1bmNvbXByZXNzZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmxhdGVkID0gZGVmbGF0ZXIuZGVmbGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuY29tcHJlc3NlZFNpemUgPSBkZWZsYXRlZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmbGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZsYXRlci5kZWZsYXRlQXN5bmMoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2VkRGF0YSA9IEJ1ZmZlci5hbGxvYyhkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuY29tcHJlc3NlZFNpemUgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNvcHkoY29tcHJlc3NlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNvbXByZXNzZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmxhdGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKEJ1ZmZlci5hbGxvYygwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFVJbnQ2NExFKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAoYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyA0KSA8PCA0KSArIGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4dHJhKGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSwgc2l6ZSwgcGFydDtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgKyA0IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBkYXRhLnJlYWRVSW50MTZMRShvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgIHNpemUgPSBkYXRhLnJlYWRVSW50MTZMRShvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgIHBhcnQgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgICAgICAgICAgICAgaWYgKENvbnN0YW50cy5JRF9aSVA2NCA9PT0gc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlWmlwNjRFeHRlbmRlZEluZm9ybWF0aW9uKHBhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5FWFRSQV9GSUVMRF9QQVJTRV9FUlJPUigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9PdmVycmlkZSBoZWFkZXIgZmllbGQgdmFsdWVzIHdpdGggdmFsdWVzIGZyb20gdGhlIFpJUDY0IGV4dHJhIGZpZWxkXG4gICAgZnVuY3Rpb24gcGFyc2VaaXA2NEV4dGVuZGVkSW5mb3JtYXRpb24oZGF0YSkge1xuICAgICAgICB2YXIgc2l6ZSwgY29tcHJlc3NlZFNpemUsIG9mZnNldCwgZGlza051bVN0YXJ0O1xuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+PSBDb25zdGFudHMuRUZfWklQNjRfU0NPTVApIHtcbiAgICAgICAgICAgIHNpemUgPSByZWFkVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLkVGX1pJUDY0X1NVTkNPTVApO1xuICAgICAgICAgICAgaWYgKF9jZW50cmFsSGVhZGVyLnNpemUgPT09IENvbnN0YW50cy5FRl9aSVA2NF9PUl8zMikge1xuICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+PSBDb25zdGFudHMuRUZfWklQNjRfUkhPKSB7XG4gICAgICAgICAgICBjb21wcmVzc2VkU2l6ZSA9IHJlYWRVSW50NjRMRShkYXRhLCBDb25zdGFudHMuRUZfWklQNjRfU0NPTVApO1xuICAgICAgICAgICAgaWYgKF9jZW50cmFsSGVhZGVyLmNvbXByZXNzZWRTaXplID09PSBDb25zdGFudHMuRUZfWklQNjRfT1JfMzIpIHtcbiAgICAgICAgICAgICAgICBfY2VudHJhbEhlYWRlci5jb21wcmVzc2VkU2l6ZSA9IGNvbXByZXNzZWRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+PSBDb25zdGFudHMuRUZfWklQNjRfRFNOKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSByZWFkVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLkVGX1pJUDY0X1JITyk7XG4gICAgICAgICAgICBpZiAoX2NlbnRyYWxIZWFkZXIub2Zmc2V0ID09PSBDb25zdGFudHMuRUZfWklQNjRfT1JfMzIpIHtcbiAgICAgICAgICAgICAgICBfY2VudHJhbEhlYWRlci5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID49IENvbnN0YW50cy5FRl9aSVA2NF9EU04gKyA0KSB7XG4gICAgICAgICAgICBkaXNrTnVtU3RhcnQgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuRUZfWklQNjRfRFNOKTtcbiAgICAgICAgICAgIGlmIChfY2VudHJhbEhlYWRlci5kaXNrTnVtU3RhcnQgPT09IENvbnN0YW50cy5FRl9aSVA2NF9PUl8xNikge1xuICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmRpc2tOdW1TdGFydCA9IGRpc2tOdW1TdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBlbnRyeU5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoX2VudHJ5TmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCByYXdFbnRyeU5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2VudHJ5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGVudHJ5TmFtZSh2YWwpIHtcbiAgICAgICAgICAgIF9lbnRyeU5hbWUgPSBVdGlscy50b0J1ZmZlcih2YWwsIGRlY29kZXIuZW5jb2RlKTtcbiAgICAgICAgICAgIHZhciBsYXN0Q2hhciA9IF9lbnRyeU5hbWVbX2VudHJ5TmFtZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIF9pc0RpcmVjdG9yeSA9IGxhc3RDaGFyID09PSA0NyB8fCBsYXN0Q2hhciA9PT0gOTI7XG4gICAgICAgICAgICBfY2VudHJhbEhlYWRlci5maWxlTmFtZUxlbmd0aCA9IF9lbnRyeU5hbWUubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBlZnMoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF9lZnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZWZzKHRoaXMuZW50cnlOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lZnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGV4dHJhKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9leHRyYTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGV4dHJhKHZhbCkge1xuICAgICAgICAgICAgX2V4dHJhID0gdmFsO1xuICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuZXh0cmFMZW5ndGggPSB2YWwubGVuZ3RoO1xuICAgICAgICAgICAgcGFyc2VFeHRyYSh2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBjb21tZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKF9jb21tZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGNvbW1lbnQodmFsKSB7XG4gICAgICAgICAgICBfY29tbWVudCA9IFV0aWxzLnRvQnVmZmVyKHZhbCwgZGVjb2Rlci5lbmNvZGUpO1xuICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuY29tbWVudExlbmd0aCA9IF9jb21tZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChfY29tbWVudC5sZW5ndGggPiAweGZmZmYpIHRocm93IFV0aWxzLkVycm9ycy5DT01NRU5UX1RPT19MT05HKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGRlY29kZXIuZGVjb2RlKF9lbnRyeU5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIF9pc0RpcmVjdG9yeVxuICAgICAgICAgICAgICAgID8gblxuICAgICAgICAgICAgICAgICAgICAgIC5zdWJzdHIobi5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdChcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAucG9wKClcbiAgICAgICAgICAgICAgICA6IG4uc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNEaXJlY3RvcnkoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2lzRGlyZWN0b3J5O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbXByZXNzZWREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3MoZmFsc2UsIG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbXByZXNzZWREYXRhQXN5bmM6IGZ1bmN0aW9uICgvKkZ1bmN0aW9uKi8gY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbXByZXNzKHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXREYXRhOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHVuY29tcHJlc3NlZERhdGEgPSBVdGlscy50b0J1ZmZlcih2YWx1ZSwgVXRpbHMuZGVjb2Rlci5lbmNvZGUpO1xuICAgICAgICAgICAgaWYgKCFfaXNEaXJlY3RvcnkgJiYgdW5jb21wcmVzc2VkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfY2VudHJhbEhlYWRlci5zaXplID0gdW5jb21wcmVzc2VkRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIubWV0aG9kID0gVXRpbHMuQ29uc3RhbnRzLkRFRkxBVEVEO1xuICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmNyYyA9IFV0aWxzLmNyYzMyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBfY2VudHJhbEhlYWRlci5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9sZGVycyBhbmQgYmxhbmsgZmlsZXMgc2hvdWxkIGJlIHN0b3JlZFxuICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLm1ldGhvZCA9IFV0aWxzLkNvbnN0YW50cy5TVE9SRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24gKHBhc3MpIHtcbiAgICAgICAgICAgIGlmIChfY2VudHJhbEhlYWRlci5jaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuY29tcHJlc3NlZERhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvbXByZXNzKGZhbHNlLCBudWxsLCBwYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXREYXRhQXN5bmM6IGZ1bmN0aW9uICgvKkZ1bmN0aW9uKi8gY2FsbGJhY2ssIHBhc3MpIHtcbiAgICAgICAgICAgIGlmIChfY2VudHJhbEhlYWRlci5jaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodW5jb21wcmVzc2VkRGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3ModHJ1ZSwgY2FsbGJhY2ssIHBhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldCBhdHRyKGF0dHIpIHtcbiAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmF0dHIgPSBhdHRyO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgYXR0cigpIHtcbiAgICAgICAgICAgIHJldHVybiBfY2VudHJhbEhlYWRlci5hdHRyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldCBoZWFkZXIoLypCdWZmZXIqLyBkYXRhKSB7XG4gICAgICAgICAgICBfY2VudHJhbEhlYWRlci5sb2FkRnJvbUJpbmFyeShkYXRhKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgaGVhZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jZW50cmFsSGVhZGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhY2tDZW50cmFsSGVhZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfY2VudHJhbEhlYWRlci5mbGFnc19lZnMgPSB0aGlzLmVmcztcbiAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmV4dHJhTGVuZ3RoID0gX2V4dHJhLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIDEuIGNyZWF0ZSBoZWFkZXIgKGJ1ZmZlcilcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBfY2VudHJhbEhlYWRlci5jZW50cmFsSGVhZGVyVG9CaW5hcnkoKTtcbiAgICAgICAgICAgIHZhciBhZGRwb3MgPSBVdGlscy5Db25zdGFudHMuQ0VOSERSO1xuICAgICAgICAgICAgLy8gMi4gYWRkIGZpbGUgbmFtZVxuICAgICAgICAgICAgX2VudHJ5TmFtZS5jb3B5KGhlYWRlciwgYWRkcG9zKTtcbiAgICAgICAgICAgIGFkZHBvcyArPSBfZW50cnlOYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIDMuIGFkZCBleHRyYSBkYXRhXG4gICAgICAgICAgICBfZXh0cmEuY29weShoZWFkZXIsIGFkZHBvcyk7XG4gICAgICAgICAgICBhZGRwb3MgKz0gX2NlbnRyYWxIZWFkZXIuZXh0cmFMZW5ndGg7XG4gICAgICAgICAgICAvLyA0LiBhZGQgZmlsZSBjb21tZW50XG4gICAgICAgICAgICBfY29tbWVudC5jb3B5KGhlYWRlciwgYWRkcG9zKTtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFja0xvY2FsSGVhZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgYWRkcG9zID0gMDtcbiAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmZsYWdzX2VmcyA9IHRoaXMuZWZzO1xuICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuZXh0cmFMb2NhbExlbmd0aCA9IF9leHRyYWxvY2FsLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIDEuIGNvbnN0cnVjdCBsb2NhbCBoZWFkZXIgQnVmZmVyXG4gICAgICAgICAgICBjb25zdCBsb2NhbEhlYWRlckJ1ZiA9IF9jZW50cmFsSGVhZGVyLmxvY2FsSGVhZGVyVG9CaW5hcnkoKTtcbiAgICAgICAgICAgIC8vIDIuIGxvY2FsSGVhZGVyIC0gY3JhdGUgaGVhZGVyIGJ1ZmZlclxuICAgICAgICAgICAgY29uc3QgbG9jYWxIZWFkZXIgPSBCdWZmZXIuYWxsb2MobG9jYWxIZWFkZXJCdWYubGVuZ3RoICsgX2VudHJ5TmFtZS5sZW5ndGggKyBfY2VudHJhbEhlYWRlci5leHRyYUxvY2FsTGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIDIuMSBhZGQgbG9jYWxoZWFkZXJcbiAgICAgICAgICAgIGxvY2FsSGVhZGVyQnVmLmNvcHkobG9jYWxIZWFkZXIsIGFkZHBvcyk7XG4gICAgICAgICAgICBhZGRwb3MgKz0gbG9jYWxIZWFkZXJCdWYubGVuZ3RoO1xuICAgICAgICAgICAgLy8gMi4yIGFkZCBmaWxlIG5hbWVcbiAgICAgICAgICAgIF9lbnRyeU5hbWUuY29weShsb2NhbEhlYWRlciwgYWRkcG9zKTtcbiAgICAgICAgICAgIGFkZHBvcyArPSBfZW50cnlOYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIDIuMyBhZGQgZXh0cmEgZmllbGRcbiAgICAgICAgICAgIF9leHRyYWxvY2FsLmNvcHkobG9jYWxIZWFkZXIsIGFkZHBvcyk7XG4gICAgICAgICAgICBhZGRwb3MgKz0gX2V4dHJhbG9jYWwubGVuZ3RoO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxIZWFkZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGZ1bmN0aW9uIChucikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjxcIiArICgobnIgJiYgbnIubGVuZ3RoICsgXCIgYnl0ZXMgYnVmZmVyXCIpIHx8IFwibnVsbFwiKSArIFwiPlwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbnRyeU5hbWU6IHRoaXMuZW50cnlOYW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBjb21tZW50OiB0aGlzLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgaXNEaXJlY3Rvcnk6IHRoaXMuaXNEaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBfY2VudHJhbEhlYWRlci50b0pTT04oKSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2VkRGF0YTogYnl0ZXMoaW5wdXQpLFxuICAgICAgICAgICAgICAgIGRhdGE6IGJ5dGVzKHVuY29tcHJlc3NlZERhdGEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgXCJcXHRcIik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsICJjb25zdCBaaXBFbnRyeSA9IHJlcXVpcmUoXCIuL3ppcEVudHJ5XCIpO1xuY29uc3QgSGVhZGVycyA9IHJlcXVpcmUoXCIuL2hlYWRlcnNcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qQnVmZmVyfG51bGwqLyBpbkJ1ZmZlciwgLyoqIG9iamVjdCAqLyBvcHRpb25zKSB7XG4gICAgdmFyIGVudHJ5TGlzdCA9IFtdLFxuICAgICAgICBlbnRyeVRhYmxlID0ge30sXG4gICAgICAgIF9jb21tZW50ID0gQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBtYWluSGVhZGVyID0gbmV3IEhlYWRlcnMuTWFpbkhlYWRlcigpLFxuICAgICAgICBsb2FkZWRFbnRyaWVzID0gZmFsc2U7XG4gICAgdmFyIHBhc3N3b3JkID0gbnVsbDtcbiAgICBjb25zdCB0ZW1wb3JhcnkgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBhc3NpZ24gb3B0aW9uc1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zO1xuXG4gICAgY29uc3QgeyBub1NvcnQsIGRlY29kZXIgfSA9IG9wdHM7XG5cbiAgICBpZiAoaW5CdWZmZXIpIHtcbiAgICAgICAgLy8gaXMgYSBtZW1vcnkgYnVmZmVyXG4gICAgICAgIHJlYWRNYWluSGVhZGVyKG9wdHMucmVhZEVudHJpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vbmUuIGlzIGEgbmV3IGZpbGVcbiAgICAgICAgbG9hZGVkRW50cmllcyA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZVRlbXBvcmFyeUZvbGRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGZvbGRlcnNMaXN0ID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIE1ha2UgbGlzdCBvZiBhbGwgZm9sZGVycyBpbiBmaWxlXG4gICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBPYmplY3Qua2V5cyhlbnRyeVRhYmxlKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBlbGVtLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnBvcCgpOyAvLyBmaWxlbmFtZVxuICAgICAgICAgICAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIGNvbnRpbnVlOyAvLyBubyBmb2xkZXJzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gZWxlbWVudHMuc2xpY2UoMCwgaSArIDEpLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gICAgICAgICAgICAgICAgZm9sZGVyc0xpc3QuYWRkKHN1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgbWlzc2luZyBmb2xkZXJzIGFzIHRlbXBvcmFyeVxuICAgICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgZm9sZGVyc0xpc3QpIHtcbiAgICAgICAgICAgIGlmICghKGVsZW0gaW4gZW50cnlUYWJsZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wZm9sZGVyID0gbmV3IFppcEVudHJ5KG9wdHMpO1xuICAgICAgICAgICAgICAgIHRlbXBmb2xkZXIuZW50cnlOYW1lID0gZWxlbTtcbiAgICAgICAgICAgICAgICB0ZW1wZm9sZGVyLmF0dHIgPSAweDEwO1xuICAgICAgICAgICAgICAgIHRlbXBmb2xkZXIudGVtcG9yYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbnRyeUxpc3QucHVzaCh0ZW1wZm9sZGVyKTtcbiAgICAgICAgICAgICAgICBlbnRyeVRhYmxlW3RlbXBmb2xkZXIuZW50cnlOYW1lXSA9IHRlbXBmb2xkZXI7XG4gICAgICAgICAgICAgICAgdGVtcG9yYXJ5LmFkZCh0ZW1wZm9sZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRFbnRyaWVzKCkge1xuICAgICAgICBsb2FkZWRFbnRyaWVzID0gdHJ1ZTtcbiAgICAgICAgZW50cnlUYWJsZSA9IHt9O1xuICAgICAgICBpZiAobWFpbkhlYWRlci5kaXNrRW50cmllcyA+IChpbkJ1ZmZlci5sZW5ndGggLSBtYWluSGVhZGVyLm9mZnNldCkgLyBVdGlscy5Db25zdGFudHMuQ0VOSERSKSB7XG4gICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuRElTS19FTlRSWV9UT09fTEFSR0UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeUxpc3QgPSBuZXcgQXJyYXkobWFpbkhlYWRlci5kaXNrRW50cmllcyk7IC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgIHZhciBpbmRleCA9IG1haW5IZWFkZXIub2Zmc2V0OyAvLyBvZmZzZXQgb2YgZmlyc3QgQ0VOIGhlYWRlclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJ5TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRtcCA9IGluZGV4LFxuICAgICAgICAgICAgICAgIGVudHJ5ID0gbmV3IFppcEVudHJ5KG9wdHMsIGluQnVmZmVyKTtcbiAgICAgICAgICAgIGVudHJ5LmhlYWRlciA9IGluQnVmZmVyLnNsaWNlKHRtcCwgKHRtcCArPSBVdGlscy5Db25zdGFudHMuQ0VOSERSKSk7XG5cbiAgICAgICAgICAgIGVudHJ5LmVudHJ5TmFtZSA9IGluQnVmZmVyLnNsaWNlKHRtcCwgKHRtcCArPSBlbnRyeS5oZWFkZXIuZmlsZU5hbWVMZW5ndGgpKTtcblxuICAgICAgICAgICAgaWYgKGVudHJ5LmhlYWRlci5leHRyYUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVudHJ5LmV4dHJhID0gaW5CdWZmZXIuc2xpY2UodG1wLCAodG1wICs9IGVudHJ5LmhlYWRlci5leHRyYUxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW50cnkuaGVhZGVyLmNvbW1lbnRMZW5ndGgpIGVudHJ5LmNvbW1lbnQgPSBpbkJ1ZmZlci5zbGljZSh0bXAsIHRtcCArIGVudHJ5LmhlYWRlci5jb21tZW50TGVuZ3RoKTtcblxuICAgICAgICAgICAgaW5kZXggKz0gZW50cnkuaGVhZGVyLmNlbnRyYWxIZWFkZXJTaXplO1xuXG4gICAgICAgICAgICBlbnRyeUxpc3RbaV0gPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5VGFibGVbZW50cnkuZW50cnlOYW1lXSA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHRlbXBvcmFyeS5jbGVhcigpO1xuICAgICAgICBtYWtlVGVtcG9yYXJ5Rm9sZGVycygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRNYWluSGVhZGVyKC8qQm9vbGVhbiovIHJlYWROb3cpIHtcbiAgICAgICAgdmFyIGkgPSBpbkJ1ZmZlci5sZW5ndGggLSBVdGlscy5Db25zdGFudHMuRU5ESERSLCAvLyBFTkQgaGVhZGVyIHNpemVcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KDAsIGkgLSAweGZmZmYpLCAvLyAweEZGRkYgaXMgdGhlIG1heCB6aXAgZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICAgICAgbiA9IG1heCxcbiAgICAgICAgICAgIGVuZFN0YXJ0ID0gaW5CdWZmZXIubGVuZ3RoLFxuICAgICAgICAgICAgZW5kT2Zmc2V0ID0gLTEsIC8vIFN0YXJ0IG9mZnNldCBvZiB0aGUgRU5EIGhlYWRlclxuICAgICAgICAgICAgY29tbWVudEVuZCA9IDA7XG5cbiAgICAgICAgLy8gb3B0aW9uIHRvIHNlYXJjaCBoZWFkZXIgZm9ybSBlbnRpcmUgZmlsZVxuICAgICAgICBjb25zdCB0cmFpbGluZ1NwYWNlID0gdHlwZW9mIG9wdHMudHJhaWxpbmdTcGFjZSA9PT0gXCJib29sZWFuXCIgPyBvcHRzLnRyYWlsaW5nU3BhY2UgOiBmYWxzZTtcbiAgICAgICAgaWYgKHRyYWlsaW5nU3BhY2UpIG1heCA9IDA7XG5cbiAgICAgICAgZm9yIChpOyBpID49IG47IGktLSkge1xuICAgICAgICAgICAgaWYgKGluQnVmZmVyW2ldICE9PSAweDUwKSBjb250aW51ZTsgLy8gcXVpY2sgY2hlY2sgdGhhdCB0aGUgYnl0ZSBpcyAnUCdcbiAgICAgICAgICAgIGlmIChpbkJ1ZmZlci5yZWFkVUludDMyTEUoaSkgPT09IFV0aWxzLkNvbnN0YW50cy5FTkRTSUcpIHtcbiAgICAgICAgICAgICAgICAvLyBcIlBLXFwwMDVcXDAwNlwiXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBjb21tZW50RW5kID0gaTtcbiAgICAgICAgICAgICAgICBlbmRTdGFydCA9IGkgKyBVdGlscy5Db25zdGFudHMuRU5ESERSO1xuICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgZm91bmQgYSByZWd1bGFyIHNpZ25hdHVyZSwgbGV0J3MgbG9vayBqdXN0IGEgYml0IGZ1cnRoZXIgdG8gY2hlY2sgaWYgdGhlcmUncyBhbnkgemlwNjQgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgbiA9IGkgLSBVdGlscy5Db25zdGFudHMuRU5ENjRIRFI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbkJ1ZmZlci5yZWFkVUludDMyTEUoaSkgPT09IFV0aWxzLkNvbnN0YW50cy5FTkQ2NFNJRykge1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgemlwNjQgc2lnbmF0dXJlLCBsZXQncyBjb250aW51ZSByZWFkaW5nIHRoZSB3aG9sZSB6aXA2NCByZWNvcmRcbiAgICAgICAgICAgICAgICBuID0gbWF4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5CdWZmZXIucmVhZFVJbnQzMkxFKGkpID09PSBVdGlscy5Db25zdGFudHMuWklQNjRTSUcpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCB0aGUgemlwNjQgcmVjb3JkLCBsZXQncyBkZXRlcm1pbmUgaXQncyBzaXplXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBlbmRTdGFydCA9IGkgKyBVdGlscy5yZWFkQmlnVUludDY0TEUoaW5CdWZmZXIsIGkgKyBVdGlscy5Db25zdGFudHMuWklQNjRTSVpFKSArIFV0aWxzLkNvbnN0YW50cy5aSVA2NExFQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kT2Zmc2V0ID09IC0xKSB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9GT1JNQVQoKTtcblxuICAgICAgICBtYWluSGVhZGVyLmxvYWRGcm9tQmluYXJ5KGluQnVmZmVyLnNsaWNlKGVuZE9mZnNldCwgZW5kU3RhcnQpKTtcbiAgICAgICAgaWYgKG1haW5IZWFkZXIuY29tbWVudExlbmd0aCkge1xuICAgICAgICAgICAgX2NvbW1lbnQgPSBpbkJ1ZmZlci5zbGljZShjb21tZW50RW5kICsgVXRpbHMuQ29uc3RhbnRzLkVOREhEUik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWROb3cpIHJlYWRFbnRyaWVzKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEVudHJpZXMoKSB7XG4gICAgICAgIGlmIChlbnRyeUxpc3QubGVuZ3RoID4gMSAmJiAhbm9Tb3J0KSB7XG4gICAgICAgICAgICBlbnRyeUxpc3Quc29ydCgoYSwgYikgPT4gYS5lbnRyeU5hbWUudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKGIuZW50cnlOYW1lLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIFppcEVudHJ5IG9iamVjdHMgZXhpc3RlbnQgaW4gdGhlIGN1cnJlbnQgb3BlbmVkIGFyY2hpdmVcbiAgICAgICAgICogQHJldHVybiBBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGVudHJpZXMoKSB7XG4gICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5TGlzdC5maWx0ZXIoKGUpID0+ICF0ZW1wb3JhcnkuaGFzKGUpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXJjaGl2ZSBjb21tZW50XG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldCBjb21tZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKF9jb21tZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGNvbW1lbnQodmFsKSB7XG4gICAgICAgICAgICBfY29tbWVudCA9IFV0aWxzLnRvQnVmZmVyKHZhbCwgZGVjb2Rlci5lbmNvZGUpO1xuICAgICAgICAgICAgbWFpbkhlYWRlci5jb21tZW50TGVuZ3RoID0gX2NvbW1lbnQubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEVudHJ5Q291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghbG9hZGVkRW50cmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWluSGVhZGVyLmRpc2tFbnRyaWVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZW50cnlMaXN0Lmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBmb3JFYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgZW50cnkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBvciBudWxsIGlmIGVudHJ5IGlzIGluZXhpc3RlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVudHJ5TmFtZVxuICAgICAgICAgKiBAcmV0dXJuIFppcEVudHJ5XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbnRyeTogZnVuY3Rpb24gKC8qU3RyaW5nKi8gZW50cnlOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5VGFibGVbZW50cnlOYW1lXSB8fCBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHRoZSBnaXZlbiBlbnRyeSB0byB0aGUgZW50cnkgbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZW50cnlcbiAgICAgICAgICovXG4gICAgICAgIHNldEVudHJ5OiBmdW5jdGlvbiAoLypaaXBFbnRyeSovIGVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnlMaXN0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgZW50cnlUYWJsZVtlbnRyeS5lbnRyeU5hbWVdID0gZW50cnk7XG4gICAgICAgICAgICBtYWluSGVhZGVyLnRvdGFsRW50cmllcyA9IGVudHJ5TGlzdC5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGZpbGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBmcm9tIHRoZSBlbnRyeSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIHRoZW4gYWxsIG5lc3RlZCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgd2lsbCBiZSByZW1vdmVkXG4gICAgICAgICAqIEBwYXJhbSBlbnRyeU5hbWVcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVGaWxlOiBmdW5jdGlvbiAoLypTdHJpbmcqLyBlbnRyeU5hbWUsIHdpdGhzdWJmb2xkZXJzID0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFsb2FkZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cnlUYWJsZVtlbnRyeU5hbWVdO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0RW50cnlDaGlsZHJlbihlbnRyeSwgd2l0aHN1YmZvbGRlcnMpLm1hcCgoY2hpbGQpID0+IGNoaWxkLmVudHJ5TmFtZSk7XG5cbiAgICAgICAgICAgIGxpc3QuZm9yRWFjaCh0aGlzLmRlbGV0ZUVudHJ5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyB0aGUgZW50cnkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBmcm9tIHRoZSBlbnRyeSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlOYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlRW50cnk6IGZ1bmN0aW9uICgvKlN0cmluZyovIGVudHJ5TmFtZSkge1xuICAgICAgICAgICAgaWYgKCFsb2FkZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cnlUYWJsZVtlbnRyeU5hbWVdO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBlbnRyeUxpc3QuaW5kZXhPZihlbnRyeSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGVudHJ5TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRyeVRhYmxlW2VudHJ5TmFtZV07XG4gICAgICAgICAgICAgICAgbWFpbkhlYWRlci50b3RhbEVudHJpZXMgPSBlbnRyeUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgSXRlcmF0ZXMgYW5kIHJldHVybnMgYWxsIG5lc3RlZCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgb2YgdGhlIGdpdmVuIGVudHJ5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbnRyeVxuICAgICAgICAgKiBAcmV0dXJuIEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbnRyeUNoaWxkcmVuOiBmdW5jdGlvbiAoLypaaXBFbnRyeSovIGVudHJ5LCBzdWJmb2xkZXJzID0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFsb2FkZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkgJiYgc3ViZm9sZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbnRyeS5lbnRyeU5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB6aXBFbnRyeSBvZiBlbnRyeUxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6aXBFbnRyeS5lbnRyeU5hbWUuc3RhcnRzV2l0aChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaCh6aXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbnRyeV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgSG93IG1hbnkgY2hpbGQgZWxlbWVudHMgZW50cnkgaGFzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7WmlwRW50cnl9IGVudHJ5XG4gICAgICAgICAqIEByZXR1cm4ge2ludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLmdldEVudHJ5Q2hpbGRyZW4oZW50cnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0LmluY2x1ZGVzKGVudHJ5KSA/IGxpc3QubGVuZ3RoIC0gMSA6IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHppcCBmaWxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQnVmZmVyXG4gICAgICAgICAqL1xuICAgICAgICBjb21wcmVzc1RvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ydEVudHJpZXMoKTtcblxuICAgICAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gW107XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJCbG9ja3MgPSBbXTtcbiAgICAgICAgICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgICAgICAgICAgbGV0IGRpbmRleCA9IDA7XG5cbiAgICAgICAgICAgIG1haW5IZWFkZXIuc2l6ZSA9IDA7XG4gICAgICAgICAgICBtYWluSGVhZGVyLm9mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQgdG90YWxFbnRyaWVzID0gMDtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21wcmVzcyBkYXRhIGFuZCBzZXQgbG9jYWwgYW5kIGVudHJ5IGhlYWRlciBhY2NvcmRpbmdseS4gUmVhc29uIHdoeSBpcyBjYWxsZWQgZmlyc3RcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkRGF0YSA9IGVudHJ5LmdldENvbXByZXNzZWREYXRhKCk7XG4gICAgICAgICAgICAgICAgZW50cnkuaGVhZGVyLm9mZnNldCA9IGRpbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIDEuIGNvbnN0cnVjdCBsb2NhbCBoZWFkZXJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbEhlYWRlciA9IGVudHJ5LnBhY2tMb2NhbEhlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gMi4gb2Zmc2V0c1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBsb2NhbEhlYWRlci5sZW5ndGggKyBjb21wcmVzc2VkRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZGluZGV4ICs9IGRhdGFMZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyAzLiBzdG9yZSB2YWx1ZXMgaW4gc2VxdWVuY2VcbiAgICAgICAgICAgICAgICBkYXRhQmxvY2sucHVzaChsb2NhbEhlYWRlcik7XG4gICAgICAgICAgICAgICAgZGF0YUJsb2NrLnB1c2goY29tcHJlc3NlZERhdGEpO1xuXG4gICAgICAgICAgICAgICAgLy8gNC4gY29uc3RydWN0IGNlbnRyYWwgaGVhZGVyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJhbEhlYWRlciA9IGVudHJ5LnBhY2tDZW50cmFsSGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgaGVhZGVyQmxvY2tzLnB1c2goY2VudHJhbEhlYWRlcik7XG4gICAgICAgICAgICAgICAgLy8gNS4gdXBkYXRlIG1haW4gaGVhZGVyXG4gICAgICAgICAgICAgICAgbWFpbkhlYWRlci5zaXplICs9IGNlbnRyYWxIZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBkYXRhTGVuZ3RoICsgY2VudHJhbEhlYWRlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdG90YWxFbnRyaWVzKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBtYWluSGVhZGVyLm1haW5IZWFkZXJTaXplOyAvLyBhbHNvIGluY2x1ZGVzIHppcCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgICAgICAvLyBwb2ludCB0byBlbmQgb2YgZGF0YSBhbmQgYmVnaW5uaW5nIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGZpcnN0IHJlY29yZFxuICAgICAgICAgICAgbWFpbkhlYWRlci5vZmZzZXQgPSBkaW5kZXg7XG4gICAgICAgICAgICBtYWluSGVhZGVyLnRvdGFsRW50cmllcyA9IHRvdGFsRW50cmllcztcblxuICAgICAgICAgICAgZGluZGV4ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IG91dEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0b3RhbFNpemUpO1xuICAgICAgICAgICAgLy8gd3JpdGUgZGF0YSBibG9ja3NcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBkYXRhQmxvY2spIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LmNvcHkob3V0QnVmZmVyLCBkaW5kZXgpO1xuICAgICAgICAgICAgICAgIGRpbmRleCArPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd3JpdGUgY2VudHJhbCBkaXJlY3RvcnkgZW50cmllc1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb250ZW50IG9mIGhlYWRlckJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQuY29weShvdXRCdWZmZXIsIGRpbmRleCk7XG4gICAgICAgICAgICAgICAgZGluZGV4ICs9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3cml0ZSBtYWluIGhlYWRlclxuICAgICAgICAgICAgY29uc3QgbWggPSBtYWluSGVhZGVyLnRvQmluYXJ5KCk7XG4gICAgICAgICAgICBpZiAoX2NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBfY29tbWVudC5jb3B5KG1oLCBVdGlscy5Db25zdGFudHMuRU5ESERSKTsgLy8gYWRkIHppcCBmaWxlIGNvbW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1oLmNvcHkob3V0QnVmZmVyLCBkaW5kZXgpO1xuXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSB1cGRhdGUgZW50cnkgYW5kIG1haW4gaGVhZGVyIG9mZnNldHMsXG4gICAgICAgICAgICAvLyB0aGV5IGFyZSBubyBsb25nZXIgdmFsaWQgYW5kIHdlIGhhdmUgdG8gcmVzZXQgY29udGVudFxuICAgICAgICAgICAgLy8gKElzc3VlIDY0KVxuXG4gICAgICAgICAgICBpbkJ1ZmZlciA9IG91dEJ1ZmZlcjtcbiAgICAgICAgICAgIGxvYWRlZEVudHJpZXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dEJ1ZmZlcjtcbiAgICAgICAgfSxcblxuICAgICAgICB0b0FzeW5jQnVmZmVyOiBmdW5jdGlvbiAoLypGdW5jdGlvbiovIG9uU3VjY2VzcywgLypGdW5jdGlvbiovIG9uRmFpbCwgLypGdW5jdGlvbiovIG9uSXRlbVN0YXJ0LCAvKkZ1bmN0aW9uKi8gb25JdGVtRW5kKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghbG9hZGVkRW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb3J0RW50cmllcygpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJhbEhlYWRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxTaXplID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgZGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxFbnRyaWVzID0gMDtcblxuICAgICAgICAgICAgICAgIG1haW5IZWFkZXIuc2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgbWFpbkhlYWRlci5vZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3MyQnVmZmVyID0gZnVuY3Rpb24gKGVudHJ5TGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5TGlzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyeUxpc3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZW50cnkuZW50cnlOYW1lICsgZW50cnkuZXh0cmEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkl0ZW1TdGFydCkgb25JdGVtU3RhcnQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5nZXRDb21wcmVzc2VkRGF0YUFzeW5jKGZ1bmN0aW9uIChjb21wcmVzc2VkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkl0ZW1FbmQpIG9uSXRlbUVuZChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5oZWFkZXIub2Zmc2V0ID0gZGluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4gY29uc3RydWN0IGxvY2FsIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsSGVhZGVyID0gZW50cnkucGFja0xvY2FsSGVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLiBvZmZzZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGxvY2FsSGVhZGVyLmxlbmd0aCArIGNvbXByZXNzZWREYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW5kZXggKz0gZGF0YUxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMuIHN0b3JlIHZhbHVlcyBpbiBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCbG9jay5wdXNoKGxvY2FsSGVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQmxvY2sucHVzaChjb21wcmVzc2VkRGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjZW50cmFsIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRhbEhlYWRlciA9IGVudHJ5LnBhY2tDZW50cmFsSGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudHJhbEhlYWRlcnMucHVzaChjZW50YWxIZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5IZWFkZXIuc2l6ZSArPSBjZW50YWxIZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBkYXRhTGVuZ3RoICsgY2VudGFsSGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEVudHJpZXMrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzMkJ1ZmZlcihlbnRyeUxpc3RzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxTaXplICs9IG1haW5IZWFkZXIubWFpbkhlYWRlclNpemU7IC8vIGFsc28gaW5jbHVkZXMgemlwIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50IHRvIGVuZCBvZiBkYXRhIGFuZCBiZWdpbm5pbmcgb2YgY2VudHJhbCBkaXJlY3RvcnkgZmlyc3QgcmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluSGVhZGVyLm9mZnNldCA9IGRpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5IZWFkZXIudG90YWxFbnRyaWVzID0gdG90YWxFbnRyaWVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRvdGFsU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQmxvY2suZm9yRWFjaChmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuY29weShvdXRCdWZmZXIsIGRpbmRleCk7IC8vIHdyaXRlIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGluZGV4ICs9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50cmFsSGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5jb3B5KG91dEJ1ZmZlciwgZGluZGV4KTsgLy8gd3JpdGUgY2VudHJhbCBkaXJlY3RvcnkgZW50cmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbmRleCArPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaCA9IG1haW5IZWFkZXIudG9CaW5hcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb21tZW50LmNvcHkobWgsIFV0aWxzLkNvbnN0YW50cy5FTkRIRFIpOyAvLyBhZGQgemlwIGZpbGUgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaC5jb3B5KG91dEJ1ZmZlciwgZGluZGV4KTsgLy8gd3JpdGUgbWFpbiBoZWFkZXJcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2UgdXBkYXRlIGVudHJ5IGFuZCBtYWluIGhlYWRlciBvZmZzZXRzLCB0aGV5IGFyZSBub1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9uZ2VyIHZhbGlkIGFuZCB3ZSBoYXZlIHRvIHJlc2V0IGNvbnRlbnQgdXNpbmcgb3VyIG5ldyBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChJc3N1ZSA2NClcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5CdWZmZXIgPSBvdXRCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkZWRFbnRyaWVzID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyhvdXRCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbXByZXNzMkJ1ZmZlcihBcnJheS5mcm9tKHRoaXMuZW50cmllcykpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG9uRmFpbChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwgImNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IHB0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgWmlwRW50cnkgPSByZXF1aXJlKFwiLi96aXBFbnRyeVwiKTtcbmNvbnN0IFppcEZpbGUgPSByZXF1aXJlKFwiLi96aXBGaWxlXCIpO1xuXG5jb25zdCBnZXRfQm9vbCA9ICguLi52YWwpID0+IFV0aWxzLmZpbmRMYXN0KHZhbCwgKGMpID0+IHR5cGVvZiBjID09PSBcImJvb2xlYW5cIik7XG5jb25zdCBnZXRfU3RyID0gKC4uLnZhbCkgPT4gVXRpbHMuZmluZExhc3QodmFsLCAoYykgPT4gdHlwZW9mIGMgPT09IFwic3RyaW5nXCIpO1xuY29uc3QgZ2V0X0Z1biA9ICguLi52YWwpID0+IFV0aWxzLmZpbmRMYXN0KHZhbCwgKGMpID0+IHR5cGVvZiBjID09PSBcImZ1bmN0aW9uXCIpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvLyBvcHRpb24gXCJub1NvcnRcIiA6IGlmIHRydWUgaXQgZGlzYWJsZXMgZmlsZXMgc29ydGluZ1xuICAgIG5vU29ydDogZmFsc2UsXG4gICAgLy8gcmVhZCBlbnRyaWVzIGR1cmluZyBsb2FkIChpbml0aWFsIGxvYWRpbmcgbWF5IGJlIHNsb3dlcilcbiAgICByZWFkRW50cmllczogZmFsc2UsXG4gICAgLy8gZGVmYXVsdCBtZXRob2QgaXMgbm9uZVxuICAgIG1ldGhvZDogVXRpbHMuQ29uc3RhbnRzLk5PTkUsXG4gICAgLy8gZmlsZSBzeXN0ZW1cbiAgICBmczogbnVsbFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLyoqU3RyaW5nKi8gaW5wdXQsIC8qKiBvYmplY3QgKi8gb3B0aW9ucykge1xuICAgIGxldCBpbkJ1ZmZlciA9IG51bGw7XG5cbiAgICAvLyBjcmVhdGUgb2JqZWN0IGJhc2VkIGRlZmF1bHQgb3B0aW9ucywgYWxsb3dpbmcgdGhlbSB0byBiZSBvdmVyd3JpdHRlblxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGRlZmF1bHRPcHRpb25zKTtcblxuICAgIC8vIHRlc3QgaW5wdXQgdmFyaWFibGVcbiAgICBpZiAoaW5wdXQgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGlucHV0KSB7XG4gICAgICAgIC8vIGlmIHZhbHVlIGlzIG5vdCBidWZmZXIgd2UgYWNjZXB0IGl0IHRvIGJlIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCBpbnB1dCk7XG4gICAgICAgICAgICBpbnB1dCA9IG9wdHMuaW5wdXQgPyBvcHRzLmlucHV0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG9wdHMuaW5wdXQpIGRlbGV0ZSBvcHRzLmlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaW5wdXQgaXMgYnVmZmVyXG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbkJ1ZmZlciA9IGlucHV0O1xuICAgICAgICAgICAgb3B0cy5tZXRob2QgPSBVdGlscy5Db25zdGFudHMuQlVGRkVSO1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gb3B0aW9uc1xuICAgIE9iamVjdC5hc3NpZ24ob3B0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbnN0YW5jaWF0ZSB1dGlscyBmaWxlc3lzdGVtXG4gICAgY29uc3QgZmlsZXRvb2xzID0gbmV3IFV0aWxzKG9wdHMpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzLmRlY29kZXIgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9wdHMuZGVjb2Rlci5lbmNvZGUgIT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2Ygb3B0cy5kZWNvZGVyLmRlY29kZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdHMuZGVjb2RlciA9IFV0aWxzLmRlY29kZXI7XG4gICAgfVxuXG4gICAgLy8gaWYgaW5wdXQgaXMgZmlsZSBuYW1lIHdlIHJldHJpZXZlIGl0cyBjb250ZW50XG4gICAgaWYgKGlucHV0ICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dCkge1xuICAgICAgICAvLyBsb2FkIHppcCBmaWxlXG4gICAgICAgIGlmIChmaWxldG9vbHMuZnMuZXhpc3RzU3luYyhpbnB1dCkpIHtcbiAgICAgICAgICAgIG9wdHMubWV0aG9kID0gVXRpbHMuQ29uc3RhbnRzLkZJTEU7XG4gICAgICAgICAgICBvcHRzLmZpbGVuYW1lID0gaW5wdXQ7XG4gICAgICAgICAgICBpbkJ1ZmZlciA9IGZpbGV0b29scy5mcy5yZWFkRmlsZVN5bmMoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLklOVkFMSURfRklMRU5BTUUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB2YXJpYWJsZVxuICAgIGNvbnN0IF96aXAgPSBuZXcgWmlwRmlsZShpbkJ1ZmZlciwgb3B0cyk7XG5cbiAgICBjb25zdCB7IGNhbm9uaWNhbCwgc2FuaXRpemUsIHppcG5hbWVmaXggfSA9IFV0aWxzO1xuXG4gICAgZnVuY3Rpb24gZ2V0RW50cnkoLyoqT2JqZWN0Ki8gZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5ICYmIF96aXApIHtcbiAgICAgICAgICAgIHZhciBpdGVtO1xuICAgICAgICAgICAgLy8gSWYgZW50cnkgd2FzIGdpdmVuIGFzIGEgZmlsZSBuYW1lXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiKSBpdGVtID0gX3ppcC5nZXRFbnRyeShwdGgucG9zaXgubm9ybWFsaXplKGVudHJ5KSk7XG4gICAgICAgICAgICAvLyBpZiBlbnRyeSB3YXMgZ2l2ZW4gYXMgYSBaaXBFbnRyeSBvYmplY3RcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGVudHJ5LmVudHJ5TmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZW50cnkuaGVhZGVyICE9PSBcInVuZGVmaW5lZFwiKSBpdGVtID0gX3ppcC5nZXRFbnRyeShlbnRyeS5lbnRyeU5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFBhdGgoemlwUGF0aCkge1xuICAgICAgICBjb25zdCB7IGpvaW4sIG5vcm1hbGl6ZSwgc2VwIH0gPSBwdGgucG9zaXg7XG4gICAgICAgIC8vIGNvbnZlcnQgd2luZG93cyBmaWxlIHNlcGFyYXRvcnMgYW5kIG5vcm1hbGl6ZVxuICAgICAgICByZXR1cm4gam9pbihcIi5cIiwgbm9ybWFsaXplKHNlcCArIHppcFBhdGguc3BsaXQoXCJcXFxcXCIpLmpvaW4oc2VwKSArIHNlcCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGVuYW1lRmlsdGVyKGZpbHRlcmZuKSB7XG4gICAgICAgIGlmIChmaWx0ZXJmbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgLy8gaWYgZmlsdGVyIGlzIFJlZ0V4cCB3cmFwIGl0XG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChyeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4LnRlc3QoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShmaWx0ZXJmbik7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgZmlsdGVyZm4pIHtcbiAgICAgICAgICAgIC8vIGlmIGZpbHRlciBpcyBub3QgZnVuY3Rpb24gd2Ugd2lsbCByZXBsYWNlIGl0XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyZm47XG4gICAgfVxuXG4gICAgLy8ga2VlcCBsYXN0IGNoYXJhY3RlciBvbiBmb2xkZXJzXG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID0gKGxvY2FsLCBlbnRyeSkgPT4ge1xuICAgICAgICBsZXQgbGFzdENoYXIgPSBlbnRyeS5zbGljZSgtMSk7XG4gICAgICAgIGxhc3RDaGFyID0gbGFzdENoYXIgPT09IGZpbGV0b29scy5zZXAgPyBmaWxldG9vbHMuc2VwIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIHB0aC5yZWxhdGl2ZShsb2NhbCwgZW50cnkpICsgbGFzdENoYXI7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRyYWN0cyB0aGUgZ2l2ZW4gZW50cnkgZnJvbSB0aGUgYXJjaGl2ZSBhbmQgcmV0dXJucyB0aGUgY29udGVudCBhcyBhIEJ1ZmZlciBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtaaXBFbnRyeXxzdHJpbmd9IGVudHJ5IFppcEVudHJ5IG9iamVjdCBvciBTdHJpbmcgd2l0aCB0aGUgZnVsbCBwYXRoIG9mIHRoZSBlbnRyeVxuICAgICAgICAgKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IFtwYXNzXSAtIHBhc3N3b3JkXG4gICAgICAgICAqIEByZXR1cm4gQnVmZmVyIG9yIE51bGwgaW4gY2FzZSBvZiBlcnJvclxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEZpbGU6IGZ1bmN0aW9uIChlbnRyeSwgcGFzcykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICByZXR1cm4gKGl0ZW0gJiYgaXRlbS5nZXREYXRhKHBhc3MpKSB8fCBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGhvdyBtYW55IGNoaWxkIGVsZW1lbnRzIGhhcyBvbiBlbnRyeSAoZGlyZWN0b3JpZXMpIG9uIGZpbGVzIGl0IGlzIGFsd2F5cyAwXG4gICAgICAgICAqIEBwYXJhbSB7WmlwRW50cnl8c3RyaW5nfSBlbnRyeSBaaXBFbnRyeSBvYmplY3Qgb3IgU3RyaW5nIHdpdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZW50cnlcbiAgICAgICAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZENvdW50OiBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfemlwLmdldENoaWxkQ291bnQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzeW5jaHJvbm91cyByZWFkRmlsZVxuICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fHN0cmluZ30gZW50cnkgWmlwRW50cnkgb2JqZWN0IG9yIFN0cmluZyB3aXRoIHRoZSBmdWxsIHBhdGggb2YgdGhlIGVudHJ5XG4gICAgICAgICAqIEBwYXJhbSB7Y2FsbGJhY2t9IGNhbGxiYWNrXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQnVmZmVyIG9yIE51bGwgaW4gY2FzZSBvZiBlcnJvclxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEZpbGVBc3luYzogZnVuY3Rpb24gKGVudHJ5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZ2V0RGF0YUFzeW5jKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgXCJnZXRFbnRyeSBmYWlsZWQgZm9yOlwiICsgZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRyYWN0cyB0aGUgZ2l2ZW4gZW50cnkgZnJvbSB0aGUgYXJjaGl2ZSBhbmQgcmV0dXJucyB0aGUgY29udGVudCBhcyBwbGFpbiB0ZXh0IGluIHRoZSBnaXZlbiBlbmNvZGluZ1xuICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fHN0cmluZ30gZW50cnkgLSBaaXBFbnRyeSBvYmplY3Qgb3IgU3RyaW5nIHdpdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZW50cnlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIC0gT3B0aW9uYWwuIElmIG5vIGVuY29kaW5nIGlzIHNwZWNpZmllZCB1dGY4IGlzIHVzZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRBc1RleHQ6IGZ1bmN0aW9uIChlbnRyeSwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGl0ZW0uZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKGVuY29kaW5nIHx8IFwidXRmOFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXN5bmNocm9ub3VzIHJlYWRBc1RleHRcbiAgICAgICAgICogQHBhcmFtIHtaaXBFbnRyeXxzdHJpbmd9IGVudHJ5IFppcEVudHJ5IG9iamVjdCBvciBTdHJpbmcgd2l0aCB0aGUgZnVsbCBwYXRoIG9mIHRoZSBlbnRyeVxuICAgICAgICAgKiBAcGFyYW0ge2NhbGxiYWNrfSBjYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nXSAtIE9wdGlvbmFsLiBJZiBubyBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdXRmOCBpcyB1c2VkXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICByZWFkQXNUZXh0QXN5bmM6IGZ1bmN0aW9uIChlbnRyeSwgY2FsbGJhY2ssIGVuY29kaW5nKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5nZXREYXRhQXN5bmMoZnVuY3Rpb24gKGRhdGEsIGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEudG9TdHJpbmcoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGVudHJ5IGZyb20gdGhlIGZpbGUgb3IgdGhlIGVudHJ5IGFuZCBhbGwgaXQncyBuZXN0ZWQgZGlyZWN0b3JpZXMgYW5kIGZpbGVzIGlmIHRoZSBnaXZlbiBlbnRyeSBpcyBhIGRpcmVjdG9yeVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fHN0cmluZ30gZW50cnlcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVGaWxlOiBmdW5jdGlvbiAoZW50cnksIHdpdGhzdWJmb2xkZXJzID0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gQFRPRE86IHRlc3QgZGVsZXRlRmlsZVxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIF96aXAuZGVsZXRlRmlsZShpdGVtLmVudHJ5TmFtZSwgd2l0aHN1YmZvbGRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGVudHJ5IGZyb20gdGhlIGZpbGUgb3IgZGlyZWN0b3J5IHdpdGhvdXQgYWZmZWN0aW5nIGFueSBuZXN0ZWQgZW50cmllc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fHN0cmluZ30gZW50cnlcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVFbnRyeTogZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogdGVzdCBkZWxldGVFbnRyeVxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIF96aXAuZGVsZXRlRW50cnkoaXRlbS5lbnRyeU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgY29tbWVudCB0byB0aGUgemlwLiBUaGUgemlwIG11c3QgYmUgcmV3cml0dGVuIGFmdGVyIGFkZGluZyB0aGUgY29tbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGFkZFppcENvbW1lbnQ6IGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogdGVzdCBhZGRaaXBDb21tZW50XG4gICAgICAgICAgICBfemlwLmNvbW1lbnQgPSBjb21tZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB6aXAgY29tbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0WmlwQ29tbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF96aXAuY29tbWVudCB8fCBcIlwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgY29tbWVudCB0byBhIHNwZWNpZmllZCB6aXBFbnRyeS4gVGhlIHppcCBtdXN0IGJlIHJld3JpdHRlbiBhZnRlciBhZGRpbmcgdGhlIGNvbW1lbnRcbiAgICAgICAgICogVGhlIGNvbW1lbnQgY2Fubm90IGV4Y2VlZCA2NTUzNSBjaGFyYWN0ZXJzIGluIGxlbmd0aFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fSBlbnRyeVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkWmlwRW50cnlDb21tZW50OiBmdW5jdGlvbiAoZW50cnksIGNvbW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNvbW1lbnQgPSBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb21tZW50IG9mIHRoZSBzcGVjaWZpZWQgZW50cnlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtaaXBFbnRyeX0gZW50cnlcbiAgICAgICAgICogQHJldHVybiBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGdldFppcEVudHJ5Q29tbWVudDogZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uY29tbWVudCB8fCBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGNvbnRlbnQgb2YgYW4gZXhpc3RpbmcgZW50cnkgaW5zaWRlIHRoZSBhcmNoaXZlLiBUaGUgemlwIG11c3QgYmUgcmV3cml0dGVuIGFmdGVyIHVwZGF0aW5nIHRoZSBjb250ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7WmlwRW50cnl9IGVudHJ5XG4gICAgICAgICAqIEBwYXJhbSB7QnVmZmVyfSBjb250ZW50XG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVGaWxlOiBmdW5jdGlvbiAoZW50cnksIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNldERhdGEoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBmaWxlIGZyb20gdGhlIGRpc2sgdG8gdGhlIGFyY2hpdmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsUGF0aCBGaWxlIHRvIGFkZCB0byB6aXBcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt6aXBQYXRoXSBPcHRpb25hbCBwYXRoIGluc2lkZSB0aGUgemlwXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbemlwTmFtZV0gT3B0aW9uYWwgbmFtZSBmb3IgdGhlIGZpbGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBPcHRpb25hbCBmaWxlIGNvbW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGFkZExvY2FsRmlsZTogZnVuY3Rpb24gKGxvY2FsUGF0aCwgemlwUGF0aCwgemlwTmFtZSwgY29tbWVudCkge1xuICAgICAgICAgICAgaWYgKGZpbGV0b29scy5mcy5leGlzdHNTeW5jKGxvY2FsUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXggWmlwUGF0aFxuICAgICAgICAgICAgICAgIHppcFBhdGggPSB6aXBQYXRoID8gZml4UGF0aCh6aXBQYXRoKSA6IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAvLyBwIC0gbG9jYWwgZmlsZSBuYW1lXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHB0aC53aW4zMi5iYXNlbmFtZShwdGgud2luMzIubm9ybWFsaXplKGxvY2FsUGF0aCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIGZpbGUgbmFtZSBpbnRvIHppcHBhdGhcbiAgICAgICAgICAgICAgICB6aXBQYXRoICs9IHppcE5hbWUgPyB6aXBOYW1lIDogcDtcblxuICAgICAgICAgICAgICAgIC8vIHJlYWQgZmlsZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgY29uc3QgX2F0dHIgPSBmaWxldG9vbHMuZnMuc3RhdFN5bmMobG9jYWxQYXRoKTtcblxuICAgICAgICAgICAgICAgIC8vIGdldCBmaWxlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gX2F0dHIuaXNGaWxlKCkgPyBmaWxldG9vbHMuZnMucmVhZEZpbGVTeW5jKGxvY2FsUGF0aCkgOiBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBmb2xkZXJcbiAgICAgICAgICAgICAgICBpZiAoX2F0dHIuaXNEaXJlY3RvcnkoKSkgemlwUGF0aCArPSBmaWxldG9vbHMuc2VwO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIGZpbGUgaW50byB6aXAgZmlsZVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsZSh6aXBQYXRoLCBkYXRhLCBjb21tZW50LCBfYXR0cik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5GSUxFX05PVF9GT1VORChsb2NhbFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayBmb3Igc2hvd2luZyBpZiBldmVyeXRoaW5nIHdhcyBkb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2FsbGJhY2sgZG9uZUNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvbmUgLSB3YXMgcmVxdWVzdCBmdWxseSBjb21wbGV0ZWRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBmaWxlIGZyb20gdGhlIGRpc2sgdG8gdGhlIGFyY2hpdmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsob2JqZWN0fHN0cmluZyl9IG9wdGlvbnMgLSBvcHRpb25zIG9iamVjdCwgaWYgaXQgaXMgc3RyaW5nIGl0IHVzIHVzZWQgYXMgbG9jYWxQYXRoLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbFBhdGggLSBMb2NhbCBwYXRoIHRvIHRoZSBmaWxlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29tbWVudF0gLSBPcHRpb25hbCBmaWxlIGNvbW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy56aXBQYXRoXSAtIE9wdGlvbmFsIHBhdGggaW5zaWRlIHRoZSB6aXBcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnppcE5hbWVdIC0gT3B0aW9uYWwgbmFtZSBmb3IgdGhlIGZpbGVcbiAgICAgICAgICogQHBhcmFtIHtkb25lQ2FsbGJhY2t9IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRoYXQgaGFuZGxlcyB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRMb2NhbEZpbGVBc3luYzogZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zIDogeyBsb2NhbFBhdGg6IG9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsUGF0aCA9IHB0aC5yZXNvbHZlKG9wdGlvbnMubG9jYWxQYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY29tbWVudCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxldCB7IHppcFBhdGgsIHppcE5hbWUgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgZmlsZXRvb2xzLmZzLnN0YXQobG9jYWxQYXRoLCBmdW5jdGlvbiAoZXJyLCBzdGF0cykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyBmaXggWmlwUGF0aFxuICAgICAgICAgICAgICAgIHppcFBhdGggPSB6aXBQYXRoID8gZml4UGF0aCh6aXBQYXRoKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgLy8gcCAtIGxvY2FsIGZpbGUgbmFtZVxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwdGgud2luMzIuYmFzZW5hbWUocHRoLndpbjMyLm5vcm1hbGl6ZShsb2NhbFBhdGgpKTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgZmlsZSBuYW1lIGludG8gemlwcGF0aFxuICAgICAgICAgICAgICAgIHppcFBhdGggKz0gemlwTmFtZSA/IHppcE5hbWUgOiBwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRzLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy5mcy5yZWFkRmlsZShsb2NhbFBhdGgsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkRmlsZSh6aXBQYXRoLCBkYXRhLCBjb21tZW50LCBzdGF0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgemlwUGF0aCArPSBmaWxldG9vbHMuc2VwO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZEZpbGUoemlwUGF0aCwgQnVmZmVyLmFsbG9jKDApLCBjb21tZW50LCBzdGF0cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoY2FsbGJhY2ssIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBsb2NhbCBkaXJlY3RvcnkgYW5kIGFsbCBpdHMgbmVzdGVkIGZpbGVzIGFuZCBkaXJlY3RvcmllcyB0byB0aGUgYXJjaGl2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxQYXRoIC0gbG9jYWwgcGF0aCB0byB0aGUgZm9sZGVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbemlwUGF0aF0gLSBvcHRpb25hbCBwYXRoIGluc2lkZSB6aXBcbiAgICAgICAgICogQHBhcmFtIHsoUmVnRXhwfGZ1bmN0aW9uKX0gW2ZpbHRlcl0gLSBvcHRpb25hbCBSZWdFeHAgb3IgRnVuY3Rpb24gaWYgZmlsZXMgbWF0Y2ggd2lsbCBiZSBpbmNsdWRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGFkZExvY2FsRm9sZGVyOiBmdW5jdGlvbiAobG9jYWxQYXRoLCB6aXBQYXRoLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgZmlsdGVyXG4gICAgICAgICAgICBmaWx0ZXIgPSBmaWxlbmFtZUZpbHRlcihmaWx0ZXIpO1xuXG4gICAgICAgICAgICAvLyBmaXggWmlwUGF0aFxuICAgICAgICAgICAgemlwUGF0aCA9IHppcFBhdGggPyBmaXhQYXRoKHppcFBhdGgpIDogXCJcIjtcblxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIHRoZSBwYXRoIGZpcnN0XG4gICAgICAgICAgICBsb2NhbFBhdGggPSBwdGgubm9ybWFsaXplKGxvY2FsUGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChmaWxldG9vbHMuZnMuZXhpc3RzU3luYyhsb2NhbFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBmaWxldG9vbHMuZmluZEZpbGVzKGxvY2FsUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZXBhdGggb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwdGguam9pbih6aXBQYXRoLCByZWxhdGl2ZVBhdGgobG9jYWxQYXRoLCBmaWxlcGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcihwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkTG9jYWxGaWxlKGZpbGVwYXRoLCBwdGguZGlybmFtZShwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5GSUxFX05PVF9GT1VORChsb2NhbFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3luY2hyb25vdXMgYWRkTG9jYWxGb2xkZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsUGF0aFxuICAgICAgICAgKiBAcGFyYW0ge2NhbGxiYWNrfSBjYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ppcFBhdGhdIG9wdGlvbmFsIHBhdGggaW5zaWRlIHppcFxuICAgICAgICAgKiBAcGFyYW0ge1JlZ0V4cHxmdW5jdGlvbn0gW2ZpbHRlcl0gb3B0aW9uYWwgUmVnRXhwIG9yIEZ1bmN0aW9uIGlmIGZpbGVzIG1hdGNoIHdpbGxcbiAgICAgICAgICogICAgICAgICAgICAgICBiZSBpbmNsdWRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGFkZExvY2FsRm9sZGVyQXN5bmM6IGZ1bmN0aW9uIChsb2NhbFBhdGgsIGNhbGxiYWNrLCB6aXBQYXRoLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgZmlsdGVyXG4gICAgICAgICAgICBmaWx0ZXIgPSBmaWxlbmFtZUZpbHRlcihmaWx0ZXIpO1xuXG4gICAgICAgICAgICAvLyBmaXggWmlwUGF0aFxuICAgICAgICAgICAgemlwUGF0aCA9IHppcFBhdGggPyBmaXhQYXRoKHppcFBhdGgpIDogXCJcIjtcblxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIHRoZSBwYXRoIGZpcnN0XG4gICAgICAgICAgICBsb2NhbFBhdGggPSBwdGgubm9ybWFsaXplKGxvY2FsUGF0aCk7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGZpbGV0b29scy5mcy5vcGVuKGxvY2FsUGF0aCwgXCJyXCIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgVXRpbHMuRXJyb3JzLkZJTEVfTk9UX0ZPVU5EKGxvY2FsUGF0aCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBmaWxldG9vbHMuZmluZEZpbGVzKGxvY2FsUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlcGF0aCA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcmVsYXRpdmVQYXRoKGxvY2FsUGF0aCwgZmlsZXBhdGgpLnNwbGl0KFwiXFxcXFwiKS5qb2luKFwiL1wiKTsgLy93aW5kb3dzIGZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ub3JtYWxpemUoXCJORkRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNmZdL2csIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXlxceDIwLVxceDdFXS9nLCBcIlwiKTsgLy8gYWNjZW50IGZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIocCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLmZzLnN0YXQoZmlsZXBhdGgsIGZ1bmN0aW9uIChlcjAsIHN0YXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXIwKSBjYWxsYmFjayh1bmRlZmluZWQsIGVyMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMuZnMucmVhZEZpbGUoZmlsZXBhdGgsIGZ1bmN0aW9uIChlcjEsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCBlcjEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRGaWxlKHppcFBhdGggKyBwLCBkYXRhLCBcIlwiLCBzdGF0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRGaWxlKHppcFBhdGggKyBwICsgXCIvXCIsIEJ1ZmZlci5hbGxvYygwKSwgXCJcIiwgc3RhdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBsb2NhbCBkaXJlY3RvcnkgYW5kIGFsbCBpdHMgbmVzdGVkIGZpbGVzIGFuZCBkaXJlY3RvcmllcyB0byB0aGUgYXJjaGl2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdCB8IHN0cmluZ30gb3B0aW9ucyAtIG9wdGlvbnMgb2JqZWN0LCBpZiBpdCBpcyBzdHJpbmcgaXQgdXMgdXNlZCBhcyBsb2NhbFBhdGguXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2FsUGF0aCAtIExvY2FsIHBhdGggdG8gdGhlIGZvbGRlci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnppcFBhdGhdIC0gb3B0aW9uYWwgcGF0aCBpbnNpZGUgemlwLlxuICAgICAgICAgKiBAcGFyYW0ge1JlZ0V4cHxmdW5jdGlvbn0gW29wdGlvbnMuZmlsdGVyXSAtIG9wdGlvbmFsIFJlZ0V4cCBvciBGdW5jdGlvbiBpZiBmaWxlcyBtYXRjaCB3aWxsIGJlIGluY2x1ZGVkLlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufHN0cmluZ30gW29wdGlvbnMubmFtZWZpeF0gLSBvcHRpb25hbCBmdW5jdGlvbiB0byBoZWxwIGZpeCBmaWxlbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge2RvbmVDYWxsYmFja30gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdGhhdCBoYW5kbGVzIHRoZSByZXNwb25zZS5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFkZExvY2FsRm9sZGVyQXN5bmMyOiBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiID8gb3B0aW9ucyA6IHsgbG9jYWxQYXRoOiBvcHRpb25zIH07XG4gICAgICAgICAgICBsb2NhbFBhdGggPSBwdGgucmVzb2x2ZShmaXhQYXRoKG9wdGlvbnMubG9jYWxQYXRoKSk7XG4gICAgICAgICAgICBsZXQgeyB6aXBQYXRoLCBmaWx0ZXIsIG5hbWVmaXggfSA9IG9wdGlvbnM7XG5cbiAgICAgICAgICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSAoZnVuY3Rpb24gKHJ4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeC50ZXN0KGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KShmaWx0ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpeCBaaXBQYXRoXG4gICAgICAgICAgICB6aXBQYXRoID0gemlwUGF0aCA/IGZpeFBhdGgoemlwUGF0aCkgOiBcIlwiO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBOYW1lZml4IGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAobmFtZWZpeCA9PSBcImxhdGluMVwiKSB7XG4gICAgICAgICAgICAgICAgbmFtZWZpeCA9IChzdHIpID0+XG4gICAgICAgICAgICAgICAgICAgIHN0clxuICAgICAgICAgICAgICAgICAgICAgICAgLm5vcm1hbGl6ZShcIk5GRFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNmZdL2csIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW15cXHgyMC1cXHg3RV0vZywgXCJcIik7IC8vIGFjY2VudCBmaXggKGxhdGluMSBjaGFyYWNlcnMgb25seSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lZml4ICE9PSBcImZ1bmN0aW9uXCIpIG5hbWVmaXggPSAoc3RyKSA9PiBzdHI7XG5cbiAgICAgICAgICAgIC8vIGludGVybmFsLCBjcmVhdGUgcmVsYXRpdmUgcGF0aCArIGZpeCB0aGUgbmFtZVxuICAgICAgICAgICAgY29uc3QgcmVsUGF0aEZpeCA9IChlbnRyeSkgPT4gcHRoLmpvaW4oemlwUGF0aCwgbmFtZWZpeChyZWxhdGl2ZVBhdGgobG9jYWxQYXRoLCBlbnRyeSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lRml4ID0gKGVudHJ5KSA9PiBwdGgud2luMzIuYmFzZW5hbWUocHRoLndpbjMyLm5vcm1hbGl6ZShuYW1lZml4KGVudHJ5KSkpO1xuXG4gICAgICAgICAgICBmaWxldG9vbHMuZnMub3Blbihsb2NhbFBhdGgsIFwiclwiLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIFV0aWxzLkVycm9ycy5GSUxFX05PVF9GT1VORChsb2NhbFBhdGgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLmZpbmRGaWxlc0FzeW5jKGxvY2FsUGF0aCwgZnVuY3Rpb24gKGVyciwgZmlsZUVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUVudHJpZXMgPSBmaWxlRW50cmllcy5maWx0ZXIoKGRpcikgPT4gZmlsdGVyKHJlbFBhdGhGaXgoZGlyKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlRW50cmllcy5sZW5ndGgpIGNhbGxiYWNrKHVuZGVmaW5lZCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUVudHJpZXMucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAobmV4dCwgZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgZG9uZSA9PT0gZmFsc2UpIHJldHVybiBzZXRJbW1lZGlhdGUobmV4dCwgZXJyLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkTG9jYWxGaWxlQXN5bmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBhdGg6IGVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6aXBQYXRoOiBwdGguZGlybmFtZShyZWxQYXRoRml4KGVudHJ5KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHppcE5hbWU6IGZpbGVOYW1lRml4KGVudHJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgbG9jYWwgZGlyZWN0b3J5IGFuZCBhbGwgaXRzIG5lc3RlZCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgdG8gdGhlIGFyY2hpdmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsUGF0aCAtIHBhdGggd2hlcmUgZmlsZXMgd2lsbCBiZSBleHRyYWN0ZWRcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gb3B0aW9uYWwgcHJvcGVydGllc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLnppcFBhdGhdIC0gb3B0aW9uYWwgcGF0aCBpbnNpZGUgemlwXG4gICAgICAgICAqIEBwYXJhbSB7UmVnRXhwfGZ1bmN0aW9ufSBbcHJvcHMuZmlsdGVyXSAtIG9wdGlvbmFsIFJlZ0V4cCBvciBGdW5jdGlvbiBpZiBmaWxlcyBtYXRjaCB3aWxsIGJlIGluY2x1ZGVkLlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufHN0cmluZ30gW3Byb3BzLm5hbWVmaXhdIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gaGVscCBmaXggZmlsZW5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGFkZExvY2FsRm9sZGVyUHJvbWlzZTogZnVuY3Rpb24gKGxvY2FsUGF0aCwgcHJvcHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMb2NhbEZvbGRlckFzeW5jMihPYmplY3QuYXNzaWduKHsgbG9jYWxQYXRoIH0sIHByb3BzKSwgKGVyciwgZG9uZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHlvdSB0byBjcmVhdGUgYSBlbnRyeSAoZmlsZSBvciBkaXJlY3RvcnkpIGluIHRoZSB6aXAgZmlsZS5cbiAgICAgICAgICogSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgZGlyZWN0b3J5IHRoZSBlbnRyeU5hbWUgbXVzdCBlbmQgaW4gLyBhbmQgYSBudWxsIGJ1ZmZlciBzaG91bGQgYmUgcHJvdmlkZWQuXG4gICAgICAgICAqIENvbW1lbnQgYW5kIGF0dHJpYnV0ZXMgYXJlIG9wdGlvbmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeU5hbWVcbiAgICAgICAgICogQHBhcmFtIHtCdWZmZXIgfCBzdHJpbmd9IGNvbnRlbnQgLSBmaWxlIGNvbnRlbnQgYXMgYnVmZmVyIG9yIHV0ZjggY29kZWQgc3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gLSBmaWxlIGNvbW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXIgfCBvYmplY3R9IFthdHRyXSAtIG51bWJlciBhcyB1bml4IGZpbGUgcGVybWlzc2lvbnMsIG9iamVjdCBhcyBmaWxlc3lzdGVtIFN0YXRzIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRmlsZTogZnVuY3Rpb24gKGVudHJ5TmFtZSwgY29udGVudCwgY29tbWVudCwgYXR0cikge1xuICAgICAgICAgICAgZW50cnlOYW1lID0gemlwbmFtZWZpeChlbnRyeU5hbWUpO1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gZ2V0RW50cnkoZW50cnlOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGVudHJ5ICE9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIHByZXBhcmUgbmV3IGVudHJ5XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGVudHJ5ID0gbmV3IFppcEVudHJ5KG9wdHMpO1xuICAgICAgICAgICAgICAgIGVudHJ5LmVudHJ5TmFtZSA9IGVudHJ5TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJ5LmNvbW1lbnQgPSBjb21tZW50IHx8IFwiXCI7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzU3RhdCA9IFwib2JqZWN0XCIgPT09IHR5cGVvZiBhdHRyICYmIGF0dHIgaW5zdGFuY2VvZiBmaWxldG9vbHMuZnMuU3RhdHM7XG5cbiAgICAgICAgICAgIC8vIGxhc3QgbW9kaWZpY2F0aW9uIHRpbWUgZnJvbSBmaWxlIHN0YXRzXG4gICAgICAgICAgICBpZiAoaXNTdGF0KSB7XG4gICAgICAgICAgICAgICAgZW50cnkuaGVhZGVyLnRpbWUgPSBhdHRyLm10aW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgZmlsZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIHZhciBmaWxlYXR0ciA9IGVudHJ5LmlzRGlyZWN0b3J5ID8gMHgxMCA6IDA7IC8vIChNUy1ET1MgZGlyZWN0b3J5IGZsYWcpXG5cbiAgICAgICAgICAgIC8vIGV4dGVuZGVkIGF0dHJpYnV0ZXMgZmllbGQgZm9yIFVuaXhcbiAgICAgICAgICAgIC8vIHNldCBmaWxlIHR5cGUgZWl0aGVyIFNfSUZESVIgLyBTX0lGUkVHXG4gICAgICAgICAgICBsZXQgdW5peCA9IGVudHJ5LmlzRGlyZWN0b3J5ID8gMHg0MDAwIDogMHg4MDAwO1xuXG4gICAgICAgICAgICBpZiAoaXNTdGF0KSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsZSBhdHRyaWJ1dGVzIGZyb20gZmlsZSBzdGF0c1xuICAgICAgICAgICAgICAgIHVuaXggfD0gMHhmZmYgJiBhdHRyLm1vZGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiBhdHRyKSB7XG4gICAgICAgICAgICAgICAgLy8gYXR0ciBmcm9tIGdpdmVuIGF0dHIgdmFsdWVzXG4gICAgICAgICAgICAgICAgdW5peCB8PSAweGZmZiAmIGF0dHI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdmFsdWVzOlxuICAgICAgICAgICAgICAgIHVuaXggfD0gZW50cnkuaXNEaXJlY3RvcnkgPyAwbzc1NSA6IDBvNjQ0OyAvLyBwZXJtaXNzaW9ucyAoZHJ3eHIteHIteCkgb3IgKC1yLXdyLS1yLS0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbGVhdHRyID0gKGZpbGVhdHRyIHwgKHVuaXggPDwgMTYpKSA+Pj4gMDsgLy8gYWRkIGF0dHJpYnV0ZXNcblxuICAgICAgICAgICAgZW50cnkuYXR0ciA9IGZpbGVhdHRyO1xuXG4gICAgICAgICAgICBlbnRyeS5zZXREYXRhKGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGUpIF96aXAuc2V0RW50cnkoZW50cnkpO1xuXG4gICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgWmlwRW50cnkgb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGZpbGVzIGFuZCBmb2xkZXJzIGluc2lkZSB0aGUgYXJjaGl2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Bhc3N3b3JkXVxuICAgICAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RW50cmllczogZnVuY3Rpb24gKHBhc3N3b3JkKSB7XG4gICAgICAgICAgICBfemlwLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gICAgICAgICAgICByZXR1cm4gX3ppcCA/IF96aXAuZW50cmllcyA6IFtdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgWmlwRW50cnkgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZmlsZSBvciBmb2xkZXIgc3BlY2lmaWVkIGJ5IGBgbmFtZWBgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIFppcEVudHJ5XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbnRyeTogZnVuY3Rpb24gKC8qKlN0cmluZyovIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFbnRyeShuYW1lKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRFbnRyeUNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3ppcC5nZXRFbnRyeUNvdW50KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gX3ppcC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0cmFjdHMgdGhlIGdpdmVuIGVudHJ5IHRvIHRoZSBnaXZlbiB0YXJnZXRQYXRoXG4gICAgICAgICAqIElmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSBpbnNpZGUgdGhlIGFyY2hpdmUsIHRoZSBlbnRpcmUgZGlyZWN0b3J5IGFuZCBpdCdzIHN1YmRpcmVjdG9yaWVzIHdpbGwgYmUgZXh0cmFjdGVkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfFppcEVudHJ5fSBlbnRyeSAtIFppcEVudHJ5IG9iamVjdCBvciBTdHJpbmcgd2l0aCB0aGUgZnVsbCBwYXRoIG9mIHRoZSBlbnRyeVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0UGF0aCAtIFRhcmdldCBmb2xkZXIgd2hlcmUgdG8gd3JpdGUgdGhlIGZpbGVcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbWFpbnRhaW5FbnRyeVBhdGg9dHJ1ZV0gLSBJZiBtYWludGFpbkVudHJ5UGF0aCBpcyB0cnVlIGFuZCB0aGUgZW50cnkgaXMgaW5zaWRlIGEgZm9sZGVyLCB0aGUgZW50cnkgZm9sZGVyIHdpbGwgYmUgY3JlYXRlZCBpbiB0YXJnZXRQYXRoIGFzIHdlbGwuIERlZmF1bHQgaXMgVFJVRVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdIC0gSWYgdGhlIGZpbGUgYWxyZWFkeSBleGlzdHMgYXQgdGhlIHRhcmdldCBwYXRoLCB0aGUgZmlsZSB3aWxsIGJlIG92ZXJ3cml0ZW4gaWYgdGhpcyBpcyB0cnVlLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtrZWVwT3JpZ2luYWxQZXJtaXNzaW9uPWZhbHNlXSAtIFRoZSBmaWxlIHdpbGwgYmUgc2V0IGFzIHRoZSBwZXJtaXNzaW9uIGZyb20gdGhlIGVudHJ5IGlmIHRoaXMgaXMgdHJ1ZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvdXRGaWxlTmFtZV0gLSBTdHJpbmcgSWYgc2V0IHdpbGwgb3ZlcnJpZGUgdGhlIGZpbGVuYW1lIG9mIHRoZSBleHRyYWN0ZWQgZmlsZSAoT25seSB3b3JrcyBpZiB0aGUgZW50cnkgaXMgYSBmaWxlKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGV4dHJhY3RFbnRyeVRvOiBmdW5jdGlvbiAoZW50cnksIHRhcmdldFBhdGgsIG1haW50YWluRW50cnlQYXRoLCBvdmVyd3JpdGUsIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIG91dEZpbGVOYW1lKSB7XG4gICAgICAgICAgICBvdmVyd3JpdGUgPSBnZXRfQm9vbChmYWxzZSwgb3ZlcndyaXRlKTtcbiAgICAgICAgICAgIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPSBnZXRfQm9vbChmYWxzZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbik7XG4gICAgICAgICAgICBtYWludGFpbkVudHJ5UGF0aCA9IGdldF9Cb29sKHRydWUsIG1haW50YWluRW50cnlQYXRoKTtcbiAgICAgICAgICAgIG91dEZpbGVOYW1lID0gZ2V0X1N0cihrZWVwT3JpZ2luYWxQZXJtaXNzaW9uLCBvdXRGaWxlTmFtZSk7XG5cbiAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLk5PX0VOVFJZKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbnRyeU5hbWUgPSBjYW5vbmljYWwoaXRlbS5lbnRyeU5hbWUpO1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gc2FuaXRpemUodGFyZ2V0UGF0aCwgb3V0RmlsZU5hbWUgJiYgIWl0ZW0uaXNEaXJlY3RvcnkgPyBvdXRGaWxlTmFtZSA6IG1haW50YWluRW50cnlQYXRoID8gZW50cnlOYW1lIDogcHRoLmJhc2VuYW1lKGVudHJ5TmFtZSkpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IF96aXAuZ2V0RW50cnlDaGlsZHJlbihpdGVtKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNEaXJlY3RvcnkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjaGlsZC5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkNBTlRfRVhUUkFDVF9GSUxFKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBjYW5vbmljYWwoY2hpbGQuZW50cnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTmFtZSA9IHNhbml0aXplKHRhcmdldFBhdGgsIG1haW50YWluRW50cnlQYXRoID8gbmFtZSA6IHB0aC5iYXNlbmFtZShuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXZlcnNlIG9wZXJhdGlvbiBmb3IgYXR0ciBkZXBlbmQgb24gbWV0aG9kIGFkZEZpbGUoKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlQXR0ciA9IGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPyBjaGlsZC5oZWFkZXIuZmlsZUF0dHIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy53cml0ZUZpbGVUbyhjaGlsZE5hbWUsIGNvbnRlbnQsIG92ZXJ3cml0ZSwgZmlsZUF0dHIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGl0ZW0uZ2V0RGF0YShfemlwLnBhc3N3b3JkKTtcbiAgICAgICAgICAgIGlmICghY29udGVudCkgdGhyb3cgVXRpbHMuRXJyb3JzLkNBTlRfRVhUUkFDVF9GSUxFKCk7XG5cbiAgICAgICAgICAgIGlmIChmaWxldG9vbHMuZnMuZXhpc3RzU3luYyh0YXJnZXQpICYmICFvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuQ0FOVF9PVkVSUklERSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIHJldmVyc2Ugb3BlcmF0aW9uIGZvciBhdHRyIGRlcGVuZCBvbiBtZXRob2QgYWRkRmlsZSgpXG4gICAgICAgICAgICBjb25zdCBmaWxlQXR0ciA9IGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPyBlbnRyeS5oZWFkZXIuZmlsZUF0dHIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmaWxldG9vbHMud3JpdGVGaWxlVG8odGFyZ2V0LCBjb250ZW50LCBvdmVyd3JpdGUsIGZpbGVBdHRyKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3QgdGhlIGFyY2hpdmVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXNzXVxuICAgICAgICAgKi9cbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKHBhc3MpIHtcbiAgICAgICAgICAgIGlmICghX3ppcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgZW50cnkgaW4gX3ppcC5lbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IF96aXAuZW50cmllc1tlbnRyeV0uZ2V0RGF0YShwYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRyYWN0cyB0aGUgZW50aXJlIGFyY2hpdmUgdG8gdGhlIGdpdmVuIGxvY2F0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRQYXRoIFRhcmdldCBsb2NhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdIElmIHRoZSBmaWxlIGFscmVhZHkgZXhpc3RzIGF0IHRoZSB0YXJnZXQgcGF0aCwgdGhlIGZpbGUgd2lsbCBiZSBvdmVyd3JpdGVuIGlmIHRoaXMgaXMgdHJ1ZS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIEZBTFNFXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBPcmlnaW5hbFBlcm1pc3Npb249ZmFsc2VdIFRoZSBmaWxlIHdpbGwgYmUgc2V0IGFzIHRoZSBwZXJtaXNzaW9uIGZyb20gdGhlIGVudHJ5IGlmIHRoaXMgaXMgdHJ1ZS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIEZBTFNFXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gW3Bhc3NdIHBhc3N3b3JkXG4gICAgICAgICAqL1xuICAgICAgICBleHRyYWN0QWxsVG86IGZ1bmN0aW9uICh0YXJnZXRQYXRoLCBvdmVyd3JpdGUsIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIHBhc3MpIHtcbiAgICAgICAgICAgIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPSBnZXRfQm9vbChmYWxzZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbik7XG4gICAgICAgICAgICBwYXNzID0gZ2V0X1N0cihrZWVwT3JpZ2luYWxQZXJtaXNzaW9uLCBwYXNzKTtcbiAgICAgICAgICAgIG92ZXJ3cml0ZSA9IGdldF9Cb29sKGZhbHNlLCBvdmVyd3JpdGUpO1xuICAgICAgICAgICAgaWYgKCFfemlwKSB0aHJvdyBVdGlscy5FcnJvcnMuTk9fWklQKCk7XG5cbiAgICAgICAgICAgIF96aXAuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeU5hbWUgPSBzYW5pdGl6ZSh0YXJnZXRQYXRoLCBjYW5vbmljYWwoZW50cnkuZW50cnlOYW1lKSk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy5tYWtlRGlyKGVudHJ5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBlbnRyeS5nZXREYXRhKHBhc3MpO1xuICAgICAgICAgICAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuQ0FOVF9FWFRSQUNUX0ZJTEUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJldmVyc2Ugb3BlcmF0aW9uIGZvciBhdHRyIGRlcGVuZCBvbiBtZXRob2QgYWRkRmlsZSgpXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZUF0dHIgPSBrZWVwT3JpZ2luYWxQZXJtaXNzaW9uID8gZW50cnkuaGVhZGVyLmZpbGVBdHRyIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGZpbGV0b29scy53cml0ZUZpbGVUbyhlbnRyeU5hbWUsIGNvbnRlbnQsIG92ZXJ3cml0ZSwgZmlsZUF0dHIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy5mcy51dGltZXNTeW5jKGVudHJ5TmFtZSwgZW50cnkuaGVhZGVyLnRpbWUsIGVudHJ5LmhlYWRlci50aW1lKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkNBTlRfRVhUUkFDVF9GSUxFKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzeW5jaHJvbm91cyBleHRyYWN0QWxsVG9cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFBhdGggVGFyZ2V0IGxvY2F0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV0gSWYgdGhlIGZpbGUgYWxyZWFkeSBleGlzdHMgYXQgdGhlIHRhcmdldCBwYXRoLCB0aGUgZmlsZSB3aWxsIGJlIG92ZXJ3cml0ZW4gaWYgdGhpcyBpcyB0cnVlLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgRkFMU0VcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBba2VlcE9yaWdpbmFsUGVybWlzc2lvbj1mYWxzZV0gVGhlIGZpbGUgd2lsbCBiZSBzZXQgYXMgdGhlIHBlcm1pc3Npb24gZnJvbSB0aGUgZW50cnkgaWYgdGhpcyBpcyB0cnVlLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgRkFMU0VcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhbGwgZW50cmllcyBhcmUgZXh0cmFjdGVkIHN1Y2Nlc3NmdWxseSBvciBhbnkgZXJyb3IgaXMgdGhyb3duLlxuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFjdEFsbFRvQXN5bmM6IGZ1bmN0aW9uICh0YXJnZXRQYXRoLCBvdmVyd3JpdGUsIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGdldF9GdW4ob3ZlcndyaXRlLCBrZWVwT3JpZ2luYWxQZXJtaXNzaW9uLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBrZWVwT3JpZ2luYWxQZXJtaXNzaW9uID0gZ2V0X0Jvb2woZmFsc2UsIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24pO1xuICAgICAgICAgICAgb3ZlcndyaXRlID0gZ2V0X0Jvb2woZmFsc2UsIG92ZXJ3cml0ZSk7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRyYWN0QWxsVG9Bc3luYyh0YXJnZXRQYXRoLCBvdmVyd3JpdGUsIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV96aXApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhVdGlscy5FcnJvcnMuTk9fWklQKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0UGF0aCA9IHB0aC5yZXNvbHZlKHRhcmdldFBhdGgpO1xuICAgICAgICAgICAgLy8gY29udmVydCBlbnRyeU5hbWUgdG9cbiAgICAgICAgICAgIGNvbnN0IGdldFBhdGggPSAoZW50cnkpID0+IHNhbml0aXplKHRhcmdldFBhdGgsIHB0aC5ub3JtYWxpemUoY2Fub25pY2FsKGVudHJ5LmVudHJ5TmFtZSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGdldEVycm9yID0gKG1zZywgZmlsZSkgPT4gbmV3IEVycm9yKG1zZyArICc6IFwiJyArIGZpbGUgKyAnXCInKTtcblxuICAgICAgICAgICAgLy8gc2VwYXJhdGUgZGlyZWN0b3JpZXMgZnJvbSBmaWxlc1xuICAgICAgICAgICAgY29uc3QgZGlyRW50cmllcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZmlsZUVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgIF96aXAuZW50cmllcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyRW50cmllcy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVFbnRyaWVzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBkaXJlY3RvcnkgZW50cmllcyBmaXJzdCBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAvLyB0aGlzIHByZXZlbnRzIHJhY2UgY29uZGl0aW9uIGFuZCBhc3N1cmVzIGZvbGRlcnMgYXJlIHRoZXJlIGJlZm9yZSB3cml0aW5nIGZpbGVzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGRpckVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJQYXRoID0gZ2V0UGF0aChlbnRyeSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJldmVyc2Ugb3BlcmF0aW9uIGZvciBhdHRyIGRlcGVuZCBvbiBtZXRob2QgYWRkRmlsZSgpXG4gICAgICAgICAgICAgICAgY29uc3QgZGlyQXR0ciA9IGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPyBlbnRyeS5oZWFkZXIuZmlsZUF0dHIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLm1ha2VEaXIoZGlyUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJBdHRyKSBmaWxldG9vbHMuZnMuY2htb2RTeW5jKGRpclBhdGgsIGRpckF0dHIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiB1bml4IHRpbWVzdGFtcCB3aWxsIGNoYW5nZSBpZiBmaWxlcyBhcmUgbGF0ZXIgYWRkZWQgdG8gZm9sZGVyLCBidXQgc3RpbGxcbiAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLmZzLnV0aW1lc1N5bmMoZGlyUGF0aCwgZW50cnkuaGVhZGVyLnRpbWUsIGVudHJ5LmhlYWRlci50aW1lKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhnZXRFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgZm9sZGVyXCIsIGRpclBhdGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbGVFbnRyaWVzLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKG5leHQsIGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnlOYW1lID0gcHRoLm5vcm1hbGl6ZShjYW5vbmljYWwoZW50cnkuZW50cnlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHNhbml0aXplKHRhcmdldFBhdGgsIGVudHJ5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5nZXREYXRhQXN5bmMoZnVuY3Rpb24gKGNvbnRlbnQsIGVycl8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycl8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoZXJyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dChVdGlscy5FcnJvcnMuQ0FOVF9FWFRSQUNUX0ZJTEUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJldmVyc2Ugb3BlcmF0aW9uIGZvciBhdHRyIGRlcGVuZCBvbiBtZXRob2QgYWRkRmlsZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVBdHRyID0ga2VlcE9yaWdpbmFsUGVybWlzc2lvbiA/IGVudHJ5LmhlYWRlci5maWxlQXR0ciA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLndyaXRlRmlsZVRvQXN5bmMoZmlsZVBhdGgsIGNvbnRlbnQsIG92ZXJ3cml0ZSwgZmlsZUF0dHIsIGZ1bmN0aW9uIChzdWNjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN1Y2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KGdldEVycm9yKFwiVW5hYmxlIHRvIHdyaXRlIGZpbGVcIiwgZmlsZVBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy5mcy51dGltZXMoZmlsZVBhdGgsIGVudHJ5LmhlYWRlci50aW1lLCBlbnRyeS5oZWFkZXIudGltZSwgZnVuY3Rpb24gKGVycl8yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycl8yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoZ2V0RXJyb3IoXCJVbmFibGUgdG8gc2V0IHRpbWVzXCIsIGZpbGVQYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCBjYWxsYmFjaykoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIHRoZSBuZXdseSBjcmVhdGVkIHppcCBmaWxlIHRvIGRpc2sgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbiBvciBpZiBhIHppcCB3YXMgb3BlbmVkIGFuZCBubyBgYHRhcmdldEZpbGVOYW1lYGAgaXMgcHJvdmlkZWQsIGl0IHdpbGwgb3ZlcndyaXRlIHRoZSBvcGVuZWQgemlwXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRGaWxlTmFtZVxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgd3JpdGVaaXA6IGZ1bmN0aW9uICh0YXJnZXRGaWxlTmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRGaWxlTmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gdGFyZ2V0RmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEZpbGVOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGFyZ2V0RmlsZU5hbWUgJiYgb3B0cy5maWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldEZpbGVOYW1lID0gb3B0cy5maWxlbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFyZ2V0RmlsZU5hbWUpIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIHppcERhdGEgPSBfemlwLmNvbXByZXNzVG9CdWZmZXIoKTtcbiAgICAgICAgICAgIGlmICh6aXBEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9rID0gZmlsZXRvb2xzLndyaXRlRmlsZVRvKHRhcmdldEZpbGVOYW1lLCB6aXBEYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIGNhbGxiYWNrKCFvayA/IG5ldyBFcnJvcihcImZhaWxlZFwiKSA6IG51bGwsIFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0RmlsZU5hbWVcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtwcm9wc11cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3ZlcndyaXRlPXRydWVdIElmIHRoZSBmaWxlIGFscmVhZHkgZXhpc3RzIGF0IHRoZSB0YXJnZXQgcGF0aCwgdGhlIGZpbGUgd2lsbCBiZSBvdmVyd3JpdGVuIGlmIHRoaXMgaXMgdHJ1ZS5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMucGVybV0gVGhlIGZpbGUgd2lsbCBiZSBzZXQgYXMgdGhlIHBlcm1pc3Npb24gZnJvbSB0aGUgZW50cnkgaWYgdGhpcyBpcyB0cnVlLlxuXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAgICAgKi9cbiAgICAgICAgd3JpdGVaaXBQcm9taXNlOiBmdW5jdGlvbiAoLyoqU3RyaW5nKi8gdGFyZ2V0RmlsZU5hbWUsIC8qIG9iamVjdCAqLyBwcm9wcykge1xuICAgICAgICAgICAgY29uc3QgeyBvdmVyd3JpdGUsIHBlcm0gfSA9IE9iamVjdC5hc3NpZ24oeyBvdmVyd3JpdGU6IHRydWUgfSwgcHJvcHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgZmlsZSBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRGaWxlTmFtZSAmJiBvcHRzLmZpbGVuYW1lKSB0YXJnZXRGaWxlTmFtZSA9IG9wdHMuZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRGaWxlTmFtZSkgcmVqZWN0KFwiQURNLVpJUDogWklQIEZpbGUgTmFtZSBNaXNzaW5nXCIpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy50b0J1ZmZlclByb21pc2UoKS50aGVuKCh6aXBEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IChkb25lKSA9PiAoZG9uZSA/IHJlc29sdmUoZG9uZSkgOiByZWplY3QoXCJBRE0tWklQOiBXYXNuJ3QgYWJsZSB0byB3cml0ZSB6aXAgZmlsZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy53cml0ZUZpbGVUb0FzeW5jKHRhcmdldEZpbGVOYW1lLCB6aXBEYXRhLCBvdmVyd3JpdGUsIHBlcm0sIHJldCk7XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSBBIHByb21pc2UgdG8gdGhlIEJ1ZmZlci5cbiAgICAgICAgICovXG4gICAgICAgIHRvQnVmZmVyUHJvbWlzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBfemlwLnRvQXN5bmNCdWZmZXIocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBlbnRpcmUgemlwIGZpbGUgYXMgYSBCdWZmZXIgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtmdW5jdGlvbn0gW29uU3VjY2Vzc11cbiAgICAgICAgICogQHByb3Age2Z1bmN0aW9ufSBbb25GYWlsXVxuICAgICAgICAgKiBAcHJvcCB7ZnVuY3Rpb259IFtvbkl0ZW1TdGFydF1cbiAgICAgICAgICogQHByb3Age2Z1bmN0aW9ufSBbb25JdGVtRW5kXVxuICAgICAgICAgKiBAcmV0dXJucyB7QnVmZmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdG9CdWZmZXI6IGZ1bmN0aW9uIChvblN1Y2Nlc3MsIG9uRmFpbCwgb25JdGVtU3RhcnQsIG9uSXRlbUVuZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvblN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIF96aXAudG9Bc3luY0J1ZmZlcihvblN1Y2Nlc3MsIG9uRmFpbCwgb25JdGVtU3RhcnQsIG9uSXRlbUVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3ppcC5jb21wcmVzc1RvQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsICIvKipcbiAqIFNldCBEZWZhdWx0cyBDb21tYW5kIC0gRWFzeSBzdG9wIHNlbGVjdGlvbiB3aXRoIHNlYXJjaFxuICovXG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIEFjdGlvblBhbmVsLFxuICBBY3Rpb24sXG4gIEljb24sXG4gIExpc3QsXG4gIHNob3dUb2FzdCxcbiAgVG9hc3QsXG4gIExvY2FsU3RvcmFnZSxcbiAgb3BlbkV4dGVuc2lvblByZWZlcmVuY2VzLFxufSBmcm9tIFwiQHJheWNhc3QvYXBpXCI7XG5pbXBvcnQgeyBsb2FkU3RhdGljR1RGUyB9IGZyb20gXCIuL2xpYi9ndGZzU3RhdGljXCI7XG5pbXBvcnQgeyBTdGF0aWNHVEZTRGF0YSwgU3RvcCB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNldERlZmF1bHRzKCkge1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtzdG9wcywgc2V0U3RvcHNdID0gdXNlU3RhdGU8U3RvcFtdPihbXSk7XG4gIGNvbnN0IFtzZWFyY2hUZXh0LCBzZXRTZWFyY2hUZXh0XSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbc2F2ZWRTdG9wSWQsIHNldFNhdmVkU3RvcElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9hZFN0b3BzKCk7XG4gICAgbG9hZFNhdmVkU3RvcCgpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgbG9hZFNhdmVkU3RvcCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2F2ZWQgPSBhd2FpdCBMb2NhbFN0b3JhZ2UuZ2V0SXRlbTxzdHJpbmc+KFwiZGVmYXVsdC1zdG9wLWlkXCIpO1xuICAgICAgaWYgKHNhdmVkKSB7XG4gICAgICAgIHNldFNhdmVkU3RvcElkKHNhdmVkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgc2F2ZWQgc3RvcDpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBsb2FkU3RvcHMgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGd0ZnNEYXRhID0gYXdhaXQgbG9hZFN0YXRpY0dURlMoKTtcbiAgICAgIGNvbnN0IGFsbFN0b3BzID0gQXJyYXkuZnJvbShndGZzRGF0YS5zdG9wcy52YWx1ZXMoKSk7XG4gICAgICBcbiAgICAgIC8vIFNvcnQgc3RvcHMgYnkgbmFtZVxuICAgICAgYWxsU3RvcHMuc29ydCgoYSwgYikgPT4gYS5zdG9wX25hbWUubG9jYWxlQ29tcGFyZShiLnN0b3BfbmFtZSkpO1xuICAgICAgXG4gICAgICBzZXRTdG9wcyhhbGxTdG9wcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHN0b3BzOlwiLCBlcnJvcik7XG4gICAgICBzaG93VG9hc3Qoe1xuICAgICAgICBzdHlsZTogVG9hc3QuU3R5bGUuRmFpbHVyZSxcbiAgICAgICAgdGl0bGU6IFwiRmFpbGVkIHRvIExvYWQgU3RvcHNcIixcbiAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIixcbiAgICAgIH0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzYXZlRGVmYXVsdFN0b3AgPSBhc3luYyAoc3RvcDogU3RvcCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9wSWQgPSBTdHJpbmcoc3RvcC5zdG9wX2lkKTtcbiAgICAgIGF3YWl0IExvY2FsU3RvcmFnZS5zZXRJdGVtKFwiZGVmYXVsdC1zdG9wLWlkXCIsIHN0b3BJZCk7XG4gICAgICBhd2FpdCBMb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImRlZmF1bHQtc3RvcC1uYW1lXCIsIHN0b3Auc3RvcF9uYW1lKTtcbiAgICAgIHNldFNhdmVkU3RvcElkKHN0b3BJZCk7XG4gICAgICBcbiAgICAgIHNob3dUb2FzdCh7XG4gICAgICAgIHN0eWxlOiBUb2FzdC5TdHlsZS5TdWNjZXNzLFxuICAgICAgICB0aXRsZTogXCJEZWZhdWx0IFN0b3AgU2V0XCIsXG4gICAgICAgIG1lc3NhZ2U6IGAke3N0b3Auc3RvcF9uYW1lfSAoJHtzdG9wSWR9KWAsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2hvd1RvYXN0KHtcbiAgICAgICAgc3R5bGU6IFRvYXN0LlN0eWxlLkZhaWx1cmUsXG4gICAgICAgIHRpdGxlOiBcIkZhaWxlZCB0byBTYXZlXCIsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRmlsdGVyIHN0b3BzIGJhc2VkIG9uIHNlYXJjaFxuICBjb25zdCBmaWx0ZXJlZFN0b3BzID0gc3RvcHMuZmlsdGVyKChzdG9wKSA9PiB7XG4gICAgY29uc3Qgc2VhcmNoID0gc2VhcmNoVGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHN0b3BJZCA9IFN0cmluZyhzdG9wLnN0b3BfaWQpO1xuICAgIGNvbnN0IHN0b3BOYW1lID0gc3RvcC5zdG9wX25hbWUgfHwgXCJcIjtcbiAgICByZXR1cm4gKFxuICAgICAgc3RvcElkLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoKSB8fFxuICAgICAgc3RvcE5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2gpXG4gICAgKTtcbiAgfSk7XG5cbiAgLy8gR3JvdXAgc3RvcHMgYnkgYXJlYS9rZXl3b3JkIGZvciBiZXR0ZXIgb3JnYW5pemF0aW9uXG4gIGNvbnN0IGNhbXB1c1N0b3BzID0gZmlsdGVyZWRTdG9wcy5maWx0ZXIoKHMpID0+IFxuICAgIHMuc3RvcF9uYW1lLmluY2x1ZGVzKFwiQ2FtcHVzXCIpIHx8IFxuICAgIHMuc3RvcF9uYW1lLmluY2x1ZGVzKFwiUGF0dGVlXCIpIHx8IFxuICAgIHMuc3RvcF9uYW1lLmluY2x1ZGVzKFwiSFVCXCIpIHx8XG4gICAgcy5zdG9wX25hbWUuaW5jbHVkZXMoXCJQb2xsb2NrXCIpIHx8XG4gICAgcy5zdG9wX25hbWUuaW5jbHVkZXMoXCJTaGllbGRzXCIpIHx8XG4gICAgcy5zdG9wX25hbWUuaW5jbHVkZXMoXCJMaWJyYXJ5XCIpXG4gICk7XG5cbiAgY29uc3QgZG93bnRvd25TdG9wcyA9IGZpbHRlcmVkU3RvcHMuZmlsdGVyKChzKSA9PiBcbiAgICBzLnN0b3BfbmFtZS5pbmNsdWRlcyhcIkRvd250b3duXCIpIHx8IFxuICAgIHMuc3RvcF9uYW1lLmluY2x1ZGVzKFwiQ29sbGVnZSBBdmVcIikgfHxcbiAgICBzLnN0b3BfbmFtZS5pbmNsdWRlcyhcIkJlYXZlciBBdmVcIikgfHxcbiAgICBzLnN0b3BfbmFtZS5pbmNsdWRlcyhcIkFsbGVuIFN0XCIpXG4gICk7XG5cbiAgY29uc3QgYXBhcnRtZW50U3RvcHMgPSBmaWx0ZXJlZFN0b3BzLmZpbHRlcigocykgPT4gXG4gICAgcy5zdG9wX25hbWUuaW5jbHVkZXMoXCJBcGFydG1lbnRcIikgfHwgXG4gICAgcy5zdG9wX25hbWUuaW5jbHVkZXMoXCJIZWlnaHRzXCIpIHx8XG4gICAgcy5zdG9wX25hbWUuaW5jbHVkZXMoXCJQYXJrXCIpIHx8XG4gICAgcy5zdG9wX25hbWUuaW5jbHVkZXMoXCJQbGF6YVwiKSB8fFxuICAgIHMuc3RvcF9uYW1lLmluY2x1ZGVzKFwiVmFpcm9cIikgfHxcbiAgICBzLnN0b3BfbmFtZS5pbmNsdWRlcyhcIlRvZnRyZWVzXCIpXG4gICk7XG5cbiAgY29uc3Qgb3RoZXJTdG9wcyA9IGZpbHRlcmVkU3RvcHMuZmlsdGVyKChzKSA9PiBcbiAgICAhY2FtcHVzU3RvcHMuaW5jbHVkZXMocykgJiYgXG4gICAgIWRvd250b3duU3RvcHMuaW5jbHVkZXMocykgJiYgXG4gICAgIWFwYXJ0bWVudFN0b3BzLmluY2x1ZGVzKHMpXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8TGlzdFxuICAgICAgaXNMb2FkaW5nPXtpc0xvYWRpbmd9XG4gICAgICBzZWFyY2hUZXh0PXtzZWFyY2hUZXh0fVxuICAgICAgb25TZWFyY2hUZXh0Q2hhbmdlPXtzZXRTZWFyY2hUZXh0fVxuICAgICAgc2VhcmNoQmFyUGxhY2Vob2xkZXI9XCJTZWFyY2ggYnkgc3RvcCBuYW1lIG9yIElELi4uXCJcbiAgICAgIG5hdmlnYXRpb25UaXRsZT1cIlNldCBEZWZhdWx0IFN0b3BcIlxuICAgID5cbiAgICAgIHtzYXZlZFN0b3BJZCAmJiAoXG4gICAgICAgIDxMaXN0LlNlY3Rpb24gdGl0bGU9XCJDdXJyZW50IERlZmF1bHRcIj5cbiAgICAgICAgICB7c3RvcHNcbiAgICAgICAgICAgIC5maWx0ZXIoKHMpID0+IFN0cmluZyhzLnN0b3BfaWQpID09PSBzYXZlZFN0b3BJZClcbiAgICAgICAgICAgIC5tYXAoKHN0b3ApID0+IChcbiAgICAgICAgICAgICAgPExpc3QuSXRlbVxuICAgICAgICAgICAgICAgIGtleT17U3RyaW5nKHN0b3Auc3RvcF9pZCl9XG4gICAgICAgICAgICAgICAgdGl0bGU9e3N0b3Auc3RvcF9uYW1lfVxuICAgICAgICAgICAgICAgIHN1YnRpdGxlPXtgU3RvcCAke1N0cmluZyhzdG9wLnN0b3BfaWQpfWB9XG4gICAgICAgICAgICAgICAgaWNvbj17eyBzb3VyY2U6IEljb24uU3RhciwgdGludENvbG9yOiBcIiNGRkQ3MDBcIiB9fVxuICAgICAgICAgICAgICAgIGFjY2Vzc29yaWVzPXtbeyB0ZXh0OiBcIkN1cnJlbnQgRGVmYXVsdFwiLCBpY29uOiBJY29uLkNoZWNrbWFyayB9XX1cbiAgICAgICAgICAgICAgICBhY3Rpb25zPXtcbiAgICAgICAgICAgICAgICAgIDxBY3Rpb25QYW5lbD5cbiAgICAgICAgICAgICAgICAgICAgPEFjdGlvblxuICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiVmlldyBTdGF0dXNcIlxuICAgICAgICAgICAgICAgICAgICAgIGljb249e0ljb24uQXJyb3dSaWdodH1cbiAgICAgICAgICAgICAgICAgICAgICBvbkFjdGlvbj17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmF2aWdhdGUgdG8gc3RhdHVzIGNvbW1hbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dUb2FzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBUb2FzdC5TdHlsZS5TdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJPcGVuaW5nIFN0YXR1c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNoZWNrIG1lbnUgYmFyIGZvciBidXMgYXJyaXZhbHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8L0FjdGlvblBhbmVsPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkpfVxuICAgICAgICA8L0xpc3QuU2VjdGlvbj5cbiAgICAgICl9XG5cbiAgICAgIHtjYW1wdXNTdG9wcy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgPExpc3QuU2VjdGlvbiB0aXRsZT1cIkNhbXB1cyBTdG9wc1wiPlxuICAgICAgICAgIHtjYW1wdXNTdG9wcy5tYXAoKHN0b3ApID0+IChcbiAgICAgICAgICAgIDxMaXN0Lkl0ZW1cbiAgICAgICAgICAgICAga2V5PXtTdHJpbmcoc3RvcC5zdG9wX2lkKX1cbiAgICAgICAgICAgICAgdGl0bGU9e3N0b3Auc3RvcF9uYW1lfVxuICAgICAgICAgICAgICBzdWJ0aXRsZT17YFN0b3AgJHtTdHJpbmcoc3RvcC5zdG9wX2lkKX1gfVxuICAgICAgICAgICAgICBpY29uPXtJY29uLkJ1aWxkaW5nfVxuICAgICAgICAgICAgICBhY2Nlc3Nvcmllcz17W1xuICAgICAgICAgICAgICAgIFN0cmluZyhzdG9wLnN0b3BfaWQpID09PSBzYXZlZFN0b3BJZCAmJiB7IGljb246IEljb24uQ2hlY2ttYXJrIH0sXG4gICAgICAgICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pIGFzIGFueX1cbiAgICAgICAgICAgICAgYWN0aW9ucz17XG4gICAgICAgICAgICAgICAgPEFjdGlvblBhbmVsPlxuICAgICAgICAgICAgICAgICAgPEFjdGlvblxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIlNldCBhcyBEZWZhdWx0IFN0b3BcIlxuICAgICAgICAgICAgICAgICAgICBpY29uPXtJY29uLlN0YXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uQWN0aW9uPXsoKSA9PiBzYXZlRGVmYXVsdFN0b3Aoc3RvcCl9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPEFjdGlvbi5Db3B5VG9DbGlwYm9hcmRcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJDb3B5IFN0b3AgSURcIlxuICAgICAgICAgICAgICAgICAgICBjb250ZW50PXtTdHJpbmcoc3RvcC5zdG9wX2lkKX1cbiAgICAgICAgICAgICAgICAgICAgc2hvcnRjdXQ9e3sgbW9kaWZpZXJzOiBbXCJjbWRcIl0sIGtleTogXCJjXCIgfX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8QWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiT3BlbiBFeHRlbnNpb24gUHJlZmVyZW5jZXNcIlxuICAgICAgICAgICAgICAgICAgICBpY29uPXtJY29uLkdlYXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uQWN0aW9uPXtvcGVuRXh0ZW5zaW9uUHJlZmVyZW5jZXN9XG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0PXt7IG1vZGlmaWVyczogW1wiY21kXCJdLCBrZXk6IFwiLFwiIH19XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvQWN0aW9uUGFuZWw+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvTGlzdC5TZWN0aW9uPlxuICAgICAgKX1cblxuICAgICAge2Rvd250b3duU3RvcHMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgIDxMaXN0LlNlY3Rpb24gdGl0bGU9XCJEb3dudG93biBTdG9wc1wiPlxuICAgICAgICAgIHtkb3dudG93blN0b3BzLm1hcCgoc3RvcCkgPT4gKFxuICAgICAgICAgICAgPExpc3QuSXRlbVxuICAgICAgICAgICAgICBrZXk9e1N0cmluZyhzdG9wLnN0b3BfaWQpfVxuICAgICAgICAgICAgICB0aXRsZT17c3RvcC5zdG9wX25hbWV9XG4gICAgICAgICAgICAgIHN1YnRpdGxlPXtgU3RvcCAke1N0cmluZyhzdG9wLnN0b3BfaWQpfWB9XG4gICAgICAgICAgICAgIGljb249e0ljb24uU3RvcmV9XG4gICAgICAgICAgICAgIGFjY2Vzc29yaWVzPXtbXG4gICAgICAgICAgICAgICAgU3RyaW5nKHN0b3Auc3RvcF9pZCkgPT09IHNhdmVkU3RvcElkICYmIHsgaWNvbjogSWNvbi5DaGVja21hcmsgfSxcbiAgICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbikgYXMgYW55fVxuICAgICAgICAgICAgICBhY3Rpb25zPXtcbiAgICAgICAgICAgICAgICA8QWN0aW9uUGFuZWw+XG4gICAgICAgICAgICAgICAgICA8QWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiU2V0IGFzIERlZmF1bHQgU3RvcFwiXG4gICAgICAgICAgICAgICAgICAgIGljb249e0ljb24uU3Rhcn1cbiAgICAgICAgICAgICAgICAgICAgb25BY3Rpb249eygpID0+IHNhdmVEZWZhdWx0U3RvcChzdG9wKX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8QWN0aW9uLkNvcHlUb0NsaXBib2FyZFxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkNvcHkgU3RvcCBJRFwiXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ9e1N0cmluZyhzdG9wLnN0b3BfaWQpfVxuICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dD17eyBtb2RpZmllcnM6IFtcImNtZFwiXSwga2V5OiBcImNcIiB9fVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIDxBY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJPcGVuIEV4dGVuc2lvbiBQcmVmZXJlbmNlc1wiXG4gICAgICAgICAgICAgICAgICAgIGljb249e0ljb24uR2Vhcn1cbiAgICAgICAgICAgICAgICAgICAgb25BY3Rpb249e29wZW5FeHRlbnNpb25QcmVmZXJlbmNlc31cbiAgICAgICAgICAgICAgICAgICAgc2hvcnRjdXQ9e3sgbW9kaWZpZXJzOiBbXCJjbWRcIl0sIGtleTogXCIsXCIgfX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9BY3Rpb25QYW5lbD5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9MaXN0LlNlY3Rpb24+XG4gICAgICApfVxuXG4gICAgICB7YXBhcnRtZW50U3RvcHMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgIDxMaXN0LlNlY3Rpb24gdGl0bGU9XCJBcGFydG1lbnRzICYgUmVzaWRlbnRpYWxcIj5cbiAgICAgICAgICB7YXBhcnRtZW50U3RvcHMubWFwKChzdG9wKSA9PiAoXG4gICAgICAgICAgICA8TGlzdC5JdGVtXG4gICAgICAgICAgICAgIGtleT17U3RyaW5nKHN0b3Auc3RvcF9pZCl9XG4gICAgICAgICAgICAgIHRpdGxlPXtzdG9wLnN0b3BfbmFtZX1cbiAgICAgICAgICAgICAgc3VidGl0bGU9e2BTdG9wICR7U3RyaW5nKHN0b3Auc3RvcF9pZCl9YH1cbiAgICAgICAgICAgICAgaWNvbj17SWNvbi5Ib3VzZX1cbiAgICAgICAgICAgICAgYWNjZXNzb3JpZXM9e1tcbiAgICAgICAgICAgICAgICBTdHJpbmcoc3RvcC5zdG9wX2lkKSA9PT0gc2F2ZWRTdG9wSWQgJiYgeyBpY29uOiBJY29uLkNoZWNrbWFyayB9LFxuICAgICAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKSBhcyBhbnl9XG4gICAgICAgICAgICAgIGFjdGlvbnM9e1xuICAgICAgICAgICAgICAgIDxBY3Rpb25QYW5lbD5cbiAgICAgICAgICAgICAgICAgIDxBY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJTZXQgYXMgRGVmYXVsdCBTdG9wXCJcbiAgICAgICAgICAgICAgICAgICAgaWNvbj17SWNvbi5TdGFyfVxuICAgICAgICAgICAgICAgICAgICBvbkFjdGlvbj17KCkgPT4gc2F2ZURlZmF1bHRTdG9wKHN0b3ApfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIDxBY3Rpb24uQ29weVRvQ2xpcGJvYXJkXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiQ29weSBTdG9wIElEXCJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudD17U3RyaW5nKHN0b3Auc3RvcF9pZCl9XG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0PXt7IG1vZGlmaWVyczogW1wiY21kXCJdLCBrZXk6IFwiY1wiIH19XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPEFjdGlvblxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIk9wZW4gRXh0ZW5zaW9uIFByZWZlcmVuY2VzXCJcbiAgICAgICAgICAgICAgICAgICAgaWNvbj17SWNvbi5HZWFyfVxuICAgICAgICAgICAgICAgICAgICBvbkFjdGlvbj17b3BlbkV4dGVuc2lvblByZWZlcmVuY2VzfVxuICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dD17eyBtb2RpZmllcnM6IFtcImNtZFwiXSwga2V5OiBcIixcIiB9fVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L0FjdGlvblBhbmVsPlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L0xpc3QuU2VjdGlvbj5cbiAgICAgICl9XG5cbiAgICAgIHtvdGhlclN0b3BzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICA8TGlzdC5TZWN0aW9uIHRpdGxlPVwiT3RoZXIgU3RvcHNcIj5cbiAgICAgICAgICB7b3RoZXJTdG9wcy5tYXAoKHN0b3ApID0+IChcbiAgICAgICAgICAgIDxMaXN0Lkl0ZW1cbiAgICAgICAgICAgICAga2V5PXtTdHJpbmcoc3RvcC5zdG9wX2lkKX1cbiAgICAgICAgICAgICAgdGl0bGU9e3N0b3Auc3RvcF9uYW1lfVxuICAgICAgICAgICAgICBzdWJ0aXRsZT17YFN0b3AgJHtTdHJpbmcoc3RvcC5zdG9wX2lkKX1gfVxuICAgICAgICAgICAgICBpY29uPXtJY29uLlBpbn1cbiAgICAgICAgICAgICAgYWNjZXNzb3JpZXM9e1tcbiAgICAgICAgICAgICAgICBTdHJpbmcoc3RvcC5zdG9wX2lkKSA9PT0gc2F2ZWRTdG9wSWQgJiYgeyBpY29uOiBJY29uLkNoZWNrbWFyayB9LFxuICAgICAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKSBhcyBhbnl9XG4gICAgICAgICAgICAgIGFjdGlvbnM9e1xuICAgICAgICAgICAgICAgIDxBY3Rpb25QYW5lbD5cbiAgICAgICAgICAgICAgICAgIDxBY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJTZXQgYXMgRGVmYXVsdCBTdG9wXCJcbiAgICAgICAgICAgICAgICAgICAgaWNvbj17SWNvbi5TdGFyfVxuICAgICAgICAgICAgICAgICAgICBvbkFjdGlvbj17KCkgPT4gc2F2ZURlZmF1bHRTdG9wKHN0b3ApfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIDxBY3Rpb24uQ29weVRvQ2xpcGJvYXJkXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiQ29weSBTdG9wIElEXCJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudD17U3RyaW5nKHN0b3Auc3RvcF9pZCl9XG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0PXt7IG1vZGlmaWVyczogW1wiY21kXCJdLCBrZXk6IFwiY1wiIH19XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPEFjdGlvblxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIk9wZW4gRXh0ZW5zaW9uIFByZWZlcmVuY2VzXCJcbiAgICAgICAgICAgICAgICAgICAgaWNvbj17SWNvbi5HZWFyfVxuICAgICAgICAgICAgICAgICAgICBvbkFjdGlvbj17b3BlbkV4dGVuc2lvblByZWZlcmVuY2VzfVxuICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dD17eyBtb2RpZmllcnM6IFtcImNtZFwiXSwga2V5OiBcIixcIiB9fVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L0FjdGlvblBhbmVsPlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L0xpc3QuU2VjdGlvbj5cbiAgICAgICl9XG5cbiAgICAgIHtmaWx0ZXJlZFN0b3BzLmxlbmd0aCA9PT0gMCAmJiBzZWFyY2hUZXh0ICYmIChcbiAgICAgICAgPExpc3QuRW1wdHlWaWV3XG4gICAgICAgICAgdGl0bGU9XCJObyBTdG9wcyBGb3VuZFwiXG4gICAgICAgICAgZGVzY3JpcHRpb249e2BObyBzdG9wcyBtYXRjaGluZyBcIiR7c2VhcmNoVGV4dH1cImB9XG4gICAgICAgICAgaWNvbj17SWNvbi5NYWduaWZ5aW5nR2xhc3N9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgIDwvTGlzdD5cbiAgKTtcbn0iLCAiLyoqXG4gKiBHVEZTIFN0YXRpYyBkYXRhIHBhcnNlciBhbmQgY2FjaGUgbWFuYWdlclxuICovXG5cbmltcG9ydCBmcyBmcm9tIFwiZnMvcHJvbWlzZXNcIjtcbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgb3MgZnJvbSBcIm9zXCI7XG5pbXBvcnQgZmV0Y2ggZnJvbSBcIm5vZGUtZmV0Y2hcIjtcbmltcG9ydCBBZG1aaXAgZnJvbSBcImFkbS16aXBcIjtcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSBcImNzdi1wYXJzZS9zeW5jXCI7XG5pbXBvcnQgeyBlbnZpcm9ubWVudCB9IGZyb20gXCJAcmF5Y2FzdC9hcGlcIjtcbmltcG9ydCB7XG4gIFN0b3AsXG4gIFJvdXRlLFxuICBUcmlwLFxuICBTdG9wVGltZSxcbiAgQ2FsZW5kYXJEYXRlLFxuICBTdGF0aWNHVEZTRGF0YSxcbiAgQ2FjaGVFbnRyeSxcbn0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbi8vIENhY2hlIGNvbmZpZ3VyYXRpb25cbmNvbnN0IENBQ0hFX0RJUiA9IHBhdGguam9pbihlbnZpcm9ubWVudC5zdXBwb3J0UGF0aCwgXCJndGZzLWNhY2hlXCIpO1xuY29uc3QgQ0FDSEVfVFRMID0gMTIgKiA2MCAqIDYwICogMTAwMDsgLy8gMTIgaG91cnMgaW4gbWlsbGlzZWNvbmRzXG5jb25zdCBHVEZTX0ZFRURfVVJMID0gXCJodHRwczovL2NhdGFidXMuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy9nb29nbGVfdHJhbnNpdC56aXBcIjtcblxuLyoqXG4gKiBFbnN1cmUgY2FjaGUgZGlyZWN0b3J5IGV4aXN0c1xuICovXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVDYWNoZURpcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy5ta2RpcihDQUNIRV9ESVIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNhY2hlIGRpcmVjdG9yeTpcIiwgZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGNhY2hlZCBkYXRhIGlmIHZhbGlkXG4gKiBAcmV0dXJucyBDYWNoZWQgR1RGUyBkYXRhIG9yIG51bGwgaWYgY2FjaGUgaXMgaW52YWxpZFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRDYWNoZWREYXRhKCk6IFByb21pc2U8U3RhdGljR1RGU0RhdGEgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2FjaGVGaWxlID0gcGF0aC5qb2luKENBQ0hFX0RJUiwgXCJzdGF0aWMtZ3Rmcy5qc29uXCIpO1xuICAgIGNvbnN0IGNhY2hlRXhpc3RzID0gYXdhaXQgZnMuYWNjZXNzKGNhY2hlRmlsZSkudGhlbigoKSA9PiB0cnVlKS5jYXRjaCgoKSA9PiBmYWxzZSk7XG4gICAgXG4gICAgaWYgKCFjYWNoZUV4aXN0cykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNhY2hlQ29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKGNhY2hlRmlsZSwgXCJ1dGYtOFwiKTtcbiAgICBjb25zdCBjYWNoZTogQ2FjaGVFbnRyeTxTdGF0aWNHVEZTRGF0YT4gPSBKU09OLnBhcnNlKGNhY2hlQ29udGVudCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgY2FjaGUgaXMgc3RpbGwgdmFsaWRcbiAgICBpZiAoRGF0ZS5ub3coKSAtIGNhY2hlLnRpbWVzdGFtcCA+IGNhY2hlLnR0bCkge1xuICAgICAgY29uc29sZS5sb2coXCJHVEZTIGNhY2hlIGV4cGlyZWRcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVjb25zdHJ1Y3QgTWFwcyBmcm9tIGNhY2hlZCBkYXRhXG4gICAgY29uc3QgZGF0YSA9IGNhY2hlLmRhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3BzOiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGRhdGEuc3RvcHMgYXMgYW55KSksXG4gICAgICByb3V0ZXM6IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoZGF0YS5yb3V0ZXMgYXMgYW55KSksXG4gICAgICB0cmlwczogbmV3IE1hcChPYmplY3QuZW50cmllcyhkYXRhLnRyaXBzIGFzIGFueSkpLFxuICAgICAgc3RvcFRpbWVzOiBkYXRhLnN0b3BUaW1lcyxcbiAgICAgIGNhbGVuZGFyRGF0ZXM6IGRhdGEuY2FsZW5kYXJEYXRlcyxcbiAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZShkYXRhLmxhc3RVcGRhdGVkKSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcmVhZCBjYWNoZTpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2F2ZSBkYXRhIHRvIGNhY2hlXG4gKiBAcGFyYW0gZGF0YSAtIEdURlMgZGF0YSB0byBjYWNoZVxuICovXG5hc3luYyBmdW5jdGlvbiBzYXZlVG9DYWNoZShkYXRhOiBTdGF0aWNHVEZTRGF0YSk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGF3YWl0IGVuc3VyZUNhY2hlRGlyKCk7XG4gICAgXG4gICAgLy8gQ29udmVydCBNYXBzIHRvIG9iamVjdHMgZm9yIEpTT04gc2VyaWFsaXphdGlvblxuICAgIGNvbnN0IHNlcmlhbGl6YWJsZSA9IHtcbiAgICAgIHN0b3BzOiBPYmplY3QuZnJvbUVudHJpZXMoZGF0YS5zdG9wcyksXG4gICAgICByb3V0ZXM6IE9iamVjdC5mcm9tRW50cmllcyhkYXRhLnJvdXRlcyksXG4gICAgICB0cmlwczogT2JqZWN0LmZyb21FbnRyaWVzKGRhdGEudHJpcHMpLFxuICAgICAgc3RvcFRpbWVzOiBkYXRhLnN0b3BUaW1lcyxcbiAgICAgIGNhbGVuZGFyRGF0ZXM6IGRhdGEuY2FsZW5kYXJEYXRlcyxcbiAgICAgIGxhc3RVcGRhdGVkOiBkYXRhLmxhc3RVcGRhdGVkLFxuICAgIH07XG4gICAgXG4gICAgY29uc3QgY2FjaGU6IENhY2hlRW50cnk8YW55PiA9IHtcbiAgICAgIGRhdGE6IHNlcmlhbGl6YWJsZSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHR0bDogQ0FDSEVfVFRMLFxuICAgIH07XG4gICAgXG4gICAgY29uc3QgY2FjaGVGaWxlID0gcGF0aC5qb2luKENBQ0hFX0RJUiwgXCJzdGF0aWMtZ3Rmcy5qc29uXCIpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShjYWNoZUZpbGUsIEpTT04uc3RyaW5naWZ5KGNhY2hlKSk7XG4gICAgY29uc29sZS5sb2coXCJHVEZTIGRhdGEgY2FjaGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgY2FjaGU6XCIsIGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIERvd25sb2FkIGFuZCBleHRyYWN0IEdURlMgWklQIGZpbGVcbiAqIEByZXR1cm5zIFBhdGggdG8gZXh0cmFjdGVkIGRpcmVjdG9yeVxuICovXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEFuZEV4dHJhY3RHVEZTKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHRlbXBEaXIgPSBwYXRoLmpvaW4ob3MudG1wZGlyKCksIGBndGZzLSR7RGF0ZS5ub3coKX1gKTtcbiAgYXdhaXQgZnMubWtkaXIodGVtcERpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gIFxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKFwiRG93bmxvYWRpbmcgR1RGUyBmZWVkIGZyb206XCIsIEdURlNfRkVFRF9VUkwpO1xuICAgIFxuICAgIC8vIERvd25sb2FkIHRoZSBaSVAgZmlsZVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goR1RGU19GRUVEX1VSTCwge1xuICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDMwMDAwKSwgLy8gMzAgc2Vjb25kIHRpbWVvdXRcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkb3dubG9hZCBHVEZTIGZlZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IHRoZSBaSVAgZGF0YSBhcyBidWZmZXJcbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IHppcEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcik7XG4gICAgXG4gICAgLy8gRXh0cmFjdCB0aGUgWklQIGZpbGUgdXNpbmcgYWRtLXppcFxuICAgIGNvbnN0IHppcCA9IG5ldyBBZG1aaXAoemlwQnVmZmVyKTtcbiAgICB6aXAuZXh0cmFjdEFsbFRvKHRlbXBEaXIsIHRydWUpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiR1RGUyBmZWVkIGV4dHJhY3RlZCB0bzpcIiwgdGVtcERpcik7XG4gICAgcmV0dXJuIHRlbXBEaXI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gQ2xlYW4gdXAgdGVtcCBkaXJlY3Rvcnkgb24gZXJyb3JcbiAgICBhd2FpdCBmcy5ybSh0ZW1wRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSkuY2F0Y2goKCkgPT4ge30pO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSBHVEZTIENTViBmaWxlXG4gKiBAcGFyYW0gZmlsZVBhdGggLSBQYXRoIHRvIHRoZSBDU1YgZmlsZVxuICogQHBhcmFtIHJlcXVpcmVkIC0gV2hldGhlciB0aGUgZmlsZSBpcyByZXF1aXJlZFxuICogQHJldHVybnMgUGFyc2VkIHJlY29yZHMgb3IgZW1wdHkgYXJyYXlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VDU1ZGaWxlPFQ+KGZpbGVQYXRoOiBzdHJpbmcsIHJlcXVpcmVkOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPFRbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZShmaWxlUGF0aCwgXCJ1dGYtOFwiKTtcbiAgICByZXR1cm4gcGFyc2UoY29udGVudCwge1xuICAgICAgY29sdW1uczogdHJ1ZSxcbiAgICAgIHNraXBfZW1wdHlfbGluZXM6IHRydWUsXG4gICAgICB0cmltOiB0cnVlLFxuICAgICAgY2FzdDogKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIC8vIEF1dG8tY2FzdCBudW1iZXJzXG4gICAgICAgIGlmIChjb250ZXh0LmhlYWRlcikgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmICghaXNOYU4obnVtKSAmJiB2YWx1ZS5tYXRjaCgvXi0/XFxkKyhcXC5cXGQrKT8kLykpIHtcbiAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBpZiAocmVxdWlyZWQgfHwgZXJyb3IuY29kZSAhPT0gXCJFTk9FTlRcIikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBhcnNlICR7ZmlsZVBhdGh9OmAsIGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBhbmQgcGFyc2UgR1RGUyBzdGF0aWMgZGF0YVxuICogQHBhcmFtIGZvcmNlUmVmcmVzaCAtIEZvcmNlIHJlZnJlc2ggZXZlbiBpZiBjYWNoZSBpcyB2YWxpZFxuICogQHJldHVybnMgUGFyc2VkIEdURlMgZGF0YVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZFN0YXRpY0dURlMoZm9yY2VSZWZyZXNoOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPFN0YXRpY0dURlNEYXRhPiB7XG4gIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gIGlmICghZm9yY2VSZWZyZXNoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gYXdhaXQgZ2V0Q2FjaGVkRGF0YSgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgY2FjaGVkIEdURlMgZGF0YVwiKTtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICB9XG4gIFxuICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgZnJlc2ggR1RGUyBkYXRhXCIpO1xuICBsZXQgZXh0cmFjdERpcjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIFxuICB0cnkge1xuICAgIC8vIERvd25sb2FkIGFuZCBleHRyYWN0IEdURlMgZmVlZFxuICAgIGV4dHJhY3REaXIgPSBhd2FpdCBkb3dubG9hZEFuZEV4dHJhY3RHVEZTKCk7XG4gICAgXG4gICAgLy8gUGFyc2UgcmVxdWlyZWQgZmlsZXNcbiAgICBjb25zdCBbc3RvcHMsIHJvdXRlcywgdHJpcHMsIHN0b3BUaW1lcywgY2FsZW5kYXJEYXRlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBwYXJzZUNTVkZpbGU8U3RvcD4ocGF0aC5qb2luKGV4dHJhY3REaXIsIFwic3RvcHMudHh0XCIpLCB0cnVlKSxcbiAgICAgIHBhcnNlQ1NWRmlsZTxSb3V0ZT4ocGF0aC5qb2luKGV4dHJhY3REaXIsIFwicm91dGVzLnR4dFwiKSwgdHJ1ZSksXG4gICAgICBwYXJzZUNTVkZpbGU8VHJpcD4ocGF0aC5qb2luKGV4dHJhY3REaXIsIFwidHJpcHMudHh0XCIpLCB0cnVlKSxcbiAgICAgIHBhcnNlQ1NWRmlsZTxTdG9wVGltZT4ocGF0aC5qb2luKGV4dHJhY3REaXIsIFwic3RvcF90aW1lcy50eHRcIiksIHRydWUpLFxuICAgICAgcGFyc2VDU1ZGaWxlPENhbGVuZGFyRGF0ZT4ocGF0aC5qb2luKGV4dHJhY3REaXIsIFwiY2FsZW5kYXJfZGF0ZXMudHh0XCIpLCBmYWxzZSksXG4gICAgXSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYExvYWRlZDogJHtzdG9wcy5sZW5ndGh9IHN0b3BzLCAke3JvdXRlcy5sZW5ndGh9IHJvdXRlcywgJHt0cmlwcy5sZW5ndGh9IHRyaXBzYCk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGxvb2t1cCBtYXBzXG4gICAgY29uc3Qgc3RvcHNNYXAgPSBuZXcgTWFwPHN0cmluZywgU3RvcD4oKTtcbiAgICBzdG9wcy5mb3JFYWNoKChzdG9wKSA9PiB7XG4gICAgICBzdG9wc01hcC5zZXQoc3RvcC5zdG9wX2lkLCBzdG9wKTtcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCByb3V0ZXNNYXAgPSBuZXcgTWFwPHN0cmluZywgUm91dGU+KCk7XG4gICAgcm91dGVzLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgICByb3V0ZXNNYXAuc2V0KHJvdXRlLnJvdXRlX2lkLCByb3V0ZSk7XG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgdHJpcHNNYXAgPSBuZXcgTWFwPHN0cmluZywgVHJpcD4oKTtcbiAgICB0cmlwcy5mb3JFYWNoKCh0cmlwKSA9PiB7XG4gICAgICB0cmlwc01hcC5zZXQodHJpcC50cmlwX2lkLCB0cmlwKTtcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBkYXRhOiBTdGF0aWNHVEZTRGF0YSA9IHtcbiAgICAgIHN0b3BzOiBzdG9wc01hcCxcbiAgICAgIHJvdXRlczogcm91dGVzTWFwLFxuICAgICAgdHJpcHM6IHRyaXBzTWFwLFxuICAgICAgc3RvcFRpbWVzLFxuICAgICAgY2FsZW5kYXJEYXRlcyxcbiAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLFxuICAgIH07XG4gICAgXG4gICAgLy8gU2F2ZSB0byBjYWNoZVxuICAgIGF3YWl0IHNhdmVUb0NhY2hlKGRhdGEpO1xuICAgIFxuICAgIHJldHVybiBkYXRhO1xuICB9IGZpbmFsbHkge1xuICAgIC8vIENsZWFuIHVwIHRlbXAgZGlyZWN0b3J5XG4gICAgaWYgKGV4dHJhY3REaXIpIHtcbiAgICAgIGF3YWl0IGZzLnJtKGV4dHJhY3REaXIsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHN0b3BzIGZvciBhIHNwZWNpZmljIHJvdXRlXG4gKiBAcGFyYW0gcm91dGVJZCAtIFJvdXRlIElEXG4gKiBAcGFyYW0gc3RhdGljRGF0YSAtIFN0YXRpYyBHVEZTIGRhdGFcbiAqIEByZXR1cm5zIEFycmF5IG9mIHN0b3BzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9wc0ZvclJvdXRlKHJvdXRlSWQ6IHN0cmluZywgc3RhdGljRGF0YTogU3RhdGljR1RGU0RhdGEpOiBTdG9wW10ge1xuICBjb25zdCBzdG9wcyA9IG5ldyBTZXQ8U3RvcD4oKTtcbiAgXG4gIC8vIEZpbmQgYWxsIHRyaXBzIGZvciB0aGlzIHJvdXRlXG4gIGNvbnN0IHJvdXRlVHJpcHMgPSBBcnJheS5mcm9tKHN0YXRpY0RhdGEudHJpcHMudmFsdWVzKCkpLmZpbHRlcihcbiAgICAodHJpcCkgPT4gdHJpcC5yb3V0ZV9pZCA9PT0gcm91dGVJZFxuICApO1xuICBcbiAgLy8gRmluZCBhbGwgc3RvcCB0aW1lcyBmb3IgdGhlc2UgdHJpcHNcbiAgY29uc3QgdHJpcElkcyA9IG5ldyBTZXQocm91dGVUcmlwcy5tYXAoKHQpID0+IHQudHJpcF9pZCkpO1xuICBjb25zdCBzdG9wSWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIFxuICBzdGF0aWNEYXRhLnN0b3BUaW1lcy5mb3JFYWNoKChzdCkgPT4ge1xuICAgIGlmICh0cmlwSWRzLmhhcyhzdC50cmlwX2lkKSkge1xuICAgICAgc3RvcElkcy5hZGQoc3Quc3RvcF9pZCk7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIEdldCBzdG9wIGRldGFpbHNcbiAgc3RvcElkcy5mb3JFYWNoKChzdG9wSWQpID0+IHtcbiAgICBjb25zdCBzdG9wID0gc3RhdGljRGF0YS5zdG9wcy5nZXQoc3RvcElkKTtcbiAgICBpZiAoc3RvcCkge1xuICAgICAgc3RvcHMuYWRkKHN0b3ApO1xuICAgIH1cbiAgfSk7XG4gIFxuICByZXR1cm4gQXJyYXkuZnJvbShzdG9wcyk7XG59XG5cbi8qKlxuICogR2V0IHJvdXRlcyBmb3IgYSBzcGVjaWZpYyBzdG9wXG4gKiBAcGFyYW0gc3RvcElkIC0gU3RvcCBJRFxuICogQHBhcmFtIHN0YXRpY0RhdGEgLSBTdGF0aWMgR1RGUyBkYXRhXG4gKiBAcmV0dXJucyBBcnJheSBvZiByb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlc0ZvclN0b3Aoc3RvcElkOiBzdHJpbmcsIHN0YXRpY0RhdGE6IFN0YXRpY0dURlNEYXRhKTogUm91dGVbXSB7XG4gIGNvbnN0IHJvdXRlcyA9IG5ldyBTZXQ8Um91dGU+KCk7XG4gIFxuICAvLyBGaW5kIGFsbCBzdG9wIHRpbWVzIGZvciB0aGlzIHN0b3BcbiAgY29uc3QgdHJpcElkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBzdGF0aWNEYXRhLnN0b3BUaW1lcy5mb3JFYWNoKChzdCkgPT4ge1xuICAgIGlmIChzdC5zdG9wX2lkID09PSBzdG9wSWQpIHtcbiAgICAgIHRyaXBJZHMuYWRkKHN0LnRyaXBfaWQpO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBGaW5kIHJvdXRlcyBmb3IgdGhlc2UgdHJpcHNcbiAgdHJpcElkcy5mb3JFYWNoKCh0cmlwSWQpID0+IHtcbiAgICBjb25zdCB0cmlwID0gc3RhdGljRGF0YS50cmlwcy5nZXQodHJpcElkKTtcbiAgICBpZiAodHJpcCkge1xuICAgICAgY29uc3Qgcm91dGUgPSBzdGF0aWNEYXRhLnJvdXRlcy5nZXQodHJpcC5yb3V0ZV9pZCk7XG4gICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgcm91dGVzLmFkZChyb3V0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiBBcnJheS5mcm9tKHJvdXRlcyk7XG59XG5cbi8qKlxuICogR2V0IHNjaGVkdWxlZCBkZXBhcnR1cmVzIGZvciBhIHN0b3BcbiAqIEBwYXJhbSBzdG9wSWQgLSBTdG9wIElEXG4gKiBAcGFyYW0gc3RhdGljRGF0YSAtIFN0YXRpYyBHVEZTIGRhdGFcbiAqIEBwYXJhbSBsaW1pdCAtIE1heGltdW0gbnVtYmVyIG9mIGRlcGFydHVyZXMgdG8gcmV0dXJuXG4gKiBAcmV0dXJucyBBcnJheSBvZiBzY2hlZHVsZWQgZGVwYXJ0dXJlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZWR1bGVkRGVwYXJ0dXJlcyhcbiAgc3RvcElkOiBzdHJpbmcsXG4gIHN0YXRpY0RhdGE6IFN0YXRpY0dURlNEYXRhLFxuICBsaW1pdDogbnVtYmVyID0gMTBcbik6IEFycmF5PHtcbiAgdHJpcElkOiBzdHJpbmc7XG4gIHJvdXRlSWQ6IHN0cmluZztcbiAgZGVwYXJ0dXJlVGltZTogc3RyaW5nO1xuICBoZWFkc2lnbj86IHN0cmluZztcbn0+IHtcbiAgY29uc3QgZGVwYXJ0dXJlczogQXJyYXk8e1xuICAgIHRyaXBJZDogc3RyaW5nO1xuICAgIHJvdXRlSWQ6IHN0cmluZztcbiAgICBkZXBhcnR1cmVUaW1lOiBzdHJpbmc7XG4gICAgaGVhZHNpZ24/OiBzdHJpbmc7XG4gIH0+ID0gW107XG4gIFxuICAvLyBGaW5kIHN0b3AgdGltZXMgZm9yIHRoaXMgc3RvcFxuICBjb25zdCByZWxldmFudFN0b3BUaW1lcyA9IHN0YXRpY0RhdGEuc3RvcFRpbWVzLmZpbHRlcigoc3QpID0+IHN0LnN0b3BfaWQgPT09IHN0b3BJZCk7XG4gIFxuICAvLyBTb3J0IGJ5IGRlcGFydHVyZSB0aW1lXG4gIHJlbGV2YW50U3RvcFRpbWVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICByZXR1cm4gYS5kZXBhcnR1cmVfdGltZS5sb2NhbGVDb21wYXJlKGIuZGVwYXJ0dXJlX3RpbWUpO1xuICB9KTtcbiAgXG4gIC8vIEdldCB0cmlwIGFuZCByb3V0ZSBpbmZvXG4gIGZvciAoY29uc3Qgc3RvcFRpbWUgb2YgcmVsZXZhbnRTdG9wVGltZXMuc2xpY2UoMCwgbGltaXQpKSB7XG4gICAgY29uc3QgdHJpcCA9IHN0YXRpY0RhdGEudHJpcHMuZ2V0KHN0b3BUaW1lLnRyaXBfaWQpO1xuICAgIGlmICh0cmlwKSB7XG4gICAgICBkZXBhcnR1cmVzLnB1c2goe1xuICAgICAgICB0cmlwSWQ6IHN0b3BUaW1lLnRyaXBfaWQsXG4gICAgICAgIHJvdXRlSWQ6IHRyaXAucm91dGVfaWQsXG4gICAgICAgIGRlcGFydHVyZVRpbWU6IHN0b3BUaW1lLmRlcGFydHVyZV90aW1lLFxuICAgICAgICBoZWFkc2lnbjogdHJpcC50cmlwX2hlYWRzaWduIHx8IHN0b3BUaW1lLnN0b3BfaGVhZHNpZ24sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBkZXBhcnR1cmVzO1xufVxuXG4vKipcbiAqIENsZWFyIHRoZSBHVEZTIGNhY2hlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhckNhY2hlKCk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGF3YWl0IGZzLnJtKENBQ0hFX0RJUiwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pO1xuICAgIGNvbnNvbGUubG9nKFwiR1RGUyBjYWNoZSBjbGVhcmVkXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY2xlYXIgY2FjaGU6XCIsIGVycm9yKTtcbiAgfVxufSIsICIvKipcbiAqIEluZGV4LmpzXG4gKlxuICogYSByZXF1ZXN0IEFQSSBjb21wYXRpYmxlIHdpdGggd2luZG93LmZldGNoXG4gKlxuICogQWxsIHNwZWMgYWxnb3JpdGhtIHN0ZXAgbnVtYmVycyBhcmUgYmFzZWQgb24gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvY29tbWl0LXNuYXBzaG90cy9hZTcxNjgyMmNiM2E2MTg0MzIyNmNkMDkwZWVmYzY1ODk0NDZjMWQyLy5cbiAqL1xuXG5pbXBvcnQgaHR0cCBmcm9tICdub2RlOmh0dHAnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ25vZGU6aHR0cHMnO1xuaW1wb3J0IHpsaWIgZnJvbSAnbm9kZTp6bGliJztcbmltcG9ydCBTdHJlYW0sIHtQYXNzVGhyb3VnaCwgcGlwZWxpbmUgYXMgcHVtcH0gZnJvbSAnbm9kZTpzdHJlYW0nO1xuaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ25vZGU6YnVmZmVyJztcblxuaW1wb3J0IGRhdGFVcmlUb0J1ZmZlciBmcm9tICdkYXRhLXVyaS10by1idWZmZXInO1xuXG5pbXBvcnQge3dyaXRlVG9TdHJlYW0sIGNsb25lfSBmcm9tICcuL2JvZHkuanMnO1xuaW1wb3J0IFJlc3BvbnNlIGZyb20gJy4vcmVzcG9uc2UuanMnO1xuaW1wb3J0IEhlYWRlcnMsIHtmcm9tUmF3SGVhZGVyc30gZnJvbSAnLi9oZWFkZXJzLmpzJztcbmltcG9ydCBSZXF1ZXN0LCB7Z2V0Tm9kZVJlcXVlc3RPcHRpb25zfSBmcm9tICcuL3JlcXVlc3QuanMnO1xuaW1wb3J0IHtGZXRjaEVycm9yfSBmcm9tICcuL2Vycm9ycy9mZXRjaC1lcnJvci5qcyc7XG5pbXBvcnQge0Fib3J0RXJyb3J9IGZyb20gJy4vZXJyb3JzL2Fib3J0LWVycm9yLmpzJztcbmltcG9ydCB7aXNSZWRpcmVjdH0gZnJvbSAnLi91dGlscy9pcy1yZWRpcmVjdC5qcyc7XG5pbXBvcnQge0Zvcm1EYXRhfSBmcm9tICdmb3JtZGF0YS1wb2x5ZmlsbC9lc20ubWluLmpzJztcbmltcG9ydCB7aXNEb21haW5PclN1YmRvbWFpbiwgaXNTYW1lUHJvdG9jb2x9IGZyb20gJy4vdXRpbHMvaXMuanMnO1xuaW1wb3J0IHtwYXJzZVJlZmVycmVyUG9saWN5RnJvbUhlYWRlcn0gZnJvbSAnLi91dGlscy9yZWZlcnJlci5qcyc7XG5pbXBvcnQge1xuXHRCbG9iLFxuXHRGaWxlLFxuXHRmaWxlRnJvbVN5bmMsXG5cdGZpbGVGcm9tLFxuXHRibG9iRnJvbVN5bmMsXG5cdGJsb2JGcm9tXG59IGZyb20gJ2ZldGNoLWJsb2IvZnJvbS5qcyc7XG5cbmV4cG9ydCB7Rm9ybURhdGEsIEhlYWRlcnMsIFJlcXVlc3QsIFJlc3BvbnNlLCBGZXRjaEVycm9yLCBBYm9ydEVycm9yLCBpc1JlZGlyZWN0fTtcbmV4cG9ydCB7QmxvYiwgRmlsZSwgZmlsZUZyb21TeW5jLCBmaWxlRnJvbSwgYmxvYkZyb21TeW5jLCBibG9iRnJvbX07XG5cbmNvbnN0IHN1cHBvcnRlZFNjaGVtYXMgPSBuZXcgU2V0KFsnZGF0YTonLCAnaHR0cDonLCAnaHR0cHM6J10pO1xuXG4vKipcbiAqIEZldGNoIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtICAge3N0cmluZyB8IFVSTCB8IGltcG9ydCgnLi9yZXF1ZXN0JykuZGVmYXVsdH0gdXJsIC0gQWJzb2x1dGUgdXJsIG9yIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIHsqfSBbb3B0aW9uc19dIC0gRmV0Y2ggb3B0aW9uc1xuICogQHJldHVybiAge1Byb21pc2U8aW1wb3J0KCcuL3Jlc3BvbnNlJykuZGVmYXVsdD59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZldGNoKHVybCwgb3B0aW9uc18pIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQvLyBCdWlsZCByZXF1ZXN0IG9iamVjdFxuXHRcdGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIG9wdGlvbnNfKTtcblx0XHRjb25zdCB7cGFyc2VkVVJMLCBvcHRpb25zfSA9IGdldE5vZGVSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0KTtcblx0XHRpZiAoIXN1cHBvcnRlZFNjaGVtYXMuaGFzKHBhcnNlZFVSTC5wcm90b2NvbCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYG5vZGUtZmV0Y2ggY2Fubm90IGxvYWQgJHt1cmx9LiBVUkwgc2NoZW1lIFwiJHtwYXJzZWRVUkwucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJyl9XCIgaXMgbm90IHN1cHBvcnRlZC5gKTtcblx0XHR9XG5cblx0XHRpZiAocGFyc2VkVVJMLnByb3RvY29sID09PSAnZGF0YTonKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gZGF0YVVyaVRvQnVmZmVyKHJlcXVlc3QudXJsKTtcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGRhdGEsIHtoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6IGRhdGEudHlwZUZ1bGx9fSk7XG5cdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXcmFwIGh0dHAucmVxdWVzdCBpbnRvIGZldGNoXG5cdFx0Y29uc3Qgc2VuZCA9IChwYXJzZWRVUkwucHJvdG9jb2wgPT09ICdodHRwczonID8gaHR0cHMgOiBodHRwKS5yZXF1ZXN0O1xuXHRcdGNvbnN0IHtzaWduYWx9ID0gcmVxdWVzdDtcblx0XHRsZXQgcmVzcG9uc2UgPSBudWxsO1xuXG5cdFx0Y29uc3QgYWJvcnQgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBlcnJvciA9IG5ldyBBYm9ydEVycm9yKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicpO1xuXHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdGlmIChyZXF1ZXN0LmJvZHkgJiYgcmVxdWVzdC5ib2R5IGluc3RhbmNlb2YgU3RyZWFtLlJlYWRhYmxlKSB7XG5cdFx0XHRcdHJlcXVlc3QuYm9keS5kZXN0cm95KGVycm9yKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuYm9keSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlLmJvZHkuZW1pdCgnZXJyb3InLCBlcnJvcik7XG5cdFx0fTtcblxuXHRcdGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcblx0XHRcdGFib3J0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgYWJvcnRBbmRGaW5hbGl6ZSA9ICgpID0+IHtcblx0XHRcdGFib3J0KCk7XG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH07XG5cblx0XHQvLyBTZW5kIHJlcXVlc3Rcblx0XHRjb25zdCByZXF1ZXN0XyA9IHNlbmQocGFyc2VkVVJMLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuXG5cdFx0aWYgKHNpZ25hbCkge1xuXHRcdFx0c2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZmluYWxpemUgPSAoKSA9PiB7XG5cdFx0XHRyZXF1ZXN0Xy5hYm9ydCgpO1xuXHRcdFx0aWYgKHNpZ25hbCkge1xuXHRcdFx0XHRzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFuZEZpbmFsaXplKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmVxdWVzdF8ub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuXHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGByZXF1ZXN0IHRvICR7cmVxdWVzdC51cmx9IGZhaWxlZCwgcmVhc29uOiAke2Vycm9yLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycm9yKSk7XG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH0pO1xuXG5cdFx0Zml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxdWVzdF8sIGVycm9yID0+IHtcblx0XHRcdGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5ib2R5KSB7XG5cdFx0XHRcdHJlc3BvbnNlLmJvZHkuZGVzdHJveShlcnJvcik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKiBjOCBpZ25vcmUgbmV4dCAxOCAqL1xuXHRcdGlmIChwcm9jZXNzLnZlcnNpb24gPCAndjE0Jykge1xuXHRcdFx0Ly8gQmVmb3JlIE5vZGUuanMgMTQsIHBpcGVsaW5lKCkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMgYW5kIGRvZXMgbm90IGFsd2F5c1xuXHRcdFx0Ly8gcHJvcGVybHkgaGFuZGxlIHdoZW4gdGhlIHNvY2tldCBjbG9zZS9lbmQgZXZlbnRzIGFyZSBvdXQgb2Ygb3JkZXIuXG5cdFx0XHRyZXF1ZXN0Xy5vbignc29ja2V0JywgcyA9PiB7XG5cdFx0XHRcdGxldCBlbmRlZFdpdGhFdmVudHNDb3VudDtcblx0XHRcdFx0cy5wcmVwZW5kTGlzdGVuZXIoJ2VuZCcsICgpID0+IHtcblx0XHRcdFx0XHRlbmRlZFdpdGhFdmVudHNDb3VudCA9IHMuX2V2ZW50c0NvdW50O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cy5wcmVwZW5kTGlzdGVuZXIoJ2Nsb3NlJywgaGFkRXJyb3IgPT4ge1xuXHRcdFx0XHRcdC8vIGlmIGVuZCBoYXBwZW5lZCBiZWZvcmUgY2xvc2UgYnV0IHRoZSBzb2NrZXQgZGlkbid0IGVtaXQgYW4gZXJyb3IsIGRvIGl0IG5vd1xuXHRcdFx0XHRcdGlmIChyZXNwb25zZSAmJiBlbmRlZFdpdGhFdmVudHNDb3VudCA8IHMuX2V2ZW50c0NvdW50ICYmICFoYWRFcnJvcikge1xuXHRcdFx0XHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1ByZW1hdHVyZSBjbG9zZScpO1xuXHRcdFx0XHRcdFx0ZXJyb3IuY29kZSA9ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSc7XG5cdFx0XHRcdFx0XHRyZXNwb25zZS5ib2R5LmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXF1ZXN0Xy5vbigncmVzcG9uc2UnLCByZXNwb25zZV8gPT4ge1xuXHRcdFx0cmVxdWVzdF8uc2V0VGltZW91dCgwKTtcblx0XHRcdGNvbnN0IGhlYWRlcnMgPSBmcm9tUmF3SGVhZGVycyhyZXNwb25zZV8ucmF3SGVhZGVycyk7XG5cblx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1XG5cdFx0XHRpZiAoaXNSZWRpcmVjdChyZXNwb25zZV8uc3RhdHVzQ29kZSkpIHtcblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuMlxuXHRcdFx0XHRjb25zdCBsb2NhdGlvbiA9IGhlYWRlcnMuZ2V0KCdMb2NhdGlvbicpO1xuXG5cdFx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1LjNcblx0XHRcdFx0bGV0IGxvY2F0aW9uVVJMID0gbnVsbDtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRsb2NhdGlvblVSTCA9IGxvY2F0aW9uID09PSBudWxsID8gbnVsbCA6IG5ldyBVUkwobG9jYXRpb24sIHJlcXVlc3QudXJsKTtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0Ly8gZXJyb3IgaGVyZSBjYW4gb25seSBiZSBpbnZhbGlkIFVSTCBpbiBMb2NhdGlvbjogaGVhZGVyXG5cdFx0XHRcdFx0Ly8gZG8gbm90IHRocm93IHdoZW4gb3B0aW9ucy5yZWRpcmVjdCA9PSBtYW51YWxcblx0XHRcdFx0XHQvLyBsZXQgdGhlIHVzZXIgZXh0cmFjdCB0aGUgZXJyb3JuZW91cyByZWRpcmVjdCBVUkxcblx0XHRcdFx0XHRpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ21hbnVhbCcpIHtcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGFuIGludmFsaWQgcmVkaXJlY3QgVVJMOiAke2xvY2F0aW9ufWAsICdpbnZhbGlkLXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS41XG5cdFx0XHRcdHN3aXRjaCAocmVxdWVzdC5yZWRpcmVjdCkge1xuXHRcdFx0XHRcdGNhc2UgJ2Vycm9yJzpcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGEgcmVkaXJlY3QsIHJlZGlyZWN0IG1vZGUgaXMgc2V0IHRvIGVycm9yOiAke3JlcXVlc3QudXJsfWAsICduby1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Y2FzZSAnbWFudWFsJzpcblx0XHRcdFx0XHRcdC8vIE5vdGhpbmcgdG8gZG9cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2ZvbGxvdyc6IHtcblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAyXG5cdFx0XHRcdFx0XHRpZiAobG9jYXRpb25VUkwgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA1XG5cdFx0XHRcdFx0XHRpZiAocmVxdWVzdC5jb3VudGVyID49IHJlcXVlc3QuZm9sbG93KSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgbWF4aW11bSByZWRpcmVjdCByZWFjaGVkIGF0OiAke3JlcXVlc3QudXJsfWAsICdtYXgtcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDYgKGNvdW50ZXIgaW5jcmVtZW50KVxuXHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgbmV3IFJlcXVlc3Qgb2JqZWN0LlxuXHRcdFx0XHRcdFx0Y29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0XHRcdGhlYWRlcnM6IG5ldyBIZWFkZXJzKHJlcXVlc3QuaGVhZGVycyksXG5cdFx0XHRcdFx0XHRcdGZvbGxvdzogcmVxdWVzdC5mb2xsb3csXG5cdFx0XHRcdFx0XHRcdGNvdW50ZXI6IHJlcXVlc3QuY291bnRlciArIDEsXG5cdFx0XHRcdFx0XHRcdGFnZW50OiByZXF1ZXN0LmFnZW50LFxuXHRcdFx0XHRcdFx0XHRjb21wcmVzczogcmVxdWVzdC5jb21wcmVzcyxcblx0XHRcdFx0XHRcdFx0bWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcblx0XHRcdFx0XHRcdFx0Ym9keTogY2xvbmUocmVxdWVzdCksXG5cdFx0XHRcdFx0XHRcdHNpZ25hbDogcmVxdWVzdC5zaWduYWwsXG5cdFx0XHRcdFx0XHRcdHNpemU6IHJlcXVlc3Quc2l6ZSxcblx0XHRcdFx0XHRcdFx0cmVmZXJyZXI6IHJlcXVlc3QucmVmZXJyZXIsXG5cdFx0XHRcdFx0XHRcdHJlZmVycmVyUG9saWN5OiByZXF1ZXN0LnJlZmVycmVyUG9saWN5XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHQvLyB3aGVuIGZvcndhcmRpbmcgc2Vuc2l0aXZlIGhlYWRlcnMgbGlrZSBcIkF1dGhvcml6YXRpb25cIixcblx0XHRcdFx0XHRcdC8vIFwiV1dXLUF1dGhlbnRpY2F0ZVwiLCBhbmQgXCJDb29raWVcIiB0byB1bnRydXN0ZWQgdGFyZ2V0cyxcblx0XHRcdFx0XHRcdC8vIGhlYWRlcnMgd2lsbCBiZSBpZ25vcmVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBkb21haW5cblx0XHRcdFx0XHRcdC8vIHRoYXQgaXMgbm90IGEgc3ViZG9tYWluIG1hdGNoIG9yIGV4YWN0IG1hdGNoIG9mIHRoZSBpbml0aWFsIGRvbWFpbi5cblx0XHRcdFx0XHRcdC8vIEZvciBleGFtcGxlLCBhIHJlZGlyZWN0IGZyb20gXCJmb28uY29tXCIgdG8gZWl0aGVyIFwiZm9vLmNvbVwiIG9yIFwic3ViLmZvby5jb21cIlxuXHRcdFx0XHRcdFx0Ly8gd2lsbCBmb3J3YXJkIHRoZSBzZW5zaXRpdmUgaGVhZGVycywgYnV0IGEgcmVkaXJlY3QgdG8gXCJiYXIuY29tXCIgd2lsbCBub3QuXG5cdFx0XHRcdFx0XHQvLyBoZWFkZXJzIHdpbGwgYWxzbyBiZSBpZ25vcmVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBkb21haW4gdXNpbmdcblx0XHRcdFx0XHRcdC8vIGEgZGlmZmVyZW50IHByb3RvY29sLiBGb3IgZXhhbXBsZSwgYSByZWRpcmVjdCBmcm9tIFwiaHR0cHM6Ly9mb28uY29tXCIgdG8gXCJodHRwOi8vZm9vLmNvbVwiXG5cdFx0XHRcdFx0XHQvLyB3aWxsIG5vdCBmb3J3YXJkIHRoZSBzZW5zaXRpdmUgaGVhZGVyc1xuXHRcdFx0XHRcdFx0aWYgKCFpc0RvbWFpbk9yU3ViZG9tYWluKHJlcXVlc3QudXJsLCBsb2NhdGlvblVSTCkgfHwgIWlzU2FtZVByb3RvY29sKHJlcXVlc3QudXJsLCBsb2NhdGlvblVSTCkpIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCBuYW1lIG9mIFsnYXV0aG9yaXphdGlvbicsICd3d3ctYXV0aGVudGljYXRlJywgJ2Nvb2tpZScsICdjb29raWUyJ10pIHtcblx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLmRlbGV0ZShuYW1lKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgOVxuXHRcdFx0XHRcdFx0aWYgKHJlc3BvbnNlXy5zdGF0dXNDb2RlICE9PSAzMDMgJiYgcmVxdWVzdC5ib2R5ICYmIG9wdGlvbnNfLmJvZHkgaW5zdGFuY2VvZiBTdHJlYW0uUmVhZGFibGUpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKCdDYW5ub3QgZm9sbG93IHJlZGlyZWN0IHdpdGggYm9keSBiZWluZyBhIHJlYWRhYmxlIHN0cmVhbScsICd1bnN1cHBvcnRlZC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMTFcblx0XHRcdFx0XHRcdGlmIChyZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAzIHx8ICgocmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAyKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSkge1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0aW9ucy5tZXRob2QgPSAnR0VUJztcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuYm9keSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxNFxuXHRcdFx0XHRcdFx0Y29uc3QgcmVzcG9uc2VSZWZlcnJlclBvbGljeSA9IHBhcnNlUmVmZXJyZXJQb2xpY3lGcm9tSGVhZGVyKGhlYWRlcnMpO1xuXHRcdFx0XHRcdFx0aWYgKHJlc3BvbnNlUmVmZXJyZXJQb2xpY3kpIHtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMucmVmZXJyZXJQb2xpY3kgPSByZXNwb25zZVJlZmVycmVyUG9saWN5O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMTVcblx0XHRcdFx0XHRcdHJlc29sdmUoZmV0Y2gobmV3IFJlcXVlc3QobG9jYXRpb25VUkwsIHJlcXVlc3RPcHRpb25zKSkpO1xuXHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKGBSZWRpcmVjdCBvcHRpb24gJyR7cmVxdWVzdC5yZWRpcmVjdH0nIGlzIG5vdCBhIHZhbGlkIHZhbHVlIG9mIFJlcXVlc3RSZWRpcmVjdGApKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBQcmVwYXJlIHJlc3BvbnNlXG5cdFx0XHRpZiAoc2lnbmFsKSB7XG5cdFx0XHRcdHJlc3BvbnNlXy5vbmNlKCdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0c2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgYm9keSA9IHB1bXAocmVzcG9uc2VfLCBuZXcgUGFzc1Rocm91Z2goKSwgZXJyb3IgPT4ge1xuXHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8yOTM3NlxuXHRcdFx0LyogYzggaWdub3JlIG5leHQgMyAqL1xuXHRcdFx0aWYgKHByb2Nlc3MudmVyc2lvbiA8ICd2MTIuMTAnKSB7XG5cdFx0XHRcdHJlc3BvbnNlXy5vbignYWJvcnRlZCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByZXNwb25zZU9wdGlvbnMgPSB7XG5cdFx0XHRcdHVybDogcmVxdWVzdC51cmwsXG5cdFx0XHRcdHN0YXR1czogcmVzcG9uc2VfLnN0YXR1c0NvZGUsXG5cdFx0XHRcdHN0YXR1c1RleHQ6IHJlc3BvbnNlXy5zdGF0dXNNZXNzYWdlLFxuXHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRzaXplOiByZXF1ZXN0LnNpemUsXG5cdFx0XHRcdGNvdW50ZXI6IHJlcXVlc3QuY291bnRlcixcblx0XHRcdFx0aGlnaFdhdGVyTWFyazogcmVxdWVzdC5oaWdoV2F0ZXJNYXJrXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCAxMi4xLjEuM1xuXHRcdFx0Y29uc3QgY29kaW5ncyA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LUVuY29kaW5nJyk7XG5cblx0XHRcdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDEyLjEuMS40OiBoYW5kbGUgY29udGVudCBjb2RpbmdzXG5cblx0XHRcdC8vIGluIGZvbGxvd2luZyBzY2VuYXJpb3Mgd2UgaWdub3JlIGNvbXByZXNzaW9uIHN1cHBvcnRcblx0XHRcdC8vIDEuIGNvbXByZXNzaW9uIHN1cHBvcnQgaXMgZGlzYWJsZWRcblx0XHRcdC8vIDIuIEhFQUQgcmVxdWVzdFxuXHRcdFx0Ly8gMy4gbm8gQ29udGVudC1FbmNvZGluZyBoZWFkZXJcblx0XHRcdC8vIDQuIG5vIGNvbnRlbnQgcmVzcG9uc2UgKDIwNClcblx0XHRcdC8vIDUuIGNvbnRlbnQgbm90IG1vZGlmaWVkIHJlc3BvbnNlICgzMDQpXG5cdFx0XHRpZiAoIXJlcXVlc3QuY29tcHJlc3MgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJyB8fCBjb2RpbmdzID09PSBudWxsIHx8IHJlc3BvbnNlXy5zdGF0dXNDb2RlID09PSAyMDQgfHwgcmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwNCkge1xuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZU9wdGlvbnMpO1xuXHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgTm9kZSB2Nitcblx0XHRcdC8vIEJlIGxlc3Mgc3RyaWN0IHdoZW4gZGVjb2RpbmcgY29tcHJlc3NlZCByZXNwb25zZXMsIHNpbmNlIHNvbWV0aW1lc1xuXHRcdFx0Ly8gc2VydmVycyBzZW5kIHNsaWdodGx5IGludmFsaWQgcmVzcG9uc2VzIHRoYXQgYXJlIHN0aWxsIGFjY2VwdGVkXG5cdFx0XHQvLyBieSBjb21tb24gYnJvd3NlcnMuXG5cdFx0XHQvLyBBbHdheXMgdXNpbmcgWl9TWU5DX0ZMVVNIIGlzIHdoYXQgY1VSTCBkb2VzLlxuXHRcdFx0Y29uc3QgemxpYk9wdGlvbnMgPSB7XG5cdFx0XHRcdGZsdXNoOiB6bGliLlpfU1lOQ19GTFVTSCxcblx0XHRcdFx0ZmluaXNoRmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNIXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBGb3IgZ3ppcFxuXHRcdFx0aWYgKGNvZGluZ3MgPT09ICdnemlwJyB8fCBjb2RpbmdzID09PSAneC1nemlwJykge1xuXHRcdFx0XHRib2R5ID0gcHVtcChib2R5LCB6bGliLmNyZWF0ZUd1bnppcCh6bGliT3B0aW9ucyksIGVycm9yID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIGRlZmxhdGVcblx0XHRcdGlmIChjb2RpbmdzID09PSAnZGVmbGF0ZScgfHwgY29kaW5ncyA9PT0gJ3gtZGVmbGF0ZScpIHtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBpbmZhbW91cyByYXcgZGVmbGF0ZSByZXNwb25zZSBmcm9tIG9sZCBzZXJ2ZXJzXG5cdFx0XHRcdC8vIGEgaGFjayBmb3Igb2xkIElJUyBhbmQgQXBhY2hlIHNlcnZlcnNcblx0XHRcdFx0Y29uc3QgcmF3ID0gcHVtcChyZXNwb25zZV8sIG5ldyBQYXNzVGhyb3VnaCgpLCBlcnJvciA9PiB7XG5cdFx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJhdy5vbmNlKCdkYXRhJywgY2h1bmsgPT4ge1xuXHRcdFx0XHRcdC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM3NTE5ODI4XG5cdFx0XHRcdFx0aWYgKChjaHVua1swXSAmIDB4MEYpID09PSAweDA4KSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gcHVtcChib2R5LCB6bGliLmNyZWF0ZUluZmxhdGUoKSwgZXJyb3IgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ym9keSA9IHB1bXAoYm9keSwgemxpYi5jcmVhdGVJbmZsYXRlUmF3KCksIGVycm9yID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJhdy5vbmNlKCdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0Ly8gU29tZSBvbGQgSUlTIHNlcnZlcnMgcmV0dXJuIHplcm8tbGVuZ3RoIE9LIGRlZmxhdGUgcmVzcG9uc2VzLCBzb1xuXHRcdFx0XHRcdC8vICdkYXRhJyBpcyBuZXZlciBlbWl0dGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9wdWxsLzkwM1xuXHRcdFx0XHRcdGlmICghcmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBiclxuXHRcdFx0aWYgKGNvZGluZ3MgPT09ICdicicpIHtcblx0XHRcdFx0Ym9keSA9IHB1bXAoYm9keSwgemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKCksIGVycm9yID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCB1c2UgcmVzcG9uc2UgYXMtaXNcblx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHR9KTtcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG5cdFx0d3JpdGVUb1N0cmVhbShyZXF1ZXN0XywgcmVxdWVzdCkuY2F0Y2gocmVqZWN0KTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKHJlcXVlc3QsIGVycm9yQ2FsbGJhY2spIHtcblx0Y29uc3QgTEFTVF9DSFVOSyA9IEJ1ZmZlci5mcm9tKCcwXFxyXFxuXFxyXFxuJyk7XG5cblx0bGV0IGlzQ2h1bmtlZFRyYW5zZmVyID0gZmFsc2U7XG5cdGxldCBwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCA9IGZhbHNlO1xuXHRsZXQgcHJldmlvdXNDaHVuaztcblxuXHRyZXF1ZXN0Lm9uKCdyZXNwb25zZScsIHJlc3BvbnNlID0+IHtcblx0XHRjb25zdCB7aGVhZGVyc30gPSByZXNwb25zZTtcblx0XHRpc0NodW5rZWRUcmFuc2ZlciA9IGhlYWRlcnNbJ3RyYW5zZmVyLWVuY29kaW5nJ10gPT09ICdjaHVua2VkJyAmJiAhaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcblx0fSk7XG5cblx0cmVxdWVzdC5vbignc29ja2V0Jywgc29ja2V0ID0+IHtcblx0XHRjb25zdCBvblNvY2tldENsb3NlID0gKCkgPT4ge1xuXHRcdFx0aWYgKGlzQ2h1bmtlZFRyYW5zZmVyICYmICFwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCkge1xuXHRcdFx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJyk7XG5cdFx0XHRcdGVycm9yLmNvZGUgPSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrKGVycm9yKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25EYXRhID0gYnVmID0+IHtcblx0XHRcdHByb3Blckxhc3RDaHVua1JlY2VpdmVkID0gQnVmZmVyLmNvbXBhcmUoYnVmLnNsaWNlKC01KSwgTEFTVF9DSFVOSykgPT09IDA7XG5cblx0XHRcdC8vIFNvbWV0aW1lcyBmaW5hbCAwLWxlbmd0aCBjaHVuayBhbmQgZW5kIG9mIG1lc3NhZ2UgY29kZSBhcmUgaW4gc2VwYXJhdGUgcGFja2V0c1xuXHRcdFx0aWYgKCFwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCAmJiBwcmV2aW91c0NodW5rKSB7XG5cdFx0XHRcdHByb3Blckxhc3RDaHVua1JlY2VpdmVkID0gKFxuXHRcdFx0XHRcdEJ1ZmZlci5jb21wYXJlKHByZXZpb3VzQ2h1bmsuc2xpY2UoLTMpLCBMQVNUX0NIVU5LLnNsaWNlKDAsIDMpKSA9PT0gMCAmJlxuXHRcdFx0XHRcdEJ1ZmZlci5jb21wYXJlKGJ1Zi5zbGljZSgtMiksIExBU1RfQ0hVTksuc2xpY2UoMykpID09PSAwXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHByZXZpb3VzQ2h1bmsgPSBidWY7XG5cdFx0fTtcblxuXHRcdHNvY2tldC5wcmVwZW5kTGlzdGVuZXIoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSk7XG5cdFx0c29ja2V0Lm9uKCdkYXRhJywgb25EYXRhKTtcblxuXHRcdHJlcXVlc3Qub24oJ2Nsb3NlJywgKCkgPT4ge1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpO1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcblx0XHR9KTtcblx0fSk7XG59XG4iLCAiZXhwb3J0IGludGVyZmFjZSBNaW1lQnVmZmVyIGV4dGVuZHMgQnVmZmVyIHtcblx0dHlwZTogc3RyaW5nO1xuXHR0eXBlRnVsbDogc3RyaW5nO1xuXHRjaGFyc2V0OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGBCdWZmZXJgIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGRhdGEgVVJJIGB1cmlgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgRGF0YSBVUkkgdG8gdHVybiBpbnRvIGEgQnVmZmVyIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXIgaW5zdGFuY2UgZnJvbSBEYXRhIFVSSVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFVcmlUb0J1ZmZlcih1cmk6IHN0cmluZyk6IE1pbWVCdWZmZXIge1xuXHRpZiAoIS9eZGF0YTovaS50ZXN0KHVyaSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHRcdFx0J2B1cmlgIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIERhdGEgVVJJIChtdXN0IGJlZ2luIHdpdGggXCJkYXRhOlwiKSdcblx0XHQpO1xuXHR9XG5cblx0Ly8gc3RyaXAgbmV3bGluZXNcblx0dXJpID0gdXJpLnJlcGxhY2UoL1xccj9cXG4vZywgJycpO1xuXG5cdC8vIHNwbGl0IHRoZSBVUkkgdXAgaW50byB0aGUgXCJtZXRhZGF0YVwiIGFuZCB0aGUgXCJkYXRhXCIgcG9ydGlvbnNcblx0Y29uc3QgZmlyc3RDb21tYSA9IHVyaS5pbmRleE9mKCcsJyk7XG5cdGlmIChmaXJzdENvbW1hID09PSAtMSB8fCBmaXJzdENvbW1hIDw9IDQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdtYWxmb3JtZWQgZGF0YTogVVJJJyk7XG5cdH1cblxuXHQvLyByZW1vdmUgdGhlIFwiZGF0YTpcIiBzY2hlbWUgYW5kIHBhcnNlIHRoZSBtZXRhZGF0YVxuXHRjb25zdCBtZXRhID0gdXJpLnN1YnN0cmluZyg1LCBmaXJzdENvbW1hKS5zcGxpdCgnOycpO1xuXG5cdGxldCBjaGFyc2V0ID0gJyc7XG5cdGxldCBiYXNlNjQgPSBmYWxzZTtcblx0Y29uc3QgdHlwZSA9IG1ldGFbMF0gfHwgJ3RleHQvcGxhaW4nO1xuXHRsZXQgdHlwZUZ1bGwgPSB0eXBlO1xuXHRmb3IgKGxldCBpID0gMTsgaSA8IG1ldGEubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAobWV0YVtpXSA9PT0gJ2Jhc2U2NCcpIHtcblx0XHRcdGJhc2U2NCA9IHRydWU7XG5cdFx0fSBlbHNlIGlmKG1ldGFbaV0pIHtcblx0XHRcdHR5cGVGdWxsICs9IGA7JHsgIG1ldGFbaV19YDtcblx0XHRcdGlmIChtZXRhW2ldLmluZGV4T2YoJ2NoYXJzZXQ9JykgPT09IDApIHtcblx0XHRcdFx0Y2hhcnNldCA9IG1ldGFbaV0uc3Vic3RyaW5nKDgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyBkZWZhdWx0cyB0byBVUy1BU0NJSSBvbmx5IGlmIHR5cGUgaXMgbm90IHByb3ZpZGVkXG5cdGlmICghbWV0YVswXSAmJiAhY2hhcnNldC5sZW5ndGgpIHtcblx0XHR0eXBlRnVsbCArPSAnO2NoYXJzZXQ9VVMtQVNDSUknO1xuXHRcdGNoYXJzZXQgPSAnVVMtQVNDSUknO1xuXHR9XG5cblx0Ly8gZ2V0IHRoZSBlbmNvZGVkIGRhdGEgcG9ydGlvbiBhbmQgZGVjb2RlIFVSSS1lbmNvZGVkIGNoYXJzXG5cdGNvbnN0IGVuY29kaW5nID0gYmFzZTY0ID8gJ2Jhc2U2NCcgOiAnYXNjaWknO1xuXHRjb25zdCBkYXRhID0gdW5lc2NhcGUodXJpLnN1YnN0cmluZyhmaXJzdENvbW1hICsgMSkpO1xuXHRjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZykgYXMgTWltZUJ1ZmZlcjtcblxuXHQvLyBzZXQgYC50eXBlYCBhbmQgYC50eXBlRnVsbGAgcHJvcGVydGllcyB0byBNSU1FIHR5cGVcblx0YnVmZmVyLnR5cGUgPSB0eXBlO1xuXHRidWZmZXIudHlwZUZ1bGwgPSB0eXBlRnVsbDtcblxuXHQvLyBzZXQgdGhlIGAuY2hhcnNldGAgcHJvcGVydHlcblx0YnVmZmVyLmNoYXJzZXQgPSBjaGFyc2V0O1xuXG5cdHJldHVybiBidWZmZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRhdGFVcmlUb0J1ZmZlcjtcbiIsICJcbi8qKlxuICogQm9keS5qc1xuICpcbiAqIEJvZHkgaW50ZXJmYWNlIHByb3ZpZGVzIGNvbW1vbiBtZXRob2RzIGZvciBSZXF1ZXN0IGFuZCBSZXNwb25zZVxuICovXG5cbmltcG9ydCBTdHJlYW0sIHtQYXNzVGhyb3VnaH0gZnJvbSAnbm9kZTpzdHJlYW0nO1xuaW1wb3J0IHt0eXBlcywgZGVwcmVjYXRlLCBwcm9taXNpZnl9IGZyb20gJ25vZGU6dXRpbCc7XG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnbm9kZTpidWZmZXInO1xuXG5pbXBvcnQgQmxvYiBmcm9tICdmZXRjaC1ibG9iJztcbmltcG9ydCB7Rm9ybURhdGEsIGZvcm1EYXRhVG9CbG9ifSBmcm9tICdmb3JtZGF0YS1wb2x5ZmlsbC9lc20ubWluLmpzJztcblxuaW1wb3J0IHtGZXRjaEVycm9yfSBmcm9tICcuL2Vycm9ycy9mZXRjaC1lcnJvci5qcyc7XG5pbXBvcnQge0ZldGNoQmFzZUVycm9yfSBmcm9tICcuL2Vycm9ycy9iYXNlLmpzJztcbmltcG9ydCB7aXNCbG9iLCBpc1VSTFNlYXJjaFBhcmFtZXRlcnN9IGZyb20gJy4vdXRpbHMvaXMuanMnO1xuXG5jb25zdCBwaXBlbGluZSA9IHByb21pc2lmeShTdHJlYW0ucGlwZWxpbmUpO1xuY29uc3QgSU5URVJOQUxTID0gU3ltYm9sKCdCb2R5IGludGVybmFscycpO1xuXG4vKipcbiAqIEJvZHkgbWl4aW5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5XG4gKlxuICogQHBhcmFtICAgU3RyZWFtICBib2R5ICBSZWFkYWJsZSBzdHJlYW1cbiAqIEBwYXJhbSAgIE9iamVjdCAgb3B0cyAgUmVzcG9uc2Ugb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb2R5IHtcblx0Y29uc3RydWN0b3IoYm9keSwge1xuXHRcdHNpemUgPSAwXG5cdH0gPSB7fSkge1xuXHRcdGxldCBib3VuZGFyeSA9IG51bGw7XG5cblx0XHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gQm9keSBpcyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdFx0Ym9keSA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChpc1VSTFNlYXJjaFBhcmFtZXRlcnMoYm9keSkpIHtcblx0XHRcdC8vIEJvZHkgaXMgYSBVUkxTZWFyY2hQYXJhbXNcblx0XHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5LnRvU3RyaW5nKCkpO1xuXHRcdH0gZWxzZSBpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0XHQvLyBCb2R5IGlzIGJsb2Jcblx0XHR9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBCdWZmZXJcblx0XHR9IGVsc2UgaWYgKHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoYm9keSkpIHtcblx0XHRcdC8vIEJvZHkgaXMgQXJyYXlCdWZmZXJcblx0XHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5KTtcblx0XHR9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBBcnJheUJ1ZmZlclZpZXdcblx0XHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5LmJ1ZmZlciwgYm9keS5ieXRlT2Zmc2V0LCBib2R5LmJ5dGVMZW5ndGgpO1xuXHRcdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuXHRcdFx0Ly8gQm9keSBpcyBzdHJlYW1cblx0XHR9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0Ly8gQm9keSBpcyBGb3JtRGF0YVxuXHRcdFx0Ym9keSA9IGZvcm1EYXRhVG9CbG9iKGJvZHkpO1xuXHRcdFx0Ym91bmRhcnkgPSBib2R5LnR5cGUuc3BsaXQoJz0nKVsxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gTm9uZSBvZiB0aGUgYWJvdmVcblx0XHRcdC8vIGNvZXJjZSB0byBzdHJpbmcgdGhlbiBidWZmZXJcblx0XHRcdGJvZHkgPSBCdWZmZXIuZnJvbShTdHJpbmcoYm9keSkpO1xuXHRcdH1cblxuXHRcdGxldCBzdHJlYW0gPSBib2R5O1xuXG5cdFx0aWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuXHRcdFx0c3RyZWFtID0gU3RyZWFtLlJlYWRhYmxlLmZyb20oYm9keSk7XG5cdFx0fSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRcdHN0cmVhbSA9IFN0cmVhbS5SZWFkYWJsZS5mcm9tKGJvZHkuc3RyZWFtKCkpO1xuXHRcdH1cblxuXHRcdHRoaXNbSU5URVJOQUxTXSA9IHtcblx0XHRcdGJvZHksXG5cdFx0XHRzdHJlYW0sXG5cdFx0XHRib3VuZGFyeSxcblx0XHRcdGRpc3R1cmJlZDogZmFsc2UsXG5cdFx0XHRlcnJvcjogbnVsbFxuXHRcdH07XG5cdFx0dGhpcy5zaXplID0gc2l6ZTtcblxuXHRcdGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG5cdFx0XHRib2R5Lm9uKCdlcnJvcicsIGVycm9yXyA9PiB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gZXJyb3JfIGluc3RhbmNlb2YgRmV0Y2hCYXNlRXJyb3IgP1xuXHRcdFx0XHRcdGVycm9yXyA6XG5cdFx0XHRcdFx0bmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHt0aGlzLnVybH06ICR7ZXJyb3JfLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycm9yXyk7XG5cdFx0XHRcdHRoaXNbSU5URVJOQUxTXS5lcnJvciA9IGVycm9yO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IGJvZHkoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5zdHJlYW07XG5cdH1cblxuXHRnZXQgYm9keVVzZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5kaXN0dXJiZWQ7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIEFycmF5QnVmZmVyXG5cdCAqXG5cdCAqIEByZXR1cm4gIFByb21pc2Vcblx0ICovXG5cdGFzeW5jIGFycmF5QnVmZmVyKCkge1xuXHRcdGNvbnN0IHtidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGh9ID0gYXdhaXQgY29uc3VtZUJvZHkodGhpcyk7XG5cdFx0cmV0dXJuIGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG5cdH1cblxuXHRhc3luYyBmb3JtRGF0YSgpIHtcblx0XHRjb25zdCBjdCA9IHRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuXG5cdFx0aWYgKGN0LnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpKSB7XG5cdFx0XHRjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcdFx0Y29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoYXdhaXQgdGhpcy50ZXh0KCkpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgcGFyYW1ldGVycykge1xuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm9ybURhdGE7XG5cdFx0fVxuXG5cdFx0Y29uc3Qge3RvRm9ybURhdGF9ID0gYXdhaXQgaW1wb3J0KCcuL3V0aWxzL211bHRpcGFydC1wYXJzZXIuanMnKTtcblx0XHRyZXR1cm4gdG9Gb3JtRGF0YSh0aGlzLmJvZHksIGN0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gcmF3IHJlc3BvbnNlIGFzIEJsb2Jcblx0ICpcblx0ICogQHJldHVybiBQcm9taXNlXG5cdCAqL1xuXHRhc3luYyBibG9iKCkge1xuXHRcdGNvbnN0IGN0ID0gKHRoaXMuaGVhZGVycyAmJiB0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkgfHwgKHRoaXNbSU5URVJOQUxTXS5ib2R5ICYmIHRoaXNbSU5URVJOQUxTXS5ib2R5LnR5cGUpIHx8ICcnO1xuXHRcdGNvbnN0IGJ1ZiA9IGF3YWl0IHRoaXMuYXJyYXlCdWZmZXIoKTtcblxuXHRcdHJldHVybiBuZXcgQmxvYihbYnVmXSwge1xuXHRcdFx0dHlwZTogY3Rcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgcmVzcG9uc2UgYXMganNvblxuXHQgKlxuXHQgKiBAcmV0dXJuICBQcm9taXNlXG5cdCAqL1xuXHRhc3luYyBqc29uKCkge1xuXHRcdGNvbnN0IHRleHQgPSBhd2FpdCB0aGlzLnRleHQoKTtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgcmVzcG9uc2UgYXMgdGV4dFxuXHQgKlxuXHQgKiBAcmV0dXJuICBQcm9taXNlXG5cdCAqL1xuXHRhc3luYyB0ZXh0KCkge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNvbnN1bWVCb2R5KHRoaXMpO1xuXHRcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZmVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgcmVzcG9uc2UgYXMgYnVmZmVyIChub24tc3BlYyBhcGkpXG5cdCAqXG5cdCAqIEByZXR1cm4gIFByb21pc2Vcblx0ICovXG5cdGJ1ZmZlcigpIHtcblx0XHRyZXR1cm4gY29uc3VtZUJvZHkodGhpcyk7XG5cdH1cbn1cblxuQm9keS5wcm90b3R5cGUuYnVmZmVyID0gZGVwcmVjYXRlKEJvZHkucHJvdG90eXBlLmJ1ZmZlciwgJ1BsZWFzZSB1c2UgXFwncmVzcG9uc2UuYXJyYXlCdWZmZXIoKVxcJyBpbnN0ZWFkIG9mIFxcJ3Jlc3BvbnNlLmJ1ZmZlcigpXFwnJywgJ25vZGUtZmV0Y2gjYnVmZmVyJyk7XG5cbi8vIEluIGJyb3dzZXJzLCBhbGwgcHJvcGVydGllcyBhcmUgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJvZHkucHJvdG90eXBlLCB7XG5cdGJvZHk6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0Ym9keVVzZWQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0YXJyYXlCdWZmZXI6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0YmxvYjoge2VudW1lcmFibGU6IHRydWV9LFxuXHRqc29uOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHRleHQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0ZGF0YToge2dldDogZGVwcmVjYXRlKCgpID0+IHt9LFxuXHRcdCdkYXRhIGRvZXNuXFwndCBleGlzdCwgdXNlIGpzb24oKSwgdGV4dCgpLCBhcnJheUJ1ZmZlcigpLCBvciBib2R5IGluc3RlYWQnLFxuXHRcdCdodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMDAwIChyZXNwb25zZSknKX1cbn0pO1xuXG4vKipcbiAqIENvbnN1bWUgYW5kIGNvbnZlcnQgYW4gZW50aXJlIEJvZHkgdG8gYSBCdWZmZXIuXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LWNvbnN1bWUtYm9keVxuICpcbiAqIEByZXR1cm4gUHJvbWlzZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lQm9keShkYXRhKSB7XG5cdGlmIChkYXRhW0lOVEVSTkFMU10uZGlzdHVyYmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgYm9keSB1c2VkIGFscmVhZHkgZm9yOiAke2RhdGEudXJsfWApO1xuXHR9XG5cblx0ZGF0YVtJTlRFUk5BTFNdLmRpc3R1cmJlZCA9IHRydWU7XG5cblx0aWYgKGRhdGFbSU5URVJOQUxTXS5lcnJvcikge1xuXHRcdHRocm93IGRhdGFbSU5URVJOQUxTXS5lcnJvcjtcblx0fVxuXG5cdGNvbnN0IHtib2R5fSA9IGRhdGE7XG5cblx0Ly8gQm9keSBpcyBudWxsXG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcblx0fVxuXG5cdC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cblx0aWYgKCEoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkpIHtcblx0XHRyZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBzdHJlYW1cblx0Ly8gZ2V0IHJlYWR5IHRvIGFjdHVhbGx5IGNvbnN1bWUgdGhlIGJvZHlcblx0Y29uc3QgYWNjdW0gPSBbXTtcblx0bGV0IGFjY3VtQnl0ZXMgPSAwO1xuXG5cdHRyeSB7XG5cdFx0Zm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBib2R5KSB7XG5cdFx0XHRpZiAoZGF0YS5zaXplID4gMCAmJiBhY2N1bUJ5dGVzICsgY2h1bmsubGVuZ3RoID4gZGF0YS5zaXplKSB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEZldGNoRXJyb3IoYGNvbnRlbnQgc2l6ZSBhdCAke2RhdGEudXJsfSBvdmVyIGxpbWl0OiAke2RhdGEuc2l6ZX1gLCAnbWF4LXNpemUnKTtcblx0XHRcdFx0Ym9keS5kZXN0cm95KGVycm9yKTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cblx0XHRcdGFjY3VtQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuXHRcdFx0YWNjdW0ucHVzaChjaHVuayk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGNvbnN0IGVycm9yXyA9IGVycm9yIGluc3RhbmNlb2YgRmV0Y2hCYXNlRXJyb3IgPyBlcnJvciA6IG5ldyBGZXRjaEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7ZGF0YS51cmx9OiAke2Vycm9yLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycm9yKTtcblx0XHR0aHJvdyBlcnJvcl87XG5cdH1cblxuXHRpZiAoYm9keS5yZWFkYWJsZUVuZGVkID09PSB0cnVlIHx8IGJvZHkuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPT09IHRydWUpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKGFjY3VtLmV2ZXJ5KGMgPT4gdHlwZW9mIGMgPT09ICdzdHJpbmcnKSkge1xuXHRcdFx0XHRyZXR1cm4gQnVmZmVyLmZyb20oYWNjdW0uam9pbignJykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gQnVmZmVyLmNvbmNhdChhY2N1bSwgYWNjdW1CeXRlcyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRocm93IG5ldyBGZXRjaEVycm9yKGBDb3VsZCBub3QgY3JlYXRlIEJ1ZmZlciBmcm9tIHJlc3BvbnNlIGJvZHkgZm9yICR7ZGF0YS51cmx9OiAke2Vycm9yLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycm9yKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEZldGNoRXJyb3IoYFByZW1hdHVyZSBjbG9zZSBvZiBzZXJ2ZXIgcmVzcG9uc2Ugd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7ZGF0YS51cmx9YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDbG9uZSBib2R5IGdpdmVuIFJlcy9SZXEgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgIGluc3RhbmNlICAgICAgIFJlc3BvbnNlIG9yIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIFN0cmluZyAgaGlnaFdhdGVyTWFyayAgaGlnaFdhdGVyTWFyayBmb3IgYm90aCBQYXNzVGhyb3VnaCBib2R5IHN0cmVhbXNcbiAqIEByZXR1cm4gIE1peGVkXG4gKi9cbmV4cG9ydCBjb25zdCBjbG9uZSA9IChpbnN0YW5jZSwgaGlnaFdhdGVyTWFyaykgPT4ge1xuXHRsZXQgcDE7XG5cdGxldCBwMjtcblx0bGV0IHtib2R5fSA9IGluc3RhbmNlW0lOVEVSTkFMU107XG5cblx0Ly8gRG9uJ3QgYWxsb3cgY2xvbmluZyBhIHVzZWQgYm9keVxuXHRpZiAoaW5zdGFuY2UuYm9keVVzZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjbG9uZSBib2R5IGFmdGVyIGl0IGlzIHVzZWQnKTtcblx0fVxuXG5cdC8vIENoZWNrIHRoYXQgYm9keSBpcyBhIHN0cmVhbSBhbmQgbm90IGZvcm0tZGF0YSBvYmplY3Rcblx0Ly8gbm90ZTogd2UgY2FuJ3QgY2xvbmUgdGhlIGZvcm0tZGF0YSBvYmplY3Qgd2l0aG91dCBoYXZpbmcgaXQgYXMgYSBkZXBlbmRlbmN5XG5cdGlmICgoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkgJiYgKHR5cGVvZiBib2R5LmdldEJvdW5kYXJ5ICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdC8vIFRlZSBpbnN0YW5jZSBib2R5XG5cdFx0cDEgPSBuZXcgUGFzc1Rocm91Z2goe2hpZ2hXYXRlck1hcmt9KTtcblx0XHRwMiA9IG5ldyBQYXNzVGhyb3VnaCh7aGlnaFdhdGVyTWFya30pO1xuXHRcdGJvZHkucGlwZShwMSk7XG5cdFx0Ym9keS5waXBlKHAyKTtcblx0XHQvLyBTZXQgaW5zdGFuY2UgYm9keSB0byB0ZWVkIGJvZHkgYW5kIHJldHVybiB0aGUgb3RoZXIgdGVlZCBib2R5XG5cdFx0aW5zdGFuY2VbSU5URVJOQUxTXS5zdHJlYW0gPSBwMTtcblx0XHRib2R5ID0gcDI7XG5cdH1cblxuXHRyZXR1cm4gYm9keTtcbn07XG5cbmNvbnN0IGdldE5vblNwZWNGb3JtRGF0YUJvdW5kYXJ5ID0gZGVwcmVjYXRlKFxuXHRib2R5ID0+IGJvZHkuZ2V0Qm91bmRhcnkoKSxcblx0J2Zvcm0tZGF0YSBkb2VzblxcJ3QgZm9sbG93IHRoZSBzcGVjIGFuZCByZXF1aXJlcyBzcGVjaWFsIHRyZWF0bWVudC4gVXNlIGFsdGVybmF0aXZlIHBhY2thZ2UnLFxuXHQnaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvMTE2Nydcbik7XG5cbi8qKlxuICogUGVyZm9ybXMgdGhlIG9wZXJhdGlvbiBcImV4dHJhY3QgYSBgQ29udGVudC1UeXBlYCB2YWx1ZSBmcm9tIHxvYmplY3R8XCIgYXNcbiAqIHNwZWNpZmllZCBpbiB0aGUgc3BlY2lmaWNhdGlvbjpcbiAqIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHlpbml0LWV4dHJhY3RcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBpbnN0YW5jZS5ib2R5IGlzIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHthbnl9IGJvZHkgQW55IG9wdGlvbnMuYm9keSBpbnB1dFxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBleHRyYWN0Q29udGVudFR5cGUgPSAoYm9keSwgcmVxdWVzdCkgPT4ge1xuXHQvLyBCb2R5IGlzIG51bGwgb3IgdW5kZWZpbmVkXG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBCb2R5IGlzIHN0cmluZ1xuXHRpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBhIFVSTFNlYXJjaFBhcmFtc1xuXHRpZiAoaXNVUkxTZWFyY2hQYXJhbWV0ZXJzKGJvZHkpKSB7XG5cdFx0cmV0dXJuICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCc7XG5cdH1cblxuXHQvLyBCb2R5IGlzIGJsb2Jcblx0aWYgKGlzQmxvYihib2R5KSkge1xuXHRcdHJldHVybiBib2R5LnR5cGUgfHwgbnVsbDtcblx0fVxuXG5cdC8vIEJvZHkgaXMgYSBCdWZmZXIgKEJ1ZmZlciwgQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KVxuXHRpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpIHx8IHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoYm9keSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAoYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0cmV0dXJuIGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke3JlcXVlc3RbSU5URVJOQUxTXS5ib3VuZGFyeX1gO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IGZvcm0gZGF0YSBpbnB1dCBmcm9tIGZvcm0tZGF0YSBtb2R1bGVcblx0aWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkuZ2V0Qm91bmRhcnkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gYG11bHRpcGFydC9mb3JtLWRhdGE7Ym91bmRhcnk9JHtnZXROb25TcGVjRm9ybURhdGFCb3VuZGFyeShib2R5KX1gO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBzdHJlYW0gLSBjYW4ndCByZWFsbHkgZG8gbXVjaCBhYm91dCB0aGlzXG5cdGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBCb2R5IGNvbnN0cnVjdG9yIGRlZmF1bHRzIG90aGVyIHRoaW5ncyB0byBzdHJpbmdcblx0cmV0dXJuICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xufTtcblxuLyoqXG4gKiBUaGUgRmV0Y2ggU3RhbmRhcmQgdHJlYXRzIHRoaXMgYXMgaWYgXCJ0b3RhbCBieXRlc1wiIGlzIGEgcHJvcGVydHkgb24gdGhlIGJvZHkuXG4gKiBGb3IgdXMsIHdlIGhhdmUgdG8gZXhwbGljaXRseSBnZXQgaXQgd2l0aCBhIGZ1bmN0aW9uLlxuICpcbiAqIHJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS10b3RhbC1ieXRlc1xuICpcbiAqIEBwYXJhbSB7YW55fSBvYmouYm9keSBCb2R5IG9iamVjdCBmcm9tIHRoZSBCb2R5IGluc3RhbmNlLlxuICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUb3RhbEJ5dGVzID0gcmVxdWVzdCA9PiB7XG5cdGNvbnN0IHtib2R5fSA9IHJlcXVlc3RbSU5URVJOQUxTXTtcblxuXHQvLyBCb2R5IGlzIG51bGwgb3IgdW5kZWZpbmVkXG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHQvLyBCb2R5IGlzIEJsb2Jcblx0aWYgKGlzQmxvYihib2R5KSkge1xuXHRcdHJldHVybiBib2R5LnNpemU7XG5cdH1cblxuXHQvLyBCb2R5IGlzIEJ1ZmZlclxuXHRpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0cmV0dXJuIGJvZHkubGVuZ3RoO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IGZvcm0gZGF0YSBpbnB1dCBmcm9tIGZvcm0tZGF0YSBtb2R1bGVcblx0aWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkuZ2V0TGVuZ3RoU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBib2R5Lmhhc0tub3duTGVuZ3RoICYmIGJvZHkuaGFzS25vd25MZW5ndGgoKSA/IGJvZHkuZ2V0TGVuZ3RoU3luYygpIDogbnVsbDtcblx0fVxuXG5cdC8vIEJvZHkgaXMgc3RyZWFtXG5cdHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBXcml0ZSBhIEJvZHkgdG8gYSBOb2RlLmpzIFdyaXRhYmxlU3RyZWFtIChlLmcuIGh0dHAuUmVxdWVzdCkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyZWFtLldyaXRhYmxlfSBkZXN0IFRoZSBzdHJlYW0gdG8gd3JpdGUgdG8uXG4gKiBAcGFyYW0gb2JqLmJvZHkgQm9keSBvYmplY3QgZnJvbSB0aGUgQm9keSBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVUb1N0cmVhbSA9IGFzeW5jIChkZXN0LCB7Ym9keX0pID0+IHtcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHQvLyBCb2R5IGlzIG51bGxcblx0XHRkZXN0LmVuZCgpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJvZHkgaXMgc3RyZWFtXG5cdFx0YXdhaXQgcGlwZWxpbmUoYm9keSwgZGVzdCk7XG5cdH1cbn07XG4iLCAiZXhwb3J0IGNsYXNzIEZldGNoQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0Ly8gSGlkZSBjdXN0b20gZXJyb3IgaW1wbGVtZW50YXRpb24gZGV0YWlscyBmcm9tIGVuZC11c2Vyc1xuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0fVxuXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0fVxufVxuIiwgIlxuaW1wb3J0IHtGZXRjaEJhc2VFcnJvcn0gZnJvbSAnLi9iYXNlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBhZGRyZXNzPzogc3RyaW5nLCBjb2RlOiBzdHJpbmcsIGRlc3Q/OiBzdHJpbmcsIGVycm5vOiBudW1iZXIsIGluZm8/OiBvYmplY3QsIG1lc3NhZ2U6IHN0cmluZywgcGF0aD86IHN0cmluZywgcG9ydD86IG51bWJlciwgc3lzY2FsbDogc3RyaW5nfX0gU3lzdGVtRXJyb3JcbiovXG5cbi8qKlxuICogRmV0Y2hFcnJvciBpbnRlcmZhY2UgZm9yIG9wZXJhdGlvbmFsIGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hFcnJvciBleHRlbmRzIEZldGNoQmFzZUVycm9yIHtcblx0LyoqXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gbWVzc2FnZSAtICAgICAgRXJyb3IgbWVzc2FnZSBmb3IgaHVtYW5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBbdHlwZV0gLSAgICAgICAgRXJyb3IgdHlwZSBmb3IgbWFjaGluZVxuXHQgKiBAcGFyYW0gIHtTeXN0ZW1FcnJvcn0gW3N5c3RlbUVycm9yXSAtIEZvciBOb2RlLmpzIHN5c3RlbSBlcnJvclxuXHQgKi9cblx0Y29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSwgc3lzdGVtRXJyb3IpIHtcblx0XHRzdXBlcihtZXNzYWdlLCB0eXBlKTtcblx0XHQvLyBXaGVuIGVyci50eXBlIGlzIGBzeXN0ZW1gLCBlcnIuZXJyb3JlZFN5c0NhbGwgY29udGFpbnMgc3lzdGVtIGVycm9yIGFuZCBlcnIuY29kZSBjb250YWlucyBzeXN0ZW0gZXJyb3IgY29kZVxuXHRcdGlmIChzeXN0ZW1FcnJvcikge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuXHRcdFx0dGhpcy5jb2RlID0gdGhpcy5lcnJubyA9IHN5c3RlbUVycm9yLmNvZGU7XG5cdFx0XHR0aGlzLmVycm9yZWRTeXNDYWxsID0gc3lzdGVtRXJyb3Iuc3lzY2FsbDtcblx0XHR9XG5cdH1cbn1cbiIsICIvKipcbiAqIElzLmpzXG4gKlxuICogT2JqZWN0IHR5cGUgY2hlY2tzLlxuICovXG5cbmNvbnN0IE5BTUUgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKiByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzI5NiNpc3N1ZWNvbW1lbnQtMzA3NTk4MTQzXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjayBmb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1VSTFNlYXJjaFBhcmFtZXRlcnMgPSBvYmplY3QgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIG9iamVjdC5hcHBlbmQgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmRlbGV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3QuZ2V0ID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5nZXRBbGwgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3Quc2V0ID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5zb3J0ID09PSAnZnVuY3Rpb24nICYmXG5cdFx0b2JqZWN0W05BTUVdID09PSAnVVJMU2VhcmNoUGFyYW1zJ1xuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqZWN0YCBpcyBhIFczQyBgQmxvYmAgb2JqZWN0ICh3aGljaCBgRmlsZWAgaW5oZXJpdHMgZnJvbSlcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrIGZvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQmxvYiA9IG9iamVjdCA9PiB7XG5cdHJldHVybiAoXG5cdFx0b2JqZWN0ICYmXG5cdFx0dHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC50eXBlID09PSAnc3RyaW5nJyAmJlxuXHRcdHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdC9eKEJsb2J8RmlsZSkkLy50ZXN0KG9iamVjdFtOQU1FXSlcblx0KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gaW5zdGFuY2Ugb2YgQWJvcnRTaWduYWwuXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjayBmb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc0Fib3J0U2lnbmFsID0gb2JqZWN0ID0+IHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiAoXG5cdFx0XHRvYmplY3RbTkFNRV0gPT09ICdBYm9ydFNpZ25hbCcgfHxcblx0XHRcdG9iamVjdFtOQU1FXSA9PT0gJ0V2ZW50VGFyZ2V0J1xuXHRcdClcblx0KTtcbn07XG5cbi8qKlxuICogaXNEb21haW5PclN1YmRvbWFpbiByZXBvcnRzIHdoZXRoZXIgc3ViIGlzIGEgc3ViZG9tYWluIChvciBleGFjdCBtYXRjaCkgb2ZcbiAqIHRoZSBwYXJlbnQgZG9tYWluLlxuICpcbiAqIEJvdGggZG9tYWlucyBtdXN0IGFscmVhZHkgYmUgaW4gY2Fub25pY2FsIGZvcm0uXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IG9yaWdpbmFsXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IGRlc3RpbmF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpc0RvbWFpbk9yU3ViZG9tYWluID0gKGRlc3RpbmF0aW9uLCBvcmlnaW5hbCkgPT4ge1xuXHRjb25zdCBvcmlnID0gbmV3IFVSTChvcmlnaW5hbCkuaG9zdG5hbWU7XG5cdGNvbnN0IGRlc3QgPSBuZXcgVVJMKGRlc3RpbmF0aW9uKS5ob3N0bmFtZTtcblxuXHRyZXR1cm4gb3JpZyA9PT0gZGVzdCB8fCBvcmlnLmVuZHNXaXRoKGAuJHtkZXN0fWApO1xufTtcblxuLyoqXG4gKiBpc1NhbWVQcm90b2NvbCByZXBvcnRzIHdoZXRoZXIgdGhlIHR3byBwcm92aWRlZCBVUkxzIHVzZSB0aGUgc2FtZSBwcm90b2NvbC5cbiAqXG4gKiBCb3RoIGRvbWFpbnMgbXVzdCBhbHJlYWR5IGJlIGluIGNhbm9uaWNhbCBmb3JtLlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSBvcmlnaW5hbFxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSBkZXN0aW5hdGlvblxuICovXG5leHBvcnQgY29uc3QgaXNTYW1lUHJvdG9jb2wgPSAoZGVzdGluYXRpb24sIG9yaWdpbmFsKSA9PiB7XG5cdGNvbnN0IG9yaWcgPSBuZXcgVVJMKG9yaWdpbmFsKS5wcm90b2NvbDtcblx0Y29uc3QgZGVzdCA9IG5ldyBVUkwoZGVzdGluYXRpb24pLnByb3RvY29sO1xuXG5cdHJldHVybiBvcmlnID09PSBkZXN0O1xufTtcbiIsICIvKipcbiAqIEhlYWRlcnMuanNcbiAqXG4gKiBIZWFkZXJzIGNsYXNzIG9mZmVycyBjb252ZW5pZW50IGhlbHBlcnNcbiAqL1xuXG5pbXBvcnQge3R5cGVzfSBmcm9tICdub2RlOnV0aWwnO1xuaW1wb3J0IGh0dHAgZnJvbSAnbm9kZTpodHRwJztcblxuLyogYzggaWdub3JlIG5leHQgOSAqL1xuY29uc3QgdmFsaWRhdGVIZWFkZXJOYW1lID0gdHlwZW9mIGh0dHAudmFsaWRhdGVIZWFkZXJOYW1lID09PSAnZnVuY3Rpb24nID9cblx0aHR0cC52YWxpZGF0ZUhlYWRlck5hbWUgOlxuXHRuYW1lID0+IHtcblx0XHRpZiAoIS9eW1xcXmBcXC1cXHchIyQlJicqKy58fl0rJC8udGVzdChuYW1lKSkge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKGBIZWFkZXIgbmFtZSBtdXN0IGJlIGEgdmFsaWQgSFRUUCB0b2tlbiBbJHtuYW1lfV1gKTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ2NvZGUnLCB7dmFsdWU6ICdFUlJfSU5WQUxJRF9IVFRQX1RPS0VOJ30pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9O1xuXG4vKiBjOCBpZ25vcmUgbmV4dCA5ICovXG5jb25zdCB2YWxpZGF0ZUhlYWRlclZhbHVlID0gdHlwZW9mIGh0dHAudmFsaWRhdGVIZWFkZXJWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/XG5cdGh0dHAudmFsaWRhdGVIZWFkZXJWYWx1ZSA6XG5cdChuYW1lLCB2YWx1ZSkgPT4ge1xuXHRcdGlmICgvW15cXHRcXHUwMDIwLVxcdTAwN0VcXHUwMDgwLVxcdTAwRkZdLy50ZXN0KHZhbHVlKSkge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgY29udGVudCBbXCIke25hbWV9XCJdYCk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICdjb2RlJywge3ZhbHVlOiAnRVJSX0lOVkFMSURfQ0hBUid9KTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7SGVhZGVycyB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBJdGVyYWJsZTxyZWFkb25seSBbc3RyaW5nLCBzdHJpbmddPiB8IEl0ZXJhYmxlPEl0ZXJhYmxlPHN0cmluZz4+fSBIZWFkZXJzSW5pdFxuICovXG5cbi8qKlxuICogVGhpcyBGZXRjaCBBUEkgaW50ZXJmYWNlIGFsbG93cyB5b3UgdG8gcGVyZm9ybSB2YXJpb3VzIGFjdGlvbnMgb24gSFRUUCByZXF1ZXN0IGFuZCByZXNwb25zZSBoZWFkZXJzLlxuICogVGhlc2UgYWN0aW9ucyBpbmNsdWRlIHJldHJpZXZpbmcsIHNldHRpbmcsIGFkZGluZyB0bywgYW5kIHJlbW92aW5nLlxuICogQSBIZWFkZXJzIG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCBoZWFkZXIgbGlzdCwgd2hpY2ggaXMgaW5pdGlhbGx5IGVtcHR5IGFuZCBjb25zaXN0cyBvZiB6ZXJvIG9yIG1vcmUgbmFtZSBhbmQgdmFsdWUgcGFpcnMuXG4gKiBZb3UgY2FuIGFkZCB0byB0aGlzIHVzaW5nIG1ldGhvZHMgbGlrZSBhcHBlbmQoKSAoc2VlIEV4YW1wbGVzLilcbiAqIEluIGFsbCBtZXRob2RzIG9mIHRoaXMgaW50ZXJmYWNlLCBoZWFkZXIgbmFtZXMgYXJlIG1hdGNoZWQgYnkgY2FzZS1pbnNlbnNpdGl2ZSBieXRlIHNlcXVlbmNlLlxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhZGVycyBleHRlbmRzIFVSTFNlYXJjaFBhcmFtcyB7XG5cdC8qKlxuXHQgKiBIZWFkZXJzIGNsYXNzXG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hlYWRlcnNJbml0fSBbaW5pdF0gLSBSZXNwb25zZSBoZWFkZXJzXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihpbml0KSB7XG5cdFx0Ly8gVmFsaWRhdGUgYW5kIG5vcm1hbGl6ZSBpbml0IG9iamVjdCBpbiBbbmFtZSwgdmFsdWUocyldW11cblx0XHQvKiogQHR5cGUge3N0cmluZ1tdW119ICovXG5cdFx0bGV0IHJlc3VsdCA9IFtdO1xuXHRcdGlmIChpbml0IGluc3RhbmNlb2YgSGVhZGVycykge1xuXHRcdFx0Y29uc3QgcmF3ID0gaW5pdC5yYXcoKTtcblx0XHRcdGZvciAoY29uc3QgW25hbWUsIHZhbHVlc10gb2YgT2JqZWN0LmVudHJpZXMocmF3KSkge1xuXHRcdFx0XHRyZXN1bHQucHVzaCguLi52YWx1ZXMubWFwKHZhbHVlID0+IFtuYW1lLCB2YWx1ZV0pKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGluaXQgPT0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdFx0Ly8gTm8gb3Bcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBpbml0ID09PSAnb2JqZWN0JyAmJiAhdHlwZXMuaXNCb3hlZFByaW1pdGl2ZShpbml0KSkge1xuXHRcdFx0Y29uc3QgbWV0aG9kID0gaW5pdFtTeW1ib2wuaXRlcmF0b3JdO1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdFx0aWYgKG1ldGhvZCA9PSBudWxsKSB7XG5cdFx0XHRcdC8vIFJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPlxuXHRcdFx0XHRyZXN1bHQucHVzaCguLi5PYmplY3QuZW50cmllcyhpbml0KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlciBwYWlycyBtdXN0IGJlIGl0ZXJhYmxlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj5cblx0XHRcdFx0Ly8gTm90ZTogcGVyIHNwZWMgd2UgaGF2ZSB0byBmaXJzdCBleGhhdXN0IHRoZSBsaXN0cyB0aGVuIHByb2Nlc3MgdGhlbVxuXHRcdFx0XHRyZXN1bHQgPSBbLi4uaW5pdF1cblx0XHRcdFx0XHQubWFwKHBhaXIgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHR0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcgfHwgdHlwZXMuaXNCb3hlZFByaW1pdGl2ZShwYWlyKVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggaGVhZGVyIHBhaXIgbXVzdCBiZSBhbiBpdGVyYWJsZSBvYmplY3QnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIFsuLi5wYWlyXTtcblx0XHRcdFx0XHR9KS5tYXAocGFpciA9PiB7XG5cdFx0XHRcdFx0XHRpZiAocGFpci5sZW5ndGggIT09IDIpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBoZWFkZXIgcGFpciBtdXN0IGJlIGEgbmFtZS92YWx1ZSB0dXBsZScpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gWy4uLnBhaXJdO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0hlYWRlcnNcXCc6IFRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3Qgb2YgdHlwZSBcXCcoc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+IG9yIHJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPiknKTtcblx0XHR9XG5cblx0XHQvLyBWYWxpZGF0ZSBhbmQgbG93ZXJjYXNlXG5cdFx0cmVzdWx0ID1cblx0XHRcdHJlc3VsdC5sZW5ndGggPiAwID9cblx0XHRcdFx0cmVzdWx0Lm1hcCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuXHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlclZhbHVlKG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuXHRcdFx0XHRcdHJldHVybiBbU3RyaW5nKG5hbWUpLnRvTG93ZXJDYXNlKCksIFN0cmluZyh2YWx1ZSldO1xuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblxuXHRcdHN1cGVyKHJlc3VsdCk7XG5cblx0XHQvLyBSZXR1cm5pbmcgYSBQcm94eSB0aGF0IHdpbGwgbG93ZXJjYXNlIGtleSBuYW1lcywgdmFsaWRhdGUgcGFyYW1ldGVycyBhbmQgc29ydCBrZXlzXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuXHRcdHJldHVybiBuZXcgUHJveHkodGhpcywge1xuXHRcdFx0Z2V0KHRhcmdldCwgcCwgcmVjZWl2ZXIpIHtcblx0XHRcdFx0c3dpdGNoIChwKSB7XG5cdFx0XHRcdFx0Y2FzZSAnYXBwZW5kJzpcblx0XHRcdFx0XHRjYXNlICdzZXQnOlxuXHRcdFx0XHRcdFx0cmV0dXJuIChuYW1lLCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0XHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyVmFsdWUobmFtZSwgU3RyaW5nKHZhbHVlKSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW3BdLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRcdFN0cmluZyhuYW1lKS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0XHRcdFN0cmluZyh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRjYXNlICdkZWxldGUnOlxuXHRcdFx0XHRcdGNhc2UgJ2hhcyc6XG5cdFx0XHRcdFx0Y2FzZSAnZ2V0QWxsJzpcblx0XHRcdFx0XHRcdHJldHVybiBuYW1lID0+IHtcblx0XHRcdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZVtwXS5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldCxcblx0XHRcdFx0XHRcdFx0XHRTdHJpbmcobmFtZSkudG9Mb3dlckNhc2UoKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGNhc2UgJ2tleXMnOlxuXHRcdFx0XHRcdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0LnNvcnQoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBTZXQoVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5rZXlzLmNhbGwodGFyZ2V0KSkua2V5cygpO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwLCByZWNlaXZlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHQvKiBjOCBpZ25vcmUgbmV4dCAqL1xuXHR9XG5cblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpO1xuXHR9XG5cblx0Z2V0KG5hbWUpIHtcblx0XHRjb25zdCB2YWx1ZXMgPSB0aGlzLmdldEFsbChuYW1lKTtcblx0XHRpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0bGV0IHZhbHVlID0gdmFsdWVzLmpvaW4oJywgJyk7XG5cdFx0aWYgKC9eY29udGVudC1lbmNvZGluZyQvaS50ZXN0KG5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0Zm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZyA9IHVuZGVmaW5lZCkge1xuXHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuXHRcdFx0UmVmbGVjdC5hcHBseShjYWxsYmFjaywgdGhpc0FyZywgW3RoaXMuZ2V0KG5hbWUpLCBuYW1lLCB0aGlzXSk7XG5cdFx0fVxuXHR9XG5cblx0KiB2YWx1ZXMoKSB7XG5cdFx0Zm9yIChjb25zdCBuYW1lIG9mIHRoaXMua2V5cygpKSB7XG5cdFx0XHR5aWVsZCB0aGlzLmdldChuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUgeygpID0+IEl0ZXJhYmxlSXRlcmF0b3I8W3N0cmluZywgc3RyaW5nXT59XG5cdCAqL1xuXHQqIGVudHJpZXMoKSB7XG5cdFx0Zm9yIChjb25zdCBuYW1lIG9mIHRoaXMua2V5cygpKSB7XG5cdFx0XHR5aWVsZCBbbmFtZSwgdGhpcy5nZXQobmFtZSldO1xuXHRcdH1cblx0fVxuXG5cdFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuXHRcdHJldHVybiB0aGlzLmVudHJpZXMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBOb2RlLWZldGNoIG5vbi1zcGVjIG1ldGhvZFxuXHQgKiByZXR1cm5pbmcgYWxsIGhlYWRlcnMgYW5kIHRoZWlyIHZhbHVlcyBhcyBhcnJheVxuXHQgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nW10+fVxuXHQgKi9cblx0cmF3KCkge1xuXHRcdHJldHVybiBbLi4udGhpcy5rZXlzKCldLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcblx0XHRcdHJlc3VsdFtrZXldID0gdGhpcy5nZXRBbGwoa2V5KTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSwge30pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZvciBiZXR0ZXIgY29uc29sZS5sb2coaGVhZGVycykgYW5kIGFsc28gdG8gY29udmVydCBIZWFkZXJzIGludG8gTm9kZS5qcyBSZXF1ZXN0IGNvbXBhdGlibGUgZm9ybWF0XG5cdCAqL1xuXHRbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG5cdFx0cmV0dXJuIFsuLi50aGlzLmtleXMoKV0ucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXRBbGwoa2V5KTtcblx0XHRcdC8vIEh0dHAucmVxdWVzdCgpIG9ubHkgc3VwcG9ydHMgc3RyaW5nIGFzIEhvc3QgaGVhZGVyLlxuXHRcdFx0Ly8gVGhpcyBoYWNrIG1ha2VzIHNwZWNpZnlpbmcgY3VzdG9tIEhvc3QgaGVhZGVyIHBvc3NpYmxlLlxuXHRcdFx0aWYgKGtleSA9PT0gJ2hvc3QnKSB7XG5cdFx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWVzWzBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0W2tleV0gPSB2YWx1ZXMubGVuZ3RoID4gMSA/IHZhbHVlcyA6IHZhbHVlc1swXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LCB7fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZS1zaGFwaW5nIG9iamVjdCBmb3IgV2ViIElETCB0ZXN0c1xuICogT25seSBuZWVkIHRvIGRvIGl0IGZvciBvdmVycmlkZGVuIG1ldGhvZHNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG5cdEhlYWRlcnMucHJvdG90eXBlLFxuXHRbJ2dldCcsICdlbnRyaWVzJywgJ2ZvckVhY2gnLCAndmFsdWVzJ10ucmVkdWNlKChyZXN1bHQsIHByb3BlcnR5KSA9PiB7XG5cdFx0cmVzdWx0W3Byb3BlcnR5XSA9IHtlbnVtZXJhYmxlOiB0cnVlfTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LCB7fSlcbik7XG5cbi8qKlxuICogQ3JlYXRlIGEgSGVhZGVycyBvYmplY3QgZnJvbSBhbiBodHRwLkluY29taW5nTWVzc2FnZS5yYXdIZWFkZXJzLCBpZ25vcmluZyB0aG9zZSB0aGF0IGRvXG4gKiBub3QgY29uZm9ybSB0byBIVFRQIGdyYW1tYXIgcHJvZHVjdGlvbnMuXG4gKiBAcGFyYW0ge2ltcG9ydCgnaHR0cCcpLkluY29taW5nTWVzc2FnZVsncmF3SGVhZGVycyddfSBoZWFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUmF3SGVhZGVycyhoZWFkZXJzID0gW10pIHtcblx0cmV0dXJuIG5ldyBIZWFkZXJzKFxuXHRcdGhlYWRlcnNcblx0XHRcdC8vIFNwbGl0IGludG8gcGFpcnNcblx0XHRcdC5yZWR1Y2UoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBhcnJheSkgPT4ge1xuXHRcdFx0XHRpZiAoaW5kZXggJSAyID09PSAwKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goYXJyYXkuc2xpY2UoaW5kZXgsIGluZGV4ICsgMikpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sIFtdKVxuXHRcdFx0LmZpbHRlcigoW25hbWUsIHZhbHVlXSkgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlclZhbHVlKG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IGNhdGNoIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cblx0KTtcbn1cbiIsICJjb25zdCByZWRpcmVjdFN0YXR1cyA9IG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG5cbi8qKlxuICogUmVkaXJlY3QgY29kZSBtYXRjaGluZ1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIC0gU3RhdHVzIGNvZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1JlZGlyZWN0ID0gY29kZSA9PiB7XG5cdHJldHVybiByZWRpcmVjdFN0YXR1cy5oYXMoY29kZSk7XG59O1xuIiwgIi8qKlxuICogUmVzcG9uc2UuanNcbiAqXG4gKiBSZXNwb25zZSBjbGFzcyBwcm92aWRlcyBjb250ZW50IGRlY29kaW5nXG4gKi9cblxuaW1wb3J0IEhlYWRlcnMgZnJvbSAnLi9oZWFkZXJzLmpzJztcbmltcG9ydCBCb2R5LCB7Y2xvbmUsIGV4dHJhY3RDb250ZW50VHlwZX0gZnJvbSAnLi9ib2R5LmpzJztcbmltcG9ydCB7aXNSZWRpcmVjdH0gZnJvbSAnLi91dGlscy9pcy1yZWRpcmVjdC5qcyc7XG5cbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnUmVzcG9uc2UgaW50ZXJuYWxzJyk7XG5cbi8qKlxuICogUmVzcG9uc2UgY2xhc3NcbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jbGFzc1xuICpcbiAqIEBwYXJhbSAgIFN0cmVhbSAgYm9keSAgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gICBPYmplY3QgIG9wdHMgIFJlc3BvbnNlIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzcG9uc2UgZXh0ZW5kcyBCb2R5IHtcblx0Y29uc3RydWN0b3IoYm9keSA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKGJvZHksIG9wdGlvbnMpO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcSwgbm8tbmVnYXRlZC1jb25kaXRpb25cblx0XHRjb25zdCBzdGF0dXMgPSBvcHRpb25zLnN0YXR1cyAhPSBudWxsID8gb3B0aW9ucy5zdGF0dXMgOiAyMDA7XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmIChib2R5ICE9PSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKGJvZHksIHRoaXMpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTFNdID0ge1xuXHRcdFx0dHlwZTogJ2RlZmF1bHQnLFxuXHRcdFx0dXJsOiBvcHRpb25zLnVybCxcblx0XHRcdHN0YXR1cyxcblx0XHRcdHN0YXR1c1RleHQ6IG9wdGlvbnMuc3RhdHVzVGV4dCB8fCAnJyxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRjb3VudGVyOiBvcHRpb25zLmNvdW50ZXIsXG5cdFx0XHRoaWdoV2F0ZXJNYXJrOiBvcHRpb25zLmhpZ2hXYXRlck1hcmtcblx0XHR9O1xuXHR9XG5cblx0Z2V0IHR5cGUoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS50eXBlO1xuXHR9XG5cblx0Z2V0IHVybCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnVybCB8fCAnJztcblx0fVxuXG5cdGdldCBzdGF0dXMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5zdGF0dXM7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVuaWVuY2UgcHJvcGVydHkgcmVwcmVzZW50aW5nIGlmIHRoZSByZXF1ZXN0IGVuZGVkIG5vcm1hbGx5XG5cdCAqL1xuXHRnZXQgb2soKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5zdGF0dXMgPj0gMjAwICYmIHRoaXNbSU5URVJOQUxTXS5zdGF0dXMgPCAzMDA7XG5cdH1cblxuXHRnZXQgcmVkaXJlY3RlZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmNvdW50ZXIgPiAwO1xuXHR9XG5cblx0Z2V0IHN0YXR1c1RleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5zdGF0dXNUZXh0O1xuXHR9XG5cblx0Z2V0IGhlYWRlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5oZWFkZXJzO1xuXHR9XG5cblx0Z2V0IGhpZ2hXYXRlck1hcmsoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5oaWdoV2F0ZXJNYXJrO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsb25lIHRoaXMgcmVzcG9uc2Vcblx0ICpcblx0ICogQHJldHVybiAgUmVzcG9uc2Vcblx0ICovXG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UoY2xvbmUodGhpcywgdGhpcy5oaWdoV2F0ZXJNYXJrKSwge1xuXHRcdFx0dHlwZTogdGhpcy50eXBlLFxuXHRcdFx0dXJsOiB0aGlzLnVybCxcblx0XHRcdHN0YXR1czogdGhpcy5zdGF0dXMsXG5cdFx0XHRzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRvazogdGhpcy5vayxcblx0XHRcdHJlZGlyZWN0ZWQ6IHRoaXMucmVkaXJlY3RlZCxcblx0XHRcdHNpemU6IHRoaXMuc2l6ZSxcblx0XHRcdGhpZ2hXYXRlck1hcms6IHRoaXMuaGlnaFdhdGVyTWFya1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgVGhlIFVSTCB0aGF0IHRoZSBuZXcgcmVzcG9uc2UgaXMgdG8gb3JpZ2luYXRlIGZyb20uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXMgQW4gb3B0aW9uYWwgc3RhdHVzIGNvZGUgZm9yIHRoZSByZXNwb25zZSAoZS5nLiwgMzAyLilcblx0ICogQHJldHVybnMge1Jlc3BvbnNlfSAgICBBIFJlc3BvbnNlIG9iamVjdC5cblx0ICovXG5cdHN0YXRpYyByZWRpcmVjdCh1cmwsIHN0YXR1cyA9IDMwMikge1xuXHRcdGlmICghaXNSZWRpcmVjdChzdGF0dXMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignRmFpbGVkIHRvIGV4ZWN1dGUgXCJyZWRpcmVjdFwiIG9uIFwicmVzcG9uc2VcIjogSW52YWxpZCBzdGF0dXMgY29kZScpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuXHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHRsb2NhdGlvbjogbmV3IFVSTCh1cmwpLnRvU3RyaW5nKClcblx0XHRcdH0sXG5cdFx0XHRzdGF0dXNcblx0XHR9KTtcblx0fVxuXG5cdHN0YXRpYyBlcnJvcigpIHtcblx0XHRjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pO1xuXHRcdHJlc3BvbnNlW0lOVEVSTkFMU10udHlwZSA9ICdlcnJvcic7XG5cdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHR9XG5cblx0c3RhdGljIGpzb24oZGF0YSA9IHVuZGVmaW5lZCwgaW5pdCA9IHt9KSB7XG5cdFx0Y29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXG5cdFx0aWYgKGJvZHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBpcyBub3QgSlNPTiBzZXJpYWxpemFibGUnKTtcblx0XHR9XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdCAmJiBpbml0LmhlYWRlcnMpO1xuXG5cdFx0aWYgKCFoZWFkZXJzLmhhcygnY29udGVudC10eXBlJykpIHtcblx0XHRcdGhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwge1xuXHRcdFx0Li4uaW5pdCxcblx0XHRcdGhlYWRlcnNcblx0XHR9KTtcblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gJ1Jlc3BvbnNlJztcblx0fVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZS5wcm90b3R5cGUsIHtcblx0dHlwZToge2VudW1lcmFibGU6IHRydWV9LFxuXHR1cmw6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c3RhdHVzOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdG9rOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZGlyZWN0ZWQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c3RhdHVzVGV4dDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRoZWFkZXJzOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGNsb25lOiB7ZW51bWVyYWJsZTogdHJ1ZX1cbn0pO1xuIiwgIi8qKlxuICogUmVxdWVzdC5qc1xuICpcbiAqIFJlcXVlc3QgY2xhc3MgY29udGFpbnMgc2VydmVyIG9ubHkgb3B0aW9uc1xuICpcbiAqIEFsbCBzcGVjIGFsZ29yaXRobSBzdGVwIG51bWJlcnMgYXJlIGJhc2VkIG9uIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnL2NvbW1pdC1zbmFwc2hvdHMvYWU3MTY4MjJjYjNhNjE4NDMyMjZjZDA5MGVlZmM2NTg5NDQ2YzFkMi8uXG4gKi9cblxuaW1wb3J0IHtmb3JtYXQgYXMgZm9ybWF0VXJsfSBmcm9tICdub2RlOnVybCc7XG5pbXBvcnQge2RlcHJlY2F0ZX0gZnJvbSAnbm9kZTp1dGlsJztcbmltcG9ydCBIZWFkZXJzIGZyb20gJy4vaGVhZGVycy5qcyc7XG5pbXBvcnQgQm9keSwge2Nsb25lLCBleHRyYWN0Q29udGVudFR5cGUsIGdldFRvdGFsQnl0ZXN9IGZyb20gJy4vYm9keS5qcyc7XG5pbXBvcnQge2lzQWJvcnRTaWduYWx9IGZyb20gJy4vdXRpbHMvaXMuanMnO1xuaW1wb3J0IHtnZXRTZWFyY2h9IGZyb20gJy4vdXRpbHMvZ2V0LXNlYXJjaC5qcyc7XG5pbXBvcnQge1xuXHR2YWxpZGF0ZVJlZmVycmVyUG9saWN5LCBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLCBERUZBVUxUX1JFRkVSUkVSX1BPTElDWVxufSBmcm9tICcuL3V0aWxzL3JlZmVycmVyLmpzJztcblxuY29uc3QgSU5URVJOQUxTID0gU3ltYm9sKCdSZXF1ZXN0IGludGVybmFscycpO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIGluc3RhbmNlIG9mIFJlcXVlc3QuXG4gKlxuICogQHBhcmFtICB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBpc1JlcXVlc3QgPSBvYmplY3QgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIG9iamVjdFtJTlRFUk5BTFNdID09PSAnb2JqZWN0J1xuXHQpO1xufTtcblxuY29uc3QgZG9CYWREYXRhV2FybiA9IGRlcHJlY2F0ZSgoKSA9PiB7fSxcblx0Jy5kYXRhIGlzIG5vdCBhIHZhbGlkIFJlcXVlc3RJbml0IHByb3BlcnR5LCB1c2UgLmJvZHkgaW5zdGVhZCcsXG5cdCdodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMDAwIChyZXF1ZXN0KScpO1xuXG4vKipcbiAqIFJlcXVlc3QgY2xhc3NcbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWNsYXNzXG4gKlxuICogQHBhcmFtICAgTWl4ZWQgICBpbnB1dCAgVXJsIG9yIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIE9iamVjdCAgaW5pdCAgIEN1c3RvbSBvcHRpb25zXG4gKiBAcmV0dXJuICBWb2lkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcXVlc3QgZXh0ZW5kcyBCb2R5IHtcblx0Y29uc3RydWN0b3IoaW5wdXQsIGluaXQgPSB7fSkge1xuXHRcdGxldCBwYXJzZWRVUkw7XG5cblx0XHQvLyBOb3JtYWxpemUgaW5wdXQgYW5kIGZvcmNlIFVSTCB0byBiZSBlbmNvZGVkIGFzIFVURi04IChodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8yNDUpXG5cdFx0aWYgKGlzUmVxdWVzdChpbnB1dCkpIHtcblx0XHRcdHBhcnNlZFVSTCA9IG5ldyBVUkwoaW5wdXQudXJsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFyc2VkVVJMID0gbmV3IFVSTChpbnB1dCk7XG5cdFx0XHRpbnB1dCA9IHt9O1xuXHRcdH1cblxuXHRcdGlmIChwYXJzZWRVUkwudXNlcm5hbWUgIT09ICcnIHx8IHBhcnNlZFVSTC5wYXNzd29yZCAhPT0gJycpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYCR7cGFyc2VkVVJMfSBpcyBhbiB1cmwgd2l0aCBlbWJlZGRlZCBjcmVkZW50aWFscy5gKTtcblx0XHR9XG5cblx0XHRsZXQgbWV0aG9kID0gaW5pdC5tZXRob2QgfHwgaW5wdXQubWV0aG9kIHx8ICdHRVQnO1xuXHRcdGlmICgvXihkZWxldGV8Z2V0fGhlYWR8b3B0aW9uc3xwb3N0fHB1dCkkL2kudGVzdChtZXRob2QpKSB7XG5cdFx0XHRtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcblx0XHR9XG5cblx0XHRpZiAoIWlzUmVxdWVzdChpbml0KSAmJiAnZGF0YScgaW4gaW5pdCkge1xuXHRcdFx0ZG9CYWREYXRhV2FybigpO1xuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRpZiAoKGluaXQuYm9keSAhPSBudWxsIHx8IChpc1JlcXVlc3QoaW5wdXQpICYmIGlucHV0LmJvZHkgIT09IG51bGwpKSAmJlxuXHRcdFx0KG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnSEVBRCcpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXF1ZXN0IHdpdGggR0VUL0hFQUQgbWV0aG9kIGNhbm5vdCBoYXZlIGJvZHknKTtcblx0XHR9XG5cblx0XHRjb25zdCBpbnB1dEJvZHkgPSBpbml0LmJvZHkgP1xuXHRcdFx0aW5pdC5ib2R5IDpcblx0XHRcdChpc1JlcXVlc3QoaW5wdXQpICYmIGlucHV0LmJvZHkgIT09IG51bGwgP1xuXHRcdFx0XHRjbG9uZShpbnB1dCkgOlxuXHRcdFx0XHRudWxsKTtcblxuXHRcdHN1cGVyKGlucHV0Qm9keSwge1xuXHRcdFx0c2l6ZTogaW5pdC5zaXplIHx8IGlucHV0LnNpemUgfHwgMFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycyB8fCBpbnB1dC5oZWFkZXJzIHx8IHt9KTtcblxuXHRcdGlmIChpbnB1dEJvZHkgIT09IG51bGwgJiYgIWhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKSkge1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSBleHRyYWN0Q29udGVudFR5cGUoaW5wdXRCb2R5LCB0aGlzKTtcblx0XHRcdGlmIChjb250ZW50VHlwZSkge1xuXHRcdFx0XHRoZWFkZXJzLnNldCgnQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBzaWduYWwgPSBpc1JlcXVlc3QoaW5wdXQpID9cblx0XHRcdGlucHV0LnNpZ25hbCA6XG5cdFx0XHRudWxsO1xuXHRcdGlmICgnc2lnbmFsJyBpbiBpbml0KSB7XG5cdFx0XHRzaWduYWwgPSBpbml0LnNpZ25hbDtcblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG5cdFx0aWYgKHNpZ25hbCAhPSBudWxsICYmICFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHNpZ25hbCB0byBiZSBhbiBpbnN0YW5jZW9mIEFib3J0U2lnbmFsIG9yIEV2ZW50VGFyZ2V0Jyk7XG5cdFx0fVxuXG5cdFx0Ly8gXHUwMEE3NS40LCBSZXF1ZXN0IGNvbnN0cnVjdG9yIHN0ZXBzLCBzdGVwIDE1LjFcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG5cdFx0bGV0IHJlZmVycmVyID0gaW5pdC5yZWZlcnJlciA9PSBudWxsID8gaW5wdXQucmVmZXJyZXIgOiBpbml0LnJlZmVycmVyO1xuXHRcdGlmIChyZWZlcnJlciA9PT0gJycpIHtcblx0XHRcdC8vIFx1MDBBNzUuNCwgUmVxdWVzdCBjb25zdHJ1Y3RvciBzdGVwcywgc3RlcCAxNS4yXG5cdFx0XHRyZWZlcnJlciA9ICduby1yZWZlcnJlcic7XG5cdFx0fSBlbHNlIGlmIChyZWZlcnJlcikge1xuXHRcdFx0Ly8gXHUwMEE3NS40LCBSZXF1ZXN0IGNvbnN0cnVjdG9yIHN0ZXBzLCBzdGVwIDE1LjMuMSwgMTUuMy4yXG5cdFx0XHRjb25zdCBwYXJzZWRSZWZlcnJlciA9IG5ldyBVUkwocmVmZXJyZXIpO1xuXHRcdFx0Ly8gXHUwMEE3NS40LCBSZXF1ZXN0IGNvbnN0cnVjdG9yIHN0ZXBzLCBzdGVwIDE1LjMuMywgMTUuMy40XG5cdFx0XHRyZWZlcnJlciA9IC9eYWJvdXQ6KFxcL1xcLyk/Y2xpZW50JC8udGVzdChwYXJzZWRSZWZlcnJlcikgPyAnY2xpZW50JyA6IHBhcnNlZFJlZmVycmVyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZWZlcnJlciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHR0aGlzW0lOVEVSTkFMU10gPSB7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHRyZWRpcmVjdDogaW5pdC5yZWRpcmVjdCB8fCBpbnB1dC5yZWRpcmVjdCB8fCAnZm9sbG93Jyxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRwYXJzZWRVUkwsXG5cdFx0XHRzaWduYWwsXG5cdFx0XHRyZWZlcnJlclxuXHRcdH07XG5cblx0XHQvLyBOb2RlLWZldGNoLW9ubHkgb3B0aW9uc1xuXHRcdHRoaXMuZm9sbG93ID0gaW5pdC5mb2xsb3cgPT09IHVuZGVmaW5lZCA/IChpbnB1dC5mb2xsb3cgPT09IHVuZGVmaW5lZCA/IDIwIDogaW5wdXQuZm9sbG93KSA6IGluaXQuZm9sbG93O1xuXHRcdHRoaXMuY29tcHJlc3MgPSBpbml0LmNvbXByZXNzID09PSB1bmRlZmluZWQgPyAoaW5wdXQuY29tcHJlc3MgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpbnB1dC5jb21wcmVzcykgOiBpbml0LmNvbXByZXNzO1xuXHRcdHRoaXMuY291bnRlciA9IGluaXQuY291bnRlciB8fCBpbnB1dC5jb3VudGVyIHx8IDA7XG5cdFx0dGhpcy5hZ2VudCA9IGluaXQuYWdlbnQgfHwgaW5wdXQuYWdlbnQ7XG5cdFx0dGhpcy5oaWdoV2F0ZXJNYXJrID0gaW5pdC5oaWdoV2F0ZXJNYXJrIHx8IGlucHV0LmhpZ2hXYXRlck1hcmsgfHwgMTYzODQ7XG5cdFx0dGhpcy5pbnNlY3VyZUhUVFBQYXJzZXIgPSBpbml0Lmluc2VjdXJlSFRUUFBhcnNlciB8fCBpbnB1dC5pbnNlY3VyZUhUVFBQYXJzZXIgfHwgZmFsc2U7XG5cblx0XHQvLyBcdTAwQTc1LjQsIFJlcXVlc3QgY29uc3RydWN0b3Igc3RlcHMsIHN0ZXAgMTYuXG5cdFx0Ly8gRGVmYXVsdCBpcyBlbXB0eSBzdHJpbmcgcGVyIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlcXVlc3QtcmVmZXJyZXItcG9saWN5XG5cdFx0dGhpcy5yZWZlcnJlclBvbGljeSA9IGluaXQucmVmZXJyZXJQb2xpY3kgfHwgaW5wdXQucmVmZXJyZXJQb2xpY3kgfHwgJyc7XG5cdH1cblxuXHQvKiogQHJldHVybnMge3N0cmluZ30gKi9cblx0Z2V0IG1ldGhvZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLm1ldGhvZDtcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuXHRnZXQgdXJsKCkge1xuXHRcdHJldHVybiBmb3JtYXRVcmwodGhpc1tJTlRFUk5BTFNdLnBhcnNlZFVSTCk7XG5cdH1cblxuXHQvKiogQHJldHVybnMge0hlYWRlcnN9ICovXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uaGVhZGVycztcblx0fVxuXG5cdGdldCByZWRpcmVjdCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnJlZGlyZWN0O1xuXHR9XG5cblx0LyoqIEByZXR1cm5zIHtBYm9ydFNpZ25hbH0gKi9cblx0Z2V0IHNpZ25hbCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnNpZ25hbDtcblx0fVxuXG5cdC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdC1yZWZlcnJlclxuXHRnZXQgcmVmZXJyZXIoKSB7XG5cdFx0aWYgKHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJykge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzW0lOVEVSTkFMU10ucmVmZXJyZXIgPT09ICdjbGllbnQnKSB7XG5cdFx0XHRyZXR1cm4gJ2Fib3V0OmNsaWVudCc7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlcikge1xuXHRcdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlci50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHRnZXQgcmVmZXJyZXJQb2xpY3koKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlclBvbGljeTtcblx0fVxuXG5cdHNldCByZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSkge1xuXHRcdHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlclBvbGljeSA9IHZhbGlkYXRlUmVmZXJyZXJQb2xpY3kocmVmZXJyZXJQb2xpY3kpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsb25lIHRoaXMgcmVxdWVzdFxuXHQgKlxuXHQgKiBAcmV0dXJuICBSZXF1ZXN0XG5cdCAqL1xuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IFJlcXVlc3QodGhpcyk7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuICdSZXF1ZXN0Jztcblx0fVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXF1ZXN0LnByb3RvdHlwZSwge1xuXHRtZXRob2Q6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0dXJsOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGhlYWRlcnM6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0cmVkaXJlY3Q6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0Y2xvbmU6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c2lnbmFsOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZmVycmVyOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZmVycmVyUG9saWN5OiB7ZW51bWVyYWJsZTogdHJ1ZX1cbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBSZXF1ZXN0IHRvIE5vZGUuanMgaHR0cCByZXF1ZXN0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0IC0gQSBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcmV0dXJuIFRoZSBvcHRpb25zIG9iamVjdCB0byBiZSBwYXNzZWQgdG8gaHR0cC5yZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBnZXROb2RlUmVxdWVzdE9wdGlvbnMgPSByZXF1ZXN0ID0+IHtcblx0Y29uc3Qge3BhcnNlZFVSTH0gPSByZXF1ZXN0W0lOVEVSTkFMU107XG5cdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXF1ZXN0W0lOVEVSTkFMU10uaGVhZGVycyk7XG5cblx0Ly8gRmV0Y2ggc3RlcCAxLjNcblx0aWYgKCFoZWFkZXJzLmhhcygnQWNjZXB0JykpIHtcblx0XHRoZWFkZXJzLnNldCgnQWNjZXB0JywgJyovKicpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXBzIDIuNC0yLjdcblx0bGV0IGNvbnRlbnRMZW5ndGhWYWx1ZSA9IG51bGw7XG5cdGlmIChyZXF1ZXN0LmJvZHkgPT09IG51bGwgJiYgL14ocG9zdHxwdXQpJC9pLnRlc3QocmVxdWVzdC5tZXRob2QpKSB7XG5cdFx0Y29udGVudExlbmd0aFZhbHVlID0gJzAnO1xuXHR9XG5cblx0aWYgKHJlcXVlc3QuYm9keSAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IHRvdGFsQnl0ZXMgPSBnZXRUb3RhbEJ5dGVzKHJlcXVlc3QpO1xuXHRcdC8vIFNldCBDb250ZW50LUxlbmd0aCBpZiB0b3RhbEJ5dGVzIGlzIGEgbnVtYmVyICh0aGF0IGlzIG5vdCBOYU4pXG5cdFx0aWYgKHR5cGVvZiB0b3RhbEJ5dGVzID09PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzTmFOKHRvdGFsQnl0ZXMpKSB7XG5cdFx0XHRjb250ZW50TGVuZ3RoVmFsdWUgPSBTdHJpbmcodG90YWxCeXRlcyk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNvbnRlbnRMZW5ndGhWYWx1ZSkge1xuXHRcdGhlYWRlcnMuc2V0KCdDb250ZW50LUxlbmd0aCcsIGNvbnRlbnRMZW5ndGhWYWx1ZSk7XG5cdH1cblxuXHQvLyA0LjEuIE1haW4gZmV0Y2gsIHN0ZXAgMi42XG5cdC8vID4gSWYgcmVxdWVzdCdzIHJlZmVycmVyIHBvbGljeSBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNldCByZXF1ZXN0J3MgcmVmZXJyZXIgcG9saWN5IHRvIHRoZVxuXHQvLyA+IGRlZmF1bHQgcmVmZXJyZXIgcG9saWN5LlxuXHRpZiAocmVxdWVzdC5yZWZlcnJlclBvbGljeSA9PT0gJycpIHtcblx0XHRyZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gREVGQVVMVF9SRUZFUlJFUl9QT0xJQ1k7XG5cdH1cblxuXHQvLyA0LjEuIE1haW4gZmV0Y2gsIHN0ZXAgMi43XG5cdC8vID4gSWYgcmVxdWVzdCdzIHJlZmVycmVyIGlzIG5vdCBcIm5vLXJlZmVycmVyXCIsIHNldCByZXF1ZXN0J3MgcmVmZXJyZXIgdG8gdGhlIHJlc3VsdCBvZiBpbnZva2luZ1xuXHQvLyA+IGRldGVybWluZSByZXF1ZXN0J3MgcmVmZXJyZXIuXG5cdGlmIChyZXF1ZXN0LnJlZmVycmVyICYmIHJlcXVlc3QucmVmZXJyZXIgIT09ICduby1yZWZlcnJlcicpIHtcblx0XHRyZXF1ZXN0W0lOVEVSTkFMU10ucmVmZXJyZXIgPSBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyKHJlcXVlc3QpO1xuXHR9IGVsc2Uge1xuXHRcdHJlcXVlc3RbSU5URVJOQUxTXS5yZWZlcnJlciA9ICduby1yZWZlcnJlcic7XG5cdH1cblxuXHQvLyA0LjUuIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCwgc3RlcCA2Ljlcblx0Ly8gPiBJZiBodHRwUmVxdWVzdCdzIHJlZmVycmVyIGlzIGEgVVJMLCB0aGVuIGFwcGVuZCBgUmVmZXJlcmAvaHR0cFJlcXVlc3QncyByZWZlcnJlciwgc2VyaWFsaXplZFxuXHQvLyA+ICBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLCB0byBodHRwUmVxdWVzdCdzIGhlYWRlciBsaXN0LlxuXHRpZiAocmVxdWVzdFtJTlRFUk5BTFNdLnJlZmVycmVyIGluc3RhbmNlb2YgVVJMKSB7XG5cdFx0aGVhZGVycy5zZXQoJ1JlZmVyZXInLCByZXF1ZXN0LnJlZmVycmVyKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwIDIuMTFcblx0aWYgKCFoZWFkZXJzLmhhcygnVXNlci1BZ2VudCcpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ1VzZXItQWdlbnQnLCAnbm9kZS1mZXRjaCcpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXAgMi4xNVxuXHRpZiAocmVxdWVzdC5jb21wcmVzcyAmJiAhaGVhZGVycy5oYXMoJ0FjY2VwdC1FbmNvZGluZycpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0FjY2VwdC1FbmNvZGluZycsICdnemlwLCBkZWZsYXRlLCBicicpO1xuXHR9XG5cblx0bGV0IHthZ2VudH0gPSByZXF1ZXN0O1xuXHRpZiAodHlwZW9mIGFnZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0YWdlbnQgPSBhZ2VudChwYXJzZWRVUkwpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgNC4yXG5cdC8vIGNodW5rZWQgZW5jb2RpbmcgaXMgaGFuZGxlZCBieSBOb2RlLmpzXG5cblx0Y29uc3Qgc2VhcmNoID0gZ2V0U2VhcmNoKHBhcnNlZFVSTCk7XG5cblx0Ly8gUGFzcyB0aGUgZnVsbCBVUkwgZGlyZWN0bHkgdG8gcmVxdWVzdCgpLCBidXQgb3ZlcndyaXRlIHRoZSBmb2xsb3dpbmdcblx0Ly8gb3B0aW9uczpcblx0Y29uc3Qgb3B0aW9ucyA9IHtcblx0XHQvLyBPdmVyd3JpdGUgc2VhcmNoIHRvIHJldGFpbiB0cmFpbGluZyA/IChpc3N1ZSAjNzc2KVxuXHRcdHBhdGg6IHBhcnNlZFVSTC5wYXRobmFtZSArIHNlYXJjaCxcblx0XHQvLyBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIG5vdCBleHByZXNzZWQgaW4gdGhlIFVSTFxuXHRcdG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG5cdFx0aGVhZGVyczogaGVhZGVyc1tTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpLFxuXHRcdGluc2VjdXJlSFRUUFBhcnNlcjogcmVxdWVzdC5pbnNlY3VyZUhUVFBQYXJzZXIsXG5cdFx0YWdlbnRcblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdC8qKiBAdHlwZSB7VVJMfSAqL1xuXHRcdHBhcnNlZFVSTCxcblx0XHRvcHRpb25zXG5cdH07XG59O1xuIiwgImV4cG9ydCBjb25zdCBnZXRTZWFyY2ggPSBwYXJzZWRVUkwgPT4ge1xuXHRpZiAocGFyc2VkVVJMLnNlYXJjaCkge1xuXHRcdHJldHVybiBwYXJzZWRVUkwuc2VhcmNoO1xuXHR9XG5cblx0Y29uc3QgbGFzdE9mZnNldCA9IHBhcnNlZFVSTC5ocmVmLmxlbmd0aCAtIDE7XG5cdGNvbnN0IGhhc2ggPSBwYXJzZWRVUkwuaGFzaCB8fCAocGFyc2VkVVJMLmhyZWZbbGFzdE9mZnNldF0gPT09ICcjJyA/ICcjJyA6ICcnKTtcblx0cmV0dXJuIHBhcnNlZFVSTC5ocmVmW2xhc3RPZmZzZXQgLSBoYXNoLmxlbmd0aF0gPT09ICc/JyA/ICc/JyA6ICcnO1xufTtcbiIsICJpbXBvcnQge2lzSVB9IGZyb20gJ25vZGU6bmV0JztcblxuLyoqXG4gKiBAZXh0ZXJuYWwgVVJMXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJMfFVSTH1cbiAqL1xuXG4vKipcbiAqIEBtb2R1bGUgdXRpbHMvcmVmZXJyZXJcbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc3RyaXAtdXJsfFJlZmVycmVyIFBvbGljeSBcdTAwQTc4LjQuIFN0cmlwIHVybCBmb3IgdXNlIGFzIGEgcmVmZXJyZXJ9XG4gKiBAcGFyYW0ge3N0cmluZ30gVVJMXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcmlnaW5Pbmx5PWZhbHNlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBVUkxGb3JVc2VBc0FSZWZlcnJlcih1cmwsIG9yaWdpbk9ubHkgPSBmYWxzZSkge1xuXHQvLyAxLiBJZiB1cmwgaXMgbnVsbCwgcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRpZiAodXJsID09IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0fVxuXG5cdHVybCA9IG5ldyBVUkwodXJsKTtcblxuXHQvLyAyLiBJZiB1cmwncyBzY2hlbWUgaXMgYSBsb2NhbCBzY2hlbWUsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRpZiAoL14oYWJvdXR8YmxvYnxkYXRhKTokLy50ZXN0KHVybC5wcm90b2NvbCkpIHtcblx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0fVxuXG5cdC8vIDMuIFNldCB1cmwncyB1c2VybmFtZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuXHR1cmwudXNlcm5hbWUgPSAnJztcblxuXHQvLyA0LiBTZXQgdXJsJ3MgcGFzc3dvcmQgdG8gbnVsbC5cblx0Ly8gTm90ZTogYG51bGxgIGFwcGVhcnMgdG8gYmUgYSBtaXN0YWtlIGFzIHRoaXMgYWN0dWFsbHkgcmVzdWx0cyBpbiB0aGUgcGFzc3dvcmQgYmVpbmcgYFwibnVsbFwiYC5cblx0dXJsLnBhc3N3b3JkID0gJyc7XG5cblx0Ly8gNS4gU2V0IHVybCdzIGZyYWdtZW50IHRvIG51bGwuXG5cdC8vIE5vdGU6IGBudWxsYCBhcHBlYXJzIHRvIGJlIGEgbWlzdGFrZSBhcyB0aGlzIGFjdHVhbGx5IHJlc3VsdHMgaW4gdGhlIGZyYWdtZW50IGJlaW5nIGBcIiNudWxsXCJgLlxuXHR1cmwuaGFzaCA9ICcnO1xuXG5cdC8vIDYuIElmIHRoZSBvcmlnaW4tb25seSBmbGFnIGlzIHRydWUsIHRoZW46XG5cdGlmIChvcmlnaW5Pbmx5KSB7XG5cdFx0Ly8gNi4xLiBTZXQgdXJsJ3MgcGF0aCB0byBudWxsLlxuXHRcdC8vIE5vdGU6IGBudWxsYCBhcHBlYXJzIHRvIGJlIGEgbWlzdGFrZSBhcyB0aGlzIGFjdHVhbGx5IHJlc3VsdHMgaW4gdGhlIHBhdGggYmVpbmcgYFwiL251bGxcImAuXG5cdFx0dXJsLnBhdGhuYW1lID0gJyc7XG5cblx0XHQvLyA2LjIuIFNldCB1cmwncyBxdWVyeSB0byBudWxsLlxuXHRcdC8vIE5vdGU6IGBudWxsYCBhcHBlYXJzIHRvIGJlIGEgbWlzdGFrZSBhcyB0aGlzIGFjdHVhbGx5IHJlc3VsdHMgaW4gdGhlIHF1ZXJ5IGJlaW5nIGBcIj9udWxsXCJgLlxuXHRcdHVybC5zZWFyY2ggPSAnJztcblx0fVxuXG5cdC8vIDcuIFJldHVybiB1cmwuXG5cdHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI2VudW1kZWYtcmVmZXJyZXJwb2xpY3l8ZW51bSBSZWZlcnJlclBvbGljeX1cbiAqL1xuZXhwb3J0IGNvbnN0IFJlZmVycmVyUG9saWN5ID0gbmV3IFNldChbXG5cdCcnLFxuXHQnbm8tcmVmZXJyZXInLFxuXHQnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnLFxuXHQnc2FtZS1vcmlnaW4nLFxuXHQnb3JpZ2luJyxcblx0J3N0cmljdC1vcmlnaW4nLFxuXHQnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcblx0J3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nLFxuXHQndW5zYWZlLXVybCdcbl0pO1xuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNkZWZhdWx0LXJlZmVycmVyLXBvbGljeXxkZWZhdWx0IHJlZmVycmVyIHBvbGljeX1cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVGRVJSRVJfUE9MSUNZID0gJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nO1xuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY2llc3xSZWZlcnJlciBQb2xpY3kgXHUwMEE3My4gUmVmZXJyZXIgUG9saWNpZXN9XG4gKiBAcGFyYW0ge3N0cmluZ30gcmVmZXJyZXJQb2xpY3lcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHJlZmVycmVyUG9saWN5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJlZmVycmVyUG9saWN5KHJlZmVycmVyUG9saWN5KSB7XG5cdGlmICghUmVmZXJyZXJQb2xpY3kuaGFzKHJlZmVycmVyUG9saWN5KSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcmVmZXJyZXJQb2xpY3k6ICR7cmVmZXJyZXJQb2xpY3l9YCk7XG5cdH1cblxuXHRyZXR1cm4gcmVmZXJyZXJQb2xpY3k7XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zZWN1cmUtY29udGV4dHMvI2lzLW9yaWdpbi10cnVzdHdvcnRoeXxSZWZlcnJlciBQb2xpY3kgXHUwMEE3My4yLiBJcyBvcmlnaW4gcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHk/fVxuICogQHBhcmFtIHtleHRlcm5hbDpVUkx9IHVybFxuICogQHJldHVybnMgYHRydWVgOiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIsIGBmYWxzZWA6IFwiTm90IFRydXN0d29ydGh5XCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwpIHtcblx0Ly8gMS4gSWYgb3JpZ2luIGlzIGFuIG9wYXF1ZSBvcmlnaW4sIHJldHVybiBcIk5vdCBUcnVzdHdvcnRoeVwiLlxuXHQvLyBOb3QgYXBwbGljYWJsZVxuXG5cdC8vIDIuIEFzc2VydDogb3JpZ2luIGlzIGEgdHVwbGUgb3JpZ2luLlxuXHQvLyBOb3QgZm9yIGltcGxlbWVudGF0aW9uc1xuXG5cdC8vIDMuIElmIG9yaWdpbidzIHNjaGVtZSBpcyBlaXRoZXIgXCJodHRwc1wiIG9yIFwid3NzXCIsIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG5cdGlmICgvXihodHRwfHdzKXM6JC8udGVzdCh1cmwucHJvdG9jb2wpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyA0LiBJZiBvcmlnaW4ncyBob3N0IGNvbXBvbmVudCBtYXRjaGVzIG9uZSBvZiB0aGUgQ0lEUiBub3RhdGlvbnMgMTI3LjAuMC4wLzggb3IgOjoxLzEyOCBbUkZDNDYzMl0sIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG5cdGNvbnN0IGhvc3RJcCA9IHVybC5ob3N0LnJlcGxhY2UoLyheXFxbKXwoXSQpL2csICcnKTtcblx0Y29uc3QgaG9zdElQVmVyc2lvbiA9IGlzSVAoaG9zdElwKTtcblxuXHRpZiAoaG9zdElQVmVyc2lvbiA9PT0gNCAmJiAvXjEyN1xcLi8udGVzdChob3N0SXApKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoaG9zdElQVmVyc2lvbiA9PT0gNiAmJiAvXigoKDArOil7N30pfCg6OigwKzopezAsNn0pKTAqMSQvLnRlc3QoaG9zdElwKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gNS4gSWYgb3JpZ2luJ3MgaG9zdCBjb21wb25lbnQgaXMgXCJsb2NhbGhvc3RcIiBvciBmYWxscyB3aXRoaW4gXCIubG9jYWxob3N0XCIsIGFuZCB0aGUgdXNlciBhZ2VudCBjb25mb3JtcyB0byB0aGUgbmFtZSByZXNvbHV0aW9uIHJ1bGVzIGluIFtsZXQtbG9jYWxob3N0LWJlLWxvY2FsaG9zdF0sIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG5cdC8vIFdlIGFyZSByZXR1cm5pbmcgRkFMU0UgaGVyZSBiZWNhdXNlIHdlIGNhbm5vdCBlbnN1cmUgY29uZm9ybWFuY2UgdG9cblx0Ly8gbGV0LWxvY2FsaG9zdC1iZS1sb2FsaG9zdCAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXdlc3QtbGV0LWxvY2FsaG9zdC1iZS1sb2NhbGhvc3QpXG5cdGlmICh1cmwuaG9zdCA9PT0gJ2xvY2FsaG9zdCcgfHwgdXJsLmhvc3QuZW5kc1dpdGgoJy5sb2NhbGhvc3QnKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIDYuIElmIG9yaWdpbidzIHNjaGVtZSBjb21wb25lbnQgaXMgZmlsZSwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0aWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gNy4gSWYgb3JpZ2luJ3Mgc2NoZW1lIGNvbXBvbmVudCBpcyBvbmUgd2hpY2ggdGhlIHVzZXIgYWdlbnQgY29uc2lkZXJzIHRvIGJlIGF1dGhlbnRpY2F0ZWQsIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG5cdC8vIE5vdCBzdXBwb3J0ZWRcblxuXHQvLyA4LiBJZiBvcmlnaW4gaGFzIGJlZW4gY29uZmlndXJlZCBhcyBhIHRydXN0d29ydGh5IG9yaWdpbiwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0Ly8gTm90IHN1cHBvcnRlZFxuXG5cdC8vIDkuIFJldHVybiBcIk5vdCBUcnVzdHdvcnRoeVwiLlxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zZWN1cmUtY29udGV4dHMvI2lzLXVybC10cnVzdHdvcnRoeXxSZWZlcnJlciBQb2xpY3kgXHUwMEE3My4zLiBJcyB1cmwgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHk/fVxuICogQHBhcmFtIHtleHRlcm5hbDpVUkx9IHVybFxuICogQHJldHVybnMgYHRydWVgOiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIsIGBmYWxzZWA6IFwiTm90IFRydXN0d29ydGh5XCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwpIHtcblx0Ly8gMS4gSWYgdXJsIGlzIFwiYWJvdXQ6YmxhbmtcIiBvciBcImFib3V0OnNyY2RvY1wiLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAoL15hYm91dDooYmxhbmt8c3JjZG9jKSQvLnRlc3QodXJsKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gMi4gSWYgdXJsJ3Mgc2NoZW1lIGlzIFwiZGF0YVwiLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAodXJsLnByb3RvY29sID09PSAnZGF0YTonKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBOb3RlOiBUaGUgb3JpZ2luIG9mIGJsb2I6IGFuZCBmaWxlc3lzdGVtOiBVUkxzIGlzIHRoZSBvcmlnaW4gb2YgdGhlIGNvbnRleHQgaW4gd2hpY2ggdGhleSB3ZXJlXG5cdC8vIGNyZWF0ZWQuIFRoZXJlZm9yZSwgYmxvYnMgY3JlYXRlZCBpbiBhIHRydXN0d29ydGh5IG9yaWdpbiB3aWxsIHRoZW1zZWx2ZXMgYmUgcG90ZW50aWFsbHlcblx0Ly8gdHJ1c3R3b3J0aHkuXG5cdGlmICgvXihibG9ifGZpbGVzeXN0ZW0pOiQvLnRlc3QodXJsLnByb3RvY29sKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gMy4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIFx1MDBBNzMuMiBJcyBvcmlnaW4gcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHk/IG9uIHVybCdzIG9yaWdpbi5cblx0cmV0dXJuIGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwpO1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSByZWZlcnJlclVSTCB0byBlbmZvcmNlIGFueSBleHRyYSBzZWN1cml0eSBwb2xpY3kgY29uc2lkZXJhdGlvbnMuXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyfFJlZmVycmVyIFBvbGljeSBcdTAwQTc4LjMuIERldGVybWluZSByZXF1ZXN0J3MgUmVmZXJyZXJ9LCBzdGVwIDdcbiAqIEBjYWxsYmFjayBtb2R1bGU6dXRpbHMvcmVmZXJyZXJ+cmVmZXJyZXJVUkxDYWxsYmFja1xuICogQHBhcmFtIHtleHRlcm5hbDpVUkx9IHJlZmVycmVyVVJMXG4gKiBAcmV0dXJucyB7ZXh0ZXJuYWw6VVJMfSBtb2RpZmllZCByZWZlcnJlclVSTFxuICovXG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHJlZmVycmVyT3JpZ2luIHRvIGVuZm9yY2UgYW55IGV4dHJhIHNlY3VyaXR5IHBvbGljeSBjb25zaWRlcmF0aW9ucy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNkZXRlcm1pbmUtcmVxdWVzdHMtcmVmZXJyZXJ8UmVmZXJyZXIgUG9saWN5IFx1MDBBNzguMy4gRGV0ZXJtaW5lIHJlcXVlc3QncyBSZWZlcnJlcn0sIHN0ZXAgN1xuICogQGNhbGxiYWNrIG1vZHVsZTp1dGlscy9yZWZlcnJlcn5yZWZlcnJlck9yaWdpbkNhbGxiYWNrXG4gKiBAcGFyYW0ge2V4dGVybmFsOlVSTH0gcmVmZXJyZXJPcmlnaW5cbiAqIEByZXR1cm5zIHtleHRlcm5hbDpVUkx9IG1vZGlmaWVkIHJlZmVycmVyT3JpZ2luXG4gKi9cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyfFJlZmVycmVyIFBvbGljeSBcdTAwQTc4LjMuIERldGVybWluZSByZXF1ZXN0J3MgUmVmZXJyZXJ9XG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiBAcGFyYW0ge21vZHVsZTp1dGlscy9yZWZlcnJlcn5yZWZlcnJlclVSTENhbGxiYWNrfSBvLnJlZmVycmVyVVJMQ2FsbGJhY2tcbiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3JlZmVycmVyfnJlZmVycmVyT3JpZ2luQ2FsbGJhY2t9IG8ucmVmZXJyZXJPcmlnaW5DYWxsYmFja1xuICogQHJldHVybnMge2V4dGVybmFsOlVSTH0gUmVxdWVzdCdzIHJlZmVycmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyKHJlcXVlc3QsIHtyZWZlcnJlclVSTENhbGxiYWNrLCByZWZlcnJlck9yaWdpbkNhbGxiYWNrfSA9IHt9KSB7XG5cdC8vIFRoZXJlIGFyZSAyIG5vdGVzIGluIHRoZSBzcGVjaWZpY2F0aW9uIGFib3V0IGludmFsaWQgcHJlLWNvbmRpdGlvbnMuICBXZSByZXR1cm4gbnVsbCwgaGVyZSwgZm9yXG5cdC8vIHRoZXNlIGNhc2VzOlxuXHQvLyA+IE5vdGU6IElmIHJlcXVlc3QncyByZWZlcnJlciBpcyBcIm5vLXJlZmVycmVyXCIsIEZldGNoIHdpbGwgbm90IGNhbGwgaW50byB0aGlzIGFsZ29yaXRobS5cblx0Ly8gPiBOb3RlOiBJZiByZXF1ZXN0J3MgcmVmZXJyZXIgcG9saWN5IGlzIHRoZSBlbXB0eSBzdHJpbmcsIEZldGNoIHdpbGwgbm90IGNhbGwgaW50byB0aGlzXG5cdC8vID4gYWxnb3JpdGhtLlxuXHRpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJyB8fCByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID09PSAnJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gMS4gTGV0IHBvbGljeSBiZSByZXF1ZXN0J3MgYXNzb2NpYXRlZCByZWZlcnJlciBwb2xpY3kuXG5cdGNvbnN0IHBvbGljeSA9IHJlcXVlc3QucmVmZXJyZXJQb2xpY3k7XG5cblx0Ly8gMi4gTGV0IGVudmlyb25tZW50IGJlIHJlcXVlc3QncyBjbGllbnQuXG5cdC8vIG5vdCBhcHBsaWNhYmxlIHRvIG5vZGUuanNcblxuXHQvLyAzLiBTd2l0Y2ggb24gcmVxdWVzdCdzIHJlZmVycmVyOlxuXHRpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ2Fib3V0OmNsaWVudCcpIHtcblx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0fVxuXG5cdC8vIFwiYSBVUkxcIjogTGV0IHJlZmVycmVyU291cmNlIGJlIHJlcXVlc3QncyByZWZlcnJlci5cblx0Y29uc3QgcmVmZXJyZXJTb3VyY2UgPSByZXF1ZXN0LnJlZmVycmVyO1xuXG5cdC8vIDQuIExldCByZXF1ZXN0J3MgcmVmZXJyZXJVUkwgYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yIHVzZSBhcyBhIHJlZmVycmVyLlxuXHRsZXQgcmVmZXJyZXJVUkwgPSBzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyKHJlZmVycmVyU291cmNlKTtcblxuXHQvLyA1LiBMZXQgcmVmZXJyZXJPcmlnaW4gYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yIHVzZSBhcyBhIHJlZmVycmVyLCB3aXRoIHRoZVxuXHQvLyAgICBvcmlnaW4tb25seSBmbGFnIHNldCB0byB0cnVlLlxuXHRsZXQgcmVmZXJyZXJPcmlnaW4gPSBzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyKHJlZmVycmVyU291cmNlLCB0cnVlKTtcblxuXHQvLyA2LiBJZiB0aGUgcmVzdWx0IG9mIHNlcmlhbGl6aW5nIHJlZmVycmVyVVJMIGlzIGEgc3RyaW5nIHdob3NlIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gNDA5Niwgc2V0XG5cdC8vICAgIHJlZmVycmVyVVJMIHRvIHJlZmVycmVyT3JpZ2luLlxuXHRpZiAocmVmZXJyZXJVUkwudG9TdHJpbmcoKS5sZW5ndGggPiA0MDk2KSB7XG5cdFx0cmVmZXJyZXJVUkwgPSByZWZlcnJlck9yaWdpbjtcblx0fVxuXG5cdC8vIDcuIFRoZSB1c2VyIGFnZW50IE1BWSBhbHRlciByZWZlcnJlclVSTCBvciByZWZlcnJlck9yaWdpbiBhdCB0aGlzIHBvaW50IHRvIGVuZm9yY2UgYXJiaXRyYXJ5XG5cdC8vICAgIHBvbGljeSBjb25zaWRlcmF0aW9ucyBpbiB0aGUgaW50ZXJlc3RzIG9mIG1pbmltaXppbmcgZGF0YSBsZWFrYWdlLiBGb3IgZXhhbXBsZSwgdGhlIHVzZXJcblx0Ly8gICAgYWdlbnQgY291bGQgc3RyaXAgdGhlIFVSTCBkb3duIHRvIGFuIG9yaWdpbiwgbW9kaWZ5IGl0cyBob3N0LCByZXBsYWNlIGl0IHdpdGggYW4gZW1wdHlcblx0Ly8gICAgc3RyaW5nLCBldGMuXG5cdGlmIChyZWZlcnJlclVSTENhbGxiYWNrKSB7XG5cdFx0cmVmZXJyZXJVUkwgPSByZWZlcnJlclVSTENhbGxiYWNrKHJlZmVycmVyVVJMKTtcblx0fVxuXG5cdGlmIChyZWZlcnJlck9yaWdpbkNhbGxiYWNrKSB7XG5cdFx0cmVmZXJyZXJPcmlnaW4gPSByZWZlcnJlck9yaWdpbkNhbGxiYWNrKHJlZmVycmVyT3JpZ2luKTtcblx0fVxuXG5cdC8vIDguRXhlY3V0ZSB0aGUgc3RhdGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSB2YWx1ZSBvZiBwb2xpY3k6XG5cdGNvbnN0IGN1cnJlbnRVUkwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcblxuXHRzd2l0Y2ggKHBvbGljeSkge1xuXHRcdGNhc2UgJ25vLXJlZmVycmVyJzpcblx0XHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXG5cdFx0Y2FzZSAnb3JpZ2luJzpcblx0XHRcdHJldHVybiByZWZlcnJlck9yaWdpbjtcblxuXHRcdGNhc2UgJ3Vuc2FmZS11cmwnOlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXG5cdFx0Y2FzZSAnc3RyaWN0LW9yaWdpbic6XG5cdFx0XHQvLyAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGlzIG5vdCBhXG5cdFx0XHQvLyAgICBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRcdFx0aWYgKGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuXHRcdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luLlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyT3JpZ2luLnRvU3RyaW5nKCk7XG5cblx0XHRjYXNlICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcblx0XHRcdC8vIDEuIElmIHRoZSBvcmlnaW4gb2YgcmVmZXJyZXJVUkwgYW5kIHRoZSBvcmlnaW4gb2YgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGFyZSB0aGUgc2FtZSwgdGhlblxuXHRcdFx0Ly8gICAgcmV0dXJuIHJlZmVycmVyVVJMLlxuXHRcdFx0aWYgKHJlZmVycmVyVVJMLm9yaWdpbiA9PT0gY3VycmVudFVSTC5vcmlnaW4pIHtcblx0XHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAyLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGlzIG5vdCBhXG5cdFx0XHQvLyAgICBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRcdFx0aWYgKGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuXHRcdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gMy4gUmV0dXJuIHJlZmVycmVyT3JpZ2luLlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyT3JpZ2luO1xuXG5cdFx0Y2FzZSAnc2FtZS1vcmlnaW4nOlxuXHRcdFx0Ly8gMS4gSWYgdGhlIG9yaWdpbiBvZiByZWZlcnJlclVSTCBhbmQgdGhlIG9yaWdpbiBvZiByZXF1ZXN0J3MgY3VycmVudCBVUkwgYXJlIHRoZSBzYW1lLCB0aGVuXG5cdFx0XHQvLyAgICByZXR1cm4gcmVmZXJyZXJVUkwuXG5cdFx0XHRpZiAocmVmZXJyZXJVUkwub3JpZ2luID09PSBjdXJyZW50VVJMLm9yaWdpbikge1xuXHRcdFx0XHRyZXR1cm4gcmVmZXJyZXJVUkw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDIuIFJldHVybiBubyByZWZlcnJlci5cblx0XHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXG5cdFx0Y2FzZSAnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcblx0XHRcdC8vIDEuIElmIHRoZSBvcmlnaW4gb2YgcmVmZXJyZXJVUkwgYW5kIHRoZSBvcmlnaW4gb2YgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGFyZSB0aGUgc2FtZSwgdGhlblxuXHRcdFx0Ly8gICAgcmV0dXJuIHJlZmVycmVyVVJMLlxuXHRcdFx0aWYgKHJlZmVycmVyVVJMLm9yaWdpbiA9PT0gY3VycmVudFVSTC5vcmlnaW4pIHtcblx0XHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG5cdFx0XHRyZXR1cm4gcmVmZXJyZXJPcmlnaW47XG5cblx0XHRjYXNlICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZSc6XG5cdFx0XHQvLyAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGlzIG5vdCBhXG5cdFx0XHQvLyAgICBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRcdFx0aWYgKGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuXHRcdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gMi4gUmV0dXJuIHJlZmVycmVyVVJMLlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcmVmZXJyZXJQb2xpY3k6ICR7cG9saWN5fWApO1xuXHR9XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3BhcnNlLXJlZmVycmVyLXBvbGljeS1mcm9tLWhlYWRlcnxSZWZlcnJlciBQb2xpY3kgXHUwMEE3OC4xLiBQYXJzZSBhIHJlZmVycmVyIHBvbGljeSBmcm9tIGEgUmVmZXJyZXItUG9saWN5IGhlYWRlcn1cbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVycyBSZXNwb25zZSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwb2xpY3lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVmZXJyZXJQb2xpY3lGcm9tSGVhZGVyKGhlYWRlcnMpIHtcblx0Ly8gMS4gTGV0IHBvbGljeS10b2tlbnMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlcyBnaXZlbiBgUmVmZXJyZXItUG9saWN5YFxuXHQvLyAgICBhbmQgcmVzcG9uc2VcdTIwMTlzIGhlYWRlciBsaXN0LlxuXHRjb25zdCBwb2xpY3lUb2tlbnMgPSAoaGVhZGVycy5nZXQoJ3JlZmVycmVyLXBvbGljeScpIHx8ICcnKS5zcGxpdCgvWyxcXHNdKy8pO1xuXG5cdC8vIDIuIExldCBwb2xpY3kgYmUgdGhlIGVtcHR5IHN0cmluZy5cblx0bGV0IHBvbGljeSA9ICcnO1xuXG5cdC8vIDMuIEZvciBlYWNoIHRva2VuIGluIHBvbGljeS10b2tlbnMsIGlmIHRva2VuIGlzIGEgcmVmZXJyZXIgcG9saWN5IGFuZCB0b2tlbiBpcyBub3QgdGhlIGVtcHR5XG5cdC8vICAgIHN0cmluZywgdGhlbiBzZXQgcG9saWN5IHRvIHRva2VuLlxuXHQvLyBOb3RlOiBUaGlzIGFsZ29yaXRobSBsb29wcyBvdmVyIG11bHRpcGxlIHBvbGljeSB2YWx1ZXMgdG8gYWxsb3cgZGVwbG95bWVudCBvZiBuZXcgcG9saWN5XG5cdC8vIHZhbHVlcyB3aXRoIGZhbGxiYWNrcyBmb3Igb2xkZXIgdXNlciBhZ2VudHMsIGFzIGRlc2NyaWJlZCBpbiBcdTAwQTcgMTEuMSBVbmtub3duIFBvbGljeSBWYWx1ZXMuXG5cdGZvciAoY29uc3QgdG9rZW4gb2YgcG9saWN5VG9rZW5zKSB7XG5cdFx0aWYgKHRva2VuICYmIFJlZmVycmVyUG9saWN5Lmhhcyh0b2tlbikpIHtcblx0XHRcdHBvbGljeSA9IHRva2VuO1xuXHRcdH1cblx0fVxuXG5cdC8vIDQuIFJldHVybiBwb2xpY3kuXG5cdHJldHVybiBwb2xpY3k7XG59XG4iLCAiaW1wb3J0IHtGZXRjaEJhc2VFcnJvcn0gZnJvbSAnLi9iYXNlLmpzJztcblxuLyoqXG4gKiBBYm9ydEVycm9yIGludGVyZmFjZSBmb3IgY2FuY2VsbGVkIHJlcXVlc3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgRmV0Y2hCYXNlRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlID0gJ2Fib3J0ZWQnKSB7XG5cdFx0c3VwZXIobWVzc2FnZSwgdHlwZSk7XG5cdH1cbn1cbiIsICJjbGFzcyBDc3ZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgb3B0aW9ucywgLi4uY29udGV4dHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSkgbWVzc2FnZSA9IG1lc3NhZ2Uuam9pbihcIiBcIikudHJpbSgpO1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDc3ZFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgZm9yIChjb25zdCBjb250ZXh0IG9mIGNvbnRleHRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dFtrZXldO1xuICAgICAgICB0aGlzW2tleV0gPSBCdWZmZXIuaXNCdWZmZXIodmFsdWUpXG4gICAgICAgICAgPyB2YWx1ZS50b1N0cmluZyhvcHRpb25zLmVuY29kaW5nKVxuICAgICAgICAgIDogdmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IENzdkVycm9yIH07XG4iLCAiY29uc3QgaXNfb2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn07XG5cbmV4cG9ydCB7IGlzX29iamVjdCB9O1xuIiwgImltcG9ydCB7IENzdkVycm9yIH0gZnJvbSBcIi4vQ3N2RXJyb3IuanNcIjtcbmltcG9ydCB7IGlzX29iamVjdCB9IGZyb20gXCIuLi91dGlscy9pc19vYmplY3QuanNcIjtcblxuY29uc3Qgbm9ybWFsaXplX2NvbHVtbnNfYXJyYXkgPSBmdW5jdGlvbiAoY29sdW1ucykge1xuICBjb25zdCBub3JtYWxpemVkQ29sdW1ucyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgY29sdW1uID0gY29sdW1uc1tpXTtcbiAgICBpZiAoY29sdW1uID09PSB1bmRlZmluZWQgfHwgY29sdW1uID09PSBudWxsIHx8IGNvbHVtbiA9PT0gZmFsc2UpIHtcbiAgICAgIG5vcm1hbGl6ZWRDb2x1bW5zW2ldID0geyBkaXNhYmxlZDogdHJ1ZSB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbm9ybWFsaXplZENvbHVtbnNbaV0gPSB7IG5hbWU6IGNvbHVtbiB9O1xuICAgIH0gZWxzZSBpZiAoaXNfb2JqZWN0KGNvbHVtbikpIHtcbiAgICAgIGlmICh0eXBlb2YgY29sdW1uLm5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IENzdkVycm9yKFwiQ1NWX09QVElPTl9DT0xVTU5TX01JU1NJTkdfTkFNRVwiLCBbXG4gICAgICAgICAgXCJPcHRpb24gY29sdW1ucyBtaXNzaW5nIG5hbWU6XCIsXG4gICAgICAgICAgYHByb3BlcnR5IFwibmFtZVwiIGlzIHJlcXVpcmVkIGF0IHBvc2l0aW9uICR7aX1gLFxuICAgICAgICAgIFwid2hlbiBjb2x1bW4gaXMgYW4gb2JqZWN0IGxpdGVyYWxcIixcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICBub3JtYWxpemVkQ29sdW1uc1tpXSA9IGNvbHVtbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IENzdkVycm9yKFwiQ1NWX0lOVkFMSURfQ09MVU1OX0RFRklOSVRJT05cIiwgW1xuICAgICAgICBcIkludmFsaWQgY29sdW1uIGRlZmluaXRpb246XCIsXG4gICAgICAgIFwiZXhwZWN0IGEgc3RyaW5nIG9yIGEgbGl0ZXJhbCBvYmplY3QsXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShjb2x1bW4pfSBhdCBwb3NpdGlvbiAke2l9YCxcbiAgICAgIF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZENvbHVtbnM7XG59O1xuXG5leHBvcnQgeyBub3JtYWxpemVfY29sdW1uc19hcnJheSB9O1xuIiwgImNsYXNzIFJlc2l6ZWFibGVCdWZmZXIge1xuICBjb25zdHJ1Y3RvcihzaXplID0gMTAwKSB7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gIH1cbiAgcHJlcGVuZCh2YWwpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoICsgdmFsLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPj0gdGhpcy5zaXplKSB7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIGlmIChsZW5ndGggPj0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJJTlZBTElEX0JVRkZFUl9TVEFURVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYnVmID0gdGhpcy5idWY7XG4gICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0aGlzLnNpemUpO1xuICAgICAgdmFsLmNvcHkodGhpcy5idWYsIDApO1xuICAgICAgYnVmLmNvcHkodGhpcy5idWYsIHZhbC5sZW5ndGgpO1xuICAgICAgdGhpcy5sZW5ndGggKz0gdmFsLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgrKztcbiAgICAgIGlmIChsZW5ndGggPT09IHRoaXMuc2l6ZSkge1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmID0gdGhpcy5jbG9uZSgpO1xuICAgICAgdGhpcy5idWZbMF0gPSB2YWw7XG4gICAgICBidWYuY29weSh0aGlzLmJ1ZiwgMSwgMCwgbGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgYXBwZW5kKHZhbCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKys7XG4gICAgaWYgKGxlbmd0aCA9PT0gdGhpcy5zaXplKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZltsZW5ndGhdID0gdmFsO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmJ1Zi5zbGljZSgwLCB0aGlzLmxlbmd0aCkpO1xuICB9XG4gIHJlc2l6ZSgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB0aGlzLnNpemUgPSB0aGlzLnNpemUgKiAyO1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0aGlzLnNpemUpO1xuICAgIHRoaXMuYnVmLmNvcHkoYnVmLCAwLCAwLCBsZW5ndGgpO1xuICAgIHRoaXMuYnVmID0gYnVmO1xuICB9XG4gIHRvU3RyaW5nKGVuY29kaW5nKSB7XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2UoMCwgdGhpcy5sZW5ndGgpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5idWYuc2xpY2UoMCwgdGhpcy5sZW5ndGgpKTtcbiAgICB9XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVzaXplYWJsZUJ1ZmZlcjtcbiIsICJpbXBvcnQgUmVzaXplYWJsZUJ1ZmZlciBmcm9tIFwiLi4vdXRpbHMvUmVzaXplYWJsZUJ1ZmZlci5qc1wiO1xuXG4vLyB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaGl0ZXNwYWNlX2NoYXJhY3RlclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zL0NoYXJhY3Rlcl9DbGFzc2VzI1R5cGVzXG4vLyBcXGZcXG5cXHJcXHRcXHZcXHUwMGEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMjhcXHUyMDI5XFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZlxuY29uc3QgbnAgPSAxMjtcbmNvbnN0IGNyID0gMTM7IC8vIGBcXHJgLCBjYXJyaWFnZSByZXR1cm4sIDB4MEQgaW4gaGV4YWRcdTAwRTljaW1hbCwgMTMgaW4gZGVjaW1hbFxuY29uc3QgbmwgPSAxMDsgLy8gYFxcbmAsIG5ld2xpbmUsIDB4MEEgaW4gaGV4YWRlY2ltYWwsIDEwIGluIGRlY2ltYWxcbmNvbnN0IHNwYWNlID0gMzI7XG5jb25zdCB0YWIgPSA5O1xuXG5jb25zdCBpbml0X3N0YXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBib21Ta2lwcGVkOiBmYWxzZSxcbiAgICBidWZCeXRlc1N0YXJ0OiAwLFxuICAgIGNhc3RGaWVsZDogb3B0aW9ucy5jYXN0X2Z1bmN0aW9uLFxuICAgIGNvbW1lbnRpbmc6IGZhbHNlLFxuICAgIC8vIEN1cnJlbnQgZXJyb3IgZW5jb3VudGVyZWQgYnkgYSByZWNvcmRcbiAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgIGVuYWJsZWQ6IG9wdGlvbnMuZnJvbV9saW5lID09PSAxLFxuICAgIGVzY2FwaW5nOiBmYWxzZSxcbiAgICBlc2NhcGVJc1F1b3RlOlxuICAgICAgQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuZXNjYXBlKSAmJlxuICAgICAgQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMucXVvdGUpICYmXG4gICAgICBCdWZmZXIuY29tcGFyZShvcHRpb25zLmVzY2FwZSwgb3B0aW9ucy5xdW90ZSkgPT09IDAsXG4gICAgLy8gY29sdW1ucyBjYW4gYmUgYGZhbHNlYCwgYHRydWVgLCBgQXJyYXlgXG4gICAgZXhwZWN0ZWRSZWNvcmRMZW5ndGg6IEFycmF5LmlzQXJyYXkob3B0aW9ucy5jb2x1bW5zKVxuICAgICAgPyBvcHRpb25zLmNvbHVtbnMubGVuZ3RoXG4gICAgICA6IHVuZGVmaW5lZCxcbiAgICBmaWVsZDogbmV3IFJlc2l6ZWFibGVCdWZmZXIoMjApLFxuICAgIGZpcnN0TGluZVRvSGVhZGVyczogb3B0aW9ucy5jYXN0X2ZpcnN0X2xpbmVfdG9faGVhZGVyLFxuICAgIG5lZWRNb3JlRGF0YVNpemU6IE1hdGgubWF4KFxuICAgICAgLy8gU2tpcCBpZiB0aGUgcmVtYWluaW5nIGJ1ZmZlciBzbWFsbGVyIHRoYW4gY29tbWVudFxuICAgICAgb3B0aW9ucy5jb21tZW50ICE9PSBudWxsID8gb3B0aW9ucy5jb21tZW50Lmxlbmd0aCA6IDAsXG4gICAgICAvLyBTa2lwIGlmIHRoZSByZW1haW5pbmcgYnVmZmVyIGNhbiBiZSBkZWxpbWl0ZXJcbiAgICAgIC4uLm9wdGlvbnMuZGVsaW1pdGVyLm1hcCgoZGVsaW1pdGVyKSA9PiBkZWxpbWl0ZXIubGVuZ3RoKSxcbiAgICAgIC8vIFNraXAgaWYgdGhlIHJlbWFpbmluZyBidWZmZXIgY2FuIGJlIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgb3B0aW9ucy5xdW90ZSAhPT0gbnVsbCA/IG9wdGlvbnMucXVvdGUubGVuZ3RoIDogMCxcbiAgICApLFxuICAgIHByZXZpb3VzQnVmOiB1bmRlZmluZWQsXG4gICAgcXVvdGluZzogZmFsc2UsXG4gICAgc3RvcDogZmFsc2UsXG4gICAgcmF3QnVmZmVyOiBuZXcgUmVzaXplYWJsZUJ1ZmZlcigxMDApLFxuICAgIHJlY29yZDogW10sXG4gICAgcmVjb3JkSGFzRXJyb3I6IGZhbHNlLFxuICAgIHJlY29yZF9sZW5ndGg6IDAsXG4gICAgcmVjb3JkRGVsaW1pdGVyTWF4TGVuZ3RoOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyLmxlbmd0aCA9PT0gMFxuICAgICAgICA/IDBcbiAgICAgICAgOiBNYXRoLm1heCguLi5vcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIubWFwKCh2KSA9PiB2Lmxlbmd0aCkpLFxuICAgIHRyaW1DaGFyczogW1xuICAgICAgQnVmZmVyLmZyb20oXCIgXCIsIG9wdGlvbnMuZW5jb2RpbmcpWzBdLFxuICAgICAgQnVmZmVyLmZyb20oXCJcXHRcIiwgb3B0aW9ucy5lbmNvZGluZylbMF0sXG4gICAgXSxcbiAgICB3YXNRdW90aW5nOiBmYWxzZSxcbiAgICB3YXNSb3dEZWxpbWl0ZXI6IGZhbHNlLFxuICAgIHRpbWNoYXJzOiBbXG4gICAgICBCdWZmZXIuZnJvbShCdWZmZXIuZnJvbShbY3JdLCBcInV0ZjhcIikudG9TdHJpbmcoKSwgb3B0aW9ucy5lbmNvZGluZyksXG4gICAgICBCdWZmZXIuZnJvbShCdWZmZXIuZnJvbShbbmxdLCBcInV0ZjhcIikudG9TdHJpbmcoKSwgb3B0aW9ucy5lbmNvZGluZyksXG4gICAgICBCdWZmZXIuZnJvbShCdWZmZXIuZnJvbShbbnBdLCBcInV0ZjhcIikudG9TdHJpbmcoKSwgb3B0aW9ucy5lbmNvZGluZyksXG4gICAgICBCdWZmZXIuZnJvbShCdWZmZXIuZnJvbShbc3BhY2VdLCBcInV0ZjhcIikudG9TdHJpbmcoKSwgb3B0aW9ucy5lbmNvZGluZyksXG4gICAgICBCdWZmZXIuZnJvbShCdWZmZXIuZnJvbShbdGFiXSwgXCJ1dGY4XCIpLnRvU3RyaW5nKCksIG9wdGlvbnMuZW5jb2RpbmcpLFxuICAgIF0sXG4gIH07XG59O1xuXG5leHBvcnQgeyBpbml0X3N0YXRlIH07XG4iLCAiY29uc3QgdW5kZXJzY29yZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uIChfLCBtYXRjaCkge1xuICAgIHJldHVybiBcIl9cIiArIG1hdGNoLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufTtcblxuZXhwb3J0IHsgdW5kZXJzY29yZSB9O1xuIiwgImltcG9ydCB7IG5vcm1hbGl6ZV9jb2x1bW5zX2FycmF5IH0gZnJvbSBcIi4vbm9ybWFsaXplX2NvbHVtbnNfYXJyYXkuanNcIjtcbmltcG9ydCB7IENzdkVycm9yIH0gZnJvbSBcIi4vQ3N2RXJyb3IuanNcIjtcbmltcG9ydCB7IHVuZGVyc2NvcmUgfSBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZS5qc1wiO1xuXG5jb25zdCBub3JtYWxpemVfb3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgLy8gTWVyZ2Ugd2l0aCB1c2VyIG9wdGlvbnNcbiAgZm9yIChjb25zdCBvcHQgaW4gb3B0cykge1xuICAgIG9wdGlvbnNbdW5kZXJzY29yZShvcHQpXSA9IG9wdHNbb3B0XTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBlbmNvZGluZ2BcbiAgLy8gTm90ZTogZGVmaW5lZCBmaXJzdCBiZWNhdXNlIG90aGVyIG9wdGlvbnMgZGVwZW5kcyBvbiBpdFxuICAvLyB0byBjb252ZXJ0IGNoYXJzL3N0cmluZ3MgaW50byBidWZmZXJzLlxuICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZW5jb2RpbmcgPT09IHRydWUpIHtcbiAgICBvcHRpb25zLmVuY29kaW5nID0gXCJ1dGY4XCI7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gbnVsbCB8fCBvcHRpb25zLmVuY29kaW5nID09PSBmYWxzZSkge1xuICAgIG9wdGlvbnMuZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKFxuICAgIHR5cGVvZiBvcHRpb25zLmVuY29kaW5nICE9PSBcInN0cmluZ1wiICYmXG4gICAgb3B0aW9ucy5lbmNvZGluZyAhPT0gbnVsbFxuICApIHtcbiAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoXG4gICAgICBcIkNTVl9JTlZBTElEX09QVElPTl9FTkNPRElOR1wiLFxuICAgICAgW1xuICAgICAgICBcIkludmFsaWQgb3B0aW9uIGVuY29kaW5nOlwiLFxuICAgICAgICBcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbCB0byByZXR1cm4gYSBidWZmZXIsXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmVuY29kaW5nKX1gLFxuICAgICAgXSxcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBib21gXG4gIGlmIChcbiAgICBvcHRpb25zLmJvbSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5ib20gPT09IG51bGwgfHxcbiAgICBvcHRpb25zLmJvbSA9PT0gZmFsc2VcbiAgKSB7XG4gICAgb3B0aW9ucy5ib20gPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmJvbSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBDc3ZFcnJvcihcbiAgICAgIFwiQ1NWX0lOVkFMSURfT1BUSU9OX0JPTVwiLFxuICAgICAgW1xuICAgICAgICBcIkludmFsaWQgb3B0aW9uIGJvbTpcIixcbiAgICAgICAgXCJib20gbXVzdCBiZSB0cnVlLFwiLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib20pfWAsXG4gICAgICBdLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGNhc3RgXG4gIG9wdGlvbnMuY2FzdF9mdW5jdGlvbiA9IG51bGw7XG4gIGlmIChcbiAgICBvcHRpb25zLmNhc3QgPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMuY2FzdCA9PT0gbnVsbCB8fFxuICAgIG9wdGlvbnMuY2FzdCA9PT0gZmFsc2UgfHxcbiAgICBvcHRpb25zLmNhc3QgPT09IFwiXCJcbiAgKSB7XG4gICAgb3B0aW9ucy5jYXN0ID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmNhc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIG9wdGlvbnMuY2FzdF9mdW5jdGlvbiA9IG9wdGlvbnMuY2FzdDtcbiAgICBvcHRpb25zLmNhc3QgPSB0cnVlO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuY2FzdCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBDc3ZFcnJvcihcbiAgICAgIFwiQ1NWX0lOVkFMSURfT1BUSU9OX0NBU1RcIixcbiAgICAgIFtcbiAgICAgICAgXCJJbnZhbGlkIG9wdGlvbiBjYXN0OlwiLFxuICAgICAgICBcImNhc3QgbXVzdCBiZSB0cnVlIG9yIGEgZnVuY3Rpb24sXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmNhc3QpfWAsXG4gICAgICBdLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGNhc3RfZGF0ZWBcbiAgaWYgKFxuICAgIG9wdGlvbnMuY2FzdF9kYXRlID09PSB1bmRlZmluZWQgfHxcbiAgICBvcHRpb25zLmNhc3RfZGF0ZSA9PT0gbnVsbCB8fFxuICAgIG9wdGlvbnMuY2FzdF9kYXRlID09PSBmYWxzZSB8fFxuICAgIG9wdGlvbnMuY2FzdF9kYXRlID09PSBcIlwiXG4gICkge1xuICAgIG9wdGlvbnMuY2FzdF9kYXRlID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5jYXN0X2RhdGUgPT09IHRydWUpIHtcbiAgICBvcHRpb25zLmNhc3RfZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY29uc3QgZGF0ZSA9IERhdGUucGFyc2UodmFsdWUpO1xuICAgICAgcmV0dXJuICFpc05hTihkYXRlKSA/IG5ldyBEYXRlKGRhdGUpIDogdmFsdWU7XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5jYXN0X2RhdGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBDc3ZFcnJvcihcbiAgICAgIFwiQ1NWX0lOVkFMSURfT1BUSU9OX0NBU1RfREFURVwiLFxuICAgICAgW1xuICAgICAgICBcIkludmFsaWQgb3B0aW9uIGNhc3RfZGF0ZTpcIixcbiAgICAgICAgXCJjYXN0X2RhdGUgbXVzdCBiZSB0cnVlIG9yIGEgZnVuY3Rpb24sXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmNhc3RfZGF0ZSl9YCxcbiAgICAgIF0sXG4gICAgICBvcHRpb25zLFxuICAgICk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgY29sdW1uc2BcbiAgb3B0aW9ucy5jYXN0X2ZpcnN0X2xpbmVfdG9faGVhZGVyID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuY29sdW1ucyA9PT0gdHJ1ZSkge1xuICAgIC8vIEZpZWxkcyBpbiB0aGUgZmlyc3QgbGluZSBhcmUgY29udmVydGVkIGFzLWlzIHRvIGNvbHVtbnNcbiAgICBvcHRpb25zLmNhc3RfZmlyc3RfbGluZV90b19oZWFkZXIgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuY29sdW1ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgb3B0aW9ucy5jYXN0X2ZpcnN0X2xpbmVfdG9faGVhZGVyID0gb3B0aW9ucy5jb2x1bW5zO1xuICAgIG9wdGlvbnMuY29sdW1ucyA9IHRydWU7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmNvbHVtbnMpKSB7XG4gICAgb3B0aW9ucy5jb2x1bW5zID0gbm9ybWFsaXplX2NvbHVtbnNfYXJyYXkob3B0aW9ucy5jb2x1bW5zKTtcbiAgfSBlbHNlIGlmIChcbiAgICBvcHRpb25zLmNvbHVtbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMuY29sdW1ucyA9PT0gbnVsbCB8fFxuICAgIG9wdGlvbnMuY29sdW1ucyA9PT0gZmFsc2VcbiAgKSB7XG4gICAgb3B0aW9ucy5jb2x1bW5zID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IENzdkVycm9yKFxuICAgICAgXCJDU1ZfSU5WQUxJRF9PUFRJT05fQ09MVU1OU1wiLFxuICAgICAgW1xuICAgICAgICBcIkludmFsaWQgb3B0aW9uIGNvbHVtbnM6XCIsXG4gICAgICAgIFwiZXhwZWN0IGFuIGFycmF5LCBhIGZ1bmN0aW9uIG9yIHRydWUsXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmNvbHVtbnMpfWAsXG4gICAgICBdLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGdyb3VwX2NvbHVtbnNfYnlfbmFtZWBcbiAgaWYgKFxuICAgIG9wdGlvbnMuZ3JvdXBfY29sdW1uc19ieV9uYW1lID09PSB1bmRlZmluZWQgfHxcbiAgICBvcHRpb25zLmdyb3VwX2NvbHVtbnNfYnlfbmFtZSA9PT0gbnVsbCB8fFxuICAgIG9wdGlvbnMuZ3JvdXBfY29sdW1uc19ieV9uYW1lID09PSBmYWxzZVxuICApIHtcbiAgICBvcHRpb25zLmdyb3VwX2NvbHVtbnNfYnlfbmFtZSA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZ3JvdXBfY29sdW1uc19ieV9uYW1lICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IENzdkVycm9yKFxuICAgICAgXCJDU1ZfSU5WQUxJRF9PUFRJT05fR1JPVVBfQ09MVU1OU19CWV9OQU1FXCIsXG4gICAgICBbXG4gICAgICAgIFwiSW52YWxpZCBvcHRpb24gZ3JvdXBfY29sdW1uc19ieV9uYW1lOlwiLFxuICAgICAgICBcImV4cGVjdCBhbiBib29sZWFuLFwiLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ncm91cF9jb2x1bW5zX2J5X25hbWUpfWAsXG4gICAgICBdLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuY29sdW1ucyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoXG4gICAgICBcIkNTVl9JTlZBTElEX09QVElPTl9HUk9VUF9DT0xVTU5TX0JZX05BTUVcIixcbiAgICAgIFtcbiAgICAgICAgXCJJbnZhbGlkIG9wdGlvbiBncm91cF9jb2x1bW5zX2J5X25hbWU6XCIsXG4gICAgICAgIFwidGhlIGBjb2x1bW5zYCBtb2RlIG11c3QgYmUgYWN0aXZhdGVkLlwiLFxuICAgICAgXSxcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBjb21tZW50YFxuICBpZiAoXG4gICAgb3B0aW9ucy5jb21tZW50ID09PSB1bmRlZmluZWQgfHxcbiAgICBvcHRpb25zLmNvbW1lbnQgPT09IG51bGwgfHxcbiAgICBvcHRpb25zLmNvbW1lbnQgPT09IGZhbHNlIHx8XG4gICAgb3B0aW9ucy5jb21tZW50ID09PSBcIlwiXG4gICkge1xuICAgIG9wdGlvbnMuY29tbWVudCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG9wdGlvbnMuY29tbWVudCA9IEJ1ZmZlci5mcm9tKG9wdGlvbnMuY29tbWVudCwgb3B0aW9ucy5lbmNvZGluZyk7XG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuY29tbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvcihcbiAgICAgICAgXCJDU1ZfSU5WQUxJRF9PUFRJT05fQ09NTUVOVFwiLFxuICAgICAgICBbXG4gICAgICAgICAgXCJJbnZhbGlkIG9wdGlvbiBjb21tZW50OlwiLFxuICAgICAgICAgIFwiY29tbWVudCBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nLFwiLFxuICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmNvbW1lbnQpfWAsXG4gICAgICAgIF0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBjb21tZW50X25vX2luZml4YFxuICBpZiAoXG4gICAgb3B0aW9ucy5jb21tZW50X25vX2luZml4ID09PSB1bmRlZmluZWQgfHxcbiAgICBvcHRpb25zLmNvbW1lbnRfbm9faW5maXggPT09IG51bGwgfHxcbiAgICBvcHRpb25zLmNvbW1lbnRfbm9faW5maXggPT09IGZhbHNlXG4gICkge1xuICAgIG9wdGlvbnMuY29tbWVudF9ub19pbmZpeCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuY29tbWVudF9ub19pbmZpeCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBDc3ZFcnJvcihcbiAgICAgIFwiQ1NWX0lOVkFMSURfT1BUSU9OX0NPTU1FTlRcIixcbiAgICAgIFtcbiAgICAgICAgXCJJbnZhbGlkIG9wdGlvbiBjb21tZW50X25vX2luZml4OlwiLFxuICAgICAgICBcInZhbHVlIG11c3QgYmUgYSBib29sZWFuLFwiLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jb21tZW50X25vX2luZml4KX1gLFxuICAgICAgXSxcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBkZWxpbWl0ZXJgXG4gIGNvbnN0IGRlbGltaXRlcl9qc29uID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5kZWxpbWl0ZXIpKVxuICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gW29wdGlvbnMuZGVsaW1pdGVyXTtcbiAgaWYgKG9wdGlvbnMuZGVsaW1pdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBDc3ZFcnJvcihcbiAgICAgIFwiQ1NWX0lOVkFMSURfT1BUSU9OX0RFTElNSVRFUlwiLFxuICAgICAgW1xuICAgICAgICBcIkludmFsaWQgb3B0aW9uIGRlbGltaXRlcjpcIixcbiAgICAgICAgXCJkZWxpbWl0ZXIgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmcgb3IgYnVmZmVyIG9yIGFycmF5IG9mIHN0cmluZ3xidWZmZXIsXCIsXG4gICAgICAgIGBnb3QgJHtkZWxpbWl0ZXJfanNvbn1gLFxuICAgICAgXSxcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLmRlbGltaXRlciA9IG9wdGlvbnMuZGVsaW1pdGVyLm1hcChmdW5jdGlvbiAoZGVsaW1pdGVyKSB7XG4gICAgaWYgKGRlbGltaXRlciA9PT0gdW5kZWZpbmVkIHx8IGRlbGltaXRlciA9PT0gbnVsbCB8fCBkZWxpbWl0ZXIgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oXCIsXCIsIG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRlbGltaXRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZGVsaW1pdGVyID0gQnVmZmVyLmZyb20oZGVsaW1pdGVyLCBvcHRpb25zLmVuY29kaW5nKTtcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGVsaW1pdGVyKSB8fCBkZWxpbWl0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoXG4gICAgICAgIFwiQ1NWX0lOVkFMSURfT1BUSU9OX0RFTElNSVRFUlwiLFxuICAgICAgICBbXG4gICAgICAgICAgXCJJbnZhbGlkIG9wdGlvbiBkZWxpbWl0ZXI6XCIsXG4gICAgICAgICAgXCJkZWxpbWl0ZXIgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmcgb3IgYnVmZmVyIG9yIGFycmF5IG9mIHN0cmluZ3xidWZmZXIsXCIsXG4gICAgICAgICAgYGdvdCAke2RlbGltaXRlcl9qc29ufWAsXG4gICAgICAgIF0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVsaW1pdGVyO1xuICB9KTtcbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZXNjYXBlYFxuICBpZiAob3B0aW9ucy5lc2NhcGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmVzY2FwZSA9PT0gdHJ1ZSkge1xuICAgIG9wdGlvbnMuZXNjYXBlID0gQnVmZmVyLmZyb20oJ1wiJywgb3B0aW9ucy5lbmNvZGluZyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZXNjYXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgb3B0aW9ucy5lc2NhcGUgPSBCdWZmZXIuZnJvbShvcHRpb25zLmVzY2FwZSwgb3B0aW9ucy5lbmNvZGluZyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5lc2NhcGUgPT09IG51bGwgfHwgb3B0aW9ucy5lc2NhcGUgPT09IGZhbHNlKSB7XG4gICAgb3B0aW9ucy5lc2NhcGUgPSBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zLmVzY2FwZSAhPT0gbnVsbCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuZXNjYXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBPcHRpb246IGVzY2FwZSBtdXN0IGJlIGEgYnVmZmVyLCBhIHN0cmluZyBvciBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuZXNjYXBlKX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZnJvbWBcbiAgaWYgKG9wdGlvbnMuZnJvbSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZnJvbSA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMuZnJvbSA9IDE7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZyb20gPT09IFwic3RyaW5nXCIgJiYgL1xcZCsvLnRlc3Qob3B0aW9ucy5mcm9tKSkge1xuICAgICAgb3B0aW9ucy5mcm9tID0gcGFyc2VJbnQob3B0aW9ucy5mcm9tKTtcbiAgICB9XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIob3B0aW9ucy5mcm9tKSkge1xuICAgICAgaWYgKG9wdGlvbnMuZnJvbSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIE9wdGlvbjogZnJvbSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0cy5mcm9tKX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIE9wdGlvbjogZnJvbSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuZnJvbSl9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGZyb21fbGluZWBcbiAgaWYgKG9wdGlvbnMuZnJvbV9saW5lID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5mcm9tX2xpbmUgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLmZyb21fbGluZSA9IDE7XG4gIH0gZWxzZSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZnJvbV9saW5lID09PSBcInN0cmluZ1wiICYmXG4gICAgICAvXFxkKy8udGVzdChvcHRpb25zLmZyb21fbGluZSlcbiAgICApIHtcbiAgICAgIG9wdGlvbnMuZnJvbV9saW5lID0gcGFyc2VJbnQob3B0aW9ucy5mcm9tX2xpbmUpO1xuICAgIH1cbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmZyb21fbGluZSkpIHtcbiAgICAgIGlmIChvcHRpb25zLmZyb21fbGluZSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBPcHRpb246IGZyb21fbGluZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBncmVhdGVyIHRoYW4gMCwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0cy5mcm9tX2xpbmUpfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgT3B0aW9uOiBmcm9tX2xpbmUgbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLmZyb21fbGluZSl9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb25zIGBpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzYFxuICBpZiAoXG4gICAgb3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID09PSB1bmRlZmluZWQgfHxcbiAgICBvcHRpb25zLmlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPT09IG51bGxcbiAgKSB7XG4gICAgb3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9PT0gXCJudW1iZXJcIikge1xuICAgIG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9IE1hdGguZmxvb3Iob3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzKTtcbiAgICBpZiAob3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID09PSAwKSB7XG4gICAgICBvcHRpb25zLmlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPSBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoXG4gICAgICBcIkNTVl9JTlZBTElEX09QVElPTl9JR05PUkVfTEFTVF9ERUxJTUlURVJTXCIsXG4gICAgICBbXG4gICAgICAgIFwiSW52YWxpZCBvcHRpb24gYGlnbm9yZV9sYXN0X2RlbGltaXRlcnNgOlwiLFxuICAgICAgICBcInRoZSB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbiB2YWx1ZSBvciBhbiBpbnRlZ2VyLFwiLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzKX1gLFxuICAgICAgXSxcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgfVxuICBpZiAob3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID09PSB0cnVlICYmIG9wdGlvbnMuY29sdW1ucyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoXG4gICAgICBcIkNTVl9JR05PUkVfTEFTVF9ERUxJTUlURVJTX1JFUVVJUkVTX0NPTFVNTlNcIixcbiAgICAgIFtcbiAgICAgICAgXCJUaGUgb3B0aW9uIGBpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzYFwiLFxuICAgICAgICBcInJlcXVpcmVzIHRoZSBhY3RpdmF0aW9uIG9mIHRoZSBgY29sdW1uc2Agb3B0aW9uXCIsXG4gICAgICBdLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGluZm9gXG4gIGlmIChcbiAgICBvcHRpb25zLmluZm8gPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMuaW5mbyA9PT0gbnVsbCB8fFxuICAgIG9wdGlvbnMuaW5mbyA9PT0gZmFsc2VcbiAgKSB7XG4gICAgb3B0aW9ucy5pbmZvID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5pbmZvICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgT3B0aW9uOiBpbmZvIG11c3QgYmUgdHJ1ZSwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5pbmZvKX1gLFxuICAgICk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgbWF4X3JlY29yZF9zaXplYFxuICBpZiAoXG4gICAgb3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMubWF4X3JlY29yZF9zaXplID09PSBudWxsIHx8XG4gICAgb3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPT09IGZhbHNlXG4gICkge1xuICAgIG9wdGlvbnMubWF4X3JlY29yZF9zaXplID0gMDtcbiAgfSBlbHNlIGlmIChcbiAgICBOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubWF4X3JlY29yZF9zaXplKSAmJlxuICAgIG9wdGlvbnMubWF4X3JlY29yZF9zaXplID49IDBcbiAgKSB7XG4gICAgLy8gR3JlYXQsIG5vdGhpbmcgdG8gZG9cbiAgfSBlbHNlIGlmIChcbiAgICB0eXBlb2Ygb3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAvXFxkKy8udGVzdChvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSlcbiAgKSB7XG4gICAgb3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPSBwYXJzZUludChvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgT3B0aW9uOiBtYXhfcmVjb3JkX3NpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMubWF4X3JlY29yZF9zaXplKX1gLFxuICAgICk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgb2JqbmFtZWBcbiAgaWYgKFxuICAgIG9wdGlvbnMub2JqbmFtZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5vYmpuYW1lID09PSBudWxsIHx8XG4gICAgb3B0aW9ucy5vYmpuYW1lID09PSBmYWxzZVxuICApIHtcbiAgICBvcHRpb25zLm9iam5hbWUgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMub2JqbmFtZSkpIHtcbiAgICBpZiAob3B0aW9ucy5vYmpuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogb2JqbmFtZSBtdXN0IGJlIGEgbm9uIGVtcHR5IGJ1ZmZlcmApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gbnVsbCkge1xuICAgICAgLy8gRG9uJ3QgY2FsbCBgdG9TdHJpbmdgLCBsZWF2ZSBvYmpuYW1lIGFzIGEgYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMub2JqbmFtZSA9IG9wdGlvbnMub2JqbmFtZS50b1N0cmluZyhvcHRpb25zLmVuY29kaW5nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMub2JqbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChvcHRpb25zLm9iam5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBvYmpuYW1lIG11c3QgYmUgYSBub24gZW1wdHkgc3RyaW5nYCk7XG4gICAgfVxuICAgIC8vIEdyZWF0LCBub3RoaW5nIHRvIGRvXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMub2JqbmFtZSA9PT0gXCJudW1iZXJcIikge1xuICAgIC8vIGlmKG9wdGlvbnMub2JqbmFtZS5sZW5ndGggPT09IDApe1xuICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogb2JqbmFtZSBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZ2ApO1xuICAgIC8vIH1cbiAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIE9wdGlvbjogb2JqbmFtZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyLCBnb3QgJHtvcHRpb25zLm9iam5hbWV9YCxcbiAgICApO1xuICB9XG4gIGlmIChvcHRpb25zLm9iam5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vYmpuYW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAob3B0aW9ucy5jb2x1bW5zICE9PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgT3B0aW9uOiBvYmpuYW1lIGluZGV4IGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIGNvbHVtbnMgb3IgYmUgZGVmaW5lZCBhcyBhIGZpZWxkXCIsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEEgc3RyaW5nIG9yIGEgYnVmZmVyXG4gICAgICBpZiAob3B0aW9ucy5jb2x1bW5zID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgT3B0aW9uOiBvYmpuYW1lIGZpZWxkIG11c3QgYmUgY29tYmluZWQgd2l0aCBjb2x1bW5zIG9yIGJlIGRlZmluZWQgYXMgYW4gaW5kZXhcIixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgb25fcmVjb3JkYFxuICBpZiAob3B0aW9ucy5vbl9yZWNvcmQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm9uX3JlY29yZCA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMub25fcmVjb3JkID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm9uX3JlY29yZCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IENzdkVycm9yKFxuICAgICAgXCJDU1ZfSU5WQUxJRF9PUFRJT05fT05fUkVDT1JEXCIsXG4gICAgICBbXG4gICAgICAgIFwiSW52YWxpZCBvcHRpb24gYG9uX3JlY29yZGA6XCIsXG4gICAgICAgIFwiZXhwZWN0IGEgZnVuY3Rpb24sXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLm9uX3JlY29yZCl9YCxcbiAgICAgIF0sXG4gICAgICBvcHRpb25zLFxuICAgICk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgb25fc2tpcGBcbiAgLy8gb3B0aW9ucy5vbl9za2lwID8/PSAoZXJyLCBjaHVuaykgPT4ge1xuICAvLyAgIHRoaXMuZW1pdCgnc2tpcCcsIGVyciwgY2h1bmspO1xuICAvLyB9O1xuICBpZiAoXG4gICAgb3B0aW9ucy5vbl9za2lwICE9PSB1bmRlZmluZWQgJiZcbiAgICBvcHRpb25zLm9uX3NraXAgIT09IG51bGwgJiZcbiAgICB0eXBlb2Ygb3B0aW9ucy5vbl9za2lwICE9PSBcImZ1bmN0aW9uXCJcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgT3B0aW9uOiBvbl9za2lwIG11c3QgYmUgYSBmdW5jdGlvbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5vbl9za2lwKX1gLFxuICAgICk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVgXG4gIGlmIChcbiAgICBvcHRpb25zLnF1b3RlID09PSBudWxsIHx8XG4gICAgb3B0aW9ucy5xdW90ZSA9PT0gZmFsc2UgfHxcbiAgICBvcHRpb25zLnF1b3RlID09PSBcIlwiXG4gICkge1xuICAgIG9wdGlvbnMucXVvdGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRpb25zLnF1b3RlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZSA9PT0gdHJ1ZSkge1xuICAgICAgb3B0aW9ucy5xdW90ZSA9IEJ1ZmZlci5mcm9tKCdcIicsIG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMucXVvdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG9wdGlvbnMucXVvdGUgPSBCdWZmZXIuZnJvbShvcHRpb25zLnF1b3RlLCBvcHRpb25zLmVuY29kaW5nKTtcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5xdW90ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgT3B0aW9uOiBxdW90ZSBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnF1b3RlKX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcmF3YFxuICBpZiAoXG4gICAgb3B0aW9ucy5yYXcgPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMucmF3ID09PSBudWxsIHx8XG4gICAgb3B0aW9ucy5yYXcgPT09IGZhbHNlXG4gICkge1xuICAgIG9wdGlvbnMucmF3ID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5yYXcgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBPcHRpb246IHJhdyBtdXN0IGJlIHRydWUsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucmF3KX1gLFxuICAgICk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcmVjb3JkX2RlbGltaXRlcmBcbiAgaWYgKG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gW107XG4gIH0gZWxzZSBpZiAoXG4gICAgdHlwZW9mIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9PT0gXCJzdHJpbmdcIiB8fFxuICAgIEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpXG4gICkge1xuICAgIGlmIChvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoXG4gICAgICAgIFwiQ1NWX0lOVkFMSURfT1BUSU9OX1JFQ09SRF9ERUxJTUlURVJcIixcbiAgICAgICAgW1xuICAgICAgICAgIFwiSW52YWxpZCBvcHRpb24gYHJlY29yZF9kZWxpbWl0ZXJgOlwiLFxuICAgICAgICAgIFwidmFsdWUgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmcgb3IgYnVmZmVyLFwiLFxuICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpfWAsXG4gICAgICAgIF0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgIH1cbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBbb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpKSB7XG4gICAgdGhyb3cgbmV3IENzdkVycm9yKFxuICAgICAgXCJDU1ZfSU5WQUxJRF9PUFRJT05fUkVDT1JEX0RFTElNSVRFUlwiLFxuICAgICAgW1xuICAgICAgICBcIkludmFsaWQgb3B0aW9uIGByZWNvcmRfZGVsaW1pdGVyYDpcIixcbiAgICAgICAgXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLCBhIGJ1ZmZlciBvciBhcnJheSBvZiBzdHJpbmd8YnVmZmVyLFwiLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyKX1gLFxuICAgICAgXSxcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIubWFwKGZ1bmN0aW9uIChyZCwgaSkge1xuICAgIGlmICh0eXBlb2YgcmQgIT09IFwic3RyaW5nXCIgJiYgIUJ1ZmZlci5pc0J1ZmZlcihyZCkpIHtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvcihcbiAgICAgICAgXCJDU1ZfSU5WQUxJRF9PUFRJT05fUkVDT1JEX0RFTElNSVRFUlwiLFxuICAgICAgICBbXG4gICAgICAgICAgXCJJbnZhbGlkIG9wdGlvbiBgcmVjb3JkX2RlbGltaXRlcmA6XCIsXG4gICAgICAgICAgXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLCBhIGJ1ZmZlciBvciBhcnJheSBvZiBzdHJpbmd8YnVmZmVyXCIsXG4gICAgICAgICAgYGF0IGluZGV4ICR7aX0sYCxcbiAgICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkocmQpfWAsXG4gICAgICAgIF0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAocmQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoXG4gICAgICAgIFwiQ1NWX0lOVkFMSURfT1BUSU9OX1JFQ09SRF9ERUxJTUlURVJcIixcbiAgICAgICAgW1xuICAgICAgICAgIFwiSW52YWxpZCBvcHRpb24gYHJlY29yZF9kZWxpbWl0ZXJgOlwiLFxuICAgICAgICAgIFwidmFsdWUgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmcgb3IgYnVmZmVyXCIsXG4gICAgICAgICAgYGF0IGluZGV4ICR7aX0sYCxcbiAgICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkocmQpfWAsXG4gICAgICAgIF0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZCA9IEJ1ZmZlci5mcm9tKHJkLCBvcHRpb25zLmVuY29kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJkO1xuICB9KTtcbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcmVsYXhfY29sdW1uX2NvdW50YFxuICBpZiAodHlwZW9mIG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50ID09PSBcImJvb2xlYW5cIikge1xuICAgIC8vIEdyZWF0LCBub3RoaW5nIHRvIGRvXG4gIH0gZWxzZSBpZiAoXG4gICAgb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnQgPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50ID09PSBudWxsXG4gICkge1xuICAgIG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50ID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgT3B0aW9uOiByZWxheF9jb2x1bW5fY291bnQgbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50KX1gLFxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9sZXNzID09PSBcImJvb2xlYW5cIikge1xuICAgIC8vIEdyZWF0LCBub3RoaW5nIHRvIGRvXG4gIH0gZWxzZSBpZiAoXG4gICAgb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbGVzcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbGVzcyA9PT0gbnVsbFxuICApIHtcbiAgICBvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9sZXNzID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgT3B0aW9uOiByZWxheF9jb2x1bW5fY291bnRfbGVzcyBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbGVzcyl9YCxcbiAgICApO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbW9yZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICB9IGVsc2UgaWYgKFxuICAgIG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50X21vcmUgPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50X21vcmUgPT09IG51bGxcbiAgKSB7XG4gICAgb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbW9yZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIE9wdGlvbjogcmVsYXhfY29sdW1uX2NvdW50X21vcmUgbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50X21vcmUpfWAsXG4gICAgKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGByZWxheF9xdW90ZXNgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWxheF9xdW90ZXMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgLy8gR3JlYXQsIG5vdGhpbmcgdG8gZG9cbiAgfSBlbHNlIGlmIChcbiAgICBvcHRpb25zLnJlbGF4X3F1b3RlcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5yZWxheF9xdW90ZXMgPT09IG51bGxcbiAgKSB7XG4gICAgb3B0aW9ucy5yZWxheF9xdW90ZXMgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBPcHRpb246IHJlbGF4X3F1b3RlcyBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5yZWxheF9xdW90ZXMpfWAsXG4gICAgKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBza2lwX2VtcHR5X2xpbmVzYFxuICBpZiAodHlwZW9mIG9wdGlvbnMuc2tpcF9lbXB0eV9saW5lcyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICB9IGVsc2UgaWYgKFxuICAgIG9wdGlvbnMuc2tpcF9lbXB0eV9saW5lcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5za2lwX2VtcHR5X2xpbmVzID09PSBudWxsXG4gICkge1xuICAgIG9wdGlvbnMuc2tpcF9lbXB0eV9saW5lcyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIE9wdGlvbjogc2tpcF9lbXB0eV9saW5lcyBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5za2lwX2VtcHR5X2xpbmVzKX1gLFxuICAgICk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgc2tpcF9yZWNvcmRzX3dpdGhfZW1wdHlfdmFsdWVzYFxuICBpZiAodHlwZW9mIG9wdGlvbnMuc2tpcF9yZWNvcmRzX3dpdGhfZW1wdHlfdmFsdWVzID09PSBcImJvb2xlYW5cIikge1xuICAgIC8vIEdyZWF0LCBub3RoaW5nIHRvIGRvXG4gIH0gZWxzZSBpZiAoXG4gICAgb3B0aW9ucy5za2lwX3JlY29yZHNfd2l0aF9lbXB0eV92YWx1ZXMgPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMuc2tpcF9yZWNvcmRzX3dpdGhfZW1wdHlfdmFsdWVzID09PSBudWxsXG4gICkge1xuICAgIG9wdGlvbnMuc2tpcF9yZWNvcmRzX3dpdGhfZW1wdHlfdmFsdWVzID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgT3B0aW9uOiBza2lwX3JlY29yZHNfd2l0aF9lbXB0eV92YWx1ZXMgbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuc2tpcF9yZWNvcmRzX3dpdGhfZW1wdHlfdmFsdWVzKX1gLFxuICAgICk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgc2tpcF9yZWNvcmRzX3dpdGhfZXJyb3JgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5za2lwX3JlY29yZHNfd2l0aF9lcnJvciA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICB9IGVsc2UgaWYgKFxuICAgIG9wdGlvbnMuc2tpcF9yZWNvcmRzX3dpdGhfZXJyb3IgPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMuc2tpcF9yZWNvcmRzX3dpdGhfZXJyb3IgPT09IG51bGxcbiAgKSB7XG4gICAgb3B0aW9ucy5za2lwX3JlY29yZHNfd2l0aF9lcnJvciA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIE9wdGlvbjogc2tpcF9yZWNvcmRzX3dpdGhfZXJyb3IgbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuc2tpcF9yZWNvcmRzX3dpdGhfZXJyb3IpfWAsXG4gICAgKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBydHJpbWBcbiAgaWYgKFxuICAgIG9wdGlvbnMucnRyaW0gPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMucnRyaW0gPT09IG51bGwgfHxcbiAgICBvcHRpb25zLnJ0cmltID09PSBmYWxzZVxuICApIHtcbiAgICBvcHRpb25zLnJ0cmltID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5ydHJpbSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIE9wdGlvbjogcnRyaW0gbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucnRyaW0pfWAsXG4gICAgKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBsdHJpbWBcbiAgaWYgKFxuICAgIG9wdGlvbnMubHRyaW0gPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMubHRyaW0gPT09IG51bGwgfHxcbiAgICBvcHRpb25zLmx0cmltID09PSBmYWxzZVxuICApIHtcbiAgICBvcHRpb25zLmx0cmltID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5sdHJpbSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIE9wdGlvbjogbHRyaW0gbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMubHRyaW0pfWAsXG4gICAgKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGB0cmltYFxuICBpZiAoXG4gICAgb3B0aW9ucy50cmltID09PSB1bmRlZmluZWQgfHxcbiAgICBvcHRpb25zLnRyaW0gPT09IG51bGwgfHxcbiAgICBvcHRpb25zLnRyaW0gPT09IGZhbHNlXG4gICkge1xuICAgIG9wdGlvbnMudHJpbSA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMudHJpbSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIE9wdGlvbjogdHJpbSBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy50cmltKX1gLFxuICAgICk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbnMgYHRyaW1gLCBgbHRyaW1gIGFuZCBgcnRyaW1gXG4gIGlmIChvcHRpb25zLnRyaW0gPT09IHRydWUgJiYgb3B0cy5sdHJpbSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpb25zLmx0cmltID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmx0cmltICE9PSB0cnVlKSB7XG4gICAgb3B0aW9ucy5sdHJpbSA9IGZhbHNlO1xuICB9XG4gIGlmIChvcHRpb25zLnRyaW0gPT09IHRydWUgJiYgb3B0cy5ydHJpbSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpb25zLnJ0cmltID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnJ0cmltICE9PSB0cnVlKSB7XG4gICAgb3B0aW9ucy5ydHJpbSA9IGZhbHNlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHRvYFxuICBpZiAob3B0aW9ucy50byA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudG8gPT09IG51bGwpIHtcbiAgICBvcHRpb25zLnRvID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvID09PSBcInN0cmluZ1wiICYmIC9cXGQrLy50ZXN0KG9wdGlvbnMudG8pKSB7XG4gICAgICBvcHRpb25zLnRvID0gcGFyc2VJbnQob3B0aW9ucy50byk7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMudG8pKSB7XG4gICAgICBpZiAob3B0aW9ucy50byA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBPcHRpb246IHRvIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLnRvKX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIE9wdGlvbjogdG8gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLnRvKX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgdG9fbGluZWBcbiAgaWYgKG9wdGlvbnMudG9fbGluZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudG9fbGluZSA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMudG9fbGluZSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b19saW5lID09PSBcInN0cmluZ1wiICYmIC9cXGQrLy50ZXN0KG9wdGlvbnMudG9fbGluZSkpIHtcbiAgICAgIG9wdGlvbnMudG9fbGluZSA9IHBhcnNlSW50KG9wdGlvbnMudG9fbGluZSk7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMudG9fbGluZSkpIHtcbiAgICAgIGlmIChvcHRpb25zLnRvX2xpbmUgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgT3B0aW9uOiB0b19saW5lIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLnRvX2xpbmUpfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgT3B0aW9uOiB0b19saW5lIG11c3QgYmUgYW4gaW50ZWdlciwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0cy50b19saW5lKX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5leHBvcnQgeyBub3JtYWxpemVfb3B0aW9ucyB9O1xuIiwgImltcG9ydCB7IG5vcm1hbGl6ZV9jb2x1bW5zX2FycmF5IH0gZnJvbSBcIi4vbm9ybWFsaXplX2NvbHVtbnNfYXJyYXkuanNcIjtcbmltcG9ydCB7IGluaXRfc3RhdGUgfSBmcm9tIFwiLi9pbml0X3N0YXRlLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVfb3B0aW9ucyB9IGZyb20gXCIuL25vcm1hbGl6ZV9vcHRpb25zLmpzXCI7XG5pbXBvcnQgeyBDc3ZFcnJvciB9IGZyb20gXCIuL0NzdkVycm9yLmpzXCI7XG5cbmNvbnN0IGlzUmVjb3JkRW1wdHkgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gIHJldHVybiByZWNvcmQuZXZlcnkoXG4gICAgKGZpZWxkKSA9PlxuICAgICAgZmllbGQgPT0gbnVsbCB8fCAoZmllbGQudG9TdHJpbmcgJiYgZmllbGQudG9TdHJpbmcoKS50cmltKCkgPT09IFwiXCIpLFxuICApO1xufTtcblxuY29uc3QgY3IgPSAxMzsgLy8gYFxccmAsIGNhcnJpYWdlIHJldHVybiwgMHgwRCBpbiBoZXhhZFx1MDBFOWNpbWFsLCAxMyBpbiBkZWNpbWFsXG5jb25zdCBubCA9IDEwOyAvLyBgXFxuYCwgbmV3bGluZSwgMHgwQSBpbiBoZXhhZGVjaW1hbCwgMTAgaW4gZGVjaW1hbFxuXG5jb25zdCBib21zID0ge1xuICAvLyBOb3RlLCB0aGUgZm9sbG93aW5nIGFyZSBlcXVhbHM6XG4gIC8vIEJ1ZmZlci5mcm9tKFwiXFx1ZmVmZlwiKVxuICAvLyBCdWZmZXIuZnJvbShbMjM5LCAxODcsIDE5MV0pXG4gIC8vIEJ1ZmZlci5mcm9tKCdFRkJCQkYnLCAnaGV4JylcbiAgdXRmODogQnVmZmVyLmZyb20oWzIzOSwgMTg3LCAxOTFdKSxcbiAgLy8gTm90ZSwgdGhlIGZvbGxvd2luZyBhcmUgZXF1YWxzOlxuICAvLyBCdWZmZXIuZnJvbSBcIlxcdWZlZmZcIiwgJ3V0ZjE2bGVcbiAgLy8gQnVmZmVyLmZyb20oWzI1NSwgMjU0XSlcbiAgdXRmMTZsZTogQnVmZmVyLmZyb20oWzI1NSwgMjU0XSksXG59O1xuXG5jb25zdCB0cmFuc2Zvcm0gPSBmdW5jdGlvbiAob3JpZ2luYWxfb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGluZm8gPSB7XG4gICAgYnl0ZXM6IDAsXG4gICAgY29tbWVudF9saW5lczogMCxcbiAgICBlbXB0eV9saW5lczogMCxcbiAgICBpbnZhbGlkX2ZpZWxkX2xlbmd0aDogMCxcbiAgICBsaW5lczogMSxcbiAgICByZWNvcmRzOiAwLFxuICB9O1xuICBjb25zdCBvcHRpb25zID0gbm9ybWFsaXplX29wdGlvbnMob3JpZ2luYWxfb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgaW5mbzogaW5mbyxcbiAgICBvcmlnaW5hbF9vcHRpb25zOiBvcmlnaW5hbF9vcHRpb25zLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgc3RhdGU6IGluaXRfc3RhdGUob3B0aW9ucyksXG4gICAgX19uZWVkTW9yZURhdGE6IGZ1bmN0aW9uIChpLCBidWZMZW4sIGVuZCkge1xuICAgICAgaWYgKGVuZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgeyBlbmNvZGluZywgZXNjYXBlLCBxdW90ZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgY29uc3QgeyBxdW90aW5nLCBuZWVkTW9yZURhdGFTaXplLCByZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGggfSA9XG4gICAgICAgIHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBudW1PZkNoYXJMZWZ0ID0gYnVmTGVuIC0gaSAtIDE7XG4gICAgICBjb25zdCByZXF1aXJlZExlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICBuZWVkTW9yZURhdGFTaXplLFxuICAgICAgICAvLyBTa2lwIGlmIHRoZSByZW1haW5pbmcgYnVmZmVyIHNtYWxsZXIgdGhhbiByZWNvcmQgZGVsaW1pdGVyXG4gICAgICAgIC8vIElmIFwicmVjb3JkX2RlbGltaXRlclwiIGlzIHlldCB0byBiZSBkaXNjb3ZlcmVkOlxuICAgICAgICAvLyAxLiBJdCBpcyBlcXVhbHMgdG8gYFtdYCBhbmQgXCJyZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGhcIiBlcXVhbHMgYDBgXG4gICAgICAgIC8vIDIuIFdlIHNldCB0aGUgbGVuZ3RoIHRvIHdpbmRvd3MgbGluZSBlbmRpbmcgaW4gdGhlIGN1cnJlbnQgZW5jb2RpbmdcbiAgICAgICAgLy8gTm90ZSwgdGhhdCBlbmNvZGluZyBpcyBrbm93biBmcm9tIHVzZXIgb3IgYm9tIGRpc2NvdmVyeSBhdCB0aGF0IHBvaW50XG4gICAgICAgIC8vIHJlY29yZERlbGltaXRlck1heExlbmd0aCxcbiAgICAgICAgcmVjb3JkRGVsaW1pdGVyTWF4TGVuZ3RoID09PSAwXG4gICAgICAgICAgPyBCdWZmZXIuZnJvbShcIlxcclxcblwiLCBlbmNvZGluZykubGVuZ3RoXG4gICAgICAgICAgOiByZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGgsXG4gICAgICAgIC8vIFNraXAgaWYgcmVtYWluaW5nIGJ1ZmZlciBjYW4gYmUgYW4gZXNjYXBlZCBxdW90ZVxuICAgICAgICBxdW90aW5nID8gKGVzY2FwZSA9PT0gbnVsbCA/IDAgOiBlc2NhcGUubGVuZ3RoKSArIHF1b3RlLmxlbmd0aCA6IDAsXG4gICAgICAgIC8vIFNraXAgaWYgcmVtYWluaW5nIGJ1ZmZlciBjYW4gYmUgcmVjb3JkIGRlbGltaXRlciBmb2xsb3dpbmcgdGhlIGNsb3NpbmcgcXVvdGVcbiAgICAgICAgcXVvdGluZyA/IHF1b3RlLmxlbmd0aCArIHJlY29yZERlbGltaXRlck1heExlbmd0aCA6IDAsXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bU9mQ2hhckxlZnQgPCByZXF1aXJlZExlbmd0aDtcbiAgICB9LFxuICAgIC8vIENlbnRyYWwgcGFyc2VyIGltcGxlbWVudGF0aW9uXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChuZXh0QnVmLCBlbmQsIHB1c2gsIGNsb3NlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJvbSxcbiAgICAgICAgY29tbWVudF9ub19pbmZpeCxcbiAgICAgICAgZW5jb2RpbmcsXG4gICAgICAgIGZyb21fbGluZSxcbiAgICAgICAgbHRyaW0sXG4gICAgICAgIG1heF9yZWNvcmRfc2l6ZSxcbiAgICAgICAgcmF3LFxuICAgICAgICByZWxheF9xdW90ZXMsXG4gICAgICAgIHJ0cmltLFxuICAgICAgICBza2lwX2VtcHR5X2xpbmVzLFxuICAgICAgICB0byxcbiAgICAgICAgdG9fbGluZSxcbiAgICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBsZXQgeyBjb21tZW50LCBlc2NhcGUsIHF1b3RlLCByZWNvcmRfZGVsaW1pdGVyIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBjb25zdCB7IGJvbVNraXBwZWQsIHByZXZpb3VzQnVmLCByYXdCdWZmZXIsIGVzY2FwZUlzUXVvdGUgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBsZXQgYnVmO1xuICAgICAgaWYgKHByZXZpb3VzQnVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG5leHRCdWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEhhbmRsZSBlbXB0eSBzdHJpbmdcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYgPSBuZXh0QnVmO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzQnVmICE9PSB1bmRlZmluZWQgJiYgbmV4dEJ1ZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJ1ZiA9IHByZXZpb3VzQnVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbcHJldmlvdXNCdWYsIG5leHRCdWZdKTtcbiAgICAgIH1cbiAgICAgIC8vIEhhbmRsZSBVVEYgQk9NXG4gICAgICBpZiAoYm9tU2tpcHBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGJvbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmJvbVNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgLy8gTm8gZW5vdWdoIGRhdGFcbiAgICAgICAgICBpZiAoZW5kID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgbW9yZSBkYXRhXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnByZXZpb3VzQnVmID0gYnVmO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIGluIGJvbXMpIHtcbiAgICAgICAgICAgIGlmIChib21zW2VuY29kaW5nXS5jb21wYXJlKGJ1ZiwgMCwgYm9tc1tlbmNvZGluZ10ubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBTa2lwIEJPTVxuICAgICAgICAgICAgICBjb25zdCBib21MZW5ndGggPSBib21zW2VuY29kaW5nXS5sZW5ndGg7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUuYnVmQnl0ZXNTdGFydCArPSBib21MZW5ndGg7XG4gICAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5zbGljZShib21MZW5ndGgpO1xuICAgICAgICAgICAgICAvLyBSZW5vcm1hbGl6ZSBvcmlnaW5hbCBvcHRpb25zIHdpdGggdGhlIG5ldyBlbmNvZGluZ1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBub3JtYWxpemVfb3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcmlnaW5hbF9vcHRpb25zLFxuICAgICAgICAgICAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIE9wdGlvbnMgd2lsbCByZS1ldmFsdWF0ZSB0aGUgQnVmZmVyIHdpdGggdGhlIG5ldyBlbmNvZGluZ1xuICAgICAgICAgICAgICAoeyBjb21tZW50LCBlc2NhcGUsIHF1b3RlIH0gPSB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZS5ib21Ta2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYnVmTGVuID0gYnVmLmxlbmd0aDtcbiAgICAgIGxldCBwb3M7XG4gICAgICBmb3IgKHBvcyA9IDA7IHBvcyA8IGJ1ZkxlbjsgcG9zKyspIHtcbiAgICAgICAgLy8gRW5zdXJlIHdlIGdldCBlbm91Z2ggc3BhY2UgdG8gbG9vayBhaGVhZFxuICAgICAgICAvLyBUaGVyZSBzaG91bGQgYmUgYSB3YXkgdG8gbW92ZSB0aGlzIG91dCBvZiB0aGUgbG9vcFxuICAgICAgICBpZiAodGhpcy5fX25lZWRNb3JlRGF0YShwb3MsIGJ1ZkxlbiwgZW5kKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuaW5mby5saW5lcysrO1xuICAgICAgICAgIHRoaXMuc3RhdGUud2FzUm93RGVsaW1pdGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvX2xpbmUgIT09IC0xICYmIHRoaXMuaW5mby5saW5lcyA+IHRvX2xpbmUpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF1dG8gZGlzY292ZXJ5IG9mIHJlY29yZF9kZWxpbWl0ZXIsIHVuaXgsIG1hYyBhbmQgd2luZG93cyBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucXVvdGluZyA9PT0gZmFsc2UgJiYgcmVjb3JkX2RlbGltaXRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zdCByZWNvcmRfZGVsaW1pdGVyQ291bnQgPSB0aGlzLl9fYXV0b0Rpc2NvdmVyUmVjb3JkRGVsaW1pdGVyKFxuICAgICAgICAgICAgYnVmLFxuICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHJlY29yZF9kZWxpbWl0ZXJDb3VudCkge1xuICAgICAgICAgICAgcmVjb3JkX2RlbGltaXRlciA9IHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHIgPSBidWZbcG9zXTtcbiAgICAgICAgaWYgKHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJhd0J1ZmZlci5hcHBlbmQoY2hyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKGNociA9PT0gY3IgfHwgY2hyID09PSBubCkgJiZcbiAgICAgICAgICB0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9PT0gZmFsc2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS53YXNSb3dEZWxpbWl0ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZpb3VzIGNoYXIgd2FzIGEgdmFsaWQgZXNjYXBlIGNoYXJcbiAgICAgICAgLy8gdHJlYXQgdGhlIGN1cnJlbnQgY2hhciBhcyBhIHJlZ3VsYXIgY2hhclxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5lc2NhcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc3RhdGUuZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBFc2NhcGUgaXMgb25seSBhY3RpdmUgaW5zaWRlIHF1b3RlZCBmaWVsZHNcbiAgICAgICAgICAvLyBXZSBhcmUgcXVvdGluZywgdGhlIGNoYXIgaXMgYW4gZXNjYXBlIGNociBhbmQgdGhlcmUgaXMgYSBjaHIgdG8gZXNjYXBlXG4gICAgICAgICAgLy8gaWYoZXNjYXBlICE9PSBudWxsICYmIHRoaXMuc3RhdGUucXVvdGluZyA9PT0gdHJ1ZSAmJiBjaHIgPT09IGVzY2FwZSAmJiBwb3MgKyAxIDwgYnVmTGVuKXtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBlc2NhcGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucXVvdGluZyA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgdGhpcy5fX2lzRXNjYXBlKGJ1ZiwgcG9zLCBjaHIpICYmXG4gICAgICAgICAgICBwb3MgKyBlc2NhcGUubGVuZ3RoIDwgYnVmTGVuXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZXNjYXBlSXNRdW90ZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fX2lzUXVvdGUoYnVmLCBwb3MgKyBlc2NhcGUubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBvcyArPSBlc2NhcGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5lc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIHBvcyArPSBlc2NhcGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdCBjdXJyZW50bHkgZXNjYXBpbmcgYW5kIGNociBpcyBhIHF1b3RlXG4gICAgICAgICAgLy8gVE9ETzogbmVlZCB0byBjb21wYXJlIGJ5dGVzIGluc3RlYWQgb2Ygc2luZ2xlIGNoYXJcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb21tZW50aW5nID09PSBmYWxzZSAmJiB0aGlzLl9faXNRdW90ZShidWYsIHBvcykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnF1b3RpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dENociA9IGJ1Zltwb3MgKyBxdW90ZS5sZW5ndGhdO1xuICAgICAgICAgICAgICBjb25zdCBpc05leHRDaHJUcmltYWJsZSA9XG4gICAgICAgICAgICAgICAgcnRyaW0gJiYgdGhpcy5fX2lzQ2hhclRyaW1hYmxlKGJ1ZiwgcG9zICsgcXVvdGUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgY29uc3QgaXNOZXh0Q2hyQ29tbWVudCA9XG4gICAgICAgICAgICAgICAgY29tbWVudCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX19jb21wYXJlQnl0ZXMoY29tbWVudCwgYnVmLCBwb3MgKyBxdW90ZS5sZW5ndGgsIG5leHRDaHIpO1xuICAgICAgICAgICAgICBjb25zdCBpc05leHRDaHJEZWxpbWl0ZXIgPSB0aGlzLl9faXNEZWxpbWl0ZXIoXG4gICAgICAgICAgICAgICAgYnVmLFxuICAgICAgICAgICAgICAgIHBvcyArIHF1b3RlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBuZXh0Q2hyLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb25zdCBpc05leHRDaHJSZWNvcmREZWxpbWl0ZXIgPVxuICAgICAgICAgICAgICAgIHJlY29yZF9kZWxpbWl0ZXIubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgICA/IHRoaXMuX19hdXRvRGlzY292ZXJSZWNvcmREZWxpbWl0ZXIoYnVmLCBwb3MgKyBxdW90ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICA6IHRoaXMuX19pc1JlY29yZERlbGltaXRlcihuZXh0Q2hyLCBidWYsIHBvcyArIHF1b3RlLmxlbmd0aCk7XG4gICAgICAgICAgICAgIC8vIEVzY2FwZSBhIHF1b3RlXG4gICAgICAgICAgICAgIC8vIFRyZWF0IG5leHQgY2hhciBhcyBhIHJlZ3VsYXIgY2hhcmFjdGVyXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBlc2NhcGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9faXNFc2NhcGUoYnVmLCBwb3MsIGNocikgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9faXNRdW90ZShidWYsIHBvcyArIGVzY2FwZS5sZW5ndGgpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHBvcyArPSBlc2NhcGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAhbmV4dENociB8fFxuICAgICAgICAgICAgICAgIGlzTmV4dENockRlbGltaXRlciB8fFxuICAgICAgICAgICAgICAgIGlzTmV4dENoclJlY29yZERlbGltaXRlciB8fFxuICAgICAgICAgICAgICAgIGlzTmV4dENockNvbW1lbnQgfHxcbiAgICAgICAgICAgICAgICBpc05leHRDaHJUcmltYWJsZVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnF1b3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLndhc1F1b3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBvcyArPSBxdW90ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlbGF4X3F1b3RlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fZXJyb3IoXG4gICAgICAgICAgICAgICAgICBuZXcgQ3N2RXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ1NWX0lOVkFMSURfQ0xPU0lOR19RVU9URVwiLFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJJbnZhbGlkIENsb3NpbmcgUXVvdGU6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgYGdvdCBcIiR7U3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hyKX1cImAsXG4gICAgICAgICAgICAgICAgICAgICAgYGF0IGxpbmUgJHt0aGlzLmluZm8ubGluZXN9YCxcbiAgICAgICAgICAgICAgICAgICAgICBcImluc3RlYWQgb2YgZGVsaW1pdGVyLCByZWNvcmQgZGVsaW1pdGVyLCB0cmltYWJsZSBjaGFyYWN0ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIihpZiBhY3RpdmF0ZWQpIG9yIGNvbW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9faW5mb0ZpZWxkKCksXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucXVvdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUud2FzUXVvdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5maWVsZC5wcmVwZW5kKHF1b3RlKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gcXVvdGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZmllbGQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gcmVsYXhfcXVvdGVzIG1vZGUsIHRyZWF0IG9wZW5pbmcgcXVvdGUgcHJlY2VkZWQgYnkgY2hycyBhcyByZWd1bGFyXG4gICAgICAgICAgICAgICAgaWYgKHJlbGF4X3F1b3RlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLl9faW5mb0ZpZWxkKCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBib20gPSBPYmplY3Qua2V5cyhib21zKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChiKSA9PlxuICAgICAgICAgICAgICAgICAgICAgIGJvbXNbYl0uZXF1YWxzKHRoaXMuc3RhdGUuZmllbGQudG9TdHJpbmcoKSkgPyBiIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVswXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgbmV3IENzdkVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiSU5WQUxJRF9PUEVOSU5HX1FVT1RFXCIsXG4gICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJJbnZhbGlkIE9wZW5pbmcgUXVvdGU6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBgYSBxdW90ZSBpcyBmb3VuZCBvbiBmaWVsZCAke0pTT04uc3RyaW5naWZ5KGluZm8uY29sdW1uKX0gYXQgbGluZSAke2luZm8ubGluZXN9LCB2YWx1ZSBpcyAke0pTT04uc3RyaW5naWZ5KHRoaXMuc3RhdGUuZmllbGQudG9TdHJpbmcoZW5jb2RpbmcpKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9tID8gYCgke2JvbX0gYm9tKWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogdGhpcy5zdGF0ZS5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5xdW90aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gcXVvdGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5xdW90aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkRGVsaW1pdGVyTGVuZ3RoID0gdGhpcy5fX2lzUmVjb3JkRGVsaW1pdGVyKFxuICAgICAgICAgICAgICBjaHIsXG4gICAgICAgICAgICAgIGJ1ZixcbiAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyZWNvcmREZWxpbWl0ZXJMZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgLy8gRG8gbm90IGVtaXQgY29tbWVudHMgd2hpY2ggdGFrZSBhIGZ1bGwgbGluZVxuICAgICAgICAgICAgICBjb25zdCBza2lwQ29tbWVudExpbmUgPVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY29tbWVudGluZyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUud2FzUXVvdGluZyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmZpZWxkLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgICAgaWYgKHNraXBDb21tZW50TGluZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5jb21tZW50X2xpbmVzKys7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBmdWxsIGNvbW1lbnQgbGluZVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFjdGl2YXRlIHJlY29yZHMgZW1pdGlvbiBpZiBhYm92ZSBmcm9tX2xpbmVcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmVuYWJsZWQgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLmluZm8ubGluZXMgK1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5zdGF0ZS53YXNSb3dEZWxpbWl0ZXIgPT09IHRydWUgPyAxIDogMCkgPj1cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9saW5lXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fX3Jlc2V0RmllbGQoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX19yZXNldFJlY29yZCgpO1xuICAgICAgICAgICAgICAgICAgcG9zICs9IHJlY29yZERlbGltaXRlckxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBpZiBsaW5lIGlzIGVtcHR5IGFuZCBza2lwX2VtcHR5X2xpbmVzIGFjdGl2YXRlZFxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNraXBfZW1wdHlfbGluZXMgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUud2FzUXVvdGluZyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5maWVsZC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW5mby5lbXB0eV9saW5lcysrO1xuICAgICAgICAgICAgICAgICAgcG9zICs9IHJlY29yZERlbGltaXRlckxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLmJ5dGVzID0gdGhpcy5zdGF0ZS5idWZCeXRlc1N0YXJ0ICsgcG9zO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyckZpZWxkID0gdGhpcy5fX29uRmllbGQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyRmllbGQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVyckZpZWxkO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5ieXRlcyA9XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmJ1ZkJ5dGVzU3RhcnQgKyBwb3MgKyByZWNvcmREZWxpbWl0ZXJMZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyUmVjb3JkID0gdGhpcy5fX29uUmVjb3JkKHB1c2gpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJSZWNvcmQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVyclJlY29yZDtcbiAgICAgICAgICAgICAgICBpZiAodG8gIT09IC0xICYmIHRoaXMuaW5mby5yZWNvcmRzID49IHRvKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jb21tZW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIHBvcyArPSByZWNvcmREZWxpbWl0ZXJMZW5ndGggLSAxO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNvbW1lbnRpbmcpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGNvbW1lbnQgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgKGNvbW1lbnRfbm9faW5maXggPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5maWVsZC5sZW5ndGggPT09IDApKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRDb3VudCA9IHRoaXMuX19jb21wYXJlQnl0ZXMoY29tbWVudCwgYnVmLCBwb3MsIGNocik7XG4gICAgICAgICAgICAgIGlmIChjb21tZW50Q291bnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNvbW1lbnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWxpbWl0ZXJMZW5ndGggPSB0aGlzLl9faXNEZWxpbWl0ZXIoYnVmLCBwb3MsIGNocik7XG4gICAgICAgICAgICBpZiAoZGVsaW1pdGVyTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5mby5ieXRlcyA9IHRoaXMuc3RhdGUuYnVmQnl0ZXNTdGFydCArIHBvcztcbiAgICAgICAgICAgICAgY29uc3QgZXJyRmllbGQgPSB0aGlzLl9fb25GaWVsZCgpO1xuICAgICAgICAgICAgICBpZiAoZXJyRmllbGQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVyckZpZWxkO1xuICAgICAgICAgICAgICBwb3MgKz0gZGVsaW1pdGVyTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNvbW1lbnRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbWF4X3JlY29yZF9zaXplICE9PSAwICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnJlY29yZF9sZW5ndGggKyB0aGlzLnN0YXRlLmZpZWxkLmxlbmd0aCA+IG1heF9yZWNvcmRfc2l6ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lcnJvcihcbiAgICAgICAgICAgICAgbmV3IENzdkVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ1NWX01BWF9SRUNPUkRfU0laRVwiLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIFwiTWF4IFJlY29yZCBTaXplOlwiLFxuICAgICAgICAgICAgICAgICAgXCJyZWNvcmQgZXhjZWVkIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0b2xlcmF0ZWQgYnl0ZXNcIixcbiAgICAgICAgICAgICAgICAgIGBvZiAke21heF9yZWNvcmRfc2l6ZX1gLFxuICAgICAgICAgICAgICAgICAgYGF0IGxpbmUgJHt0aGlzLmluZm8ubGluZXN9YCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aGlzLl9faW5mb0ZpZWxkKCksXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXBwZW5kID1cbiAgICAgICAgICBsdHJpbSA9PT0gZmFsc2UgfHxcbiAgICAgICAgICB0aGlzLnN0YXRlLnF1b3RpbmcgPT09IHRydWUgfHxcbiAgICAgICAgICB0aGlzLnN0YXRlLmZpZWxkLmxlbmd0aCAhPT0gMCB8fFxuICAgICAgICAgICF0aGlzLl9faXNDaGFyVHJpbWFibGUoYnVmLCBwb3MpO1xuICAgICAgICAvLyBydHJpbSBpbiBub24gcXVvdGluZyBpcyBoYW5kbGUgaW4gX19vbkZpZWxkXG4gICAgICAgIGNvbnN0IHJhcHBlbmQgPSBydHJpbSA9PT0gZmFsc2UgfHwgdGhpcy5zdGF0ZS53YXNRdW90aW5nID09PSBmYWxzZTtcbiAgICAgICAgaWYgKGxhcHBlbmQgPT09IHRydWUgJiYgcmFwcGVuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc3RhdGUuZmllbGQuYXBwZW5kKGNocik7XG4gICAgICAgIH0gZWxzZSBpZiAocnRyaW0gPT09IHRydWUgJiYgIXRoaXMuX19pc0NoYXJUcmltYWJsZShidWYsIHBvcykpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2Vycm9yKFxuICAgICAgICAgICAgbmV3IENzdkVycm9yKFxuICAgICAgICAgICAgICBcIkNTVl9OT05fVFJJTUFCTEVfQ0hBUl9BRlRFUl9DTE9TSU5HX1FVT1RFXCIsXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkludmFsaWQgQ2xvc2luZyBRdW90ZTpcIixcbiAgICAgICAgICAgICAgICBcImZvdW5kIG5vbiB0cmltYWJsZSBieXRlIGFmdGVyIHF1b3RlXCIsXG4gICAgICAgICAgICAgICAgYGF0IGxpbmUgJHt0aGlzLmluZm8ubGluZXN9YCxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICB0aGlzLl9faW5mb0ZpZWxkKCksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxhcHBlbmQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwb3MgKz0gdGhpcy5fX2lzQ2hhclRyaW1hYmxlKGJ1ZiwgcG9zKSAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZW5kID09PSB0cnVlKSB7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBhcmUgbm90IGVuZGluZyBpbiBhIHF1b3Rpbmcgc3RhdGVcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucXVvdGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19lcnJvcihcbiAgICAgICAgICAgIG5ldyBDc3ZFcnJvcihcbiAgICAgICAgICAgICAgXCJDU1ZfUVVPVEVfTk9UX0NMT1NFRFwiLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJRdW90ZSBOb3QgQ2xvc2VkOlwiLFxuICAgICAgICAgICAgICAgIGB0aGUgcGFyc2luZyBpcyBmaW5pc2hlZCB3aXRoIGFuIG9wZW5pbmcgcXVvdGUgYXQgbGluZSAke3RoaXMuaW5mby5saW5lc31gLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgIHRoaXMuX19pbmZvRmllbGQoKSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2tpcCBsYXN0IGxpbmUgaWYgaXQgaGFzIG5vIGNoYXJhY3RlcnNcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLnN0YXRlLndhc1F1b3RpbmcgPT09IHRydWUgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCAhPT0gMCB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5maWVsZC5sZW5ndGggIT09IDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuaW5mby5ieXRlcyA9IHRoaXMuc3RhdGUuYnVmQnl0ZXNTdGFydCArIHBvcztcbiAgICAgICAgICAgIGNvbnN0IGVyckZpZWxkID0gdGhpcy5fX29uRmllbGQoKTtcbiAgICAgICAgICAgIGlmIChlcnJGaWVsZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyRmllbGQ7XG4gICAgICAgICAgICBjb25zdCBlcnJSZWNvcmQgPSB0aGlzLl9fb25SZWNvcmQocHVzaCk7XG4gICAgICAgICAgICBpZiAoZXJyUmVjb3JkICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnJSZWNvcmQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5pbmZvLmVtcHR5X2xpbmVzKys7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmNvbW1lbnRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5mby5jb21tZW50X2xpbmVzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlLmJ1ZkJ5dGVzU3RhcnQgKz0gcG9zO1xuICAgICAgICB0aGlzLnN0YXRlLnByZXZpb3VzQnVmID0gYnVmLnNsaWNlKHBvcyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZS53YXNSb3dEZWxpbWl0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5pbmZvLmxpbmVzKys7XG4gICAgICAgIHRoaXMuc3RhdGUud2FzUm93RGVsaW1pdGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBfX29uUmVjb3JkOiBmdW5jdGlvbiAocHVzaCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2x1bW5zLFxuICAgICAgICBncm91cF9jb2x1bW5zX2J5X25hbWUsXG4gICAgICAgIGVuY29kaW5nLFxuICAgICAgICBpbmZvLFxuICAgICAgICBmcm9tLFxuICAgICAgICByZWxheF9jb2x1bW5fY291bnQsXG4gICAgICAgIHJlbGF4X2NvbHVtbl9jb3VudF9sZXNzLFxuICAgICAgICByZWxheF9jb2x1bW5fY291bnRfbW9yZSxcbiAgICAgICAgcmF3LFxuICAgICAgICBza2lwX3JlY29yZHNfd2l0aF9lbXB0eV92YWx1ZXMsXG4gICAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgY29uc3QgeyBlbmFibGVkLCByZWNvcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19yZXNldFJlY29yZCgpO1xuICAgICAgfVxuICAgICAgLy8gQ29udmVydCB0aGUgZmlyc3QgbGluZSBpbnRvIGNvbHVtbiBuYW1lc1xuICAgICAgY29uc3QgcmVjb3JkTGVuZ3RoID0gcmVjb3JkLmxlbmd0aDtcbiAgICAgIGlmIChjb2x1bW5zID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChza2lwX3JlY29yZHNfd2l0aF9lbXB0eV92YWx1ZXMgPT09IHRydWUgJiYgaXNSZWNvcmRFbXB0eShyZWNvcmQpKSB7XG4gICAgICAgICAgdGhpcy5fX3Jlc2V0UmVjb3JkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlyc3RMaW5lVG9Db2x1bW5zKHJlY29yZCk7XG4gICAgICB9XG4gICAgICBpZiAoY29sdW1ucyA9PT0gZmFsc2UgJiYgdGhpcy5pbmZvLnJlY29yZHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5leHBlY3RlZFJlY29yZExlbmd0aCA9IHJlY29yZExlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChyZWNvcmRMZW5ndGggIT09IHRoaXMuc3RhdGUuZXhwZWN0ZWRSZWNvcmRMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZXJyID1cbiAgICAgICAgICBjb2x1bW5zID09PSBmYWxzZVxuICAgICAgICAgICAgPyBuZXcgQ3N2RXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDU1ZfUkVDT1JEX0lOQ09OU0lTVEVOVF9GSUVMRFNfTEVOR1RIXCIsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgXCJJbnZhbGlkIFJlY29yZCBMZW5ndGg6XCIsXG4gICAgICAgICAgICAgICAgICBgZXhwZWN0ICR7dGhpcy5zdGF0ZS5leHBlY3RlZFJlY29yZExlbmd0aH0sYCxcbiAgICAgICAgICAgICAgICAgIGBnb3QgJHtyZWNvcmRMZW5ndGh9IG9uIGxpbmUgJHt0aGlzLmluZm8ubGluZXN9YCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aGlzLl9faW5mb0ZpZWxkKCksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgcmVjb3JkOiByZWNvcmQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBuZXcgQ3N2RXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDU1ZfUkVDT1JEX0lOQ09OU0lTVEVOVF9DT0xVTU5TXCIsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgXCJJbnZhbGlkIFJlY29yZCBMZW5ndGg6XCIsXG4gICAgICAgICAgICAgICAgICBgY29sdW1ucyBsZW5ndGggaXMgJHtjb2x1bW5zLmxlbmd0aH0sYCwgLy8gcmVuYW1lIGNvbHVtbnNcbiAgICAgICAgICAgICAgICAgIGBnb3QgJHtyZWNvcmRMZW5ndGh9IG9uIGxpbmUgJHt0aGlzLmluZm8ubGluZXN9YCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aGlzLl9faW5mb0ZpZWxkKCksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgcmVjb3JkOiByZWNvcmQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJlbGF4X2NvbHVtbl9jb3VudCA9PT0gdHJ1ZSB8fFxuICAgICAgICAgIChyZWxheF9jb2x1bW5fY291bnRfbGVzcyA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgcmVjb3JkTGVuZ3RoIDwgdGhpcy5zdGF0ZS5leHBlY3RlZFJlY29yZExlbmd0aCkgfHxcbiAgICAgICAgICAocmVsYXhfY29sdW1uX2NvdW50X21vcmUgPT09IHRydWUgJiZcbiAgICAgICAgICAgIHJlY29yZExlbmd0aCA+IHRoaXMuc3RhdGUuZXhwZWN0ZWRSZWNvcmRMZW5ndGgpXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMuaW5mby5pbnZhbGlkX2ZpZWxkX2xlbmd0aCsrO1xuICAgICAgICAgIHRoaXMuc3RhdGUuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgLy8gRXJyb3IgaXMgdW5kZWZpbmVkIHdpdGggc2tpcF9yZWNvcmRzX3dpdGhfZXJyb3JcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmaW5hbEVyciA9IHRoaXMuX19lcnJvcihlcnIpO1xuICAgICAgICAgIGlmIChmaW5hbEVycikgcmV0dXJuIGZpbmFsRXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2tpcF9yZWNvcmRzX3dpdGhfZW1wdHlfdmFsdWVzID09PSB0cnVlICYmIGlzUmVjb3JkRW1wdHkocmVjb3JkKSkge1xuICAgICAgICB0aGlzLl9fcmVzZXRSZWNvcmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGUucmVjb3JkSGFzRXJyb3IgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fX3Jlc2V0UmVjb3JkKCk7XG4gICAgICAgIHRoaXMuc3RhdGUucmVjb3JkSGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pbmZvLnJlY29yZHMrKztcbiAgICAgIGlmIChmcm9tID09PSAxIHx8IHRoaXMuaW5mby5yZWNvcmRzID49IGZyb20pIHtcbiAgICAgICAgY29uc3QgeyBvYmpuYW1lIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIFdpdGggY29sdW1ucywgcmVjb3JkcyBhcmUgb2JqZWN0XG4gICAgICAgIGlmIChjb2x1bW5zICE9PSBmYWxzZSkge1xuICAgICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICAgIC8vIFRyYW5zZm9ybSByZWNvcmQgYXJyYXkgdG8gYW4gb2JqZWN0XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSByZWNvcmQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1uc1tpXSA9PT0gdW5kZWZpbmVkIHx8IGNvbHVtbnNbaV0uZGlzYWJsZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gVHVybiBkdXBsaWNhdGUgY29sdW1ucyBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGdyb3VwX2NvbHVtbnNfYnlfbmFtZSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICBvYmpbY29sdW1uc1tpXS5uYW1lXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2NvbHVtbnNbaV0ubmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgb2JqW2NvbHVtbnNbaV0ubmFtZV0gPSBvYmpbY29sdW1uc1tpXS5uYW1lXS5jb25jYXQocmVjb3JkW2ldKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpbY29sdW1uc1tpXS5uYW1lXSA9IFtvYmpbY29sdW1uc1tpXS5uYW1lXSwgcmVjb3JkW2ldXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2JqW2NvbHVtbnNbaV0ubmFtZV0gPSByZWNvcmRbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFdpdGhvdXQgb2JqbmFtZSAoZGVmYXVsdClcbiAgICAgICAgICBpZiAocmF3ID09PSB0cnVlIHx8IGluZm8gPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dFJlY29yZCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHsgcmVjb3JkOiBvYmogfSxcbiAgICAgICAgICAgICAgcmF3ID09PSB0cnVlXG4gICAgICAgICAgICAgICAgPyB7IHJhdzogdGhpcy5zdGF0ZS5yYXdCdWZmZXIudG9TdHJpbmcoZW5jb2RpbmcpIH1cbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgICBpbmZvID09PSB0cnVlID8geyBpbmZvOiB0aGlzLl9faW5mb1JlY29yZCgpIH0gOiB7fSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fcHVzaChcbiAgICAgICAgICAgICAgb2JqbmFtZSA9PT0gdW5kZWZpbmVkID8gZXh0UmVjb3JkIDogW29ialtvYmpuYW1lXSwgZXh0UmVjb3JkXSxcbiAgICAgICAgICAgICAgcHVzaCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19wdXNoKFxuICAgICAgICAgICAgICBvYmpuYW1lID09PSB1bmRlZmluZWQgPyBvYmogOiBbb2JqW29iam5hbWVdLCBvYmpdLFxuICAgICAgICAgICAgICBwdXNoLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gV2l0aG91dCBjb2x1bW5zLCByZWNvcmRzIGFyZSBhcnJheVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyYXcgPT09IHRydWUgfHwgaW5mbyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgZXh0UmVjb3JkID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgeyByZWNvcmQ6IHJlY29yZCB9LFxuICAgICAgICAgICAgICByYXcgPT09IHRydWVcbiAgICAgICAgICAgICAgICA/IHsgcmF3OiB0aGlzLnN0YXRlLnJhd0J1ZmZlci50b1N0cmluZyhlbmNvZGluZykgfVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICAgIGluZm8gPT09IHRydWUgPyB7IGluZm86IHRoaXMuX19pbmZvUmVjb3JkKCkgfSA6IHt9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19wdXNoKFxuICAgICAgICAgICAgICBvYmpuYW1lID09PSB1bmRlZmluZWQgPyBleHRSZWNvcmQgOiBbcmVjb3JkW29iam5hbWVdLCBleHRSZWNvcmRdLFxuICAgICAgICAgICAgICBwdXNoLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5fX3B1c2goXG4gICAgICAgICAgICAgIG9iam5hbWUgPT09IHVuZGVmaW5lZCA/IHJlY29yZCA6IFtyZWNvcmRbb2JqbmFtZV0sIHJlY29yZF0sXG4gICAgICAgICAgICAgIHB1c2gsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fX3Jlc2V0UmVjb3JkKCk7XG4gICAgfSxcbiAgICBfX2ZpcnN0TGluZVRvQ29sdW1uczogZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgY29uc3QgeyBmaXJzdExpbmVUb0hlYWRlcnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID1cbiAgICAgICAgICBmaXJzdExpbmVUb0hlYWRlcnMgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyByZWNvcmRcbiAgICAgICAgICAgIDogZmlyc3RMaW5lVG9IZWFkZXJzLmNhbGwobnVsbCwgcmVjb3JkKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19lcnJvcihcbiAgICAgICAgICAgIG5ldyBDc3ZFcnJvcihcbiAgICAgICAgICAgICAgXCJDU1ZfSU5WQUxJRF9DT0xVTU5fTUFQUElOR1wiLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJJbnZhbGlkIENvbHVtbiBNYXBwaW5nOlwiLFxuICAgICAgICAgICAgICAgIFwiZXhwZWN0IGFuIGFycmF5IGZyb20gY29sdW1uIGZ1bmN0aW9uLFwiLFxuICAgICAgICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShoZWFkZXJzKX1gLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgIHRoaXMuX19pbmZvRmllbGQoKSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEhlYWRlcnMgPSBub3JtYWxpemVfY29sdW1uc19hcnJheShoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5leHBlY3RlZFJlY29yZExlbmd0aCA9IG5vcm1hbGl6ZWRIZWFkZXJzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbHVtbnMgPSBub3JtYWxpemVkSGVhZGVycztcbiAgICAgICAgdGhpcy5fX3Jlc2V0UmVjb3JkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgX19yZXNldFJlY29yZDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYXcgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5yYXdCdWZmZXIucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUuZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnN0YXRlLnJlY29yZCA9IFtdO1xuICAgICAgdGhpcy5zdGF0ZS5yZWNvcmRfbGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIF9fb25GaWVsZDogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgeyBjYXN0LCBlbmNvZGluZywgcnRyaW0sIG1heF9yZWNvcmRfc2l6ZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgY29uc3QgeyBlbmFibGVkLCB3YXNRdW90aW5nIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBmb3IgdGhlIGZyb21fbGluZSBvcHRpb25zXG4gICAgICBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19yZXNldEZpZWxkKCk7XG4gICAgICB9XG4gICAgICBsZXQgZmllbGQgPSB0aGlzLnN0YXRlLmZpZWxkLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICAgIGlmIChydHJpbSA9PT0gdHJ1ZSAmJiB3YXNRdW90aW5nID09PSBmYWxzZSkge1xuICAgICAgICBmaWVsZCA9IGZpZWxkLnRyaW1SaWdodCgpO1xuICAgICAgfVxuICAgICAgaWYgKGNhc3QgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgW2VyciwgZl0gPSB0aGlzLl9fY2FzdChmaWVsZCk7XG4gICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVycjtcbiAgICAgICAgZmllbGQgPSBmO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5yZWNvcmQucHVzaChmaWVsZCk7XG4gICAgICAvLyBJbmNyZW1lbnQgcmVjb3JkIGxlbmd0aCBpZiByZWNvcmQgc2l6ZSBtdXN0IG5vdCBleGNlZWQgYSBsaW1pdFxuICAgICAgaWYgKG1heF9yZWNvcmRfc2l6ZSAhPT0gMCAmJiB0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5yZWNvcmRfbGVuZ3RoICs9IGZpZWxkLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19yZXNldEZpZWxkKCk7XG4gICAgfSxcbiAgICBfX3Jlc2V0RmllbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3RhdGUuZmllbGQucmVzZXQoKTtcbiAgICAgIHRoaXMuc3RhdGUud2FzUXVvdGluZyA9IGZhbHNlO1xuICAgIH0sXG4gICAgX19wdXNoOiBmdW5jdGlvbiAocmVjb3JkLCBwdXNoKSB7XG4gICAgICBjb25zdCB7IG9uX3JlY29yZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9uX3JlY29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLl9faW5mb1JlY29yZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlY29yZCA9IG9uX3JlY29yZC5jYWxsKG51bGwsIHJlY29yZCwgaW5mbyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY29yZCA9PT0gdW5kZWZpbmVkIHx8IHJlY29yZCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHVzaChyZWNvcmQpO1xuICAgIH0sXG4gICAgLy8gUmV0dXJuIGEgdHVwbGUgd2l0aCB0aGUgZXJyb3IgYW5kIHRoZSBjYXN0ZWQgdmFsdWVcbiAgICBfX2Nhc3Q6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgY29uc3QgeyBjb2x1bW5zLCByZWxheF9jb2x1bW5fY291bnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGNvbnN0IGlzQ29sdW1ucyA9IEFycmF5LmlzQXJyYXkoY29sdW1ucyk7XG4gICAgICAvLyBEb250IGxvb3NlIHRpbWUgY2FsbGluZyBjYXN0XG4gICAgICAvLyBiZWNhdXNlIHRoZSBmaW5hbCByZWNvcmQgaXMgYW4gb2JqZWN0XG4gICAgICAvLyBhbmQgdGhpcyBmaWVsZCBjYW4ndCBiZSBhc3NvY2lhdGVkIHRvIGEga2V5IHByZXNlbnQgaW4gY29sdW1uc1xuICAgICAgaWYgKFxuICAgICAgICBpc0NvbHVtbnMgPT09IHRydWUgJiZcbiAgICAgICAgcmVsYXhfY29sdW1uX2NvdW50ICYmXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb2x1bW5zLmxlbmd0aCA8PSB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGhcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlLmNhc3RGaWVsZCAhPT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLl9faW5mb0ZpZWxkKCk7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMuc3RhdGUuY2FzdEZpZWxkLmNhbGwobnVsbCwgZmllbGQsIGluZm8pXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIFtlcnJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX2lzRmxvYXQoZmllbGQpKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCBwYXJzZUZsb2F0KGZpZWxkKV07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jYXN0X2RhdGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLl9faW5mb0ZpZWxkKCk7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB0aGlzLm9wdGlvbnMuY2FzdF9kYXRlLmNhbGwobnVsbCwgZmllbGQsIGluZm8pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdW5kZWZpbmVkLCBmaWVsZF07XG4gICAgfSxcbiAgICAvLyBIZWxwZXIgdG8gdGVzdCBpZiBhIGNoYXJhY3RlciBpcyBhIHNwYWNlIG9yIGEgbGluZSBkZWxpbWl0ZXJcbiAgICBfX2lzQ2hhclRyaW1hYmxlOiBmdW5jdGlvbiAoYnVmLCBwb3MpIHtcbiAgICAgIGNvbnN0IGlzVHJpbSA9IChidWYsIHBvcykgPT4ge1xuICAgICAgICBjb25zdCB7IHRpbWNoYXJzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsb29wMTogZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1jaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHRpbWNoYXIgPSB0aW1jaGFyc1tpXTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRpbWNoYXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aW1jaGFyW2pdICE9PSBidWZbcG9zICsgal0pIGNvbnRpbnVlIGxvb3AxO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGltY2hhci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGlzVHJpbShidWYsIHBvcyk7XG4gICAgfSxcbiAgICAvLyBLZWVwIGl0IGluIGNhc2Ugd2UgaW1wbGVtZW50IHRoZSBgY2FzdF9pbnRgIG9wdGlvblxuICAgIC8vIF9faXNJbnQodmFsdWUpe1xuICAgIC8vICAgLy8gcmV0dXJuIE51bWJlci5pc0ludGVnZXIocGFyc2VJbnQodmFsdWUpKVxuICAgIC8vICAgLy8gcmV0dXJuICFpc05hTiggcGFyc2VJbnQoIG9iaiApICk7XG4gICAgLy8gICByZXR1cm4gL14oXFwtfFxcKyk/WzEtOV1bMC05XSokLy50ZXN0KHZhbHVlKVxuICAgIC8vIH1cbiAgICBfX2lzRmxvYXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIC0gcGFyc2VGbG9hdCh2YWx1ZSkgKyAxID49IDA7IC8vIEJvcnJvd2VkIGZyb20ganF1ZXJ5XG4gICAgfSxcbiAgICBfX2NvbXBhcmVCeXRlczogZnVuY3Rpb24gKHNvdXJjZUJ1ZiwgdGFyZ2V0QnVmLCB0YXJnZXRQb3MsIGZpcnN0Qnl0ZSkge1xuICAgICAgaWYgKHNvdXJjZUJ1ZlswXSAhPT0gZmlyc3RCeXRlKSByZXR1cm4gMDtcbiAgICAgIGNvbnN0IHNvdXJjZUxlbmd0aCA9IHNvdXJjZUJ1Zi5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvdXJjZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzb3VyY2VCdWZbaV0gIT09IHRhcmdldEJ1Zlt0YXJnZXRQb3MgKyBpXSkgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlTGVuZ3RoO1xuICAgIH0sXG4gICAgX19pc0RlbGltaXRlcjogZnVuY3Rpb24gKGJ1ZiwgcG9zLCBjaHIpIHtcbiAgICAgIGNvbnN0IHsgZGVsaW1pdGVyLCBpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoXG4gICAgICAgIGlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPT09IHRydWUgJiZcbiAgICAgICAgdGhpcy5zdGF0ZS5yZWNvcmQubGVuZ3RoID09PSB0aGlzLm9wdGlvbnMuY29sdW1ucy5sZW5ndGggLSAxXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzICE9PSBmYWxzZSAmJlxuICAgICAgICB0eXBlb2YgaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGggPT09IGlnbm9yZV9sYXN0X2RlbGltaXRlcnMgLSAxXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBsb29wMTogZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxpbWl0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVsID0gZGVsaW1pdGVyW2ldO1xuICAgICAgICBpZiAoZGVsWzBdID09PSBjaHIpIHtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGRlbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGRlbFtqXSAhPT0gYnVmW3BvcyArIGpdKSBjb250aW51ZSBsb29wMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlbC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgX19pc1JlY29yZERlbGltaXRlcjogZnVuY3Rpb24gKGNociwgYnVmLCBwb3MpIHtcbiAgICAgIGNvbnN0IHsgcmVjb3JkX2RlbGltaXRlciB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgY29uc3QgcmVjb3JkRGVsaW1pdGVyTGVuZ3RoID0gcmVjb3JkX2RlbGltaXRlci5sZW5ndGg7XG4gICAgICBsb29wMTogZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvcmREZWxpbWl0ZXJMZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByZCA9IHJlY29yZF9kZWxpbWl0ZXJbaV07XG4gICAgICAgIGNvbnN0IHJkTGVuZ3RoID0gcmQubGVuZ3RoO1xuICAgICAgICBpZiAocmRbMF0gIT09IGNocikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgcmRMZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChyZFtqXSAhPT0gYnVmW3BvcyArIGpdKSB7XG4gICAgICAgICAgICBjb250aW51ZSBsb29wMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJkLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgX19pc0VzY2FwZTogZnVuY3Rpb24gKGJ1ZiwgcG9zLCBjaHIpIHtcbiAgICAgIGNvbnN0IHsgZXNjYXBlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoZXNjYXBlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBsID0gZXNjYXBlLmxlbmd0aDtcbiAgICAgIGlmIChlc2NhcGVbMF0gPT09IGNocikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChlc2NhcGVbaV0gIT09IGJ1Zltwb3MgKyBpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIF9faXNRdW90ZTogZnVuY3Rpb24gKGJ1ZiwgcG9zKSB7XG4gICAgICBjb25zdCB7IHF1b3RlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAocXVvdGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IGwgPSBxdW90ZS5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAocXVvdGVbaV0gIT09IGJ1Zltwb3MgKyBpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBfX2F1dG9EaXNjb3ZlclJlY29yZERlbGltaXRlcjogZnVuY3Rpb24gKGJ1ZiwgcG9zKSB7XG4gICAgICBjb25zdCB7IGVuY29kaW5nIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAvLyBOb3RlLCB3ZSBkb24ndCBuZWVkIHRvIGNhY2hlIHRoaXMgaW5mb3JtYXRpb24gaW4gc3RhdGUsXG4gICAgICAvLyBJdCBpcyBvbmx5IGNhbGxlZCBvbiB0aGUgZmlyc3QgbGluZSB1bnRpbCB3ZSBmaW5kIG91dCBhIHN1aXRhYmxlXG4gICAgICAvLyByZWNvcmQgZGVsaW1pdGVyLlxuICAgICAgY29uc3QgcmRzID0gW1xuICAgICAgICAvLyBJbXBvcnRhbnQsIHRoZSB3aW5kb3dzIGxpbmUgZW5kaW5nIG11c3QgYmUgYmVmb3JlIG1hYyBvcyA5XG4gICAgICAgIEJ1ZmZlci5mcm9tKFwiXFxyXFxuXCIsIGVuY29kaW5nKSxcbiAgICAgICAgQnVmZmVyLmZyb20oXCJcXG5cIiwgZW5jb2RpbmcpLFxuICAgICAgICBCdWZmZXIuZnJvbShcIlxcclwiLCBlbmNvZGluZyksXG4gICAgICBdO1xuICAgICAgbG9vcDogZm9yIChsZXQgaSA9IDA7IGkgPCByZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbCA9IHJkc1tpXS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgaWYgKHJkc1tpXVtqXSAhPT0gYnVmW3BvcyArIGpdKSB7XG4gICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMucmVjb3JkX2RlbGltaXRlci5wdXNoKHJkc1tpXSk7XG4gICAgICAgIHRoaXMuc3RhdGUucmVjb3JkRGVsaW1pdGVyTWF4TGVuZ3RoID0gcmRzW2ldLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJkc1tpXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIF9fZXJyb3I6IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGNvbnN0IHsgZW5jb2RpbmcsIHJhdywgc2tpcF9yZWNvcmRzX3dpdGhfZXJyb3IgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGNvbnN0IGVyciA9IHR5cGVvZiBtc2cgPT09IFwic3RyaW5nXCIgPyBuZXcgRXJyb3IobXNnKSA6IG1zZztcbiAgICAgIGlmIChza2lwX3JlY29yZHNfd2l0aF9lcnJvcikge1xuICAgICAgICB0aGlzLnN0YXRlLnJlY29yZEhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbl9za2lwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25fc2tpcChcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIHJhdyA/IHRoaXMuc3RhdGUucmF3QnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuZW1pdCgnc2tpcCcsIGVyciwgcmF3ID8gdGhpcy5zdGF0ZS5yYXdCdWZmZXIudG9TdHJpbmcoZW5jb2RpbmcpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfSxcbiAgICBfX2luZm9EYXRhU2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50aGlzLmluZm8sXG4gICAgICAgIGNvbHVtbnM6IHRoaXMub3B0aW9ucy5jb2x1bW5zLFxuICAgICAgfTtcbiAgICB9LFxuICAgIF9faW5mb1JlY29yZDogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgeyBjb2x1bW5zLCByYXcsIGVuY29kaW5nIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50aGlzLl9faW5mb0RhdGFTZXQoKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgIGhlYWRlcjogY29sdW1ucyA9PT0gdHJ1ZSxcbiAgICAgICAgaW5kZXg6IHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCxcbiAgICAgICAgcmF3OiByYXcgPyB0aGlzLnN0YXRlLnJhd0J1ZmZlci50b1N0cmluZyhlbmNvZGluZykgOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH0sXG4gICAgX19pbmZvRmllbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHsgY29sdW1ucyB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgY29uc3QgaXNDb2x1bW5zID0gQXJyYXkuaXNBcnJheShjb2x1bW5zKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRoaXMuX19pbmZvUmVjb3JkKCksXG4gICAgICAgIGNvbHVtbjpcbiAgICAgICAgICBpc0NvbHVtbnMgPT09IHRydWVcbiAgICAgICAgICAgID8gY29sdW1ucy5sZW5ndGggPiB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGhcbiAgICAgICAgICAgICAgPyBjb2x1bW5zW3RoaXMuc3RhdGUucmVjb3JkLmxlbmd0aF0ubmFtZVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIDogdGhpcy5zdGF0ZS5yZWNvcmQubGVuZ3RoLFxuICAgICAgICBxdW90aW5nOiB0aGlzLnN0YXRlLndhc1F1b3RpbmcsXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG59O1xuXG5leHBvcnQgeyB0cmFuc2Zvcm0sIENzdkVycm9yIH07XG4iLCAiaW1wb3J0IHsgQ3N2RXJyb3IsIHRyYW5zZm9ybSB9IGZyb20gXCIuL2FwaS9pbmRleC5qc1wiO1xuXG5jb25zdCBwYXJzZSA9IGZ1bmN0aW9uIChkYXRhLCBvcHRzID0ge30pIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICB9XG4gIGNvbnN0IHJlY29yZHMgPSBvcHRzICYmIG9wdHMub2JqbmFtZSA/IHt9IDogW107XG4gIGNvbnN0IHBhcnNlciA9IHRyYW5zZm9ybShvcHRzKTtcbiAgY29uc3QgcHVzaCA9IChyZWNvcmQpID0+IHtcbiAgICBpZiAocGFyc2VyLm9wdGlvbnMub2JqbmFtZSA9PT0gdW5kZWZpbmVkKSByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICBlbHNlIHtcbiAgICAgIHJlY29yZHNbcmVjb3JkWzBdXSA9IHJlY29yZFsxXTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNsb3NlID0gKCkgPT4ge307XG4gIGNvbnN0IGVycjEgPSBwYXJzZXIucGFyc2UoZGF0YSwgZmFsc2UsIHB1c2gsIGNsb3NlKTtcbiAgaWYgKGVycjEgIT09IHVuZGVmaW5lZCkgdGhyb3cgZXJyMTtcbiAgY29uc3QgZXJyMiA9IHBhcnNlci5wYXJzZSh1bmRlZmluZWQsIHRydWUsIHB1c2gsIGNsb3NlKTtcbiAgaWYgKGVycjIgIT09IHVuZGVmaW5lZCkgdGhyb3cgZXJyMjtcbiAgcmV0dXJuIHJlY29yZHM7XG59O1xuXG4vLyBleHBvcnQgZGVmYXVsdCBwYXJzZVxuZXhwb3J0IHsgcGFyc2UgfTtcbmV4cG9ydCB7IENzdkVycm9yIH07XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFBZ0JBLFFBQUk7QUFDbEIsZUFBTztNQUNUO0FDQ00sZUFBVSxhQUFhQyxJQUFNO0FBQ2pDLGVBQVEsT0FBT0EsT0FBTSxZQUFZQSxPQUFNLFFBQVMsT0FBT0EsT0FBTTtNQUMvRDtBQUVPLFlBQU0saUNBVVBEO0FBRVUsZUFBQSxnQkFBZ0IsSUFBYyxNQUFZO0FBQ3hELFlBQUk7QUFDRixpQkFBTyxlQUFlLElBQUksUUFBUTtZQUNoQyxPQUFPO1lBQ1AsY0FBYztVQUNmLENBQUE7aUJBQ0RFLEtBQU07O01BSVY7QUMxQkEsWUFBTSxrQkFBa0I7QUFDeEIsWUFBTSxzQkFBc0IsUUFBUSxVQUFVO0FBQzlDLFlBQU0sd0JBQXdCLFFBQVEsT0FBTyxLQUFLLGVBQWU7QUFHM0QsZUFBVSxXQUFjLFVBR3JCO0FBQ1AsZUFBTyxJQUFJLGdCQUFnQixRQUFRO01BQ3JDO0FBR00sZUFBVSxvQkFBdUIsT0FBeUI7QUFDOUQsZUFBTyxXQUFXLGFBQVcsUUFBUSxLQUFLLENBQUM7TUFDN0M7QUFHTSxlQUFVLG9CQUErQixRQUFXO0FBQ3hELGVBQU8sc0JBQXNCLE1BQU07TUFDckM7ZUFFZ0IsbUJBQ2QsU0FDQSxhQUNBLFlBQThEO0FBRzlELGVBQU8sb0JBQW9CLEtBQUssU0FBUyxhQUFhLFVBQVU7TUFDbEU7ZUFLZ0IsWUFDZCxTQUNBLGFBQ0EsWUFBc0Q7QUFDdEQsMkJBQ0UsbUJBQW1CLFNBQVMsYUFBYSxVQUFVLEdBQ25ELFFBQ0EsOEJBQThC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LElBQUksTUFBTSxrREFBa0Q7QUFBQSxRQUNuRTtBQUFBLE1BQ0Q7QUFBQSxJQUNEO0FBQUE7QUFBQTs7O0FDN1RBO0FBQUEsMkNBQUFFLFVBQUFDLFNBQUE7QUFBQSxJQUFBQSxRQUFPLFVBQVU7QUFBQTtBQUFBLE1BRWIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQTtBQUFBLE1BR25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUE7QUFBQSxNQUduQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBO0FBQUEsTUFHbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixRQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBLE1BRW5CLFVBQW1CO0FBQUE7QUFBQSxNQUNuQixVQUFtQjtBQUFBO0FBQUEsTUFDbkIsWUFBbUI7QUFBQTtBQUFBLE1BQ25CLFVBQW1CO0FBQUE7QUFBQSxNQUNuQixlQUFtQjtBQUFBO0FBQUEsTUFFbkIsVUFBbUI7QUFBQTtBQUFBLE1BQ25CLFVBQW1CO0FBQUE7QUFBQSxNQUNuQixXQUFtQjtBQUFBO0FBQUEsTUFDbkIsV0FBbUI7QUFBQTtBQUFBLE1BQ25CLFVBQW1CO0FBQUE7QUFBQSxNQUNuQixVQUFtQjtBQUFBO0FBQUEsTUFDbkIsVUFBbUI7QUFBQTtBQUFBLE1BQ25CLGFBQW1CO0FBQUE7QUFBQSxNQUNuQixVQUFtQjtBQUFBO0FBQUEsTUFDbkIsVUFBbUI7QUFBQTtBQUFBLE1BQ25CLFdBQW1CO0FBQUE7QUFBQSxNQUNuQixVQUFtQjtBQUFBO0FBQUEsTUFDbkIsWUFBbUI7QUFBQTtBQUFBO0FBQUEsTUFHbkIsUUFBbUI7QUFBQTtBQUFBLE1BQ25CLFFBQW1CO0FBQUE7QUFBQSxNQUNuQixVQUFtQjtBQUFBO0FBQUEsTUFDbkIsVUFBbUI7QUFBQTtBQUFBLE1BQ25CLFVBQW1CO0FBQUE7QUFBQSxNQUNuQixVQUFtQjtBQUFBO0FBQUEsTUFDbkIsVUFBbUI7QUFBQTtBQUFBO0FBQUEsTUFFbkIsVUFBbUI7QUFBQTtBQUFBLE1BQ25CLG1CQUFtQjtBQUFBO0FBQUEsTUFDbkIsUUFBbUI7QUFBQTtBQUFBO0FBQUEsTUFFbkIsT0FBbUI7QUFBQTtBQUFBO0FBQUEsTUFFbkIsTUFBbUI7QUFBQTtBQUFBO0FBQUEsTUFFbkIsV0FBbUI7QUFBQTtBQUFBLE1BQ25CLFVBQW1CO0FBQUE7QUFBQSxNQUNuQixhQUFtQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSW5CLFNBQW1CO0FBQUE7QUFBQSxNQUNuQixXQUFtQjtBQUFBO0FBQUEsTUFDbkIsV0FBbUI7QUFBQTtBQUFBLE1BQ25CLFVBQW1CO0FBQUE7QUFBQSxNQUNuQixTQUFtQjtBQUFBO0FBQUEsTUFDbkIsV0FBbUI7QUFBQTtBQUFBLE1BQ25CLFNBQW1CO0FBQUE7QUFBQTtBQUFBLE1BRW5CLFNBQW1CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUluQixTQUFtQjtBQUFBO0FBQUE7QUFBQSxNQUduQixNQUFtQjtBQUFBLE1BQ25CLFFBQW1CO0FBQUEsTUFDbkIsTUFBbUI7QUFBQTtBQUFBLE1BR25CLE9BQW1CO0FBQUEsTUFDbkIsU0FBbUI7QUFBQTtBQUFBLE1BR25CLFVBQW1CO0FBQUEsTUFDbkIsV0FBbUI7QUFBQSxNQUNuQixRQUFtQjtBQUFBLE1BQ25CLFFBQW1CO0FBQUEsTUFDbkIsU0FBbUI7QUFBQSxNQUNuQixZQUFtQjtBQUFBLE1BQ25CLFNBQW1CO0FBQUEsTUFDbkIsU0FBbUI7QUFBQSxNQUNuQixVQUFtQjtBQUFBLE1BQ25CLGVBQW1CO0FBQUEsTUFDbkIsa0JBQW1CO0FBQUEsTUFDbkIsa0JBQW1CO0FBQUEsTUFDbkIsY0FBbUI7QUFBQSxNQUNuQixlQUFtQjtBQUFBLE1BQ25CLGtCQUFtQjtBQUFBLE1BQ25CLFNBQW1CO0FBQUEsTUFDbkIsU0FBbUI7QUFBQSxNQUNuQixXQUFtQjtBQUFBLE1BRW5CLGdCQUFtQjtBQUFBLE1BQ25CLGdCQUFtQjtBQUFBLE1BQ25CLGtCQUFtQjtBQUFBLE1BQ25CLGdCQUFtQjtBQUFBLE1BQ25CLGNBQW1CO0FBQUEsTUFDbkIsY0FBbUI7QUFBQSxJQUN2QjtBQUFBO0FBQUE7OztBQzdJQTtBQUFBLHdDQUFBQyxVQUFBO0FBQUEsUUFBTSxTQUFTO0FBQUE7QUFBQSxNQUVYLGFBQWE7QUFBQSxNQUNiLGFBQWE7QUFBQSxNQUNiLGFBQWE7QUFBQTtBQUFBLE1BR2Isc0JBQXNCO0FBQUEsTUFDdEIsb0JBQW9CO0FBQUEsTUFDcEIsbUJBQW1CO0FBQUE7QUFBQSxNQUduQixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxpQkFBaUI7QUFBQSxNQUNqQixnQkFBZ0I7QUFBQTtBQUFBLE1BR2hCLFlBQVk7QUFBQSxNQUNaLGtCQUFrQjtBQUFBLE1BQ2xCLGVBQWU7QUFBQSxNQUNmLG9CQUFvQjtBQUFBLE1BQ3BCLHNCQUFzQjtBQUFBLE1BQ3RCLGtCQUFrQjtBQUFBLE1BQ2xCLHNCQUFzQjtBQUFBLE1BQ3RCLG1CQUFtQjtBQUFBLE1BQ25CLHFCQUFxQjtBQUFBLE1BQ3JCLG9CQUFvQjtBQUFBO0FBQUEsTUFHcEIsbUJBQW1CO0FBQUEsTUFDbkIsZUFBZTtBQUFBLE1BQ2Ysc0JBQXNCO0FBQUEsTUFDdEIsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YseUJBQXlCO0FBQUEsTUFDekIsZ0JBQWdCO0FBQUEsTUFDaEIsaUJBQWlCO0FBQUEsTUFDakIsa0JBQWtCO0FBQUEsTUFDbEIsZ0JBQWdCO0FBQUEsTUFDaEIsb0JBQW9CO0FBQUEsTUFDcEIsZ0JBQWdCO0FBQUE7QUFBQSxNQUdoQixrQkFBa0I7QUFBQTtBQUFBLE1BQ2xCLHlCQUF5QjtBQUFBLElBQzdCO0FBR0EsYUFBUyxFQUFFLFNBQVM7QUFDaEIsYUFBTyxZQUFhLE1BQU07QUFDdEIsWUFBSSxLQUFLLFFBQVE7QUFDYixvQkFBVSxRQUFRLFFBQVEsYUFBYSxDQUFDLEdBQUcsTUFBTSxLQUFLLENBQUMsS0FBSyxFQUFFO0FBQUEsUUFDbEU7QUFFQSxlQUFPLElBQUksTUFBTSxjQUFjLE9BQU87QUFBQSxNQUMxQztBQUFBLElBQ0o7QUFHQSxlQUFXLE9BQU8sT0FBTyxLQUFLLE1BQU0sR0FBRztBQUNuQyxNQUFBQSxTQUFRLEdBQUcsSUFBSSxFQUFFLE9BQU8sR0FBRyxDQUFDO0FBQUEsSUFDaEM7QUFBQTtBQUFBOzs7QUM5REE7QUFBQSx1Q0FBQUMsVUFBQUMsU0FBQTtBQUFBLFFBQU0sVUFBVSxRQUFRLElBQUk7QUFDNUIsUUFBTSxNQUFNLFFBQVEsTUFBTTtBQUMxQixRQUFNLFlBQVk7QUFDbEIsUUFBTSxTQUFTO0FBQ2YsUUFBTSxRQUFRLE9BQU8sWUFBWSxZQUFZLFlBQVksUUFBUTtBQUVqRSxRQUFNLFNBQVMsQ0FBQyxRQUFRLE9BQU8sUUFBUSxZQUFZLFFBQVE7QUFHM0QsUUFBTSxXQUFXLElBQUksWUFBWSxHQUFHLEVBQUUsSUFBSSxDQUFDQyxJQUFHLE1BQU07QUFDaEQsZUFBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDeEIsYUFBSyxJQUFJLE9BQU8sR0FBRztBQUNmLGNBQUksYUFBYyxNQUFNO0FBQUEsUUFDNUIsT0FBTztBQUNILGlCQUFPO0FBQUEsUUFDWDtBQUFBLE1BQ0o7QUFDQSxhQUFPLE1BQU07QUFBQSxJQUNqQixDQUFDO0FBSUQsYUFBUyxNQUFNLE1BQU07QUFDakIsV0FBSyxNQUFNLElBQUk7QUFDZixXQUFLLEtBQUs7QUFFVixVQUFJLE9BQU8sSUFBSSxHQUFHO0FBRWQsWUFBSSxPQUFPLEtBQUssRUFBRSxLQUFLLE9BQU8sS0FBSyxHQUFHLGFBQWEsWUFBWTtBQUMzRCxlQUFLLEtBQUssS0FBSztBQUFBLFFBQ25CO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFFQSxJQUFBRCxRQUFPLFVBQVU7QUFJakIsVUFBTSxVQUFVLFVBQVUsU0FBcUIsUUFBUTtBQUNuRCxZQUFNRSxRQUFPO0FBR2IsZUFBUyxVQUFxQixPQUFPO0FBQ2pDLFlBQUksZUFBZSxNQUFNLE1BQU1BLE1BQUssR0FBRyxFQUFFLENBQUM7QUFDMUMsY0FBTSxNQUFNQSxNQUFLLEdBQUcsRUFBRSxRQUFRLFNBQVUsTUFBTTtBQUMxQyxjQUFJLENBQUMsUUFBUSxLQUFLLE9BQU8sSUFBSSxDQUFDLE1BQU0sSUFBSztBQUN6QywwQkFBZ0JBLE1BQUssTUFBTTtBQUMzQixjQUFJQztBQUNKLGNBQUk7QUFDQSxZQUFBQSxRQUFPRCxNQUFLLEdBQUcsU0FBUyxZQUFZO0FBQUEsVUFDeEMsU0FBU0UsSUFBRztBQUNSLFlBQUFGLE1BQUssR0FBRyxVQUFVLFlBQVk7QUFBQSxVQUNsQztBQUNBLGNBQUlDLFNBQVFBLE1BQUssT0FBTyxFQUFHLE9BQU0sT0FBTyxnQkFBZ0IsSUFBSSxZQUFZLEdBQUc7QUFBQSxRQUMvRSxDQUFDO0FBQUEsTUFDTDtBQUVBLGdCQUFVLE1BQU07QUFBQSxJQUNwQjtBQUVBLFVBQU0sVUFBVSxjQUFjLFNBQXFCRSxPQUFpQixTQUFxQixXQUFzQixNQUFNO0FBQ2pILFlBQU1ILFFBQU87QUFDYixVQUFJQSxNQUFLLEdBQUcsV0FBV0csS0FBSSxHQUFHO0FBQzFCLFlBQUksQ0FBQyxVQUFXLFFBQU87QUFFdkIsWUFBSUYsUUFBT0QsTUFBSyxHQUFHLFNBQVNHLEtBQUk7QUFDaEMsWUFBSUYsTUFBSyxZQUFZLEdBQUc7QUFDcEIsaUJBQU87QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUNBLFVBQUksU0FBUyxJQUFJLFFBQVFFLEtBQUk7QUFDN0IsVUFBSSxDQUFDSCxNQUFLLEdBQUcsV0FBVyxNQUFNLEdBQUc7QUFDN0IsUUFBQUEsTUFBSyxRQUFRLE1BQU07QUFBQSxNQUN2QjtBQUVBLFVBQUk7QUFDSixVQUFJO0FBQ0EsYUFBS0EsTUFBSyxHQUFHLFNBQVNHLE9BQU0sS0FBSyxHQUFLO0FBQUEsTUFDMUMsU0FBU0QsSUFBRztBQUNSLFFBQUFGLE1BQUssR0FBRyxVQUFVRyxPQUFNLEdBQUs7QUFDN0IsYUFBS0gsTUFBSyxHQUFHLFNBQVNHLE9BQU0sS0FBSyxHQUFLO0FBQUEsTUFDMUM7QUFDQSxVQUFJLElBQUk7QUFDSixZQUFJO0FBQ0EsVUFBQUgsTUFBSyxHQUFHLFVBQVUsSUFBSSxTQUFTLEdBQUcsUUFBUSxRQUFRLENBQUM7QUFBQSxRQUN2RCxVQUFFO0FBQ0UsVUFBQUEsTUFBSyxHQUFHLFVBQVUsRUFBRTtBQUFBLFFBQ3hCO0FBQUEsTUFDSjtBQUNBLE1BQUFBLE1BQUssR0FBRyxVQUFVRyxPQUFNLFFBQVEsR0FBSztBQUNyQyxhQUFPO0FBQUEsSUFDWDtBQUVBLFVBQU0sVUFBVSxtQkFBbUIsU0FBcUJBLE9BQWlCLFNBQXFCLFdBQXNCLE1BQW1CLFVBQVU7QUFDN0ksVUFBSSxPQUFPLFNBQVMsWUFBWTtBQUM1QixtQkFBVztBQUNYLGVBQU87QUFBQSxNQUNYO0FBRUEsWUFBTUgsUUFBTztBQUViLE1BQUFBLE1BQUssR0FBRyxPQUFPRyxPQUFNLFNBQVUsT0FBTztBQUNsQyxZQUFJLFNBQVMsQ0FBQyxVQUFXLFFBQU8sU0FBUyxLQUFLO0FBRTlDLFFBQUFILE1BQUssR0FBRyxLQUFLRyxPQUFNLFNBQVUsS0FBS0YsT0FBTTtBQUNwQyxjQUFJLFNBQVNBLE1BQUssWUFBWSxHQUFHO0FBQzdCLG1CQUFPLFNBQVMsS0FBSztBQUFBLFVBQ3pCO0FBRUEsY0FBSSxTQUFTLElBQUksUUFBUUUsS0FBSTtBQUM3QixVQUFBSCxNQUFLLEdBQUcsT0FBTyxRQUFRLFNBQVUsUUFBUTtBQUNyQyxnQkFBSSxDQUFDLE9BQVEsQ0FBQUEsTUFBSyxRQUFRLE1BQU07QUFFaEMsWUFBQUEsTUFBSyxHQUFHLEtBQUtHLE9BQU0sS0FBSyxLQUFPLFNBQVVDLE1BQUssSUFBSTtBQUM5QyxrQkFBSUEsTUFBSztBQUNMLGdCQUFBSixNQUFLLEdBQUcsTUFBTUcsT0FBTSxLQUFPLFdBQVk7QUFDbkMsa0JBQUFILE1BQUssR0FBRyxLQUFLRyxPQUFNLEtBQUssS0FBTyxTQUFVQyxNQUFLQyxLQUFJO0FBQzlDLG9CQUFBTCxNQUFLLEdBQUcsTUFBTUssS0FBSSxTQUFTLEdBQUcsUUFBUSxRQUFRLEdBQUcsV0FBWTtBQUN6RCxzQkFBQUwsTUFBSyxHQUFHLE1BQU1LLEtBQUksV0FBWTtBQUMxQix3QkFBQUwsTUFBSyxHQUFHLE1BQU1HLE9BQU0sUUFBUSxLQUFPLFdBQVk7QUFDM0MsbUNBQVMsSUFBSTtBQUFBLHdCQUNqQixDQUFDO0FBQUEsc0JBQ0wsQ0FBQztBQUFBLG9CQUNMLENBQUM7QUFBQSxrQkFDTCxDQUFDO0FBQUEsZ0JBQ0wsQ0FBQztBQUFBLGNBQ0wsV0FBVyxJQUFJO0FBQ1gsZ0JBQUFILE1BQUssR0FBRyxNQUFNLElBQUksU0FBUyxHQUFHLFFBQVEsUUFBUSxHQUFHLFdBQVk7QUFDekQsa0JBQUFBLE1BQUssR0FBRyxNQUFNLElBQUksV0FBWTtBQUMxQixvQkFBQUEsTUFBSyxHQUFHLE1BQU1HLE9BQU0sUUFBUSxLQUFPLFdBQVk7QUFDM0MsK0JBQVMsSUFBSTtBQUFBLG9CQUNqQixDQUFDO0FBQUEsa0JBQ0wsQ0FBQztBQUFBLGdCQUNMLENBQUM7QUFBQSxjQUNMLE9BQU87QUFDSCxnQkFBQUgsTUFBSyxHQUFHLE1BQU1HLE9BQU0sUUFBUSxLQUFPLFdBQVk7QUFDM0MsMkJBQVMsSUFBSTtBQUFBLGdCQUNqQixDQUFDO0FBQUEsY0FDTDtBQUFBLFlBQ0osQ0FBQztBQUFBLFVBQ0wsQ0FBQztBQUFBLFFBQ0wsQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ0w7QUFFQSxVQUFNLFVBQVUsWUFBWSxTQUFxQkEsT0FBTTtBQUNuRCxZQUFNSCxRQUFPO0FBRWIsZUFBUyxTQUFvQixLQUFnQixTQUFxQixXQUFXO0FBQ3pFLFlBQUksT0FBTyxZQUFZLFdBQVc7QUFDOUIsc0JBQVk7QUFDWixvQkFBVTtBQUFBLFFBQ2Q7QUFDQSxZQUFJLFFBQVEsQ0FBQztBQUNiLFFBQUFBLE1BQUssR0FBRyxZQUFZLEdBQUcsRUFBRSxRQUFRLFNBQVUsTUFBTTtBQUM3QyxnQkFBTUcsUUFBTyxJQUFJLEtBQUssS0FBSyxJQUFJO0FBQy9CLGdCQUFNRixRQUFPRCxNQUFLLEdBQUcsU0FBU0csS0FBSTtBQUVsQyxjQUFJLENBQUMsV0FBVyxRQUFRLEtBQUtBLEtBQUksR0FBRztBQUNoQyxrQkFBTSxLQUFLLElBQUksVUFBVUEsS0FBSSxLQUFLRixNQUFLLFlBQVksSUFBSUQsTUFBSyxNQUFNLEdBQUc7QUFBQSxVQUN6RTtBQUVBLGNBQUlDLE1BQUssWUFBWSxLQUFLLFVBQVcsU0FBUSxNQUFNLE9BQU8sU0FBU0UsT0FBTSxTQUFTLFNBQVMsQ0FBQztBQUFBLFFBQ2hHLENBQUM7QUFDRCxlQUFPO0FBQUEsTUFDWDtBQUVBLGFBQU8sU0FBU0EsT0FBTSxRQUFXLElBQUk7QUFBQSxJQUN6QztBQWVBLFVBQU0sVUFBVSxpQkFBaUIsU0FBVSxLQUFLLElBQUk7QUFDaEQsWUFBTUgsUUFBTztBQUNiLFVBQUksVUFBVSxDQUFDO0FBQ2YsTUFBQUEsTUFBSyxHQUFHLFFBQVEsS0FBSyxTQUFVLEtBQUssTUFBTTtBQUN0QyxZQUFJLElBQUssUUFBTyxHQUFHLEdBQUc7QUFDdEIsWUFBSSxjQUFjLEtBQUs7QUFDdkIsWUFBSSxDQUFDLFlBQWEsUUFBTyxHQUFHLE1BQU0sT0FBTztBQUN6QyxhQUFLLFFBQVEsU0FBVSxNQUFNO0FBQ3pCLGlCQUFPLElBQUksS0FBSyxLQUFLLElBQUk7QUFDekIsVUFBQUEsTUFBSyxHQUFHLEtBQUssTUFBTSxTQUFVSSxNQUFLSCxPQUFNO0FBQ3BDLGdCQUFJRyxLQUFLLFFBQU8sR0FBR0EsSUFBRztBQUN0QixnQkFBSUgsT0FBTTtBQUNOLHNCQUFRLEtBQUssSUFBSSxVQUFVLElBQUksS0FBS0EsTUFBSyxZQUFZLElBQUlELE1BQUssTUFBTSxHQUFHO0FBQ3ZFLGtCQUFJQyxNQUFLLFlBQVksR0FBRztBQUNwQixnQkFBQUQsTUFBSyxlQUFlLE1BQU0sU0FBVUksTUFBSyxLQUFLO0FBQzFDLHNCQUFJQSxLQUFLLFFBQU8sR0FBR0EsSUFBRztBQUN0Qiw0QkFBVSxRQUFRLE9BQU8sR0FBRztBQUM1QixzQkFBSSxDQUFDLEVBQUUsWUFBYSxJQUFHLE1BQU0sT0FBTztBQUFBLGdCQUN4QyxDQUFDO0FBQUEsY0FDTCxPQUFPO0FBQ0gsb0JBQUksQ0FBQyxFQUFFLFlBQWEsSUFBRyxNQUFNLE9BQU87QUFBQSxjQUN4QztBQUFBLFlBQ0o7QUFBQSxVQUNKLENBQUM7QUFBQSxRQUNMLENBQUM7QUFBQSxNQUNMLENBQUM7QUFBQSxJQUNMO0FBRUEsVUFBTSxVQUFVLGdCQUFnQixXQUFZO0FBQUEsSUFBQztBQUU3QyxVQUFNLFVBQVUsZ0JBQWdCLFdBQVk7QUFBQSxJQUFDO0FBSzdDLFVBQU0sY0FBYyxTQUFVLEtBQUssTUFBTTtBQUNyQyxhQUFPLFVBQVUsTUFBTSxRQUFRLEdBQUksSUFBSyxRQUFRO0FBQUEsSUFDcEQ7QUFFQSxVQUFNLFFBQVEsU0FBVSxLQUFLO0FBQ3pCLFVBQUksT0FBTyxRQUFRLFVBQVU7QUFDekIsY0FBTSxPQUFPLEtBQUssS0FBSyxNQUFNO0FBQUEsTUFDakM7QUFFQSxVQUFJLE1BQU0sSUFBSTtBQUNkLFVBQUksTUFBTSxDQUFDO0FBQ1gsZUFBUyxNQUFNLEdBQUcsTUFBTSxNQUFPLE9BQU0sTUFBTSxZQUFZLEtBQUssSUFBSSxLQUFLLENBQUM7QUFFdEUsYUFBTyxDQUFDLFFBQVE7QUFBQSxJQUNwQjtBQUVBLFVBQU0saUJBQWlCLFNBQXFCLFFBQVE7QUFDaEQsY0FBUSxRQUFRO0FBQUEsUUFDWixLQUFLLFVBQVU7QUFDWCxpQkFBTyxhQUFhLFNBQVM7QUFBQSxRQUNqQyxLQUFLLFVBQVU7QUFDWCxpQkFBTyxlQUFlLFNBQVM7QUFBQSxRQUNuQztBQUNJLGlCQUFPLGtCQUFrQixTQUFTO0FBQUEsTUFDMUM7QUFBQSxJQUNKO0FBT0EsVUFBTSxZQUFZLFNBQXFCRCxPQUFNO0FBQ3pDLFVBQUksQ0FBQ0EsTUFBTSxRQUFPO0FBRWxCLFlBQU0sYUFBYSxJQUFJLE1BQU0sVUFBVSxNQUFNQSxNQUFLLE1BQU0sSUFBSSxFQUFFLEtBQUssR0FBRyxDQUFDO0FBQ3ZFLGFBQU8sSUFBSSxLQUFLLEtBQUssVUFBVTtBQUFBLElBQ25DO0FBUUEsVUFBTSxhQUFhLFNBQVVBLE9BQU07QUFDL0IsVUFBSSxDQUFDQSxNQUFNLFFBQU87QUFFbEIsWUFBTSxhQUFhLElBQUksTUFBTSxVQUFVLE1BQU1BLE1BQUssTUFBTSxJQUFJLEVBQUUsS0FBSyxHQUFHLENBQUM7QUFDdkUsYUFBTyxJQUFJLE1BQU0sS0FBSyxLQUFLLFVBQVU7QUFBQSxJQUN6QztBQVFBLFVBQU0sV0FBVyxTQUFVLEtBQUssVUFBVTtBQUN0QyxVQUFJLENBQUMsTUFBTSxRQUFRLEdBQUcsRUFBRyxPQUFNLElBQUksVUFBVSxrQkFBa0I7QUFFL0QsWUFBTSxNQUFNLElBQUksV0FBVztBQUMzQixlQUFTRyxLQUFJLE1BQU0sR0FBR0EsTUFBSyxHQUFHQSxNQUFLO0FBQy9CLFlBQUksU0FBUyxJQUFJQSxFQUFDLEdBQUdBLElBQUcsR0FBRyxHQUFHO0FBQzFCLGlCQUFPLElBQUlBLEVBQUM7QUFBQSxRQUNoQjtBQUFBLE1BQ0o7QUFDQSxhQUFPO0FBQUEsSUFDWDtBQUdBLFVBQU0sV0FBVyxTQUFxQixRQUFtQixNQUFNO0FBQzNELGVBQVMsSUFBSSxRQUFRLElBQUksVUFBVSxNQUFNLENBQUM7QUFDMUMsVUFBSSxRQUFRLEtBQUssTUFBTSxHQUFHO0FBQzFCLGVBQVNBLEtBQUksR0FBRyxJQUFJLE1BQU0sUUFBUUEsS0FBSSxHQUFHQSxNQUFLO0FBQzFDLFlBQUlILFFBQU8sSUFBSSxVQUFVLElBQUksS0FBSyxRQUFRLE1BQU0sTUFBTUcsSUFBRyxDQUFDLEVBQUUsS0FBSyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQzFFLFlBQUlILE1BQUssUUFBUSxNQUFNLE1BQU0sR0FBRztBQUM1QixpQkFBT0E7QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUNBLGFBQU8sSUFBSSxVQUFVLElBQUksS0FBSyxRQUFRLElBQUksU0FBUyxJQUFJLENBQUMsQ0FBQztBQUFBLElBQzdEO0FBR0EsVUFBTSxXQUFXLFNBQVMsU0FBd0MsT0FBc0IsU0FBUztBQUM3RixVQUFJLE9BQU8sU0FBUyxLQUFLLEdBQUc7QUFDeEIsZUFBTztBQUFBLE1BQ1gsV0FBVyxpQkFBaUIsWUFBWTtBQUNwQyxlQUFPLE9BQU8sS0FBSyxLQUFLO0FBQUEsTUFDNUIsT0FBTztBQUVILGVBQU8sT0FBTyxVQUFVLFdBQVcsUUFBUSxLQUFLLElBQUksT0FBTyxNQUFNLENBQUM7QUFBQSxNQUN0RTtBQUFBLElBQ0o7QUFFQSxVQUFNLGtCQUFrQixTQUFxQixRQUFnQixPQUFPO0FBQ2hFLFVBQUksUUFBUSxPQUFPLEtBQUssT0FBTyxNQUFNLE9BQU8sUUFBUSxDQUFDLENBQUM7QUFDdEQsWUFBTSxPQUFPO0FBRWIsYUFBTyxTQUFTLEtBQUssTUFBTSxTQUFTLEtBQUssQ0FBQyxFQUFFO0FBQUEsSUFDaEQ7QUFFQSxVQUFNLGVBQWUsU0FBVSxLQUFLO0FBQ2hDLGFBQU8sSUFBSSxNQUFPLE9BQU8sS0FBTSxPQUFRLE1BQU0sS0FBSyxLQUFNLE9BQU8sS0FBTSxNQUFRLEdBQUcsQ0FBQyxHQUFHLEtBQUssSUFBSyxPQUFPLEtBQU0sSUFBTSxDQUFDLEdBQUksT0FBTyxLQUFNLElBQU8sT0FBTyxJQUFLLEtBQU8sTUFBTSxPQUFTLENBQUM7QUFBQSxJQUNqTDtBQUVBLFVBQU0sZUFBZSxTQUFVLEtBQUs7QUFDaEMsVUFBSSxPQUFPO0FBQ1gsVUFBSSxPQUFPO0FBQ1gsVUFBSSxJQUFJLFlBQVksSUFBSSxNQUFNO0FBQzFCLGdCQUFVLElBQUksWUFBWSxJQUFJLE9BQVEsUUFBUyxJQUFPLElBQUksU0FBUyxJQUFJLEtBQU0sSUFBSyxJQUFJLFFBQVE7QUFDOUYsZUFBUSxJQUFJLFNBQVMsS0FBSyxLQUFPLElBQUksV0FBVyxLQUFLLElBQU0sSUFBSSxXQUFXLEtBQUs7QUFBQSxNQUNuRjtBQUNBLGFBQVEsUUFBUSxLQUFNO0FBQUEsSUFDMUI7QUFFQSxVQUFNLFFBQVE7QUFDZCxVQUFNLFdBQVc7QUFBQTtBQUFBOzs7QUMvVWpCO0FBQUEsdUNBQUFJLFVBQUFDLFNBQUE7QUFBQSxRQUFNLE1BQU0sUUFBUSxNQUFNO0FBRTFCLElBQUFBLFFBQU8sVUFBVSxTQUFxQkMsT0FBdUIsRUFBRSxJQUFBQyxJQUFHLEdBQUc7QUFDakUsVUFBSSxRQUFRRCxTQUFRLElBQ2hCLE9BQU8sUUFBUSxHQUNmLFFBQVE7QUFFWixlQUFTLFVBQVU7QUFDZixlQUFPO0FBQUEsVUFDSCxXQUFXO0FBQUEsVUFDWCxVQUFVO0FBQUEsVUFDVixRQUFRO0FBQUEsVUFDUixZQUFZO0FBQUEsVUFDWixPQUFPO0FBQUEsVUFDUCxPQUFPO0FBQUEsUUFDWDtBQUFBLE1BQ0o7QUFFQSxVQUFJLFNBQVNDLElBQUcsV0FBVyxLQUFLLEdBQUc7QUFDL0IsZ0JBQVFBLElBQUcsU0FBUyxLQUFLO0FBQ3pCLGFBQUssWUFBWSxNQUFNLFlBQVk7QUFDbkMsYUFBSyxRQUFRLE1BQU07QUFDbkIsYUFBSyxRQUFRLE1BQU07QUFDbkIsYUFBSyxjQUFjLEtBQVEsTUFBTSxVQUFVO0FBQzNDLGFBQUssWUFBWSxNQUFRLE1BQU0sVUFBVTtBQUN6QyxhQUFLLFNBQVMsSUFBSSxTQUFTLEtBQUssRUFBRSxDQUFDLE1BQU07QUFBQSxNQUM3QyxPQUFPO0FBQ0gsZ0JBQVEsS0FBSyxtQkFBbUIsS0FBSztBQUFBLE1BQ3pDO0FBRUEsYUFBTztBQUFBLFFBQ0gsSUFBSSxZQUFZO0FBQ1osaUJBQU8sS0FBSztBQUFBLFFBQ2hCO0FBQUEsUUFFQSxJQUFJLFdBQVc7QUFDWCxpQkFBTyxLQUFLO0FBQUEsUUFDaEI7QUFBQSxRQUVBLElBQUksU0FBUztBQUNULGlCQUFPLEtBQUs7QUFBQSxRQUNoQjtBQUFBLFFBRUEsSUFBSSxRQUFRO0FBQ1IsaUJBQU8sS0FBSztBQUFBLFFBQ2hCO0FBQUEsUUFFQSxJQUFJLFFBQVE7QUFDUixpQkFBTyxLQUFLO0FBQUEsUUFDaEI7QUFBQSxRQUVBLElBQUksYUFBYTtBQUNiLGlCQUFPLEtBQUs7QUFBQSxRQUNoQjtBQUFBLFFBRUEsa0JBQWtCLFdBQVk7QUFBQSxRQUFDO0FBQUEsUUFFL0Isa0JBQWtCLFdBQVk7QUFBQSxRQUFDO0FBQUEsUUFFL0IsUUFBUSxXQUFZO0FBQ2hCLGlCQUFPO0FBQUEsWUFDSCxNQUFNO0FBQUEsWUFDTixhQUFhLEtBQUs7QUFBQSxZQUNsQixZQUFZLEtBQUs7QUFBQSxZQUNqQixVQUFVLEtBQUs7QUFBQSxZQUNmLGNBQWMsS0FBSztBQUFBLFlBQ25CLE9BQU8sS0FBSztBQUFBLFlBQ1osT0FBTyxLQUFLO0FBQUEsVUFDaEI7QUFBQSxRQUNKO0FBQUEsUUFFQSxVQUFVLFdBQVk7QUFDbEIsaUJBQU8sS0FBSyxVQUFVLEtBQUssT0FBTyxHQUFHLE1BQU0sR0FBSTtBQUFBLFFBQ25EO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQTtBQUFBOzs7QUMzRUE7QUFBQSx5Q0FBQUMsVUFBQUMsU0FBQTtBQUFBLElBQUFBLFFBQU8sVUFBVTtBQUFBLE1BQ2IsS0FBSztBQUFBLE1BQ0wsUUFBUSxDQUFDLFNBQVMsT0FBTyxLQUFLLE1BQU0sTUFBTTtBQUFBLE1BQzFDLFFBQVEsQ0FBQyxTQUFTLEtBQUssU0FBUyxNQUFNO0FBQUEsSUFDMUM7QUFBQTtBQUFBOzs7QUNKQTtBQUFBLHVDQUFBQyxVQUFBQyxTQUFBO0FBQUEsSUFBQUEsUUFBTyxVQUFVO0FBQ2pCLElBQUFBLFFBQU8sUUFBUSxZQUFZO0FBQzNCLElBQUFBLFFBQU8sUUFBUSxTQUFTO0FBQ3hCLElBQUFBLFFBQU8sUUFBUSxXQUFXO0FBQzFCLElBQUFBLFFBQU8sUUFBUSxVQUFVO0FBQUE7QUFBQTs7O0FDSnpCO0FBQUEsZ0RBQUFDLFVBQUFDLFNBQUE7QUFBQSxRQUFJLFFBQVE7QUFBWixRQUNJLFlBQVksTUFBTTtBQUd0QixJQUFBQSxRQUFPLFVBQVUsV0FBWTtBQUN6QixVQUFJLFdBQVcsSUFDWCxXQUFXLElBQ1gsU0FBUyxHQUNULFVBQVUsR0FDVixRQUFRLEdBQ1IsT0FBTyxHQUNQLGtCQUFrQixHQUNsQixRQUFRLEdBQ1IsWUFBWSxHQUNaLFlBQVksR0FDWixVQUFVLEdBQ1YsYUFBYSxHQUNiLFVBQVUsR0FDVixRQUFRLEdBQ1IsVUFBVTtBQUVkLGtCQUFZLE1BQU0sUUFBUSxPQUFTO0FBSW5DLGdCQUFVLFVBQVU7QUFFcEIsWUFBTSxlQUFlO0FBQUEsUUFDakIsVUFBVTtBQUFBLE1BQ2Q7QUFHQSxZQUFNLFNBQVMsQ0FBQyxRQUFRLEtBQUssSUFBSSxHQUFHLEdBQUcsTUFBTTtBQUM3QyxZQUFNLFNBQVMsQ0FBQyxRQUFRLEtBQUssSUFBSSxHQUFHLEdBQUcsSUFBSTtBQUMzQyxZQUFNLFFBQVEsQ0FBQyxRQUFRLEtBQUssSUFBSSxHQUFHLEdBQUcsSUFBSTtBQUUxQyxjQUFRLE1BQU0sYUFBYSxvQkFBSSxLQUFLLENBQUM7QUFFckMsYUFBTztBQUFBLFFBQ0gsSUFBSSxPQUFPO0FBQ1AsaUJBQU87QUFBQSxRQUNYO0FBQUEsUUFDQSxJQUFJLEtBQUssS0FBSztBQUNWLHFCQUFXO0FBQUEsUUFDZjtBQUFBLFFBRUEsSUFBSSxVQUFVO0FBQ1YsaUJBQU87QUFBQSxRQUNYO0FBQUEsUUFDQSxJQUFJLFFBQVEsS0FBSztBQUNiLHFCQUFXO0FBQUEsUUFDZjtBQUFBLFFBRUEsSUFBSSxRQUFRO0FBQ1IsaUJBQU87QUFBQSxRQUNYO0FBQUEsUUFDQSxJQUFJLE1BQU0sS0FBSztBQUNYLG1CQUFTO0FBQUEsUUFDYjtBQUFBLFFBRUEsSUFBSSxZQUFZO0FBQ1osa0JBQVEsU0FBUyxVQUFVLFdBQVc7QUFBQSxRQUMxQztBQUFBLFFBQ0EsSUFBSSxVQUFVLEtBQUs7QUFDZixjQUFJLEtBQUs7QUFDTCxzQkFBVSxVQUFVO0FBQUEsVUFDeEIsT0FBTztBQUNILHNCQUFVLENBQUMsVUFBVTtBQUFBLFVBQ3pCO0FBQUEsUUFDSjtBQUFBLFFBRUEsSUFBSSxhQUFhO0FBQ2Isa0JBQVEsU0FBUyxVQUFVLFlBQVk7QUFBQSxRQUMzQztBQUFBLFFBQ0EsSUFBSSxXQUFXLEtBQUs7QUFDaEIsY0FBSSxLQUFLO0FBQ0wsc0JBQVUsVUFBVTtBQUFBLFVBQ3hCLE9BQU87QUFDSCxzQkFBVSxDQUFDLFVBQVU7QUFBQSxVQUN6QjtBQUFBLFFBQ0o7QUFBQSxRQUVBLElBQUksU0FBUztBQUNULGlCQUFPO0FBQUEsUUFDWDtBQUFBLFFBQ0EsSUFBSSxPQUFPLEtBQUs7QUFDWixrQkFBUSxLQUFLO0FBQUEsWUFDVCxLQUFLLFVBQVU7QUFDWCxtQkFBSyxVQUFVO0FBQUEsWUFDbkIsS0FBSyxVQUFVO0FBQUEsWUFDZjtBQUNJLG1CQUFLLFVBQVU7QUFBQSxVQUN2QjtBQUNBLG9CQUFVO0FBQUEsUUFDZDtBQUFBLFFBRUEsSUFBSSxPQUFPO0FBQ1AsaUJBQU8sTUFBTSxhQUFhLEtBQUssT0FBTztBQUFBLFFBQzFDO0FBQUEsUUFDQSxJQUFJLEtBQUssS0FBSztBQUNWLGVBQUssVUFBVSxNQUFNLGFBQWEsR0FBRztBQUFBLFFBQ3pDO0FBQUEsUUFFQSxJQUFJLFVBQVU7QUFDVixpQkFBTztBQUFBLFFBQ1g7QUFBQSxRQUNBLElBQUksUUFBUSxLQUFLO0FBQ2Isa0JBQVEsT0FBTyxHQUFHO0FBQUEsUUFDdEI7QUFBQSxRQUVBLElBQUksZUFBZTtBQUNmLGlCQUFPLE1BQU0sVUFBVSxDQUFDO0FBQUEsUUFDNUI7QUFBQSxRQUNBLElBQUksTUFBTTtBQUNOLGlCQUFPO0FBQUEsUUFDWDtBQUFBLFFBQ0EsSUFBSSxJQUFJLEtBQUs7QUFDVCxpQkFBTyxPQUFPLEdBQUc7QUFBQSxRQUNyQjtBQUFBLFFBRUEsSUFBSSxpQkFBaUI7QUFDakIsaUJBQU87QUFBQSxRQUNYO0FBQUEsUUFDQSxJQUFJLGVBQWUsS0FBSztBQUNwQiw0QkFBa0IsT0FBTyxHQUFHO0FBQUEsUUFDaEM7QUFBQSxRQUVBLElBQUksT0FBTztBQUNQLGlCQUFPO0FBQUEsUUFDWDtBQUFBLFFBQ0EsSUFBSSxLQUFLLEtBQUs7QUFDVixrQkFBUSxPQUFPLEdBQUc7QUFBQSxRQUN0QjtBQUFBLFFBRUEsSUFBSSxpQkFBaUI7QUFDakIsaUJBQU87QUFBQSxRQUNYO0FBQUEsUUFDQSxJQUFJLGVBQWUsS0FBSztBQUNwQixzQkFBWTtBQUFBLFFBQ2hCO0FBQUEsUUFFQSxJQUFJLGNBQWM7QUFDZCxpQkFBTztBQUFBLFFBQ1g7QUFBQSxRQUNBLElBQUksWUFBWSxLQUFLO0FBQ2pCLHNCQUFZO0FBQUEsUUFDaEI7QUFBQSxRQUVBLElBQUksbUJBQW1CO0FBQ25CLGlCQUFPLGFBQWE7QUFBQSxRQUN4QjtBQUFBLFFBQ0EsSUFBSSxpQkFBaUIsS0FBSztBQUN0Qix1QkFBYSxXQUFXO0FBQUEsUUFDNUI7QUFBQSxRQUVBLElBQUksZ0JBQWdCO0FBQ2hCLGlCQUFPO0FBQUEsUUFDWDtBQUFBLFFBQ0EsSUFBSSxjQUFjLEtBQUs7QUFDbkIsb0JBQVU7QUFBQSxRQUNkO0FBQUEsUUFFQSxJQUFJLGVBQWU7QUFDZixpQkFBTztBQUFBLFFBQ1g7QUFBQSxRQUNBLElBQUksYUFBYSxLQUFLO0FBQ2xCLHVCQUFhLE9BQU8sR0FBRztBQUFBLFFBQzNCO0FBQUEsUUFFQSxJQUFJLFNBQVM7QUFDVCxpQkFBTztBQUFBLFFBQ1g7QUFBQSxRQUNBLElBQUksT0FBTyxLQUFLO0FBQ1osb0JBQVUsT0FBTyxHQUFHO0FBQUEsUUFDeEI7QUFBQSxRQUVBLElBQUksT0FBTztBQUNQLGlCQUFPO0FBQUEsUUFDWDtBQUFBLFFBQ0EsSUFBSSxLQUFLLEtBQUs7QUFDVixrQkFBUSxPQUFPLEdBQUc7QUFBQSxRQUN0QjtBQUFBO0FBQUEsUUFHQSxJQUFJLFdBQVc7QUFDWCxrQkFBUSxTQUFTLE1BQU0sS0FBSztBQUFBLFFBQ2hDO0FBQUEsUUFFQSxJQUFJLFNBQVM7QUFDVCxpQkFBTztBQUFBLFFBQ1g7QUFBQSxRQUNBLElBQUksT0FBTyxLQUFLO0FBQ1osb0JBQVUsT0FBTyxHQUFHO0FBQUEsUUFDeEI7QUFBQSxRQUVBLElBQUksWUFBWTtBQUNaLGtCQUFRLFNBQVMsVUFBVSxhQUFhLFVBQVU7QUFBQSxRQUN0RDtBQUFBLFFBRUEsSUFBSSxvQkFBb0I7QUFDcEIsaUJBQU8sVUFBVSxTQUFTLFlBQVksWUFBWTtBQUFBLFFBQ3REO0FBQUEsUUFFQSxJQUFJLGlCQUFpQjtBQUNqQixpQkFBTyxVQUFVLFVBQVUsU0FBUyxhQUFhLFdBQVcsYUFBYTtBQUFBLFFBQzdFO0FBQUEsUUFFQSxJQUFJLGNBQWM7QUFDZCxpQkFBTztBQUFBLFFBQ1g7QUFBQSxRQUVBLDJCQUEyQixTQUFxQixPQUFPO0FBQ25ELGNBQUksT0FBTyxNQUFNLE1BQU0sU0FBUyxVQUFVLFVBQVUsTUFBTTtBQUUxRCxjQUFJLEtBQUssYUFBYSxDQUFDLE1BQU0sVUFBVSxRQUFRO0FBQzNDLGtCQUFNLE1BQU0sT0FBTyxZQUFZO0FBQUEsVUFDbkM7QUFHQSx1QkFBYSxVQUFVLEtBQUssYUFBYSxVQUFVLE1BQU07QUFFekQsdUJBQWEsUUFBUSxLQUFLLGFBQWEsVUFBVSxNQUFNO0FBRXZELHVCQUFhLFNBQVMsS0FBSyxhQUFhLFVBQVUsTUFBTTtBQUV4RCx1QkFBYSxPQUFPLEtBQUssYUFBYSxVQUFVLE1BQU07QUFFdEQsdUJBQWEsTUFBTSxLQUFLLGFBQWEsVUFBVSxNQUFNO0FBRXJELHVCQUFhLGlCQUFpQixLQUFLLGFBQWEsVUFBVSxNQUFNO0FBRWhFLHVCQUFhLE9BQU8sS0FBSyxhQUFhLFVBQVUsTUFBTTtBQUV0RCx1QkFBYSxXQUFXLEtBQUssYUFBYSxVQUFVLE1BQU07QUFFMUQsdUJBQWEsV0FBVyxLQUFLLGFBQWEsVUFBVSxNQUFNO0FBRzFELGdCQUFNLGFBQWEsVUFBVSxVQUFVLFNBQVMsYUFBYTtBQUM3RCxnQkFBTSxXQUFXLGFBQWEsYUFBYTtBQUMzQyxpQkFBTyxNQUFNLE1BQU0sWUFBWSxRQUFRO0FBQUEsUUFDM0M7QUFBQSxRQUVBLGdCQUFnQixTQUFxQixNQUFNO0FBRXZDLGNBQUksS0FBSyxXQUFXLFVBQVUsVUFBVSxLQUFLLGFBQWEsQ0FBQyxNQUFNLFVBQVUsUUFBUTtBQUMvRSxrQkFBTSxNQUFNLE9BQU8sWUFBWTtBQUFBLFVBQ25DO0FBRUEscUJBQVcsS0FBSyxhQUFhLFVBQVUsTUFBTTtBQUU3QyxxQkFBVyxLQUFLLGFBQWEsVUFBVSxNQUFNO0FBRTdDLG1CQUFTLEtBQUssYUFBYSxVQUFVLE1BQU07QUFFM0Msb0JBQVUsS0FBSyxhQUFhLFVBQVUsTUFBTTtBQUU1QyxrQkFBUSxLQUFLLGFBQWEsVUFBVSxNQUFNO0FBRTFDLGlCQUFPLEtBQUssYUFBYSxVQUFVLE1BQU07QUFFekMsNEJBQWtCLEtBQUssYUFBYSxVQUFVLE1BQU07QUFFcEQsa0JBQVEsS0FBSyxhQUFhLFVBQVUsTUFBTTtBQUUxQyxzQkFBWSxLQUFLLGFBQWEsVUFBVSxNQUFNO0FBRTlDLHNCQUFZLEtBQUssYUFBYSxVQUFVLE1BQU07QUFFOUMsb0JBQVUsS0FBSyxhQUFhLFVBQVUsTUFBTTtBQUU1Qyx1QkFBYSxLQUFLLGFBQWEsVUFBVSxNQUFNO0FBRS9DLG9CQUFVLEtBQUssYUFBYSxVQUFVLE1BQU07QUFFNUMsa0JBQVEsS0FBSyxhQUFhLFVBQVUsTUFBTTtBQUUxQyxvQkFBVSxLQUFLLGFBQWEsVUFBVSxNQUFNO0FBQUEsUUFDaEQ7QUFBQSxRQUVBLHFCQUFxQixXQUFZO0FBRTdCLGNBQUksT0FBTyxPQUFPLE1BQU0sVUFBVSxNQUFNO0FBRXhDLGVBQUssY0FBYyxVQUFVLFFBQVEsQ0FBQztBQUV0QyxlQUFLLGNBQWMsVUFBVSxVQUFVLE1BQU07QUFFN0MsZUFBSyxjQUFjLFFBQVEsVUFBVSxNQUFNO0FBRTNDLGVBQUssY0FBYyxTQUFTLFVBQVUsTUFBTTtBQUU1QyxlQUFLLGNBQWMsT0FBTyxVQUFVLE1BQU07QUFFMUMsZUFBSyxjQUFjLE1BQU0sVUFBVSxNQUFNO0FBRXpDLGVBQUssY0FBYyxpQkFBaUIsVUFBVSxNQUFNO0FBRXBELGVBQUssY0FBYyxPQUFPLFVBQVUsTUFBTTtBQUUxQyxlQUFLLGNBQWMsV0FBVyxVQUFVLE1BQU07QUFFOUMsZUFBSyxjQUFjLGFBQWEsVUFBVSxVQUFVLE1BQU07QUFDMUQsaUJBQU87QUFBQSxRQUNYO0FBQUEsUUFFQSx1QkFBdUIsV0FBWTtBQUUvQixjQUFJLE9BQU8sT0FBTyxNQUFNLFVBQVUsU0FBUyxZQUFZLFlBQVksT0FBTztBQUUxRSxlQUFLLGNBQWMsVUFBVSxRQUFRLENBQUM7QUFFdEMsZUFBSyxjQUFjLFVBQVUsVUFBVSxNQUFNO0FBRTdDLGVBQUssY0FBYyxVQUFVLFVBQVUsTUFBTTtBQUU3QyxlQUFLLGNBQWMsUUFBUSxVQUFVLE1BQU07QUFFM0MsZUFBSyxjQUFjLFNBQVMsVUFBVSxNQUFNO0FBRTVDLGVBQUssY0FBYyxPQUFPLFVBQVUsTUFBTTtBQUUxQyxlQUFLLGNBQWMsTUFBTSxVQUFVLE1BQU07QUFFekMsZUFBSyxjQUFjLGlCQUFpQixVQUFVLE1BQU07QUFFcEQsZUFBSyxjQUFjLE9BQU8sVUFBVSxNQUFNO0FBRTFDLGVBQUssY0FBYyxXQUFXLFVBQVUsTUFBTTtBQUU5QyxlQUFLLGNBQWMsV0FBVyxVQUFVLE1BQU07QUFFOUMsZUFBSyxjQUFjLFNBQVMsVUFBVSxNQUFNO0FBRTVDLGVBQUssY0FBYyxZQUFZLFVBQVUsTUFBTTtBQUUvQyxlQUFLLGNBQWMsU0FBUyxVQUFVLE1BQU07QUFFNUMsZUFBSyxjQUFjLE9BQU8sVUFBVSxNQUFNO0FBRTFDLGVBQUssY0FBYyxTQUFTLFVBQVUsTUFBTTtBQUM1QyxpQkFBTztBQUFBLFFBQ1g7QUFBQSxRQUVBLFFBQVEsV0FBWTtBQUNoQixnQkFBTSxRQUFRLFNBQVUsSUFBSTtBQUN4QixtQkFBTyxLQUFLO0FBQUEsVUFDaEI7QUFFQSxpQkFBTztBQUFBLFlBQ0gsTUFBTTtBQUFBLFlBQ04sU0FBUztBQUFBLFlBQ1QsT0FBTztBQUFBLFlBQ1AsUUFBUSxNQUFNLGVBQWUsT0FBTztBQUFBLFlBQ3BDLE1BQU0sS0FBSztBQUFBLFlBQ1gsS0FBSyxPQUFPLEtBQUssU0FBUyxFQUFFLEVBQUUsWUFBWTtBQUFBLFlBQzFDLGdCQUFnQixNQUFNLGVBQWU7QUFBQSxZQUNyQyxNQUFNLE1BQU0sS0FBSztBQUFBLFlBQ2pCLGdCQUFnQixNQUFNLFNBQVM7QUFBQSxZQUMvQixhQUFhLE1BQU0sU0FBUztBQUFBLFlBQzVCLGVBQWUsTUFBTSxPQUFPO0FBQUEsWUFDNUIsY0FBYztBQUFBLFlBQ2QsUUFBUTtBQUFBLFlBQ1IsTUFBTTtBQUFBLFlBQ04sUUFBUTtBQUFBLFlBQ1IsbUJBQW1CLE1BQU0sVUFBVSxTQUFTLFlBQVksWUFBWSxPQUFPO0FBQUEsVUFDL0U7QUFBQSxRQUNKO0FBQUEsUUFFQSxVQUFVLFdBQVk7QUFDbEIsaUJBQU8sS0FBSyxVQUFVLEtBQUssT0FBTyxHQUFHLE1BQU0sR0FBSTtBQUFBLFFBQ25EO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQTtBQUFBOzs7QUNyWEE7QUFBQSwrQ0FBQUMsVUFBQUMsU0FBQTtBQUFBLFFBQUksUUFBUTtBQUFaLFFBQ0ksWUFBWSxNQUFNO0FBR3RCLElBQUFBLFFBQU8sVUFBVSxXQUFZO0FBQ3pCLFVBQUksaUJBQWlCLEdBQ2pCLGdCQUFnQixHQUNoQixRQUFRLEdBQ1IsVUFBVSxHQUNWLGlCQUFpQjtBQUVyQixhQUFPO0FBQUEsUUFDSCxJQUFJLGNBQWM7QUFDZCxpQkFBTztBQUFBLFFBQ1g7QUFBQSxRQUNBLElBQUksWUFBdUIsS0FBSztBQUM1QiwyQkFBaUIsZ0JBQWdCO0FBQUEsUUFDckM7QUFBQSxRQUVBLElBQUksZUFBZTtBQUNmLGlCQUFPO0FBQUEsUUFDWDtBQUFBLFFBQ0EsSUFBSSxhQUF3QixLQUFLO0FBQzdCLDBCQUFnQixpQkFBaUI7QUFBQSxRQUNyQztBQUFBLFFBRUEsSUFBSSxPQUFPO0FBQ1AsaUJBQU87QUFBQSxRQUNYO0FBQUEsUUFDQSxJQUFJLEtBQWdCLEtBQUs7QUFDckIsa0JBQVE7QUFBQSxRQUNaO0FBQUEsUUFFQSxJQUFJLFNBQVM7QUFDVCxpQkFBTztBQUFBLFFBQ1g7QUFBQSxRQUNBLElBQUksT0FBa0IsS0FBSztBQUN2QixvQkFBVTtBQUFBLFFBQ2Q7QUFBQSxRQUVBLElBQUksZ0JBQWdCO0FBQ2hCLGlCQUFPO0FBQUEsUUFDWDtBQUFBLFFBQ0EsSUFBSSxjQUF5QixLQUFLO0FBQzlCLDJCQUFpQjtBQUFBLFFBQ3JCO0FBQUEsUUFFQSxJQUFJLGlCQUFpQjtBQUNqQixpQkFBTyxVQUFVLFNBQVM7QUFBQSxRQUM5QjtBQUFBLFFBRUEsZ0JBQWdCLFNBQXFCLE1BQU07QUFHdkMsZUFDSyxLQUFLLFdBQVcsVUFBVSxVQUFVLEtBQUssYUFBYSxDQUFDLE1BQU0sVUFBVSxZQUN2RSxLQUFLLFNBQVMsVUFBVSxZQUFZLEtBQUssYUFBYSxDQUFDLE1BQU0sVUFBVSxXQUMxRTtBQUNFLGtCQUFNLE1BQU0sT0FBTyxZQUFZO0FBQUEsVUFDbkM7QUFFQSxjQUFJLEtBQUssYUFBYSxDQUFDLE1BQU0sVUFBVSxRQUFRO0FBRTNDLDZCQUFpQixLQUFLLGFBQWEsVUFBVSxNQUFNO0FBRW5ELDRCQUFnQixLQUFLLGFBQWEsVUFBVSxNQUFNO0FBRWxELG9CQUFRLEtBQUssYUFBYSxVQUFVLE1BQU07QUFFMUMsc0JBQVUsS0FBSyxhQUFhLFVBQVUsTUFBTTtBQUU1Qyw2QkFBaUIsS0FBSyxhQUFhLFVBQVUsTUFBTTtBQUFBLFVBQ3ZELE9BQU87QUFFSCw2QkFBaUIsTUFBTSxnQkFBZ0IsTUFBTSxVQUFVLFFBQVE7QUFFL0QsNEJBQWdCLE1BQU0sZ0JBQWdCLE1BQU0sVUFBVSxRQUFRO0FBRTlELG9CQUFRLE1BQU0sZ0JBQWdCLE1BQU0sVUFBVSxTQUFTO0FBRXZELHNCQUFVLE1BQU0sZ0JBQWdCLE1BQU0sVUFBVSxRQUFRO0FBRXhELDZCQUFpQjtBQUFBLFVBQ3JCO0FBQUEsUUFDSjtBQUFBLFFBRUEsVUFBVSxXQUFZO0FBQ2xCLGNBQUksSUFBSSxPQUFPLE1BQU0sVUFBVSxTQUFTLGNBQWM7QUFFdEQsWUFBRSxjQUFjLFVBQVUsUUFBUSxDQUFDO0FBQ25DLFlBQUUsY0FBYyxHQUFHLENBQUM7QUFFcEIsWUFBRSxjQUFjLGdCQUFnQixVQUFVLE1BQU07QUFFaEQsWUFBRSxjQUFjLGVBQWUsVUFBVSxNQUFNO0FBRS9DLFlBQUUsY0FBYyxPQUFPLFVBQVUsTUFBTTtBQUV2QyxZQUFFLGNBQWMsU0FBUyxVQUFVLE1BQU07QUFFekMsWUFBRSxjQUFjLGdCQUFnQixVQUFVLE1BQU07QUFFaEQsWUFBRSxLQUFLLEtBQUssVUFBVSxNQUFNO0FBRTVCLGlCQUFPO0FBQUEsUUFDWDtBQUFBLFFBRUEsUUFBUSxXQUFZO0FBRWhCLGdCQUFNLFNBQVMsU0FBVSxJQUFJLEtBQUs7QUFDOUIsZ0JBQUksT0FBTyxHQUFHLFNBQVMsRUFBRSxFQUFFLFlBQVk7QUFDdkMsbUJBQU8sS0FBSyxTQUFTLElBQUssUUFBTyxNQUFNO0FBQ3ZDLG1CQUFPLE9BQU87QUFBQSxVQUNsQjtBQUVBLGlCQUFPO0FBQUEsWUFDSCxhQUFhO0FBQUEsWUFDYixjQUFjO0FBQUEsWUFDZCxNQUFNLFFBQVE7QUFBQSxZQUNkLFFBQVEsT0FBTyxTQUFTLENBQUM7QUFBQSxZQUN6QixlQUFlO0FBQUEsVUFDbkI7QUFBQSxRQUNKO0FBQUEsUUFFQSxVQUFVLFdBQVk7QUFDbEIsaUJBQU8sS0FBSyxVQUFVLEtBQUssT0FBTyxHQUFHLE1BQU0sR0FBSTtBQUFBLFFBQ25EO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQTtBQUFBOzs7QUNoSUE7QUFBQSwwQ0FBQUMsVUFBQTtBQUFBLElBQUFBLFNBQVEsY0FBYztBQUN0QixJQUFBQSxTQUFRLGFBQWE7QUFBQTtBQUFBOzs7QUNEckI7QUFBQSw2Q0FBQUMsVUFBQUMsU0FBQTtBQUFBLElBQUFBLFFBQU8sVUFBVSxTQUFxQixPQUFPO0FBQ3pDLFVBQUlDLFFBQU8sUUFBUSxNQUFNO0FBRXpCLFVBQUksT0FBTyxFQUFFLFlBQVksU0FBUyxNQUFNLFNBQVMsSUFBSSxJQUFJLEtBQUssS0FBSztBQUVuRSxhQUFPO0FBQUEsUUFDSCxTQUFTLFdBQVk7QUFDakIsaUJBQU9BLE1BQUssZUFBZSxPQUFPLElBQUk7QUFBQSxRQUMxQztBQUFBLFFBRUEsY0FBYyxTQUF1QixVQUFVO0FBQzNDLGNBQUksTUFBTUEsTUFBSyxpQkFBaUIsSUFBSSxHQUNoQyxRQUFRLENBQUMsR0FDVCxRQUFRO0FBQ1osY0FBSSxHQUFHLFFBQVEsU0FBVSxNQUFNO0FBQzNCLGtCQUFNLEtBQUssSUFBSTtBQUNmLHFCQUFTLEtBQUs7QUFBQSxVQUNsQixDQUFDO0FBQ0QsY0FBSSxHQUFHLE9BQU8sV0FBWTtBQUN0QixnQkFBSSxNQUFNLE9BQU8sTUFBTSxLQUFLLEdBQ3hCLFVBQVU7QUFDZCxnQkFBSSxLQUFLLENBQUM7QUFDVixxQkFBU0MsS0FBSSxHQUFHQSxLQUFJLE1BQU0sUUFBUUEsTUFBSztBQUNuQyxrQkFBSSxPQUFPLE1BQU1BLEVBQUM7QUFDbEIsbUJBQUssS0FBSyxLQUFLLE9BQU87QUFDdEIseUJBQVcsS0FBSztBQUFBLFlBQ3BCO0FBQ0Esd0JBQVksU0FBUyxHQUFHO0FBQUEsVUFDNUIsQ0FBQztBQUNELGNBQUksSUFBSSxLQUFLO0FBQUEsUUFDakI7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBO0FBQUE7OztBQ2hDQTtBQUFBLDZDQUFBQyxVQUFBQyxTQUFBO0FBQUEsUUFBTSxVQUFVLEVBQUUsUUFBUSxXQUFXLFFBQVEsU0FBUyxPQUFPLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQyxLQUFLO0FBRWxGLElBQUFBLFFBQU8sVUFBVSxTQUFxQixPQUFrQixnQkFBZ0I7QUFDcEUsVUFBSUMsUUFBTyxRQUFRLE1BQU07QUFDekIsWUFBTSxTQUFTLFdBQVcsTUFBTSxpQkFBaUIsSUFBSSxFQUFFLGlCQUFpQixlQUFlLElBQUksQ0FBQztBQUU1RixhQUFPO0FBQUEsUUFDSCxTQUFTLFdBQVk7QUFDakIsaUJBQU9BLE1BQUssZUFBZSxPQUFPLE1BQU07QUFBQSxRQUM1QztBQUFBLFFBRUEsY0FBYyxTQUF1QixVQUFVO0FBQzNDLGNBQUksTUFBTUEsTUFBSyxpQkFBaUIsTUFBTSxHQUNsQyxRQUFRLENBQUMsR0FDVCxRQUFRO0FBQ1osY0FBSSxHQUFHLFFBQVEsU0FBVSxNQUFNO0FBQzNCLGtCQUFNLEtBQUssSUFBSTtBQUNmLHFCQUFTLEtBQUs7QUFBQSxVQUNsQixDQUFDO0FBQ0QsY0FBSSxHQUFHLE9BQU8sV0FBWTtBQUN0QixnQkFBSSxNQUFNLE9BQU8sTUFBTSxLQUFLLEdBQ3hCLFVBQVU7QUFDZCxnQkFBSSxLQUFLLENBQUM7QUFDVixxQkFBU0MsS0FBSSxHQUFHQSxLQUFJLE1BQU0sUUFBUUEsTUFBSztBQUNuQyxrQkFBSSxPQUFPLE1BQU1BLEVBQUM7QUFDbEIsbUJBQUssS0FBSyxLQUFLLE9BQU87QUFDdEIseUJBQVcsS0FBSztBQUFBLFlBQ3BCO0FBQ0Esd0JBQVksU0FBUyxHQUFHO0FBQUEsVUFDNUIsQ0FBQztBQUNELGNBQUksSUFBSSxLQUFLO0FBQUEsUUFDakI7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBO0FBQUE7OztBQ2pDQTtBQUFBLDhDQUFBQyxVQUFBQyxTQUFBO0FBQUE7QUFJQSxRQUFNLEVBQUUsZUFBZSxJQUFJLFFBQVEsUUFBUTtBQUMzQyxRQUFNLFNBQVM7QUFHZixRQUFNLFdBQVcsSUFBSSxZQUFZLEdBQUcsRUFBRSxJQUFJLENBQUNDLElBQUcsUUFBUTtBQUNsRCxlQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSztBQUN4QixZQUFJLE9BQU8sTUFBTSxJQUFJO0FBQ2pCLGdCQUFPLFFBQVEsSUFBSztBQUFBLFFBQ3hCLE9BQU87QUFDSCxtQkFBUztBQUFBLFFBQ2I7QUFBQSxNQUNKO0FBQ0EsYUFBTyxRQUFRO0FBQUEsSUFDbkIsQ0FBQztBQUdELFFBQU0sT0FBTyxDQUFDLEdBQUcsTUFBTSxLQUFLLEtBQUssR0FBRyxDQUFDLE1BQU07QUFHM0MsUUFBTSxjQUFjLENBQUMsUUFBUSxTQUFTO0FBQ2xDLGFBQU8sVUFBVSxTQUFTLFFBQVEsR0FBSSxJQUFLLFdBQVc7QUFBQSxJQUMxRDtBQUdBLFFBQU0sVUFBVSxNQUFNO0FBQ2xCLFVBQUksZUFBZSxPQUFPLGdCQUFnQjtBQUN0QyxlQUFPLGVBQWUsT0FBTyxNQUFNLEVBQUUsQ0FBQztBQUFBLE1BQzFDLE9BQU87QUFFSCxlQUFPLFFBQVEsS0FBSztBQUFBLE1BQ3hCO0FBQUEsSUFDSjtBQUdBLFlBQVEsT0FBTyxNQUFNO0FBQ2pCLFlBQU0sT0FBTyxPQUFPLE1BQU0sRUFBRTtBQUM1QixZQUFNLE1BQU0sS0FBSztBQUNqQixlQUFTQyxLQUFJLEdBQUdBLEtBQUksS0FBS0EsS0FBSyxNQUFLQSxFQUFDLElBQUssS0FBSyxPQUFPLElBQUksTUFBTztBQUNoRSxhQUFPO0FBQUEsSUFDWDtBQUdBLFFBQU0sU0FBUztBQUFBLE1BQ1g7QUFBQSxJQUNKO0FBR0EsYUFBUyxTQUFTLElBQUk7QUFDbEIsWUFBTSxPQUFPLE9BQU8sU0FBUyxFQUFFLElBQUksS0FBSyxPQUFPLEtBQUssRUFBRTtBQUN0RCxXQUFLLE9BQU8sSUFBSSxZQUFZLENBQUMsV0FBWSxXQUFZLFNBQVUsQ0FBQztBQUNoRSxlQUFTQSxLQUFJLEdBQUdBLEtBQUksS0FBSyxRQUFRQSxNQUFLO0FBQ2xDLGFBQUssV0FBVyxLQUFLQSxFQUFDLENBQUM7QUFBQSxNQUMzQjtBQUFBLElBQ0o7QUFFQSxhQUFTLFVBQVUsYUFBYSxTQUFVLFdBQVc7QUFDakQsWUFBTSxPQUFPLEtBQUs7QUFDbEIsV0FBSyxDQUFDLElBQUksWUFBWSxLQUFLLENBQUMsR0FBRyxTQUFTO0FBQ3hDLFdBQUssQ0FBQyxLQUFLLEtBQUssQ0FBQyxJQUFJO0FBQ3JCLFdBQUssQ0FBQyxJQUFJLEtBQUssS0FBSyxDQUFDLEdBQUcsU0FBUyxJQUFJO0FBQ3JDLFdBQUssQ0FBQyxJQUFJLFlBQVksS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRTtBQUM3QyxhQUFPO0FBQUEsSUFDWDtBQUVBLGFBQVMsVUFBVSxPQUFPLFdBQVk7QUFDbEMsWUFBTSxLQUFLLEtBQUssS0FBSyxDQUFDLElBQUksT0FBTztBQUNqQyxhQUFRLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxJQUFLO0FBQUEsSUFDbkM7QUFFQSxhQUFTLGVBQTBCLEtBQUs7QUFFcEMsWUFBTSxPQUFPLElBQUksU0FBUyxHQUFHO0FBRzdCLGFBQU8sU0FBcUIsTUFBTTtBQUU5QixjQUFNLFNBQVMsT0FBTyxNQUFNLEtBQUssTUFBTTtBQUN2QyxZQUFJLE1BQU07QUFFVixpQkFBUyxLQUFLLE1BQU07QUFHaEIsaUJBQU8sS0FBSyxJQUFJLEtBQUssV0FBVyxJQUFJLEtBQUssS0FBSyxDQUFDO0FBQUEsUUFDbkQ7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFFQSxhQUFTLGVBQTBCLEtBQUs7QUFFcEMsWUFBTSxPQUFPLElBQUksU0FBUyxHQUFHO0FBRzdCLGFBQU8sU0FBcUIsTUFBaUIsUUFBcUIsTUFBTSxHQUFHO0FBRXZFLFlBQUksQ0FBQyxPQUFRLFVBQVMsT0FBTyxNQUFNLEtBQUssTUFBTTtBQUU5QyxpQkFBUyxLQUFLLE1BQU07QUFDaEIsZ0JBQU0sSUFBSSxLQUFLLEtBQUs7QUFDcEIsaUJBQU8sS0FBSyxJQUFJLElBQUk7QUFDcEIsZUFBSyxXQUFXLENBQUM7QUFBQSxRQUNyQjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsSUFDSjtBQUVBLGFBQVMsUUFBbUIsTUFBaUIsUUFBMkIsS0FBSztBQUN6RSxVQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sU0FBUyxJQUFJLEtBQUssS0FBSyxTQUFTLElBQUk7QUFDckQsZUFBTyxPQUFPLE1BQU0sQ0FBQztBQUFBLE1BQ3pCO0FBR0EsWUFBTSxZQUFZLGVBQWUsR0FBRztBQUdwQyxZQUFNLE9BQU8sVUFBVSxLQUFLLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFJeEMsWUFBTSxjQUFjLE9BQU8sUUFBUSxPQUFTLElBQU0sT0FBTyxlQUFlLE9BQU8sUUFBUTtBQUd2RixVQUFJLEtBQUssRUFBRSxNQUFNLFlBQVk7QUFDekIsY0FBTSxPQUFPLGVBQWU7QUFBQSxNQUNoQztBQUdBLGFBQU8sVUFBVSxLQUFLLE1BQU0sRUFBRSxDQUFDO0FBQUEsSUFDbkM7QUFHQSxhQUFTLFFBQVEsTUFBTTtBQUNuQixVQUFJLE9BQU8sU0FBUyxJQUFJLEtBQUssS0FBSyxVQUFVLElBQUk7QUFFNUMsZUFBTyxVQUFVLFdBQVk7QUFDekIsaUJBQU8sS0FBSyxNQUFNLEdBQUcsRUFBRTtBQUFBLFFBQzNCO0FBQUEsTUFDSixXQUFXLFNBQVMsUUFBUTtBQUV4QixlQUFPLFVBQVUsUUFBUTtBQUFBLE1BQzdCLE9BQU87QUFFSCxlQUFPLFVBQVU7QUFBQSxNQUNyQjtBQUFBLElBQ0o7QUFFQSxhQUFTLFFBQW1CLE1BQWlCLFFBQTJCLEtBQWlCLFVBQVUsT0FBTztBQUV0RyxVQUFJLFFBQVEsS0FBTSxRQUFPLE9BQU8sTUFBTSxDQUFDO0FBRXZDLFVBQUksQ0FBQyxPQUFPLFNBQVMsSUFBSSxFQUFHLFFBQU8sT0FBTyxLQUFLLEtBQUssU0FBUyxDQUFDO0FBRzlELFlBQU0sWUFBWSxlQUFlLEdBQUc7QUFHcEMsWUFBTSxPQUFPLE9BQU8sUUFBUTtBQUM1QixXQUFLLEVBQUUsSUFBSyxPQUFPLFFBQVEsS0FBTTtBQUdqQyxVQUFJLFFBQVMsTUFBSyxFQUFFLElBQUssT0FBTyxRQUFRLEtBQU07QUFHOUMsWUFBTSxTQUFTLE9BQU8sTUFBTSxLQUFLLFNBQVMsRUFBRTtBQUM1QyxnQkFBVSxNQUFNLE1BQU07QUFHdEIsYUFBTyxVQUFVLE1BQU0sUUFBUSxFQUFFO0FBQUEsSUFDckM7QUFFQSxJQUFBRixRQUFPLFVBQVUsRUFBRSxTQUFTLFNBQVMsUUFBUTtBQUFBO0FBQUE7OztBQzlLN0M7QUFBQSwwQ0FBQUcsVUFBQTtBQUFBLElBQUFBLFNBQVEsV0FBVztBQUNuQixJQUFBQSxTQUFRLFdBQVc7QUFDbkIsSUFBQUEsU0FBUSxZQUFZO0FBQUE7QUFBQTs7O0FDRnBCO0FBQUEscUNBQUFDLFVBQUFDLFNBQUE7QUFBQSxRQUFJLFFBQVE7QUFBWixRQUNJQyxXQUFVO0FBRGQsUUFFSSxZQUFZLE1BQU07QUFGdEIsUUFHSSxVQUFVO0FBRWQsSUFBQUQsUUFBTyxVQUFVLFNBQXdCLFNBQW9CLE9BQU87QUFDaEUsVUFBSSxpQkFBaUIsSUFBSUMsU0FBUSxZQUFZLEdBQ3pDLGFBQWEsT0FBTyxNQUFNLENBQUMsR0FDM0IsV0FBVyxPQUFPLE1BQU0sQ0FBQyxHQUN6QixlQUFlLE9BQ2YsbUJBQW1CLE1BQ25CLFNBQVMsT0FBTyxNQUFNLENBQUMsR0FDdkIsY0FBYyxPQUFPLE1BQU0sQ0FBQyxHQUM1QixPQUFPO0FBR1gsWUFBTSxPQUFPO0FBRWIsWUFBTSxVQUFVLE9BQU8sS0FBSyxZQUFZLFdBQVcsS0FBSyxVQUFVLE1BQU07QUFDeEUsYUFBTyxRQUFRLGVBQWUsS0FBSyxJQUFJLFFBQVEsTUFBTTtBQUVyRCxlQUFTLDJCQUEyQjtBQUVoQyxZQUFJLENBQUMsU0FBUyxFQUFFLGlCQUFpQixhQUFhO0FBQzFDLGlCQUFPLE9BQU8sTUFBTSxDQUFDO0FBQUEsUUFDekI7QUFDQSxzQkFBYyxlQUFlLDBCQUEwQixLQUFLO0FBQzVELGVBQU8sTUFBTSxNQUFNLGVBQWUsZ0JBQWdCLGVBQWUsaUJBQWlCLGVBQWUsY0FBYztBQUFBLE1BQ25IO0FBRUEsZUFBUyxRQUFRLE1BQU07QUFFbkIsWUFBSSxDQUFDLGVBQWUsWUFBWTtBQUM1QixjQUFJLE1BQU0sTUFBTSxJQUFJLE1BQU0sZUFBZSxZQUFZLEtBQUs7QUFDdEQsbUJBQU87QUFBQSxVQUNYO0FBQUEsUUFDSixPQUFPO0FBQ0gsZ0JBQU0sYUFBYSxDQUFDO0FBQ3BCLGdCQUFNLGdCQUFnQixlQUFlLGlCQUFpQixlQUFlO0FBRXJFLGNBQUksTUFBTSxhQUFhLGFBQWEsS0FBSyxVQUFVLFVBQVUsTUFBTSxhQUFhLGFBQWEsS0FBSyxVQUFVLFFBQVE7QUFDaEgsa0JBQU0sTUFBTSxPQUFPLHFCQUFxQjtBQUFBLFVBQzVDO0FBR0EsY0FBSSxNQUFNLGFBQWEsYUFBYSxLQUFLLFVBQVUsUUFBUTtBQUV2RCx1QkFBVyxNQUFNLE1BQU0sYUFBYSxnQkFBZ0IsVUFBVSxNQUFNO0FBQ3BFLHVCQUFXLGlCQUFpQixNQUFNLGFBQWEsZ0JBQWdCLFVBQVUsTUFBTTtBQUMvRSx1QkFBVyxPQUFPLE1BQU0sYUFBYSxnQkFBZ0IsVUFBVSxNQUFNO0FBQUEsVUFDekUsV0FBVyxNQUFNLGFBQWEsZ0JBQWdCLEVBQUUsTUFBTSxPQUFRO0FBRTFELHVCQUFXLE1BQU0sTUFBTSxhQUFhLGdCQUFnQixVQUFVLFNBQVMsQ0FBQztBQUN4RSx1QkFBVyxpQkFBaUIsTUFBTSxhQUFhLGdCQUFnQixVQUFVLFNBQVMsQ0FBQztBQUNuRix1QkFBVyxPQUFPLE1BQU0sYUFBYSxnQkFBZ0IsVUFBVSxTQUFTLENBQUM7QUFBQSxVQUM3RSxPQUFPO0FBQ0gsa0JBQU0sTUFBTSxPQUFPLG1CQUFtQjtBQUFBLFVBQzFDO0FBR0EsY0FBSSxXQUFXLG1CQUFtQixlQUFlLGtCQUFrQixXQUFXLFNBQVMsZUFBZSxRQUFRLFdBQVcsUUFBUSxlQUFlLEtBQUs7QUFDakosa0JBQU0sTUFBTSxPQUFPLGtCQUFrQjtBQUFBLFVBQ3pDO0FBQ0EsY0FBSSxNQUFNLE1BQU0sSUFBSSxNQUFNLFdBQVcsS0FBSztBQUN0QyxtQkFBTztBQUFBLFVBQ1g7QUFBQSxRQU1KO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLFdBQXVCLE9BQW9CLFVBQTZCLE1BQU07QUFDbkYsWUFBSSxPQUFPLGFBQWEsZUFBZSxPQUFPLFVBQVUsVUFBVTtBQUM5RCxpQkFBTztBQUNQLGtCQUFRO0FBQUEsUUFDWjtBQUNBLFlBQUksY0FBYztBQUNkLGNBQUksU0FBUyxVQUFVO0FBQ25CLHFCQUFTLE9BQU8sTUFBTSxDQUFDLEdBQUcsTUFBTSxPQUFPLHdCQUF3QixDQUFDO0FBQUEsVUFDcEU7QUFDQSxpQkFBTyxPQUFPLE1BQU0sQ0FBQztBQUFBLFFBQ3pCO0FBRUEsWUFBSSxpQkFBaUIseUJBQXlCO0FBRTlDLFlBQUksZUFBZSxXQUFXLEdBQUc7QUFFN0IsY0FBSSxTQUFTLFNBQVUsVUFBUyxjQUFjO0FBQzlDLGlCQUFPO0FBQUEsUUFDWDtBQUVBLFlBQUksZUFBZSxXQUFXO0FBQzFCLGNBQUksYUFBYSxPQUFPLFFBQVEsQ0FBQyxPQUFPLFNBQVMsSUFBSSxHQUFHO0FBQ3BELGtCQUFNLE1BQU0sT0FBTyxtQkFBbUI7QUFBQSxVQUMxQztBQUNBLDJCQUFpQixRQUFRLFVBQVUsUUFBUSxnQkFBZ0IsZ0JBQWdCLElBQUk7QUFBQSxRQUNuRjtBQUVBLFlBQUksT0FBTyxPQUFPLE1BQU0sZUFBZSxJQUFJO0FBRTNDLGdCQUFRLGVBQWUsUUFBUTtBQUFBLFVBQzNCLEtBQUssTUFBTSxVQUFVO0FBQ2pCLDJCQUFlLEtBQUssSUFBSTtBQUN4QixnQkFBSSxDQUFDLFFBQVEsSUFBSSxHQUFHO0FBQ2hCLGtCQUFJLFNBQVMsU0FBVSxVQUFTLE1BQU0sTUFBTSxPQUFPLFFBQVEsQ0FBQztBQUM1RCxvQkFBTSxNQUFNLE9BQU8sUUFBUTtBQUFBLFlBQy9CLE9BQU87QUFFSCxrQkFBSSxTQUFTLFNBQVUsVUFBUyxJQUFJO0FBQ3BDLHFCQUFPO0FBQUEsWUFDWDtBQUFBLFVBQ0osS0FBSyxNQUFNLFVBQVU7QUFDakIsZ0JBQUksV0FBVyxJQUFJLFFBQVEsU0FBUyxnQkFBZ0IsZUFBZSxJQUFJO0FBQ3ZFLGdCQUFJLENBQUMsT0FBTztBQUNSLG9CQUFNLFNBQVMsU0FBUyxRQUFRLElBQUk7QUFDcEMscUJBQU8sS0FBSyxNQUFNLENBQUM7QUFDbkIsa0JBQUksQ0FBQyxRQUFRLElBQUksR0FBRztBQUNoQixzQkFBTSxNQUFNLE9BQU8sUUFBUSxJQUFJLFFBQVEsT0FBTyxVQUFVLENBQUMsR0FBRztBQUFBLGNBQ2hFO0FBQ0EscUJBQU87QUFBQSxZQUNYLE9BQU87QUFDSCx1QkFBUyxhQUFhLFNBQVUsUUFBUTtBQUNwQyx1QkFBTyxLQUFLLFFBQVEsQ0FBQztBQUNyQixvQkFBSSxVQUFVO0FBQ1Ysc0JBQUksQ0FBQyxRQUFRLE1BQU0sR0FBRztBQUNsQiw2QkFBUyxRQUFRLE1BQU0sT0FBTyxRQUFRLENBQUM7QUFBQSxrQkFDM0MsT0FBTztBQUNILDZCQUFTLE1BQU07QUFBQSxrQkFDbkI7QUFBQSxnQkFDSjtBQUFBLGNBQ0osQ0FBQztBQUFBLFlBQ0w7QUFDQTtBQUFBLFVBQ0o7QUFDSSxnQkFBSSxTQUFTLFNBQVUsVUFBUyxPQUFPLE1BQU0sQ0FBQyxHQUFHLE1BQU0sT0FBTyxlQUFlLENBQUM7QUFDOUUsa0JBQU0sTUFBTSxPQUFPLGVBQWU7QUFBQSxRQUMxQztBQUFBLE1BQ0o7QUFFQSxlQUFTLFNBQXFCLE9BQW9CLFVBQVU7QUFDeEQsYUFBSyxDQUFDLG9CQUFvQixDQUFDLGlCQUFpQixXQUFXLE9BQU8sU0FBUyxLQUFLLEdBQUc7QUFFM0UsY0FBSSxTQUFTLFNBQVUsVUFBUyx5QkFBeUIsQ0FBQztBQUMxRCxpQkFBTyx5QkFBeUI7QUFBQSxRQUNwQztBQUVBLFlBQUksaUJBQWlCLFVBQVUsQ0FBQyxjQUFjO0FBQzFDLGNBQUk7QUFFSixrQkFBUSxlQUFlLFFBQVE7QUFBQSxZQUMzQixLQUFLLE1BQU0sVUFBVTtBQUNqQiw2QkFBZSxpQkFBaUIsZUFBZTtBQUUvQywrQkFBaUIsT0FBTyxNQUFNLGlCQUFpQixNQUFNO0FBQ3JELCtCQUFpQixLQUFLLGNBQWM7QUFFcEMsa0JBQUksU0FBUyxTQUFVLFVBQVMsY0FBYztBQUM5QyxxQkFBTztBQUFBLFlBQ1g7QUFBQSxZQUNBLEtBQUssTUFBTSxVQUFVO0FBQ2pCLGtCQUFJLFdBQVcsSUFBSSxRQUFRLFNBQVMsZ0JBQWdCO0FBQ3BELGtCQUFJLENBQUMsT0FBTztBQUNSLG9CQUFJLFdBQVcsU0FBUyxRQUFRO0FBQ2hDLCtCQUFlLGlCQUFpQixTQUFTO0FBQ3pDLHVCQUFPO0FBQUEsY0FDWCxPQUFPO0FBQ0gseUJBQVMsYUFBYSxTQUFVLE1BQU07QUFDbEMsbUNBQWlCLE9BQU8sTUFBTSxLQUFLLE1BQU07QUFDekMsaUNBQWUsaUJBQWlCLEtBQUs7QUFDckMsdUJBQUssS0FBSyxjQUFjO0FBQ3hCLDhCQUFZLFNBQVMsY0FBYztBQUFBLGdCQUN2QyxDQUFDO0FBQUEsY0FDTDtBQUNBLHlCQUFXO0FBQ1g7QUFBQSxVQUNSO0FBQUEsUUFDSixXQUFXLFNBQVMsVUFBVTtBQUMxQixtQkFBUyxPQUFPLE1BQU0sQ0FBQyxDQUFDO0FBQUEsUUFDNUIsT0FBTztBQUNILGlCQUFPLE9BQU8sTUFBTSxDQUFDO0FBQUEsUUFDekI7QUFBQSxNQUNKO0FBRUEsZUFBUyxhQUFhLFFBQVEsUUFBUTtBQUNsQyxnQkFBUSxPQUFPLGFBQWEsU0FBUyxDQUFDLEtBQUssS0FBSyxPQUFPLGFBQWEsTUFBTTtBQUFBLE1BQzlFO0FBRUEsZUFBUyxXQUFXLE1BQU07QUFDdEIsWUFBSTtBQUNBLGNBQUksU0FBUztBQUNiLGNBQUksV0FBVyxNQUFNO0FBQ3JCLGlCQUFPLFNBQVMsSUFBSSxLQUFLLFFBQVE7QUFDN0Isd0JBQVksS0FBSyxhQUFhLE1BQU07QUFDcEMsc0JBQVU7QUFDVixtQkFBTyxLQUFLLGFBQWEsTUFBTTtBQUMvQixzQkFBVTtBQUNWLG1CQUFPLEtBQUssTUFBTSxRQUFRLFNBQVMsSUFBSTtBQUN2QyxzQkFBVTtBQUNWLGdCQUFJLFVBQVUsYUFBYSxXQUFXO0FBQ2xDLDRDQUE4QixJQUFJO0FBQUEsWUFDdEM7QUFBQSxVQUNKO0FBQUEsUUFDSixTQUFTLE9BQU87QUFDWixnQkFBTSxNQUFNLE9BQU8sd0JBQXdCO0FBQUEsUUFDL0M7QUFBQSxNQUNKO0FBR0EsZUFBUyw4QkFBOEIsTUFBTTtBQUN6QyxZQUFJLE1BQU0sZ0JBQWdCLFFBQVE7QUFFbEMsWUFBSSxLQUFLLFVBQVUsVUFBVSxnQkFBZ0I7QUFDekMsaUJBQU8sYUFBYSxNQUFNLFVBQVUsZ0JBQWdCO0FBQ3BELGNBQUksZUFBZSxTQUFTLFVBQVUsZ0JBQWdCO0FBQ2xELDJCQUFlLE9BQU87QUFBQSxVQUMxQjtBQUFBLFFBQ0o7QUFDQSxZQUFJLEtBQUssVUFBVSxVQUFVLGNBQWM7QUFDdkMsMkJBQWlCLGFBQWEsTUFBTSxVQUFVLGNBQWM7QUFDNUQsY0FBSSxlQUFlLG1CQUFtQixVQUFVLGdCQUFnQjtBQUM1RCwyQkFBZSxpQkFBaUI7QUFBQSxVQUNwQztBQUFBLFFBQ0o7QUFDQSxZQUFJLEtBQUssVUFBVSxVQUFVLGNBQWM7QUFDdkMsbUJBQVMsYUFBYSxNQUFNLFVBQVUsWUFBWTtBQUNsRCxjQUFJLGVBQWUsV0FBVyxVQUFVLGdCQUFnQjtBQUNwRCwyQkFBZSxTQUFTO0FBQUEsVUFDNUI7QUFBQSxRQUNKO0FBQ0EsWUFBSSxLQUFLLFVBQVUsVUFBVSxlQUFlLEdBQUc7QUFDM0MseUJBQWUsS0FBSyxhQUFhLFVBQVUsWUFBWTtBQUN2RCxjQUFJLGVBQWUsaUJBQWlCLFVBQVUsZ0JBQWdCO0FBQzFELDJCQUFlLGVBQWU7QUFBQSxVQUNsQztBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBRUEsYUFBTztBQUFBLFFBQ0gsSUFBSSxZQUFZO0FBQ1osaUJBQU8sUUFBUSxPQUFPLFVBQVU7QUFBQSxRQUNwQztBQUFBLFFBQ0EsSUFBSSxlQUFlO0FBQ2YsaUJBQU87QUFBQSxRQUNYO0FBQUEsUUFDQSxJQUFJLFVBQVUsS0FBSztBQUNmLHVCQUFhLE1BQU0sU0FBUyxLQUFLLFFBQVEsTUFBTTtBQUMvQyxjQUFJLFdBQVcsV0FBVyxXQUFXLFNBQVMsQ0FBQztBQUMvQyx5QkFBZSxhQUFhLE1BQU0sYUFBYTtBQUMvQyx5QkFBZSxpQkFBaUIsV0FBVztBQUFBLFFBQy9DO0FBQUEsUUFFQSxJQUFJLE1BQU07QUFDTixjQUFJLE9BQU8sU0FBUyxZQUFZO0FBQzVCLG1CQUFPLEtBQUssS0FBSyxTQUFTO0FBQUEsVUFDOUIsT0FBTztBQUNILG1CQUFPO0FBQUEsVUFDWDtBQUFBLFFBQ0o7QUFBQSxRQUVBLElBQUksUUFBUTtBQUNSLGlCQUFPO0FBQUEsUUFDWDtBQUFBLFFBQ0EsSUFBSSxNQUFNLEtBQUs7QUFDWCxtQkFBUztBQUNULHlCQUFlLGNBQWMsSUFBSTtBQUNqQyxxQkFBVyxHQUFHO0FBQUEsUUFDbEI7QUFBQSxRQUVBLElBQUksVUFBVTtBQUNWLGlCQUFPLFFBQVEsT0FBTyxRQUFRO0FBQUEsUUFDbEM7QUFBQSxRQUNBLElBQUksUUFBUSxLQUFLO0FBQ2IscUJBQVcsTUFBTSxTQUFTLEtBQUssUUFBUSxNQUFNO0FBQzdDLHlCQUFlLGdCQUFnQixTQUFTO0FBQ3hDLGNBQUksU0FBUyxTQUFTLE1BQVEsT0FBTSxNQUFNLE9BQU8saUJBQWlCO0FBQUEsUUFDdEU7QUFBQSxRQUVBLElBQUksT0FBTztBQUNQLGNBQUksSUFBSSxRQUFRLE9BQU8sVUFBVTtBQUNqQyxpQkFBTyxlQUNELEVBQ0ssT0FBTyxFQUFFLFNBQVMsQ0FBQyxFQUNuQixNQUFNLEdBQUcsRUFDVCxJQUFJLElBQ1QsRUFBRSxNQUFNLEdBQUcsRUFBRSxJQUFJO0FBQUEsUUFDM0I7QUFBQSxRQUNBLElBQUksY0FBYztBQUNkLGlCQUFPO0FBQUEsUUFDWDtBQUFBLFFBRUEsbUJBQW1CLFdBQVk7QUFDM0IsaUJBQU8sU0FBUyxPQUFPLElBQUk7QUFBQSxRQUMvQjtBQUFBLFFBRUEsd0JBQXdCLFNBQXVCLFVBQVU7QUFDckQsbUJBQVMsTUFBTSxRQUFRO0FBQUEsUUFDM0I7QUFBQSxRQUVBLFNBQVMsU0FBVSxPQUFPO0FBQ3RCLDZCQUFtQixNQUFNLFNBQVMsT0FBTyxNQUFNLFFBQVEsTUFBTTtBQUM3RCxjQUFJLENBQUMsZ0JBQWdCLGlCQUFpQixRQUFRO0FBQzFDLDJCQUFlLE9BQU8saUJBQWlCO0FBQ3ZDLDJCQUFlLFNBQVMsTUFBTSxVQUFVO0FBQ3hDLDJCQUFlLE1BQU0sTUFBTSxNQUFNLEtBQUs7QUFDdEMsMkJBQWUsVUFBVTtBQUFBLFVBQzdCLE9BQU87QUFFSCwyQkFBZSxTQUFTLE1BQU0sVUFBVTtBQUFBLFVBQzVDO0FBQUEsUUFDSjtBQUFBLFFBRUEsU0FBUyxTQUFVLE1BQU07QUFDckIsY0FBSSxlQUFlLFNBQVM7QUFDeEIsbUJBQU87QUFBQSxVQUNYLE9BQU87QUFDSCxtQkFBTyxXQUFXLE9BQU8sTUFBTSxJQUFJO0FBQUEsVUFDdkM7QUFBQSxRQUNKO0FBQUEsUUFFQSxjQUFjLFNBQXVCLFVBQVUsTUFBTTtBQUNqRCxjQUFJLGVBQWUsU0FBUztBQUN4QixxQkFBUyxnQkFBZ0I7QUFBQSxVQUM3QixPQUFPO0FBQ0gsdUJBQVcsTUFBTSxVQUFVLElBQUk7QUFBQSxVQUNuQztBQUFBLFFBQ0o7QUFBQSxRQUVBLElBQUksS0FBSyxNQUFNO0FBQ1gseUJBQWUsT0FBTztBQUFBLFFBQzFCO0FBQUEsUUFDQSxJQUFJLE9BQU87QUFDUCxpQkFBTyxlQUFlO0FBQUEsUUFDMUI7QUFBQSxRQUVBLElBQUksT0FBa0IsTUFBTTtBQUN4Qix5QkFBZSxlQUFlLElBQUk7QUFBQSxRQUN0QztBQUFBLFFBRUEsSUFBSSxTQUFTO0FBQ1QsaUJBQU87QUFBQSxRQUNYO0FBQUEsUUFFQSxtQkFBbUIsV0FBWTtBQUMzQix5QkFBZSxZQUFZLEtBQUs7QUFDaEMseUJBQWUsY0FBYyxPQUFPO0FBRXBDLGNBQUksU0FBUyxlQUFlLHNCQUFzQjtBQUNsRCxjQUFJLFNBQVMsTUFBTSxVQUFVO0FBRTdCLHFCQUFXLEtBQUssUUFBUSxNQUFNO0FBQzlCLG9CQUFVLFdBQVc7QUFFckIsaUJBQU8sS0FBSyxRQUFRLE1BQU07QUFDMUIsb0JBQVUsZUFBZTtBQUV6QixtQkFBUyxLQUFLLFFBQVEsTUFBTTtBQUM1QixpQkFBTztBQUFBLFFBQ1g7QUFBQSxRQUVBLGlCQUFpQixXQUFZO0FBQ3pCLGNBQUksU0FBUztBQUNiLHlCQUFlLFlBQVksS0FBSztBQUNoQyx5QkFBZSxtQkFBbUIsWUFBWTtBQUU5QyxnQkFBTSxpQkFBaUIsZUFBZSxvQkFBb0I7QUFFMUQsZ0JBQU0sY0FBYyxPQUFPLE1BQU0sZUFBZSxTQUFTLFdBQVcsU0FBUyxlQUFlLGdCQUFnQjtBQUU1Ryx5QkFBZSxLQUFLLGFBQWEsTUFBTTtBQUN2QyxvQkFBVSxlQUFlO0FBRXpCLHFCQUFXLEtBQUssYUFBYSxNQUFNO0FBQ25DLG9CQUFVLFdBQVc7QUFFckIsc0JBQVksS0FBSyxhQUFhLE1BQU07QUFDcEMsb0JBQVUsWUFBWTtBQUV0QixpQkFBTztBQUFBLFFBQ1g7QUFBQSxRQUVBLFFBQVEsV0FBWTtBQUNoQixnQkFBTSxRQUFRLFNBQVUsSUFBSTtBQUN4QixtQkFBTyxPQUFRLE1BQU0sR0FBRyxTQUFTLG1CQUFvQixVQUFVO0FBQUEsVUFDbkU7QUFFQSxpQkFBTztBQUFBLFlBQ0gsV0FBVyxLQUFLO0FBQUEsWUFDaEIsTUFBTSxLQUFLO0FBQUEsWUFDWCxTQUFTLEtBQUs7QUFBQSxZQUNkLGFBQWEsS0FBSztBQUFBLFlBQ2xCLFFBQVEsZUFBZSxPQUFPO0FBQUEsWUFDOUIsZ0JBQWdCLE1BQU0sS0FBSztBQUFBLFlBQzNCLE1BQU0sTUFBTSxnQkFBZ0I7QUFBQSxVQUNoQztBQUFBLFFBQ0o7QUFBQSxRQUVBLFVBQVUsV0FBWTtBQUNsQixpQkFBTyxLQUFLLFVBQVUsS0FBSyxPQUFPLEdBQUcsTUFBTSxHQUFJO0FBQUEsUUFDbkQ7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBO0FBQUE7OztBQ3BaQTtBQUFBLG9DQUFBQyxVQUFBQyxTQUFBO0FBQUEsUUFBTSxXQUFXO0FBQ2pCLFFBQU1DLFdBQVU7QUFDaEIsUUFBTSxRQUFRO0FBRWQsSUFBQUQsUUFBTyxVQUFVLFNBQTBCLFVBQXdCLFNBQVM7QUFDeEUsVUFBSSxZQUFZLENBQUMsR0FDYixhQUFhLENBQUMsR0FDZCxXQUFXLE9BQU8sTUFBTSxDQUFDLEdBQ3pCLGFBQWEsSUFBSUMsU0FBUSxXQUFXLEdBQ3BDLGdCQUFnQjtBQUNwQixVQUFJLFdBQVc7QUFDZixZQUFNLFlBQVksb0JBQUksSUFBSTtBQUcxQixZQUFNLE9BQU87QUFFYixZQUFNLEVBQUUsUUFBUSxRQUFRLElBQUk7QUFFNUIsVUFBSSxVQUFVO0FBRVYsdUJBQWUsS0FBSyxXQUFXO0FBQUEsTUFDbkMsT0FBTztBQUVILHdCQUFnQjtBQUFBLE1BQ3BCO0FBRUEsZUFBUyx1QkFBdUI7QUFDNUIsY0FBTSxjQUFjLG9CQUFJLElBQUk7QUFHNUIsbUJBQVcsUUFBUSxPQUFPLEtBQUssVUFBVSxHQUFHO0FBQ3hDLGdCQUFNLFdBQVcsS0FBSyxNQUFNLEdBQUc7QUFDL0IsbUJBQVMsSUFBSTtBQUNiLGNBQUksQ0FBQyxTQUFTLE9BQVE7QUFDdEIsbUJBQVNDLEtBQUksR0FBR0EsS0FBSSxTQUFTLFFBQVFBLE1BQUs7QUFDdEMsa0JBQU0sTUFBTSxTQUFTLE1BQU0sR0FBR0EsS0FBSSxDQUFDLEVBQUUsS0FBSyxHQUFHLElBQUk7QUFDakQsd0JBQVksSUFBSSxHQUFHO0FBQUEsVUFDdkI7QUFBQSxRQUNKO0FBR0EsbUJBQVcsUUFBUSxhQUFhO0FBQzVCLGNBQUksRUFBRSxRQUFRLGFBQWE7QUFDdkIsa0JBQU0sYUFBYSxJQUFJLFNBQVMsSUFBSTtBQUNwQyx1QkFBVyxZQUFZO0FBQ3ZCLHVCQUFXLE9BQU87QUFDbEIsdUJBQVcsWUFBWTtBQUN2QixzQkFBVSxLQUFLLFVBQVU7QUFDekIsdUJBQVcsV0FBVyxTQUFTLElBQUk7QUFDbkMsc0JBQVUsSUFBSSxVQUFVO0FBQUEsVUFDNUI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUVBLGVBQVMsY0FBYztBQUNuQix3QkFBZ0I7QUFDaEIscUJBQWEsQ0FBQztBQUNkLFlBQUksV0FBVyxlQUFlLFNBQVMsU0FBUyxXQUFXLFVBQVUsTUFBTSxVQUFVLFFBQVE7QUFDekYsZ0JBQU0sTUFBTSxPQUFPLHFCQUFxQjtBQUFBLFFBQzVDO0FBQ0Esb0JBQVksSUFBSSxNQUFNLFdBQVcsV0FBVztBQUM1QyxZQUFJLFFBQVEsV0FBVztBQUN2QixpQkFBU0EsS0FBSSxHQUFHQSxLQUFJLFVBQVUsUUFBUUEsTUFBSztBQUN2QyxjQUFJLE1BQU0sT0FDTixRQUFRLElBQUksU0FBUyxNQUFNLFFBQVE7QUFDdkMsZ0JBQU0sU0FBUyxTQUFTLE1BQU0sS0FBTSxPQUFPLE1BQU0sVUFBVSxNQUFPO0FBRWxFLGdCQUFNLFlBQVksU0FBUyxNQUFNLEtBQU0sT0FBTyxNQUFNLE9BQU8sY0FBZTtBQUUxRSxjQUFJLE1BQU0sT0FBTyxhQUFhO0FBQzFCLGtCQUFNLFFBQVEsU0FBUyxNQUFNLEtBQU0sT0FBTyxNQUFNLE9BQU8sV0FBWTtBQUFBLFVBQ3ZFO0FBRUEsY0FBSSxNQUFNLE9BQU8sY0FBZSxPQUFNLFVBQVUsU0FBUyxNQUFNLEtBQUssTUFBTSxNQUFNLE9BQU8sYUFBYTtBQUVwRyxtQkFBUyxNQUFNLE9BQU87QUFFdEIsb0JBQVVBLEVBQUMsSUFBSTtBQUNmLHFCQUFXLE1BQU0sU0FBUyxJQUFJO0FBQUEsUUFDbEM7QUFDQSxrQkFBVSxNQUFNO0FBQ2hCLDZCQUFxQjtBQUFBLE1BQ3pCO0FBRUEsZUFBUyxlQUEyQixTQUFTO0FBQ3pDLFlBQUlBLEtBQUksU0FBUyxTQUFTLE1BQU0sVUFBVSxRQUN0QyxNQUFNLEtBQUssSUFBSSxHQUFHQSxLQUFJLEtBQU0sR0FDNUIsSUFBSSxLQUNKLFdBQVcsU0FBUyxRQUNwQixZQUFZLElBQ1osYUFBYTtBQUdqQixjQUFNLGdCQUFnQixPQUFPLEtBQUssa0JBQWtCLFlBQVksS0FBSyxnQkFBZ0I7QUFDckYsWUFBSSxjQUFlLE9BQU07QUFFekIsYUFBS0EsSUFBR0EsTUFBSyxHQUFHQSxNQUFLO0FBQ2pCLGNBQUksU0FBU0EsRUFBQyxNQUFNLEdBQU07QUFDMUIsY0FBSSxTQUFTLGFBQWFBLEVBQUMsTUFBTSxNQUFNLFVBQVUsUUFBUTtBQUVyRCx3QkFBWUE7QUFDWix5QkFBYUE7QUFDYix1QkFBV0EsS0FBSSxNQUFNLFVBQVU7QUFFL0IsZ0JBQUlBLEtBQUksTUFBTSxVQUFVO0FBQ3hCO0FBQUEsVUFDSjtBQUVBLGNBQUksU0FBUyxhQUFhQSxFQUFDLE1BQU0sTUFBTSxVQUFVLFVBQVU7QUFFdkQsZ0JBQUk7QUFDSjtBQUFBLFVBQ0o7QUFFQSxjQUFJLFNBQVMsYUFBYUEsRUFBQyxNQUFNLE1BQU0sVUFBVSxVQUFVO0FBRXZELHdCQUFZQTtBQUNaLHVCQUFXQSxLQUFJLE1BQU0sZ0JBQWdCLFVBQVVBLEtBQUksTUFBTSxVQUFVLFNBQVMsSUFBSSxNQUFNLFVBQVU7QUFDaEc7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUVBLFlBQUksYUFBYSxHQUFJLE9BQU0sTUFBTSxPQUFPLGVBQWU7QUFFdkQsbUJBQVcsZUFBZSxTQUFTLE1BQU0sV0FBVyxRQUFRLENBQUM7QUFDN0QsWUFBSSxXQUFXLGVBQWU7QUFDMUIscUJBQVcsU0FBUyxNQUFNLGFBQWEsTUFBTSxVQUFVLE1BQU07QUFBQSxRQUNqRTtBQUNBLFlBQUksUUFBUyxhQUFZO0FBQUEsTUFDN0I7QUFFQSxlQUFTLGNBQWM7QUFDbkIsWUFBSSxVQUFVLFNBQVMsS0FBSyxDQUFDLFFBQVE7QUFDakMsb0JBQVUsS0FBSyxDQUFDLEdBQUcsTUFBTSxFQUFFLFVBQVUsWUFBWSxFQUFFLGNBQWMsRUFBRSxVQUFVLFlBQVksQ0FBQyxDQUFDO0FBQUEsUUFDL0Y7QUFBQSxNQUNKO0FBRUEsYUFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLSCxJQUFJLFVBQVU7QUFDVixjQUFJLENBQUMsZUFBZTtBQUNoQix3QkFBWTtBQUFBLFVBQ2hCO0FBQ0EsaUJBQU8sVUFBVSxPQUFPLENBQUNDLE9BQU0sQ0FBQyxVQUFVLElBQUlBLEVBQUMsQ0FBQztBQUFBLFFBQ3BEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQU1BLElBQUksVUFBVTtBQUNWLGlCQUFPLFFBQVEsT0FBTyxRQUFRO0FBQUEsUUFDbEM7QUFBQSxRQUNBLElBQUksUUFBUSxLQUFLO0FBQ2IscUJBQVcsTUFBTSxTQUFTLEtBQUssUUFBUSxNQUFNO0FBQzdDLHFCQUFXLGdCQUFnQixTQUFTO0FBQUEsUUFDeEM7QUFBQSxRQUVBLGVBQWUsV0FBWTtBQUN2QixjQUFJLENBQUMsZUFBZTtBQUNoQixtQkFBTyxXQUFXO0FBQUEsVUFDdEI7QUFFQSxpQkFBTyxVQUFVO0FBQUEsUUFDckI7QUFBQSxRQUVBLFNBQVMsU0FBVSxVQUFVO0FBQ3pCLGVBQUssUUFBUSxRQUFRLFFBQVE7QUFBQSxRQUNqQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBUUEsVUFBVSxTQUFxQixXQUFXO0FBQ3RDLGNBQUksQ0FBQyxlQUFlO0FBQ2hCLHdCQUFZO0FBQUEsVUFDaEI7QUFDQSxpQkFBTyxXQUFXLFNBQVMsS0FBSztBQUFBLFFBQ3BDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBT0EsVUFBVSxTQUF1QixPQUFPO0FBQ3BDLGNBQUksQ0FBQyxlQUFlO0FBQ2hCLHdCQUFZO0FBQUEsVUFDaEI7QUFDQSxvQkFBVSxLQUFLLEtBQUs7QUFDcEIscUJBQVcsTUFBTSxTQUFTLElBQUk7QUFDOUIscUJBQVcsZUFBZSxVQUFVO0FBQUEsUUFDeEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBU0EsWUFBWSxTQUFxQixXQUFXLGlCQUFpQixNQUFNO0FBQy9ELGNBQUksQ0FBQyxlQUFlO0FBQ2hCLHdCQUFZO0FBQUEsVUFDaEI7QUFDQSxnQkFBTSxRQUFRLFdBQVcsU0FBUztBQUNsQyxnQkFBTSxPQUFPLEtBQUssaUJBQWlCLE9BQU8sY0FBYyxFQUFFLElBQUksQ0FBQyxVQUFVLE1BQU0sU0FBUztBQUV4RixlQUFLLFFBQVEsS0FBSyxXQUFXO0FBQUEsUUFDakM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQVFBLGFBQWEsU0FBcUIsV0FBVztBQUN6QyxjQUFJLENBQUMsZUFBZTtBQUNoQix3QkFBWTtBQUFBLFVBQ2hCO0FBQ0EsZ0JBQU0sUUFBUSxXQUFXLFNBQVM7QUFDbEMsZ0JBQU0sUUFBUSxVQUFVLFFBQVEsS0FBSztBQUNyQyxjQUFJLFNBQVMsR0FBRztBQUNaLHNCQUFVLE9BQU8sT0FBTyxDQUFDO0FBQ3pCLG1CQUFPLFdBQVcsU0FBUztBQUMzQix1QkFBVyxlQUFlLFVBQVU7QUFBQSxVQUN4QztBQUFBLFFBQ0o7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQVFBLGtCQUFrQixTQUF1QixPQUFPLGFBQWEsTUFBTTtBQUMvRCxjQUFJLENBQUMsZUFBZTtBQUNoQix3QkFBWTtBQUFBLFVBQ2hCO0FBQ0EsY0FBSSxPQUFPLFVBQVUsVUFBVTtBQUMzQixnQkFBSSxNQUFNLGVBQWUsWUFBWTtBQUNqQyxvQkFBTSxPQUFPLENBQUM7QUFDZCxvQkFBTSxPQUFPLE1BQU07QUFFbkIseUJBQVcsWUFBWSxXQUFXO0FBQzlCLG9CQUFJLFNBQVMsVUFBVSxXQUFXLElBQUksR0FBRztBQUNyQyx1QkFBSyxLQUFLLFFBQVE7QUFBQSxnQkFDdEI7QUFBQSxjQUNKO0FBQ0EscUJBQU87QUFBQSxZQUNYLE9BQU87QUFDSCxxQkFBTyxDQUFDLEtBQUs7QUFBQSxZQUNqQjtBQUFBLFVBQ0o7QUFDQSxpQkFBTyxDQUFDO0FBQUEsUUFDWjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBUUEsZUFBZSxTQUFVLE9BQU87QUFDNUIsY0FBSSxTQUFTLE1BQU0sYUFBYTtBQUM1QixrQkFBTSxPQUFPLEtBQUssaUJBQWlCLEtBQUs7QUFDeEMsbUJBQU8sS0FBSyxTQUFTLEtBQUssSUFBSSxLQUFLLFNBQVMsSUFBSSxLQUFLO0FBQUEsVUFDekQ7QUFDQSxpQkFBTztBQUFBLFFBQ1g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFPQSxrQkFBa0IsV0FBWTtBQUMxQixjQUFJLENBQUMsZUFBZTtBQUNoQix3QkFBWTtBQUFBLFVBQ2hCO0FBQ0Esc0JBQVk7QUFFWixnQkFBTSxZQUFZLENBQUM7QUFDbkIsZ0JBQU0sZUFBZSxDQUFDO0FBQ3RCLGNBQUksWUFBWTtBQUNoQixjQUFJLFNBQVM7QUFFYixxQkFBVyxPQUFPO0FBQ2xCLHFCQUFXLFNBQVM7QUFDcEIsY0FBSSxlQUFlO0FBRW5CLHFCQUFXLFNBQVMsS0FBSyxTQUFTO0FBRTlCLGtCQUFNLGlCQUFpQixNQUFNLGtCQUFrQjtBQUMvQyxrQkFBTSxPQUFPLFNBQVM7QUFHdEIsa0JBQU0sY0FBYyxNQUFNLGdCQUFnQjtBQUcxQyxrQkFBTSxhQUFhLFlBQVksU0FBUyxlQUFlO0FBQ3ZELHNCQUFVO0FBR1Ysc0JBQVUsS0FBSyxXQUFXO0FBQzFCLHNCQUFVLEtBQUssY0FBYztBQUc3QixrQkFBTSxnQkFBZ0IsTUFBTSxrQkFBa0I7QUFDOUMseUJBQWEsS0FBSyxhQUFhO0FBRS9CLHVCQUFXLFFBQVEsY0FBYztBQUNqQyx5QkFBYSxhQUFhLGNBQWM7QUFDeEM7QUFBQSxVQUNKO0FBRUEsdUJBQWEsV0FBVztBQUV4QixxQkFBVyxTQUFTO0FBQ3BCLHFCQUFXLGVBQWU7QUFFMUIsbUJBQVM7QUFDVCxnQkFBTSxZQUFZLE9BQU8sTUFBTSxTQUFTO0FBRXhDLHFCQUFXLFdBQVcsV0FBVztBQUM3QixvQkFBUSxLQUFLLFdBQVcsTUFBTTtBQUM5QixzQkFBVSxRQUFRO0FBQUEsVUFDdEI7QUFHQSxxQkFBVyxXQUFXLGNBQWM7QUFDaEMsb0JBQVEsS0FBSyxXQUFXLE1BQU07QUFDOUIsc0JBQVUsUUFBUTtBQUFBLFVBQ3RCO0FBR0EsZ0JBQU0sS0FBSyxXQUFXLFNBQVM7QUFDL0IsY0FBSSxVQUFVO0FBQ1YscUJBQVMsS0FBSyxJQUFJLE1BQU0sVUFBVSxNQUFNO0FBQUEsVUFDNUM7QUFDQSxhQUFHLEtBQUssV0FBVyxNQUFNO0FBTXpCLHFCQUFXO0FBQ1gsMEJBQWdCO0FBRWhCLGlCQUFPO0FBQUEsUUFDWDtBQUFBLFFBRUEsZUFBZSxTQUF1QixXQUF3QixRQUFxQixhQUEwQixXQUFXO0FBQ3BILGNBQUk7QUFDQSxnQkFBSSxDQUFDLGVBQWU7QUFDaEIsMEJBQVk7QUFBQSxZQUNoQjtBQUNBLHdCQUFZO0FBRVosa0JBQU0sWUFBWSxDQUFDO0FBQ25CLGtCQUFNLGlCQUFpQixDQUFDO0FBQ3hCLGdCQUFJLFlBQVk7QUFDaEIsZ0JBQUksU0FBUztBQUNiLGdCQUFJLGVBQWU7QUFFbkIsdUJBQVcsT0FBTztBQUNsQix1QkFBVyxTQUFTO0FBRXBCLGtCQUFNLGtCQUFrQixTQUFVLFlBQVk7QUFDMUMsa0JBQUksV0FBVyxTQUFTLEdBQUc7QUFDdkIsc0JBQU0sUUFBUSxXQUFXLE1BQU07QUFDL0Isc0JBQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxNQUFNLFNBQVM7QUFDcEQsb0JBQUksWUFBYSxhQUFZLElBQUk7QUFDakMsc0JBQU0sdUJBQXVCLFNBQVUsZ0JBQWdCO0FBQ25ELHNCQUFJLFVBQVcsV0FBVSxJQUFJO0FBQzdCLHdCQUFNLE9BQU8sU0FBUztBQUd0Qix3QkFBTSxjQUFjLE1BQU0sZ0JBQWdCO0FBRzFDLHdCQUFNLGFBQWEsWUFBWSxTQUFTLGVBQWU7QUFDdkQsNEJBQVU7QUFHViw0QkFBVSxLQUFLLFdBQVc7QUFDMUIsNEJBQVUsS0FBSyxjQUFjO0FBRzdCLHdCQUFNLGVBQWUsTUFBTSxrQkFBa0I7QUFDN0MsaUNBQWUsS0FBSyxZQUFZO0FBQ2hDLDZCQUFXLFFBQVEsYUFBYTtBQUNoQywrQkFBYSxhQUFhLGFBQWE7QUFDdkM7QUFFQSxrQ0FBZ0IsVUFBVTtBQUFBLGdCQUM5QixDQUFDO0FBQUEsY0FDTCxPQUFPO0FBQ0gsNkJBQWEsV0FBVztBQUV4QiwyQkFBVyxTQUFTO0FBQ3BCLDJCQUFXLGVBQWU7QUFFMUIseUJBQVM7QUFDVCxzQkFBTSxZQUFZLE9BQU8sTUFBTSxTQUFTO0FBQ3hDLDBCQUFVLFFBQVEsU0FBVSxTQUFTO0FBQ2pDLDBCQUFRLEtBQUssV0FBVyxNQUFNO0FBQzlCLDRCQUFVLFFBQVE7QUFBQSxnQkFDdEIsQ0FBQztBQUNELCtCQUFlLFFBQVEsU0FBVSxTQUFTO0FBQ3RDLDBCQUFRLEtBQUssV0FBVyxNQUFNO0FBQzlCLDRCQUFVLFFBQVE7QUFBQSxnQkFDdEIsQ0FBQztBQUVELHNCQUFNLEtBQUssV0FBVyxTQUFTO0FBQy9CLG9CQUFJLFVBQVU7QUFDViwyQkFBUyxLQUFLLElBQUksTUFBTSxVQUFVLE1BQU07QUFBQSxnQkFDNUM7QUFFQSxtQkFBRyxLQUFLLFdBQVcsTUFBTTtBQU16QiwyQkFBVztBQUNYLGdDQUFnQjtBQUVoQiwwQkFBVSxTQUFTO0FBQUEsY0FDdkI7QUFBQSxZQUNKO0FBRUEsNEJBQWdCLE1BQU0sS0FBSyxLQUFLLE9BQU8sQ0FBQztBQUFBLFVBQzVDLFNBQVNBLElBQUc7QUFDUixtQkFBT0EsRUFBQztBQUFBLFVBQ1o7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQTtBQUFBOzs7QUM3YkE7QUFBQSxvQ0FBQUMsVUFBQUMsU0FBQTtBQUFBLFFBQU0sUUFBUTtBQUNkLFFBQU0sTUFBTSxRQUFRLE1BQU07QUFDMUIsUUFBTSxXQUFXO0FBQ2pCLFFBQU0sVUFBVTtBQUVoQixRQUFNLFdBQVcsSUFBSSxRQUFRLE1BQU0sU0FBUyxLQUFLLENBQUMsTUFBTSxPQUFPLE1BQU0sU0FBUztBQUM5RSxRQUFNLFVBQVUsSUFBSSxRQUFRLE1BQU0sU0FBUyxLQUFLLENBQUMsTUFBTSxPQUFPLE1BQU0sUUFBUTtBQUM1RSxRQUFNLFVBQVUsSUFBSSxRQUFRLE1BQU0sU0FBUyxLQUFLLENBQUMsTUFBTSxPQUFPLE1BQU0sVUFBVTtBQUU5RSxRQUFNLGlCQUFpQjtBQUFBO0FBQUEsTUFFbkIsUUFBUTtBQUFBO0FBQUEsTUFFUixhQUFhO0FBQUE7QUFBQSxNQUViLFFBQVEsTUFBTSxVQUFVO0FBQUE7QUFBQSxNQUV4QixJQUFJO0FBQUEsSUFDUjtBQUVBLElBQUFBLFFBQU8sVUFBVSxTQUFzQixPQUFxQixTQUFTO0FBQ2pFLFVBQUksV0FBVztBQUdmLFlBQU0sT0FBTyxPQUFPLE9BQU8sdUJBQU8sT0FBTyxJQUFJLEdBQUcsY0FBYztBQUc5RCxVQUFJLFNBQVMsYUFBYSxPQUFPLE9BQU87QUFFcEMsWUFBSSxFQUFFLGlCQUFpQixhQUFhO0FBQ2hDLGlCQUFPLE9BQU8sTUFBTSxLQUFLO0FBQ3pCLGtCQUFRLEtBQUssUUFBUSxLQUFLLFFBQVE7QUFDbEMsY0FBSSxLQUFLLE1BQU8sUUFBTyxLQUFLO0FBQUEsUUFDaEM7QUFHQSxZQUFJLE9BQU8sU0FBUyxLQUFLLEdBQUc7QUFDeEIscUJBQVc7QUFDWCxlQUFLLFNBQVMsTUFBTSxVQUFVO0FBQzlCLGtCQUFRO0FBQUEsUUFDWjtBQUFBLE1BQ0o7QUFHQSxhQUFPLE9BQU8sTUFBTSxPQUFPO0FBRzNCLFlBQU0sWUFBWSxJQUFJLE1BQU0sSUFBSTtBQUVoQyxVQUFJLE9BQU8sS0FBSyxZQUFZLFlBQVksT0FBTyxLQUFLLFFBQVEsV0FBVyxjQUFjLE9BQU8sS0FBSyxRQUFRLFdBQVcsWUFBWTtBQUM1SCxhQUFLLFVBQVUsTUFBTTtBQUFBLE1BQ3pCO0FBR0EsVUFBSSxTQUFTLGFBQWEsT0FBTyxPQUFPO0FBRXBDLFlBQUksVUFBVSxHQUFHLFdBQVcsS0FBSyxHQUFHO0FBQ2hDLGVBQUssU0FBUyxNQUFNLFVBQVU7QUFDOUIsZUFBSyxXQUFXO0FBQ2hCLHFCQUFXLFVBQVUsR0FBRyxhQUFhLEtBQUs7QUFBQSxRQUM5QyxPQUFPO0FBQ0gsZ0JBQU0sTUFBTSxPQUFPLGlCQUFpQjtBQUFBLFFBQ3hDO0FBQUEsTUFDSjtBQUdBLFlBQU0sT0FBTyxJQUFJLFFBQVEsVUFBVSxJQUFJO0FBRXZDLFlBQU0sRUFBRSxXQUFXLFVBQVUsV0FBVyxJQUFJO0FBRTVDLGVBQVMsU0FBcUIsT0FBTztBQUNqQyxZQUFJLFNBQVMsTUFBTTtBQUNmLGNBQUk7QUFFSixjQUFJLE9BQU8sVUFBVSxTQUFVLFFBQU8sS0FBSyxTQUFTLElBQUksTUFBTSxVQUFVLEtBQUssQ0FBQztBQUU5RSxjQUFJLE9BQU8sVUFBVSxZQUFZLE9BQU8sTUFBTSxjQUFjLGVBQWUsT0FBTyxNQUFNLFdBQVcsWUFBYSxRQUFPLEtBQUssU0FBUyxNQUFNLFNBQVM7QUFFcEosY0FBSSxNQUFNO0FBQ04sbUJBQU87QUFBQSxVQUNYO0FBQUEsUUFDSjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxRQUFRLFNBQVM7QUFDdEIsY0FBTSxFQUFFLE1BQU0sV0FBVyxJQUFJLElBQUksSUFBSTtBQUVyQyxlQUFPLEtBQUssS0FBSyxVQUFVLE1BQU0sUUFBUSxNQUFNLElBQUksRUFBRSxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUM7QUFBQSxNQUN6RTtBQUVBLGVBQVMsZUFBZSxVQUFVO0FBQzlCLFlBQUksb0JBQW9CLFFBQVE7QUFFNUIsaUJBQVEsMEJBQVUsSUFBSTtBQUNsQixtQkFBTyxTQUFVLFVBQVU7QUFDdkIscUJBQU8sR0FBRyxLQUFLLFFBQVE7QUFBQSxZQUMzQjtBQUFBLFVBQ0osR0FBRyxRQUFRO0FBQUEsUUFDZixXQUFXLGVBQWUsT0FBTyxVQUFVO0FBRXZDLGlCQUFPLE1BQU07QUFBQSxRQUNqQjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBR0EsWUFBTSxlQUFlLENBQUMsT0FBTyxVQUFVO0FBQ25DLFlBQUksV0FBVyxNQUFNLE1BQU0sRUFBRTtBQUM3QixtQkFBVyxhQUFhLFVBQVUsTUFBTSxVQUFVLE1BQU07QUFDeEQsZUFBTyxJQUFJLFNBQVMsT0FBTyxLQUFLLElBQUk7QUFBQSxNQUN4QztBQUVBLGFBQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQU9ILFVBQVUsU0FBVSxPQUFPLE1BQU07QUFDN0IsY0FBSSxPQUFPLFNBQVMsS0FBSztBQUN6QixpQkFBUSxRQUFRLEtBQUssUUFBUSxJQUFJLEtBQU07QUFBQSxRQUMzQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQU9BLFlBQVksU0FBVSxPQUFPO0FBQ3pCLGdCQUFNLE9BQU8sU0FBUyxLQUFLO0FBQzNCLGNBQUksTUFBTTtBQUNOLG1CQUFPLEtBQUssY0FBYyxJQUFJO0FBQUEsVUFDbEM7QUFBQSxRQUNKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQVNBLGVBQWUsU0FBVSxPQUFPLFVBQVU7QUFDdEMsY0FBSSxPQUFPLFNBQVMsS0FBSztBQUN6QixjQUFJLE1BQU07QUFDTixpQkFBSyxhQUFhLFFBQVE7QUFBQSxVQUM5QixPQUFPO0FBQ0gscUJBQVMsTUFBTSx5QkFBeUIsS0FBSztBQUFBLFVBQ2pEO0FBQUEsUUFDSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFTQSxZQUFZLFNBQVUsT0FBTyxVQUFVO0FBQ25DLGNBQUksT0FBTyxTQUFTLEtBQUs7QUFDekIsY0FBSSxNQUFNO0FBQ04sZ0JBQUksT0FBTyxLQUFLLFFBQVE7QUFDeEIsZ0JBQUksUUFBUSxLQUFLLFFBQVE7QUFDckIscUJBQU8sS0FBSyxTQUFTLFlBQVksTUFBTTtBQUFBLFlBQzNDO0FBQUEsVUFDSjtBQUNBLGlCQUFPO0FBQUEsUUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQVVBLGlCQUFpQixTQUFVLE9BQU8sVUFBVSxVQUFVO0FBQ2xELGNBQUksT0FBTyxTQUFTLEtBQUs7QUFDekIsY0FBSSxNQUFNO0FBQ04saUJBQUssYUFBYSxTQUFVLE1BQU0sS0FBSztBQUNuQyxrQkFBSSxLQUFLO0FBQ0wseUJBQVMsTUFBTSxHQUFHO0FBQ2xCO0FBQUEsY0FDSjtBQUVBLGtCQUFJLFFBQVEsS0FBSyxRQUFRO0FBQ3JCLHlCQUFTLEtBQUssU0FBUyxZQUFZLE1BQU0sQ0FBQztBQUFBLGNBQzlDLE9BQU87QUFDSCx5QkFBUyxFQUFFO0FBQUEsY0FDZjtBQUFBLFlBQ0osQ0FBQztBQUFBLFVBQ0wsT0FBTztBQUNILHFCQUFTLEVBQUU7QUFBQSxVQUNmO0FBQUEsUUFDSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBUUEsWUFBWSxTQUFVLE9BQU8saUJBQWlCLE1BQU07QUFFaEQsY0FBSSxPQUFPLFNBQVMsS0FBSztBQUN6QixjQUFJLE1BQU07QUFDTixpQkFBSyxXQUFXLEtBQUssV0FBVyxjQUFjO0FBQUEsVUFDbEQ7QUFBQSxRQUNKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFRQSxhQUFhLFNBQVUsT0FBTztBQUUxQixjQUFJLE9BQU8sU0FBUyxLQUFLO0FBQ3pCLGNBQUksTUFBTTtBQUNOLGlCQUFLLFlBQVksS0FBSyxTQUFTO0FBQUEsVUFDbkM7QUFBQSxRQUNKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBT0EsZUFBZSxTQUFVLFNBQVM7QUFFOUIsZUFBSyxVQUFVO0FBQUEsUUFDbkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFPQSxlQUFlLFdBQVk7QUFDdkIsaUJBQU8sS0FBSyxXQUFXO0FBQUEsUUFDM0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBU0Esb0JBQW9CLFNBQVUsT0FBTyxTQUFTO0FBQzFDLGNBQUksT0FBTyxTQUFTLEtBQUs7QUFDekIsY0FBSSxNQUFNO0FBQ04saUJBQUssVUFBVTtBQUFBLFVBQ25CO0FBQUEsUUFDSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBUUEsb0JBQW9CLFNBQVUsT0FBTztBQUNqQyxjQUFJLE9BQU8sU0FBUyxLQUFLO0FBQ3pCLGNBQUksTUFBTTtBQUNOLG1CQUFPLEtBQUssV0FBVztBQUFBLFVBQzNCO0FBQ0EsaUJBQU87QUFBQSxRQUNYO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFRQSxZQUFZLFNBQVUsT0FBTyxTQUFTO0FBQ2xDLGNBQUksT0FBTyxTQUFTLEtBQUs7QUFDekIsY0FBSSxNQUFNO0FBQ04saUJBQUssUUFBUSxPQUFPO0FBQUEsVUFDeEI7QUFBQSxRQUNKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBVUEsY0FBYyxTQUFVQyxZQUFXLFNBQVMsU0FBUyxTQUFTO0FBQzFELGNBQUksVUFBVSxHQUFHLFdBQVdBLFVBQVMsR0FBRztBQUVwQyxzQkFBVSxVQUFVLFFBQVEsT0FBTyxJQUFJO0FBR3ZDLGtCQUFNLElBQUksSUFBSSxNQUFNLFNBQVMsSUFBSSxNQUFNLFVBQVVBLFVBQVMsQ0FBQztBQUczRCx1QkFBVyxVQUFVLFVBQVU7QUFHL0Isa0JBQU0sUUFBUSxVQUFVLEdBQUcsU0FBU0EsVUFBUztBQUc3QyxrQkFBTSxPQUFPLE1BQU0sT0FBTyxJQUFJLFVBQVUsR0FBRyxhQUFhQSxVQUFTLElBQUksT0FBTyxNQUFNLENBQUM7QUFHbkYsZ0JBQUksTUFBTSxZQUFZLEVBQUcsWUFBVyxVQUFVO0FBRzlDLGlCQUFLLFFBQVEsU0FBUyxNQUFNLFNBQVMsS0FBSztBQUFBLFVBQzlDLE9BQU87QUFDSCxrQkFBTSxNQUFNLE9BQU8sZUFBZUEsVUFBUztBQUFBLFVBQy9DO0FBQUEsUUFDSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQW9CQSxtQkFBbUIsU0FBVUMsVUFBUyxVQUFVO0FBQzVDLFVBQUFBLFdBQVUsT0FBT0EsYUFBWSxXQUFXQSxXQUFVLEVBQUUsV0FBV0EsU0FBUTtBQUN2RSxnQkFBTUQsYUFBWSxJQUFJLFFBQVFDLFNBQVEsU0FBUztBQUMvQyxnQkFBTSxFQUFFLFFBQVEsSUFBSUE7QUFDcEIsY0FBSSxFQUFFLFNBQVMsUUFBUSxJQUFJQTtBQUMzQixnQkFBTUMsUUFBTztBQUViLG9CQUFVLEdBQUcsS0FBS0YsWUFBVyxTQUFVLEtBQUssT0FBTztBQUMvQyxnQkFBSSxJQUFLLFFBQU8sU0FBUyxLQUFLLEtBQUs7QUFFbkMsc0JBQVUsVUFBVSxRQUFRLE9BQU8sSUFBSTtBQUV2QyxrQkFBTSxJQUFJLElBQUksTUFBTSxTQUFTLElBQUksTUFBTSxVQUFVQSxVQUFTLENBQUM7QUFFM0QsdUJBQVcsVUFBVSxVQUFVO0FBRS9CLGdCQUFJLE1BQU0sT0FBTyxHQUFHO0FBQ2hCLHdCQUFVLEdBQUcsU0FBU0EsWUFBVyxTQUFVRyxNQUFLLE1BQU07QUFDbEQsb0JBQUlBLEtBQUssUUFBTyxTQUFTQSxNQUFLLEtBQUs7QUFDbkMsZ0JBQUFELE1BQUssUUFBUSxTQUFTLE1BQU0sU0FBUyxLQUFLO0FBQzFDLHVCQUFPLGFBQWEsVUFBVSxRQUFXLElBQUk7QUFBQSxjQUNqRCxDQUFDO0FBQUEsWUFDTCxXQUFXLE1BQU0sWUFBWSxHQUFHO0FBQzVCLHlCQUFXLFVBQVU7QUFDckIsY0FBQUEsTUFBSyxRQUFRLFNBQVMsT0FBTyxNQUFNLENBQUMsR0FBRyxTQUFTLEtBQUs7QUFDckQscUJBQU8sYUFBYSxVQUFVLFFBQVcsSUFBSTtBQUFBLFlBQ2pEO0FBQUEsVUFDSixDQUFDO0FBQUEsUUFDTDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFTQSxnQkFBZ0IsU0FBVUYsWUFBVyxTQUFTLFFBQVE7QUFFbEQsbUJBQVMsZUFBZSxNQUFNO0FBRzlCLG9CQUFVLFVBQVUsUUFBUSxPQUFPLElBQUk7QUFHdkMsVUFBQUEsYUFBWSxJQUFJLFVBQVVBLFVBQVM7QUFFbkMsY0FBSSxVQUFVLEdBQUcsV0FBV0EsVUFBUyxHQUFHO0FBQ3BDLGtCQUFNLFFBQVEsVUFBVSxVQUFVQSxVQUFTO0FBQzNDLGtCQUFNRSxRQUFPO0FBRWIsZ0JBQUksTUFBTSxRQUFRO0FBQ2QseUJBQVcsWUFBWSxPQUFPO0FBQzFCLHNCQUFNLElBQUksSUFBSSxLQUFLLFNBQVMsYUFBYUYsWUFBVyxRQUFRLENBQUM7QUFDN0Qsb0JBQUksT0FBTyxDQUFDLEdBQUc7QUFDWCxrQkFBQUUsTUFBSyxhQUFhLFVBQVUsSUFBSSxRQUFRLENBQUMsQ0FBQztBQUFBLGdCQUM5QztBQUFBLGNBQ0o7QUFBQSxZQUNKO0FBQUEsVUFDSixPQUFPO0FBQ0gsa0JBQU0sTUFBTSxPQUFPLGVBQWVGLFVBQVM7QUFBQSxVQUMvQztBQUFBLFFBQ0o7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFVQSxxQkFBcUIsU0FBVUEsWUFBVyxVQUFVLFNBQVMsUUFBUTtBQUVqRSxtQkFBUyxlQUFlLE1BQU07QUFHOUIsb0JBQVUsVUFBVSxRQUFRLE9BQU8sSUFBSTtBQUd2QyxVQUFBQSxhQUFZLElBQUksVUFBVUEsVUFBUztBQUVuQyxjQUFJRSxRQUFPO0FBQ1gsb0JBQVUsR0FBRyxLQUFLRixZQUFXLEtBQUssU0FBVSxLQUFLO0FBQzdDLGdCQUFJLE9BQU8sSUFBSSxTQUFTLFVBQVU7QUFDOUIsdUJBQVMsUUFBVyxNQUFNLE9BQU8sZUFBZUEsVUFBUyxDQUFDO0FBQUEsWUFDOUQsV0FBVyxLQUFLO0FBQ1osdUJBQVMsUUFBVyxHQUFHO0FBQUEsWUFDM0IsT0FBTztBQUNILGtCQUFJLFFBQVEsVUFBVSxVQUFVQSxVQUFTO0FBQ3pDLGtCQUFJSSxLQUFJO0FBRVIsa0JBQUksT0FBTyxXQUFZO0FBQ25CLGdCQUFBQSxNQUFLO0FBQ0wsb0JBQUlBLEtBQUksTUFBTSxRQUFRO0FBQ2xCLHNCQUFJLFdBQVcsTUFBTUEsRUFBQztBQUN0QixzQkFBSSxJQUFJLGFBQWFKLFlBQVcsUUFBUSxFQUFFLE1BQU0sSUFBSSxFQUFFLEtBQUssR0FBRztBQUM5RCxzQkFBSSxFQUNDLFVBQVUsS0FBSyxFQUNmLFFBQVEsb0JBQW9CLEVBQUUsRUFDOUIsUUFBUSxpQkFBaUIsRUFBRTtBQUNoQyxzQkFBSSxPQUFPLENBQUMsR0FBRztBQUNYLDhCQUFVLEdBQUcsS0FBSyxVQUFVLFNBQVUsS0FBSyxPQUFPO0FBQzlDLDBCQUFJLElBQUssVUFBUyxRQUFXLEdBQUc7QUFDaEMsMEJBQUksTUFBTSxPQUFPLEdBQUc7QUFDaEIsa0NBQVUsR0FBRyxTQUFTLFVBQVUsU0FBVSxLQUFLLE1BQU07QUFDakQsOEJBQUksS0FBSztBQUNMLHFDQUFTLFFBQVcsR0FBRztBQUFBLDBCQUMzQixPQUFPO0FBQ0gsNEJBQUFFLE1BQUssUUFBUSxVQUFVLEdBQUcsTUFBTSxJQUFJLEtBQUs7QUFDekMsaUNBQUs7QUFBQSwwQkFDVDtBQUFBLHdCQUNKLENBQUM7QUFBQSxzQkFDTCxPQUFPO0FBQ0gsd0JBQUFBLE1BQUssUUFBUSxVQUFVLElBQUksS0FBSyxPQUFPLE1BQU0sQ0FBQyxHQUFHLElBQUksS0FBSztBQUMxRCw2QkFBSztBQUFBLHNCQUNUO0FBQUEsb0JBQ0osQ0FBQztBQUFBLGtCQUNMLE9BQU87QUFDSCw0QkFBUSxTQUFTLE1BQU07QUFDbkIsMkJBQUs7QUFBQSxvQkFDVCxDQUFDO0FBQUEsa0JBQ0w7QUFBQSxnQkFDSixPQUFPO0FBQ0gsMkJBQVMsTUFBTSxNQUFTO0FBQUEsZ0JBQzVCO0FBQUEsY0FDSjtBQUVBLG1CQUFLO0FBQUEsWUFDVDtBQUFBLFVBQ0osQ0FBQztBQUFBLFFBQ0w7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFhQSxzQkFBc0IsU0FBVUQsVUFBUyxVQUFVO0FBQy9DLGdCQUFNQyxRQUFPO0FBQ2IsVUFBQUQsV0FBVSxPQUFPQSxhQUFZLFdBQVdBLFdBQVUsRUFBRSxXQUFXQSxTQUFRO0FBQ3ZFLHNCQUFZLElBQUksUUFBUSxRQUFRQSxTQUFRLFNBQVMsQ0FBQztBQUNsRCxjQUFJLEVBQUUsU0FBUyxRQUFRLFFBQVEsSUFBSUE7QUFFbkMsY0FBSSxrQkFBa0IsUUFBUTtBQUMxQixxQkFBVSwwQkFBVSxJQUFJO0FBQ3BCLHFCQUFPLFNBQVUsVUFBVTtBQUN2Qix1QkFBTyxHQUFHLEtBQUssUUFBUTtBQUFBLGNBQzNCO0FBQUEsWUFDSixHQUFHLE1BQU07QUFBQSxVQUNiLFdBQVcsZUFBZSxPQUFPLFFBQVE7QUFDckMscUJBQVMsV0FBWTtBQUNqQixxQkFBTztBQUFBLFlBQ1g7QUFBQSxVQUNKO0FBR0Esb0JBQVUsVUFBVSxRQUFRLE9BQU8sSUFBSTtBQUd2QyxjQUFJLFdBQVcsVUFBVTtBQUNyQixzQkFBVSxDQUFDLFFBQ1AsSUFDSyxVQUFVLEtBQUssRUFDZixRQUFRLG9CQUFvQixFQUFFLEVBQzlCLFFBQVEsaUJBQWlCLEVBQUU7QUFBQSxVQUN4QztBQUVBLGNBQUksT0FBTyxZQUFZLFdBQVksV0FBVSxDQUFDLFFBQVE7QUFHdEQsZ0JBQU0sYUFBYSxDQUFDLFVBQVUsSUFBSSxLQUFLLFNBQVMsUUFBUSxhQUFhLFdBQVcsS0FBSyxDQUFDLENBQUM7QUFDdkYsZ0JBQU0sY0FBYyxDQUFDLFVBQVUsSUFBSSxNQUFNLFNBQVMsSUFBSSxNQUFNLFVBQVUsUUFBUSxLQUFLLENBQUMsQ0FBQztBQUVyRixvQkFBVSxHQUFHLEtBQUssV0FBVyxLQUFLLFNBQVUsS0FBSztBQUM3QyxnQkFBSSxPQUFPLElBQUksU0FBUyxVQUFVO0FBQzlCLHVCQUFTLFFBQVcsTUFBTSxPQUFPLGVBQWUsU0FBUyxDQUFDO0FBQUEsWUFDOUQsV0FBVyxLQUFLO0FBQ1osdUJBQVMsUUFBVyxHQUFHO0FBQUEsWUFDM0IsT0FBTztBQUNILHdCQUFVLGVBQWUsV0FBVyxTQUFVRSxNQUFLLGFBQWE7QUFDNUQsb0JBQUlBLEtBQUssUUFBTyxTQUFTQSxJQUFHO0FBQzVCLDhCQUFjLFlBQVksT0FBTyxDQUFDLFFBQVEsT0FBTyxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBQ2pFLG9CQUFJLENBQUMsWUFBWSxPQUFRLFVBQVMsUUFBVyxLQUFLO0FBRWxEO0FBQUEsa0JBQ0ksWUFBWSxRQUFRLEVBQUUsT0FBTyxTQUFVLE1BQU0sT0FBTztBQUNoRCwyQkFBTyxTQUFVQSxNQUFLLE1BQU07QUFDeEIsMEJBQUlBLFFBQU8sU0FBUyxNQUFPLFFBQU8sYUFBYSxNQUFNQSxNQUFLLEtBQUs7QUFFL0Qsc0JBQUFELE1BQUs7QUFBQSx3QkFDRDtBQUFBLDBCQUNJLFdBQVc7QUFBQSwwQkFDWCxTQUFTLElBQUksUUFBUSxXQUFXLEtBQUssQ0FBQztBQUFBLDBCQUN0QyxTQUFTLFlBQVksS0FBSztBQUFBLHdCQUM5QjtBQUFBLHdCQUNBO0FBQUEsc0JBQ0o7QUFBQSxvQkFDSjtBQUFBLGtCQUNKLEdBQUcsUUFBUTtBQUFBLGdCQUNmO0FBQUEsY0FDSixDQUFDO0FBQUEsWUFDTDtBQUFBLFVBQ0osQ0FBQztBQUFBLFFBQ0w7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQVdBLHVCQUF1QixTQUFVRixZQUFXLE9BQU87QUFDL0MsaUJBQU8sSUFBSSxRQUFRLENBQUMsU0FBUyxXQUFXO0FBQ3BDLGlCQUFLLHFCQUFxQixPQUFPLE9BQU8sRUFBRSxXQUFBQSxXQUFVLEdBQUcsS0FBSyxHQUFHLENBQUMsS0FBSyxTQUFTO0FBQzFFLGtCQUFJLElBQUssUUFBTyxHQUFHO0FBQ25CLGtCQUFJLEtBQU0sU0FBUSxJQUFJO0FBQUEsWUFDMUIsQ0FBQztBQUFBLFVBQ0wsQ0FBQztBQUFBLFFBQ0w7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBWUEsU0FBUyxTQUFVLFdBQVcsU0FBUyxTQUFTLE1BQU07QUFDbEQsc0JBQVksV0FBVyxTQUFTO0FBQ2hDLGNBQUksUUFBUSxTQUFTLFNBQVM7QUFDOUIsZ0JBQU0sU0FBUyxTQUFTO0FBR3hCLGNBQUksQ0FBQyxRQUFRO0FBQ1Qsb0JBQVEsSUFBSSxTQUFTLElBQUk7QUFDekIsa0JBQU0sWUFBWTtBQUFBLFVBQ3RCO0FBQ0EsZ0JBQU0sVUFBVSxXQUFXO0FBRTNCLGdCQUFNLFNBQVMsYUFBYSxPQUFPLFFBQVEsZ0JBQWdCLFVBQVUsR0FBRztBQUd4RSxjQUFJLFFBQVE7QUFDUixrQkFBTSxPQUFPLE9BQU8sS0FBSztBQUFBLFVBQzdCO0FBR0EsY0FBSSxXQUFXLE1BQU0sY0FBYyxLQUFPO0FBSTFDLGNBQUksT0FBTyxNQUFNLGNBQWMsUUFBUztBQUV4QyxjQUFJLFFBQVE7QUFFUixvQkFBUSxPQUFRLEtBQUs7QUFBQSxVQUN6QixXQUFXLGFBQWEsT0FBTyxNQUFNO0FBRWpDLG9CQUFRLE9BQVE7QUFBQSxVQUNwQixPQUFPO0FBRUgsb0JBQVEsTUFBTSxjQUFjLE1BQVE7QUFBQSxVQUN4QztBQUVBLHNCQUFZLFdBQVksUUFBUSxRQUFTO0FBRXpDLGdCQUFNLE9BQU87QUFFYixnQkFBTSxRQUFRLE9BQU87QUFDckIsY0FBSSxDQUFDLE9BQVEsTUFBSyxTQUFTLEtBQUs7QUFFaEMsaUJBQU87QUFBQSxRQUNYO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFRQSxZQUFZLFNBQVUsVUFBVTtBQUM1QixlQUFLLFdBQVc7QUFDaEIsaUJBQU8sT0FBTyxLQUFLLFVBQVUsQ0FBQztBQUFBLFFBQ2xDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFRQSxVQUFVLFNBQXNCLE1BQU07QUFDbEMsaUJBQU8sU0FBUyxJQUFJO0FBQUEsUUFDeEI7QUFBQSxRQUVBLGVBQWUsV0FBWTtBQUN2QixpQkFBTyxLQUFLLGNBQWM7QUFBQSxRQUM5QjtBQUFBLFFBRUEsU0FBUyxTQUFVLFVBQVU7QUFDekIsaUJBQU8sS0FBSyxRQUFRLFFBQVE7QUFBQSxRQUNoQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFlQSxnQkFBZ0IsU0FBVSxPQUFPLFlBQVksbUJBQW1CLFdBQVcsd0JBQXdCLGFBQWE7QUFDNUcsc0JBQVksU0FBUyxPQUFPLFNBQVM7QUFDckMsbUNBQXlCLFNBQVMsT0FBTyxzQkFBc0I7QUFDL0QsOEJBQW9CLFNBQVMsTUFBTSxpQkFBaUI7QUFDcEQsd0JBQWMsUUFBUSx3QkFBd0IsV0FBVztBQUV6RCxjQUFJLE9BQU8sU0FBUyxLQUFLO0FBQ3pCLGNBQUksQ0FBQyxNQUFNO0FBQ1Asa0JBQU0sTUFBTSxPQUFPLFNBQVM7QUFBQSxVQUNoQztBQUVBLGNBQUksWUFBWSxVQUFVLEtBQUssU0FBUztBQUV4QyxjQUFJLFNBQVMsU0FBUyxZQUFZLGVBQWUsQ0FBQyxLQUFLLGNBQWMsY0FBYyxvQkFBb0IsWUFBWSxJQUFJLFNBQVMsU0FBUyxDQUFDO0FBRTFJLGNBQUksS0FBSyxhQUFhO0FBQ2xCLGdCQUFJLFdBQVcsS0FBSyxpQkFBaUIsSUFBSTtBQUN6QyxxQkFBUyxRQUFRLFNBQVUsT0FBTztBQUM5QixrQkFBSSxNQUFNLFlBQWE7QUFDdkIsa0JBQUlLLFdBQVUsTUFBTSxRQUFRO0FBQzVCLGtCQUFJLENBQUNBLFVBQVM7QUFDVixzQkFBTSxNQUFNLE9BQU8sa0JBQWtCO0FBQUEsY0FDekM7QUFDQSxrQkFBSSxPQUFPLFVBQVUsTUFBTSxTQUFTO0FBQ3BDLGtCQUFJLFlBQVksU0FBUyxZQUFZLG9CQUFvQixPQUFPLElBQUksU0FBUyxJQUFJLENBQUM7QUFFbEYsb0JBQU1DLFlBQVcseUJBQXlCLE1BQU0sT0FBTyxXQUFXO0FBQ2xFLHdCQUFVLFlBQVksV0FBV0QsVUFBUyxXQUFXQyxTQUFRO0FBQUEsWUFDakUsQ0FBQztBQUNELG1CQUFPO0FBQUEsVUFDWDtBQUVBLGNBQUksVUFBVSxLQUFLLFFBQVEsS0FBSyxRQUFRO0FBQ3hDLGNBQUksQ0FBQyxRQUFTLE9BQU0sTUFBTSxPQUFPLGtCQUFrQjtBQUVuRCxjQUFJLFVBQVUsR0FBRyxXQUFXLE1BQU0sS0FBSyxDQUFDLFdBQVc7QUFDL0Msa0JBQU0sTUFBTSxPQUFPLGNBQWM7QUFBQSxVQUNyQztBQUVBLGdCQUFNLFdBQVcseUJBQXlCLE1BQU0sT0FBTyxXQUFXO0FBQ2xFLG9CQUFVLFlBQVksUUFBUSxTQUFTLFdBQVcsUUFBUTtBQUUxRCxpQkFBTztBQUFBLFFBQ1g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBTUEsTUFBTSxTQUFVLE1BQU07QUFDbEIsY0FBSSxDQUFDLE1BQU07QUFDUCxtQkFBTztBQUFBLFVBQ1g7QUFFQSxtQkFBUyxTQUFTLEtBQUssU0FBUztBQUM1QixnQkFBSTtBQUNBLGtCQUFJLE1BQU0sYUFBYTtBQUNuQjtBQUFBLGNBQ0o7QUFDQSxrQkFBSSxVQUFVLEtBQUssUUFBUSxLQUFLLEVBQUUsUUFBUSxJQUFJO0FBQzlDLGtCQUFJLENBQUMsU0FBUztBQUNWLHVCQUFPO0FBQUEsY0FDWDtBQUFBLFlBQ0osU0FBUyxLQUFLO0FBQ1YscUJBQU87QUFBQSxZQUNYO0FBQUEsVUFDSjtBQUNBLGlCQUFPO0FBQUEsUUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFZQSxjQUFjLFNBQVUsWUFBWSxXQUFXLHdCQUF3QixNQUFNO0FBQ3pFLG1DQUF5QixTQUFTLE9BQU8sc0JBQXNCO0FBQy9ELGlCQUFPLFFBQVEsd0JBQXdCLElBQUk7QUFDM0Msc0JBQVksU0FBUyxPQUFPLFNBQVM7QUFDckMsY0FBSSxDQUFDLEtBQU0sT0FBTSxNQUFNLE9BQU8sT0FBTztBQUVyQyxlQUFLLFFBQVEsUUFBUSxTQUFVLE9BQU87QUFDbEMsZ0JBQUksWUFBWSxTQUFTLFlBQVksVUFBVSxNQUFNLFNBQVMsQ0FBQztBQUMvRCxnQkFBSSxNQUFNLGFBQWE7QUFDbkIsd0JBQVUsUUFBUSxTQUFTO0FBQzNCO0FBQUEsWUFDSjtBQUNBLGdCQUFJLFVBQVUsTUFBTSxRQUFRLElBQUk7QUFDaEMsZ0JBQUksQ0FBQyxTQUFTO0FBQ1Ysb0JBQU0sTUFBTSxPQUFPLGtCQUFrQjtBQUFBLFlBQ3pDO0FBRUEsa0JBQU0sV0FBVyx5QkFBeUIsTUFBTSxPQUFPLFdBQVc7QUFDbEUsc0JBQVUsWUFBWSxXQUFXLFNBQVMsV0FBVyxRQUFRO0FBQzdELGdCQUFJO0FBQ0Esd0JBQVUsR0FBRyxXQUFXLFdBQVcsTUFBTSxPQUFPLE1BQU0sTUFBTSxPQUFPLElBQUk7QUFBQSxZQUMzRSxTQUFTLEtBQUs7QUFDVixvQkFBTSxNQUFNLE9BQU8sa0JBQWtCO0FBQUEsWUFDekM7QUFBQSxVQUNKLENBQUM7QUFBQSxRQUNMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQVlBLG1CQUFtQixTQUFVLFlBQVksV0FBVyx3QkFBd0IsVUFBVTtBQUNsRixxQkFBVyxRQUFRLFdBQVcsd0JBQXdCLFFBQVE7QUFDOUQsbUNBQXlCLFNBQVMsT0FBTyxzQkFBc0I7QUFDL0Qsc0JBQVksU0FBUyxPQUFPLFNBQVM7QUFDckMsY0FBSSxDQUFDLFVBQVU7QUFDWCxtQkFBTyxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFDcEMsbUJBQUssa0JBQWtCLFlBQVksV0FBVyx3QkFBd0IsU0FBVSxLQUFLO0FBQ2pGLG9CQUFJLEtBQUs7QUFDTCx5QkFBTyxHQUFHO0FBQUEsZ0JBQ2QsT0FBTztBQUNILDBCQUFRLElBQUk7QUFBQSxnQkFDaEI7QUFBQSxjQUNKLENBQUM7QUFBQSxZQUNMLENBQUM7QUFBQSxVQUNMO0FBQ0EsY0FBSSxDQUFDLE1BQU07QUFDUCxxQkFBUyxNQUFNLE9BQU8sT0FBTyxDQUFDO0FBQzlCO0FBQUEsVUFDSjtBQUVBLHVCQUFhLElBQUksUUFBUSxVQUFVO0FBRW5DLGdCQUFNLFVBQVUsQ0FBQyxVQUFVLFNBQVMsWUFBWSxJQUFJLFVBQVUsVUFBVSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQ3pGLGdCQUFNLFdBQVcsQ0FBQyxLQUFLLFNBQVMsSUFBSSxNQUFNLE1BQU0sUUFBUSxPQUFPLEdBQUc7QUFHbEUsZ0JBQU0sYUFBYSxDQUFDO0FBQ3BCLGdCQUFNLGNBQWMsQ0FBQztBQUNyQixlQUFLLFFBQVEsUUFBUSxDQUFDQyxPQUFNO0FBQ3hCLGdCQUFJQSxHQUFFLGFBQWE7QUFDZix5QkFBVyxLQUFLQSxFQUFDO0FBQUEsWUFDckIsT0FBTztBQUNILDBCQUFZLEtBQUtBLEVBQUM7QUFBQSxZQUN0QjtBQUFBLFVBQ0osQ0FBQztBQUlELHFCQUFXLFNBQVMsWUFBWTtBQUM1QixrQkFBTSxVQUFVLFFBQVEsS0FBSztBQUU3QixrQkFBTSxVQUFVLHlCQUF5QixNQUFNLE9BQU8sV0FBVztBQUNqRSxnQkFBSTtBQUNBLHdCQUFVLFFBQVEsT0FBTztBQUN6QixrQkFBSSxRQUFTLFdBQVUsR0FBRyxVQUFVLFNBQVMsT0FBTztBQUVwRCx3QkFBVSxHQUFHLFdBQVcsU0FBUyxNQUFNLE9BQU8sTUFBTSxNQUFNLE9BQU8sSUFBSTtBQUFBLFlBQ3pFLFNBQVMsSUFBSTtBQUNULHVCQUFTLFNBQVMsMkJBQTJCLE9BQU8sQ0FBQztBQUFBLFlBQ3pEO0FBQUEsVUFDSjtBQUVBLHNCQUFZLFFBQVEsRUFBRSxPQUFPLFNBQVUsTUFBTSxPQUFPO0FBQ2hELG1CQUFPLFNBQVUsS0FBSztBQUNsQixrQkFBSSxLQUFLO0FBQ0wscUJBQUssR0FBRztBQUFBLGNBQ1osT0FBTztBQUNILHNCQUFNLFlBQVksSUFBSSxVQUFVLFVBQVUsTUFBTSxTQUFTLENBQUM7QUFDMUQsc0JBQU0sV0FBVyxTQUFTLFlBQVksU0FBUztBQUMvQyxzQkFBTSxhQUFhLFNBQVUsU0FBUyxPQUFPO0FBQ3pDLHNCQUFJLE9BQU87QUFDUCx5QkFBSyxLQUFLO0FBQUEsa0JBQ2QsV0FBVyxDQUFDLFNBQVM7QUFDakIseUJBQUssTUFBTSxPQUFPLGtCQUFrQixDQUFDO0FBQUEsa0JBQ3pDLE9BQU87QUFFSCwwQkFBTSxXQUFXLHlCQUF5QixNQUFNLE9BQU8sV0FBVztBQUNsRSw4QkFBVSxpQkFBaUIsVUFBVSxTQUFTLFdBQVcsVUFBVSxTQUFVLE1BQU07QUFDL0UsMEJBQUksQ0FBQyxNQUFNO0FBQ1AsNkJBQUssU0FBUyx3QkFBd0IsUUFBUSxDQUFDO0FBQUEsc0JBQ25EO0FBQ0EsZ0NBQVUsR0FBRyxPQUFPLFVBQVUsTUFBTSxPQUFPLE1BQU0sTUFBTSxPQUFPLE1BQU0sU0FBVSxPQUFPO0FBQ2pGLDRCQUFJLE9BQU87QUFDUCwrQkFBSyxTQUFTLHVCQUF1QixRQUFRLENBQUM7QUFBQSx3QkFDbEQsT0FBTztBQUNILCtCQUFLO0FBQUEsd0JBQ1Q7QUFBQSxzQkFDSixDQUFDO0FBQUEsb0JBQ0wsQ0FBQztBQUFBLGtCQUNMO0FBQUEsZ0JBQ0osQ0FBQztBQUFBLGNBQ0w7QUFBQSxZQUNKO0FBQUEsVUFDSixHQUFHLFFBQVEsRUFBRTtBQUFBLFFBQ2pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFRQSxVQUFVLFNBQVUsZ0JBQWdCLFVBQVU7QUFDMUMsY0FBSSxVQUFVLFdBQVcsR0FBRztBQUN4QixnQkFBSSxPQUFPLG1CQUFtQixZQUFZO0FBQ3RDLHlCQUFXO0FBQ1gsK0JBQWlCO0FBQUEsWUFDckI7QUFBQSxVQUNKO0FBRUEsY0FBSSxDQUFDLGtCQUFrQixLQUFLLFVBQVU7QUFDbEMsNkJBQWlCLEtBQUs7QUFBQSxVQUMxQjtBQUNBLGNBQUksQ0FBQyxlQUFnQjtBQUVyQixjQUFJLFVBQVUsS0FBSyxpQkFBaUI7QUFDcEMsY0FBSSxTQUFTO0FBQ1QsZ0JBQUksS0FBSyxVQUFVLFlBQVksZ0JBQWdCLFNBQVMsSUFBSTtBQUM1RCxnQkFBSSxPQUFPLGFBQWEsV0FBWSxVQUFTLENBQUMsS0FBSyxJQUFJLE1BQU0sUUFBUSxJQUFJLE1BQU0sRUFBRTtBQUFBLFVBQ3JGO0FBQUEsUUFDSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBV0EsaUJBQWlCLFNBQXNCLGdCQUE2QixPQUFPO0FBQ3ZFLGdCQUFNLEVBQUUsV0FBVyxLQUFLLElBQUksT0FBTyxPQUFPLEVBQUUsV0FBVyxLQUFLLEdBQUcsS0FBSztBQUVwRSxpQkFBTyxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFFcEMsZ0JBQUksQ0FBQyxrQkFBa0IsS0FBSyxTQUFVLGtCQUFpQixLQUFLO0FBQzVELGdCQUFJLENBQUMsZUFBZ0IsUUFBTyxnQ0FBZ0M7QUFFNUQsaUJBQUssZ0JBQWdCLEVBQUUsS0FBSyxDQUFDLFlBQVk7QUFDckMsb0JBQU0sTUFBTSxDQUFDLFNBQVUsT0FBTyxRQUFRLElBQUksSUFBSSxPQUFPLHdDQUF3QztBQUM3Rix3QkFBVSxpQkFBaUIsZ0JBQWdCLFNBQVMsV0FBVyxNQUFNLEdBQUc7QUFBQSxZQUM1RSxHQUFHLE1BQU07QUFBQSxVQUNiLENBQUM7QUFBQSxRQUNMO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLQSxpQkFBaUIsV0FBWTtBQUN6QixpQkFBTyxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFDcEMsaUJBQUssY0FBYyxTQUFTLE1BQU07QUFBQSxVQUN0QyxDQUFDO0FBQUEsUUFDTDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBV0EsVUFBVSxTQUFVLFdBQVcsUUFBUSxhQUFhLFdBQVc7QUFDM0QsY0FBSSxPQUFPLGNBQWMsWUFBWTtBQUNqQyxpQkFBSyxjQUFjLFdBQVcsUUFBUSxhQUFhLFNBQVM7QUFDNUQsbUJBQU87QUFBQSxVQUNYO0FBQ0EsaUJBQU8sS0FBSyxpQkFBaUI7QUFBQSxRQUNqQztBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQUE7QUFBQTs7O0FDcDdCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUEsbUJBQW9DO0FBQ3BDLElBQUFDLGNBU087OztBQ1ZQLHNCQUFlO0FBQ2Ysa0JBQWlCO0FBQ2pCLGdCQUFlOzs7QUNFZixJQUFBQyxvQkFBaUI7QUFDakIsd0JBQWtCO0FBQ2xCLHVCQUFpQjtBQUNqQixJQUFBQyxzQkFBb0Q7QUFDcEQsSUFBQUMsc0JBQXFCOzs7QUNDZixTQUFVLGdCQUFnQixLQUFXO0FBQzFDLE1BQUksQ0FBQyxVQUFVLEtBQUssR0FBRyxHQUFHO0FBQ3pCLFVBQU0sSUFBSSxVQUNULGtFQUFrRTs7QUFLcEUsUUFBTSxJQUFJLFFBQVEsVUFBVSxFQUFFO0FBRzlCLFFBQU0sYUFBYSxJQUFJLFFBQVEsR0FBRztBQUNsQyxNQUFJLGVBQWUsTUFBTSxjQUFjLEdBQUc7QUFDekMsVUFBTSxJQUFJLFVBQVUscUJBQXFCOztBQUkxQyxRQUFNLE9BQU8sSUFBSSxVQUFVLEdBQUcsVUFBVSxFQUFFLE1BQU0sR0FBRztBQUVuRCxNQUFJLFVBQVU7QUFDZCxNQUFJLFNBQVM7QUFDYixRQUFNLE9BQU8sS0FBSyxDQUFDLEtBQUs7QUFDeEIsTUFBSSxXQUFXO0FBQ2YsV0FBU0MsS0FBSSxHQUFHQSxLQUFJLEtBQUssUUFBUUEsTUFBSztBQUNyQyxRQUFJLEtBQUtBLEVBQUMsTUFBTSxVQUFVO0FBQ3pCLGVBQVM7ZUFDQSxLQUFLQSxFQUFDLEdBQUc7QUFDbEIsa0JBQVksSUFBTSxLQUFLQSxFQUFDLENBQUM7QUFDekIsVUFBSSxLQUFLQSxFQUFDLEVBQUUsUUFBUSxVQUFVLE1BQU0sR0FBRztBQUN0QyxrQkFBVSxLQUFLQSxFQUFDLEVBQUUsVUFBVSxDQUFDOzs7O0FBS2hDLE1BQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsUUFBUTtBQUNoQyxnQkFBWTtBQUNaLGNBQVU7O0FBSVgsUUFBTSxXQUFXLFNBQVMsV0FBVztBQUNyQyxRQUFNLE9BQU8sU0FBUyxJQUFJLFVBQVUsYUFBYSxDQUFDLENBQUM7QUFDbkQsUUFBTSxTQUFTLE9BQU8sS0FBSyxNQUFNLFFBQVE7QUFHekMsU0FBTyxPQUFPO0FBQ2QsU0FBTyxXQUFXO0FBR2xCLFNBQU8sVUFBVTtBQUVqQixTQUFPO0FBQ1I7QUFFQSxJQUFBLGVBQWU7OztBQzVEZix5QkFBa0M7QUFDbEMsdUJBQTBDO0FBQzFDLHlCQUFxQjtBQUVyQjtBQUNBOzs7QUNaTyxJQUFNLGlCQUFOLGNBQTZCLE1BQU07QUFBQSxFQUN6QyxZQUFZLFNBQVMsTUFBTTtBQUMxQixVQUFNLE9BQU87QUFFYixVQUFNLGtCQUFrQixNQUFNLEtBQUssV0FBVztBQUU5QyxTQUFLLE9BQU87QUFBQSxFQUNiO0FBQUEsRUFFQSxJQUFJLE9BQU87QUFDVixXQUFPLEtBQUssWUFBWTtBQUFBLEVBQ3pCO0FBQUEsRUFFQSxLQUFLLE9BQU8sV0FBVyxJQUFJO0FBQzFCLFdBQU8sS0FBSyxZQUFZO0FBQUEsRUFDekI7QUFDRDs7O0FDTk8sSUFBTSxhQUFOLGNBQXlCLGVBQWU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNOUMsWUFBWSxTQUFTLE1BQU0sYUFBYTtBQUN2QyxVQUFNLFNBQVMsSUFBSTtBQUVuQixRQUFJLGFBQWE7QUFFaEIsV0FBSyxPQUFPLEtBQUssUUFBUSxZQUFZO0FBQ3JDLFdBQUssaUJBQWlCLFlBQVk7QUFBQSxJQUNuQztBQUFBLEVBQ0Q7QUFDRDs7O0FDbkJBLElBQU0sT0FBTyxPQUFPO0FBUWIsSUFBTSx3QkFBd0IsWUFBVTtBQUM5QyxTQUNDLE9BQU8sV0FBVyxZQUNsQixPQUFPLE9BQU8sV0FBVyxjQUN6QixPQUFPLE9BQU8sV0FBVyxjQUN6QixPQUFPLE9BQU8sUUFBUSxjQUN0QixPQUFPLE9BQU8sV0FBVyxjQUN6QixPQUFPLE9BQU8sUUFBUSxjQUN0QixPQUFPLE9BQU8sUUFBUSxjQUN0QixPQUFPLE9BQU8sU0FBUyxjQUN2QixPQUFPLElBQUksTUFBTTtBQUVuQjtBQU9PLElBQU0sU0FBUyxZQUFVO0FBQy9CLFNBQ0MsVUFDQSxPQUFPLFdBQVcsWUFDbEIsT0FBTyxPQUFPLGdCQUFnQixjQUM5QixPQUFPLE9BQU8sU0FBUyxZQUN2QixPQUFPLE9BQU8sV0FBVyxjQUN6QixPQUFPLE9BQU8sZ0JBQWdCLGNBQzlCLGdCQUFnQixLQUFLLE9BQU8sSUFBSSxDQUFDO0FBRW5DO0FBT08sSUFBTSxnQkFBZ0IsWUFBVTtBQUN0QyxTQUNDLE9BQU8sV0FBVyxhQUNqQixPQUFPLElBQUksTUFBTSxpQkFDakIsT0FBTyxJQUFJLE1BQU07QUFHcEI7QUFVTyxJQUFNLHNCQUFzQixDQUFDLGFBQWEsYUFBYTtBQUM3RCxRQUFNLE9BQU8sSUFBSSxJQUFJLFFBQVEsRUFBRTtBQUMvQixRQUFNLE9BQU8sSUFBSSxJQUFJLFdBQVcsRUFBRTtBQUVsQyxTQUFPLFNBQVMsUUFBUSxLQUFLLFNBQVMsSUFBSSxJQUFJLEVBQUU7QUFDakQ7QUFTTyxJQUFNLGlCQUFpQixDQUFDLGFBQWEsYUFBYTtBQUN4RCxRQUFNLE9BQU8sSUFBSSxJQUFJLFFBQVEsRUFBRTtBQUMvQixRQUFNLE9BQU8sSUFBSSxJQUFJLFdBQVcsRUFBRTtBQUVsQyxTQUFPLFNBQVM7QUFDakI7OztBSHBFQSxJQUFNLGVBQVcsNEJBQVUsbUJBQUFDLFFBQU8sUUFBUTtBQUMxQyxJQUFNLFlBQVksT0FBTyxnQkFBZ0I7QUFXekMsSUFBcUIsT0FBckIsTUFBMEI7QUFBQSxFQUN6QixZQUFZLE1BQU07QUFBQSxJQUNqQixPQUFPO0FBQUEsRUFDUixJQUFJLENBQUMsR0FBRztBQUNQLFFBQUksV0FBVztBQUVmLFFBQUksU0FBUyxNQUFNO0FBRWxCLGFBQU87QUFBQSxJQUNSLFdBQVcsc0JBQXNCLElBQUksR0FBRztBQUV2QyxhQUFPLDBCQUFPLEtBQUssS0FBSyxTQUFTLENBQUM7QUFBQSxJQUNuQyxXQUFXLE9BQU8sSUFBSSxHQUFHO0FBQUEsSUFFekIsV0FBVywwQkFBTyxTQUFTLElBQUksR0FBRztBQUFBLElBRWxDLFdBQVcsdUJBQU0saUJBQWlCLElBQUksR0FBRztBQUV4QyxhQUFPLDBCQUFPLEtBQUssSUFBSTtBQUFBLElBQ3hCLFdBQVcsWUFBWSxPQUFPLElBQUksR0FBRztBQUVwQyxhQUFPLDBCQUFPLEtBQUssS0FBSyxRQUFRLEtBQUssWUFBWSxLQUFLLFVBQVU7QUFBQSxJQUNqRSxXQUFXLGdCQUFnQixtQkFBQUEsU0FBUTtBQUFBLElBRW5DLFdBQVcsZ0JBQWdCLFVBQVU7QUFFcEMsYUFBTyxlQUFlLElBQUk7QUFDMUIsaUJBQVcsS0FBSyxLQUFLLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFBQSxJQUNsQyxPQUFPO0FBR04sYUFBTywwQkFBTyxLQUFLLE9BQU8sSUFBSSxDQUFDO0FBQUEsSUFDaEM7QUFFQSxRQUFJLFNBQVM7QUFFYixRQUFJLDBCQUFPLFNBQVMsSUFBSSxHQUFHO0FBQzFCLGVBQVMsbUJBQUFBLFFBQU8sU0FBUyxLQUFLLElBQUk7QUFBQSxJQUNuQyxXQUFXLE9BQU8sSUFBSSxHQUFHO0FBQ3hCLGVBQVMsbUJBQUFBLFFBQU8sU0FBUyxLQUFLLEtBQUssT0FBTyxDQUFDO0FBQUEsSUFDNUM7QUFFQSxTQUFLLFNBQVMsSUFBSTtBQUFBLE1BQ2pCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBLFdBQVc7QUFBQSxNQUNYLE9BQU87QUFBQSxJQUNSO0FBQ0EsU0FBSyxPQUFPO0FBRVosUUFBSSxnQkFBZ0IsbUJBQUFBLFNBQVE7QUFDM0IsV0FBSyxHQUFHLFNBQVMsWUFBVTtBQUMxQixjQUFNLFFBQVEsa0JBQWtCLGlCQUMvQixTQUNBLElBQUksV0FBVywrQ0FBK0MsS0FBSyxHQUFHLEtBQUssT0FBTyxPQUFPLElBQUksVUFBVSxNQUFNO0FBQzlHLGFBQUssU0FBUyxFQUFFLFFBQVE7QUFBQSxNQUN6QixDQUFDO0FBQUEsSUFDRjtBQUFBLEVBQ0Q7QUFBQSxFQUVBLElBQUksT0FBTztBQUNWLFdBQU8sS0FBSyxTQUFTLEVBQUU7QUFBQSxFQUN4QjtBQUFBLEVBRUEsSUFBSSxXQUFXO0FBQ2QsV0FBTyxLQUFLLFNBQVMsRUFBRTtBQUFBLEVBQ3hCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsTUFBTSxjQUFjO0FBQ25CLFVBQU0sRUFBQyxRQUFRLFlBQVksV0FBVSxJQUFJLE1BQU0sWUFBWSxJQUFJO0FBQy9ELFdBQU8sT0FBTyxNQUFNLFlBQVksYUFBYSxVQUFVO0FBQUEsRUFDeEQ7QUFBQSxFQUVBLE1BQU0sV0FBVztBQUNoQixVQUFNLEtBQUssS0FBSyxRQUFRLElBQUksY0FBYztBQUUxQyxRQUFJLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRztBQUN2RCxZQUFNLFdBQVcsSUFBSSxTQUFTO0FBQzlCLFlBQU0sYUFBYSxJQUFJLGdCQUFnQixNQUFNLEtBQUssS0FBSyxDQUFDO0FBRXhELGlCQUFXLENBQUMsTUFBTSxLQUFLLEtBQUssWUFBWTtBQUN2QyxpQkFBUyxPQUFPLE1BQU0sS0FBSztBQUFBLE1BQzVCO0FBRUEsYUFBTztBQUFBLElBQ1I7QUFFQSxVQUFNLEVBQUMsWUFBQUMsWUFBVSxJQUFJLE1BQU07QUFDM0IsV0FBT0EsWUFBVyxLQUFLLE1BQU0sRUFBRTtBQUFBLEVBQ2hDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsTUFBTSxPQUFPO0FBQ1osVUFBTSxLQUFNLEtBQUssV0FBVyxLQUFLLFFBQVEsSUFBSSxjQUFjLEtBQU8sS0FBSyxTQUFTLEVBQUUsUUFBUSxLQUFLLFNBQVMsRUFBRSxLQUFLLFFBQVM7QUFDeEgsVUFBTSxNQUFNLE1BQU0sS0FBSyxZQUFZO0FBRW5DLFdBQU8sSUFBSSxtQkFBSyxDQUFDLEdBQUcsR0FBRztBQUFBLE1BQ3RCLE1BQU07QUFBQSxJQUNQLENBQUM7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsTUFBTSxPQUFPO0FBQ1osVUFBTSxPQUFPLE1BQU0sS0FBSyxLQUFLO0FBQzdCLFdBQU8sS0FBSyxNQUFNLElBQUk7QUFBQSxFQUN2QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLE1BQU0sT0FBTztBQUNaLFVBQU0sU0FBUyxNQUFNLFlBQVksSUFBSTtBQUNyQyxXQUFPLElBQUksWUFBWSxFQUFFLE9BQU8sTUFBTTtBQUFBLEVBQ3ZDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsU0FBUztBQUNSLFdBQU8sWUFBWSxJQUFJO0FBQUEsRUFDeEI7QUFDRDtBQUVBLEtBQUssVUFBVSxhQUFTLDRCQUFVLEtBQUssVUFBVSxRQUFRLHNFQUEwRSxtQkFBbUI7QUFHdEosT0FBTyxpQkFBaUIsS0FBSyxXQUFXO0FBQUEsRUFDdkMsTUFBTSxFQUFDLFlBQVksS0FBSTtBQUFBLEVBQ3ZCLFVBQVUsRUFBQyxZQUFZLEtBQUk7QUFBQSxFQUMzQixhQUFhLEVBQUMsWUFBWSxLQUFJO0FBQUEsRUFDOUIsTUFBTSxFQUFDLFlBQVksS0FBSTtBQUFBLEVBQ3ZCLE1BQU0sRUFBQyxZQUFZLEtBQUk7QUFBQSxFQUN2QixNQUFNLEVBQUMsWUFBWSxLQUFJO0FBQUEsRUFDdkIsTUFBTSxFQUFDLFNBQUs7QUFBQSxJQUFVLE1BQU07QUFBQSxJQUFDO0FBQUEsSUFDNUI7QUFBQSxJQUNBO0FBQUEsRUFBaUUsRUFBQztBQUNwRSxDQUFDO0FBU0QsZUFBZSxZQUFZLE1BQU07QUFDaEMsTUFBSSxLQUFLLFNBQVMsRUFBRSxXQUFXO0FBQzlCLFVBQU0sSUFBSSxVQUFVLDBCQUEwQixLQUFLLEdBQUcsRUFBRTtBQUFBLEVBQ3pEO0FBRUEsT0FBSyxTQUFTLEVBQUUsWUFBWTtBQUU1QixNQUFJLEtBQUssU0FBUyxFQUFFLE9BQU87QUFDMUIsVUFBTSxLQUFLLFNBQVMsRUFBRTtBQUFBLEVBQ3ZCO0FBRUEsUUFBTSxFQUFDLEtBQUksSUFBSTtBQUdmLE1BQUksU0FBUyxNQUFNO0FBQ2xCLFdBQU8sMEJBQU8sTUFBTSxDQUFDO0FBQUEsRUFDdEI7QUFHQSxNQUFJLEVBQUUsZ0JBQWdCLG1CQUFBRCxVQUFTO0FBQzlCLFdBQU8sMEJBQU8sTUFBTSxDQUFDO0FBQUEsRUFDdEI7QUFJQSxRQUFNLFFBQVEsQ0FBQztBQUNmLE1BQUksYUFBYTtBQUVqQixNQUFJO0FBQ0gscUJBQWlCLFNBQVMsTUFBTTtBQUMvQixVQUFJLEtBQUssT0FBTyxLQUFLLGFBQWEsTUFBTSxTQUFTLEtBQUssTUFBTTtBQUMzRCxjQUFNLFFBQVEsSUFBSSxXQUFXLG1CQUFtQixLQUFLLEdBQUcsZ0JBQWdCLEtBQUssSUFBSSxJQUFJLFVBQVU7QUFDL0YsYUFBSyxRQUFRLEtBQUs7QUFDbEIsY0FBTTtBQUFBLE1BQ1A7QUFFQSxvQkFBYyxNQUFNO0FBQ3BCLFlBQU0sS0FBSyxLQUFLO0FBQUEsSUFDakI7QUFBQSxFQUNELFNBQVMsT0FBTztBQUNmLFVBQU0sU0FBUyxpQkFBaUIsaUJBQWlCLFFBQVEsSUFBSSxXQUFXLCtDQUErQyxLQUFLLEdBQUcsS0FBSyxNQUFNLE9BQU8sSUFBSSxVQUFVLEtBQUs7QUFDcEssVUFBTTtBQUFBLEVBQ1A7QUFFQSxNQUFJLEtBQUssa0JBQWtCLFFBQVEsS0FBSyxlQUFlLFVBQVUsTUFBTTtBQUN0RSxRQUFJO0FBQ0gsVUFBSSxNQUFNLE1BQU0sT0FBSyxPQUFPLE1BQU0sUUFBUSxHQUFHO0FBQzVDLGVBQU8sMEJBQU8sS0FBSyxNQUFNLEtBQUssRUFBRSxDQUFDO0FBQUEsTUFDbEM7QUFFQSxhQUFPLDBCQUFPLE9BQU8sT0FBTyxVQUFVO0FBQUEsSUFDdkMsU0FBUyxPQUFPO0FBQ2YsWUFBTSxJQUFJLFdBQVcsa0RBQWtELEtBQUssR0FBRyxLQUFLLE1BQU0sT0FBTyxJQUFJLFVBQVUsS0FBSztBQUFBLElBQ3JIO0FBQUEsRUFDRCxPQUFPO0FBQ04sVUFBTSxJQUFJLFdBQVcsNERBQTRELEtBQUssR0FBRyxFQUFFO0FBQUEsRUFDNUY7QUFDRDtBQVNPLElBQU0sUUFBUSxDQUFDLFVBQVUsa0JBQWtCO0FBQ2pELE1BQUk7QUFDSixNQUFJO0FBQ0osTUFBSSxFQUFDLEtBQUksSUFBSSxTQUFTLFNBQVM7QUFHL0IsTUFBSSxTQUFTLFVBQVU7QUFDdEIsVUFBTSxJQUFJLE1BQU0sb0NBQW9DO0FBQUEsRUFDckQ7QUFJQSxNQUFLLGdCQUFnQixtQkFBQUEsV0FBWSxPQUFPLEtBQUssZ0JBQWdCLFlBQWE7QUFFekUsU0FBSyxJQUFJLCtCQUFZLEVBQUMsY0FBYSxDQUFDO0FBQ3BDLFNBQUssSUFBSSwrQkFBWSxFQUFDLGNBQWEsQ0FBQztBQUNwQyxTQUFLLEtBQUssRUFBRTtBQUNaLFNBQUssS0FBSyxFQUFFO0FBRVosYUFBUyxTQUFTLEVBQUUsU0FBUztBQUM3QixXQUFPO0FBQUEsRUFDUjtBQUVBLFNBQU87QUFDUjtBQUVBLElBQU0saUNBQTZCO0FBQUEsRUFDbEMsVUFBUSxLQUFLLFlBQVk7QUFBQSxFQUN6QjtBQUFBLEVBQ0E7QUFDRDtBQVlPLElBQU0scUJBQXFCLENBQUMsTUFBTSxZQUFZO0FBRXBELE1BQUksU0FBUyxNQUFNO0FBQ2xCLFdBQU87QUFBQSxFQUNSO0FBR0EsTUFBSSxPQUFPLFNBQVMsVUFBVTtBQUM3QixXQUFPO0FBQUEsRUFDUjtBQUdBLE1BQUksc0JBQXNCLElBQUksR0FBRztBQUNoQyxXQUFPO0FBQUEsRUFDUjtBQUdBLE1BQUksT0FBTyxJQUFJLEdBQUc7QUFDakIsV0FBTyxLQUFLLFFBQVE7QUFBQSxFQUNyQjtBQUdBLE1BQUksMEJBQU8sU0FBUyxJQUFJLEtBQUssdUJBQU0saUJBQWlCLElBQUksS0FBSyxZQUFZLE9BQU8sSUFBSSxHQUFHO0FBQ3RGLFdBQU87QUFBQSxFQUNSO0FBRUEsTUFBSSxnQkFBZ0IsVUFBVTtBQUM3QixXQUFPLGlDQUFpQyxRQUFRLFNBQVMsRUFBRSxRQUFRO0FBQUEsRUFDcEU7QUFHQSxNQUFJLFFBQVEsT0FBTyxLQUFLLGdCQUFnQixZQUFZO0FBQ25ELFdBQU8sZ0NBQWdDLDJCQUEyQixJQUFJLENBQUM7QUFBQSxFQUN4RTtBQUdBLE1BQUksZ0JBQWdCLG1CQUFBQSxTQUFRO0FBQzNCLFdBQU87QUFBQSxFQUNSO0FBR0EsU0FBTztBQUNSO0FBV08sSUFBTSxnQkFBZ0IsYUFBVztBQUN2QyxRQUFNLEVBQUMsS0FBSSxJQUFJLFFBQVEsU0FBUztBQUdoQyxNQUFJLFNBQVMsTUFBTTtBQUNsQixXQUFPO0FBQUEsRUFDUjtBQUdBLE1BQUksT0FBTyxJQUFJLEdBQUc7QUFDakIsV0FBTyxLQUFLO0FBQUEsRUFDYjtBQUdBLE1BQUksMEJBQU8sU0FBUyxJQUFJLEdBQUc7QUFDMUIsV0FBTyxLQUFLO0FBQUEsRUFDYjtBQUdBLE1BQUksUUFBUSxPQUFPLEtBQUssa0JBQWtCLFlBQVk7QUFDckQsV0FBTyxLQUFLLGtCQUFrQixLQUFLLGVBQWUsSUFBSSxLQUFLLGNBQWMsSUFBSTtBQUFBLEVBQzlFO0FBR0EsU0FBTztBQUNSO0FBU08sSUFBTSxnQkFBZ0IsT0FBTyxNQUFNLEVBQUMsS0FBSSxNQUFNO0FBQ3BELE1BQUksU0FBUyxNQUFNO0FBRWxCLFNBQUssSUFBSTtBQUFBLEVBQ1YsT0FBTztBQUVOLFVBQU0sU0FBUyxNQUFNLElBQUk7QUFBQSxFQUMxQjtBQUNEOzs7QUl0WUEsSUFBQUUsb0JBQW9CO0FBQ3BCLHVCQUFpQjtBQUdqQixJQUFNLHFCQUFxQixPQUFPLGlCQUFBQyxRQUFLLHVCQUF1QixhQUM3RCxpQkFBQUEsUUFBSyxxQkFDTCxVQUFRO0FBQ1AsTUFBSSxDQUFDLDBCQUEwQixLQUFLLElBQUksR0FBRztBQUMxQyxVQUFNLFFBQVEsSUFBSSxVQUFVLDJDQUEyQyxJQUFJLEdBQUc7QUFDOUUsV0FBTyxlQUFlLE9BQU8sUUFBUSxFQUFDLE9BQU8seUJBQXdCLENBQUM7QUFDdEUsVUFBTTtBQUFBLEVBQ1A7QUFDRDtBQUdELElBQU0sc0JBQXNCLE9BQU8saUJBQUFBLFFBQUssd0JBQXdCLGFBQy9ELGlCQUFBQSxRQUFLLHNCQUNMLENBQUMsTUFBTSxVQUFVO0FBQ2hCLE1BQUksa0NBQWtDLEtBQUssS0FBSyxHQUFHO0FBQ2xELFVBQU0sUUFBUSxJQUFJLFVBQVUseUNBQXlDLElBQUksSUFBSTtBQUM3RSxXQUFPLGVBQWUsT0FBTyxRQUFRLEVBQUMsT0FBTyxtQkFBa0IsQ0FBQztBQUNoRSxVQUFNO0FBQUEsRUFDUDtBQUNEO0FBY0QsSUFBcUIsVUFBckIsTUFBcUIsaUJBQWdCLGdCQUFnQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT3BELFlBQVksTUFBTTtBQUdqQixRQUFJLFNBQVMsQ0FBQztBQUNkLFFBQUksZ0JBQWdCLFVBQVM7QUFDNUIsWUFBTSxNQUFNLEtBQUssSUFBSTtBQUNyQixpQkFBVyxDQUFDLE1BQU0sTUFBTSxLQUFLLE9BQU8sUUFBUSxHQUFHLEdBQUc7QUFDakQsZUFBTyxLQUFLLEdBQUcsT0FBTyxJQUFJLFdBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBQUEsTUFDbEQ7QUFBQSxJQUNELFdBQVcsUUFBUSxNQUFNO0FBQUEsSUFFekIsV0FBVyxPQUFPLFNBQVMsWUFBWSxDQUFDLHdCQUFNLGlCQUFpQixJQUFJLEdBQUc7QUFDckUsWUFBTSxTQUFTLEtBQUssT0FBTyxRQUFRO0FBRW5DLFVBQUksVUFBVSxNQUFNO0FBRW5CLGVBQU8sS0FBSyxHQUFHLE9BQU8sUUFBUSxJQUFJLENBQUM7QUFBQSxNQUNwQyxPQUFPO0FBQ04sWUFBSSxPQUFPLFdBQVcsWUFBWTtBQUNqQyxnQkFBTSxJQUFJLFVBQVUsK0JBQStCO0FBQUEsUUFDcEQ7QUFJQSxpQkFBUyxDQUFDLEdBQUcsSUFBSSxFQUNmLElBQUksVUFBUTtBQUNaLGNBQ0MsT0FBTyxTQUFTLFlBQVksd0JBQU0saUJBQWlCLElBQUksR0FDdEQ7QUFDRCxrQkFBTSxJQUFJLFVBQVUsNkNBQTZDO0FBQUEsVUFDbEU7QUFFQSxpQkFBTyxDQUFDLEdBQUcsSUFBSTtBQUFBLFFBQ2hCLENBQUMsRUFBRSxJQUFJLFVBQVE7QUFDZCxjQUFJLEtBQUssV0FBVyxHQUFHO0FBQ3RCLGtCQUFNLElBQUksVUFBVSw2Q0FBNkM7QUFBQSxVQUNsRTtBQUVBLGlCQUFPLENBQUMsR0FBRyxJQUFJO0FBQUEsUUFDaEIsQ0FBQztBQUFBLE1BQ0g7QUFBQSxJQUNELE9BQU87QUFDTixZQUFNLElBQUksVUFBVSxzSUFBeUk7QUFBQSxJQUM5SjtBQUdBLGFBQ0MsT0FBTyxTQUFTLElBQ2YsT0FBTyxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUssTUFBTTtBQUM3Qix5QkFBbUIsSUFBSTtBQUN2QiwwQkFBb0IsTUFBTSxPQUFPLEtBQUssQ0FBQztBQUN2QyxhQUFPLENBQUMsT0FBTyxJQUFJLEVBQUUsWUFBWSxHQUFHLE9BQU8sS0FBSyxDQUFDO0FBQUEsSUFDbEQsQ0FBQyxJQUNEO0FBRUYsVUFBTSxNQUFNO0FBSVosV0FBTyxJQUFJLE1BQU0sTUFBTTtBQUFBLE1BQ3RCLElBQUksUUFBUSxHQUFHLFVBQVU7QUFDeEIsZ0JBQVEsR0FBRztBQUFBLFVBQ1YsS0FBSztBQUFBLFVBQ0wsS0FBSztBQUNKLG1CQUFPLENBQUMsTUFBTSxVQUFVO0FBQ3ZCLGlDQUFtQixJQUFJO0FBQ3ZCLGtDQUFvQixNQUFNLE9BQU8sS0FBSyxDQUFDO0FBQ3ZDLHFCQUFPLGdCQUFnQixVQUFVLENBQUMsRUFBRTtBQUFBLGdCQUNuQztBQUFBLGdCQUNBLE9BQU8sSUFBSSxFQUFFLFlBQVk7QUFBQSxnQkFDekIsT0FBTyxLQUFLO0FBQUEsY0FDYjtBQUFBLFlBQ0Q7QUFBQSxVQUVELEtBQUs7QUFBQSxVQUNMLEtBQUs7QUFBQSxVQUNMLEtBQUs7QUFDSixtQkFBTyxVQUFRO0FBQ2QsaUNBQW1CLElBQUk7QUFDdkIscUJBQU8sZ0JBQWdCLFVBQVUsQ0FBQyxFQUFFO0FBQUEsZ0JBQ25DO0FBQUEsZ0JBQ0EsT0FBTyxJQUFJLEVBQUUsWUFBWTtBQUFBLGNBQzFCO0FBQUEsWUFDRDtBQUFBLFVBRUQsS0FBSztBQUNKLG1CQUFPLE1BQU07QUFDWixxQkFBTyxLQUFLO0FBQ1oscUJBQU8sSUFBSSxJQUFJLGdCQUFnQixVQUFVLEtBQUssS0FBSyxNQUFNLENBQUMsRUFBRSxLQUFLO0FBQUEsWUFDbEU7QUFBQSxVQUVEO0FBQ0MsbUJBQU8sUUFBUSxJQUFJLFFBQVEsR0FBRyxRQUFRO0FBQUEsUUFDeEM7QUFBQSxNQUNEO0FBQUEsSUFDRCxDQUFDO0FBQUEsRUFFRjtBQUFBLEVBRUEsS0FBSyxPQUFPLFdBQVcsSUFBSTtBQUMxQixXQUFPLEtBQUssWUFBWTtBQUFBLEVBQ3pCO0FBQUEsRUFFQSxXQUFXO0FBQ1YsV0FBTyxPQUFPLFVBQVUsU0FBUyxLQUFLLElBQUk7QUFBQSxFQUMzQztBQUFBLEVBRUEsSUFBSSxNQUFNO0FBQ1QsVUFBTSxTQUFTLEtBQUssT0FBTyxJQUFJO0FBQy9CLFFBQUksT0FBTyxXQUFXLEdBQUc7QUFDeEIsYUFBTztBQUFBLElBQ1I7QUFFQSxRQUFJLFFBQVEsT0FBTyxLQUFLLElBQUk7QUFDNUIsUUFBSSxzQkFBc0IsS0FBSyxJQUFJLEdBQUc7QUFDckMsY0FBUSxNQUFNLFlBQVk7QUFBQSxJQUMzQjtBQUVBLFdBQU87QUFBQSxFQUNSO0FBQUEsRUFFQSxRQUFRLFVBQVUsVUFBVSxRQUFXO0FBQ3RDLGVBQVcsUUFBUSxLQUFLLEtBQUssR0FBRztBQUMvQixjQUFRLE1BQU0sVUFBVSxTQUFTLENBQUMsS0FBSyxJQUFJLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQztBQUFBLElBQzlEO0FBQUEsRUFDRDtBQUFBLEVBRUEsQ0FBRSxTQUFTO0FBQ1YsZUFBVyxRQUFRLEtBQUssS0FBSyxHQUFHO0FBQy9CLFlBQU0sS0FBSyxJQUFJLElBQUk7QUFBQSxJQUNwQjtBQUFBLEVBQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLENBQUUsVUFBVTtBQUNYLGVBQVcsUUFBUSxLQUFLLEtBQUssR0FBRztBQUMvQixZQUFNLENBQUMsTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDO0FBQUEsSUFDNUI7QUFBQSxFQUNEO0FBQUEsRUFFQSxDQUFDLE9BQU8sUUFBUSxJQUFJO0FBQ25CLFdBQU8sS0FBSyxRQUFRO0FBQUEsRUFDckI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPQSxNQUFNO0FBQ0wsV0FBTyxDQUFDLEdBQUcsS0FBSyxLQUFLLENBQUMsRUFBRSxPQUFPLENBQUMsUUFBUSxRQUFRO0FBQy9DLGFBQU8sR0FBRyxJQUFJLEtBQUssT0FBTyxHQUFHO0FBQzdCLGFBQU87QUFBQSxJQUNSLEdBQUcsQ0FBQyxDQUFDO0FBQUEsRUFDTjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsQ0FBQyxPQUFPLElBQUksNEJBQTRCLENBQUMsSUFBSTtBQUM1QyxXQUFPLENBQUMsR0FBRyxLQUFLLEtBQUssQ0FBQyxFQUFFLE9BQU8sQ0FBQyxRQUFRLFFBQVE7QUFDL0MsWUFBTSxTQUFTLEtBQUssT0FBTyxHQUFHO0FBRzlCLFVBQUksUUFBUSxRQUFRO0FBQ25CLGVBQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQztBQUFBLE1BQ3ZCLE9BQU87QUFDTixlQUFPLEdBQUcsSUFBSSxPQUFPLFNBQVMsSUFBSSxTQUFTLE9BQU8sQ0FBQztBQUFBLE1BQ3BEO0FBRUEsYUFBTztBQUFBLElBQ1IsR0FBRyxDQUFDLENBQUM7QUFBQSxFQUNOO0FBQ0Q7QUFNQSxPQUFPO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixDQUFDLE9BQU8sV0FBVyxXQUFXLFFBQVEsRUFBRSxPQUFPLENBQUMsUUFBUSxhQUFhO0FBQ3BFLFdBQU8sUUFBUSxJQUFJLEVBQUMsWUFBWSxLQUFJO0FBQ3BDLFdBQU87QUFBQSxFQUNSLEdBQUcsQ0FBQyxDQUFDO0FBQ047QUFPTyxTQUFTLGVBQWUsVUFBVSxDQUFDLEdBQUc7QUFDNUMsU0FBTyxJQUFJO0FBQUEsSUFDVixRQUVFLE9BQU8sQ0FBQyxRQUFRLE9BQU8sT0FBTyxVQUFVO0FBQ3hDLFVBQUksUUFBUSxNQUFNLEdBQUc7QUFDcEIsZUFBTyxLQUFLLE1BQU0sTUFBTSxPQUFPLFFBQVEsQ0FBQyxDQUFDO0FBQUEsTUFDMUM7QUFFQSxhQUFPO0FBQUEsSUFDUixHQUFHLENBQUMsQ0FBQyxFQUNKLE9BQU8sQ0FBQyxDQUFDLE1BQU0sS0FBSyxNQUFNO0FBQzFCLFVBQUk7QUFDSCwyQkFBbUIsSUFBSTtBQUN2Qiw0QkFBb0IsTUFBTSxPQUFPLEtBQUssQ0FBQztBQUN2QyxlQUFPO0FBQUEsTUFDUixRQUFRO0FBQ1AsZUFBTztBQUFBLE1BQ1I7QUFBQSxJQUNELENBQUM7QUFBQSxFQUVIO0FBQ0Q7OztBQzFRQSxJQUFNLGlCQUFpQixvQkFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLENBQUM7QUFRakQsSUFBTSxhQUFhLFVBQVE7QUFDakMsU0FBTyxlQUFlLElBQUksSUFBSTtBQUMvQjs7O0FDQUEsSUFBTUMsYUFBWSxPQUFPLG9CQUFvQjtBQVc3QyxJQUFxQixXQUFyQixNQUFxQixrQkFBaUIsS0FBSztBQUFBLEVBQzFDLFlBQVksT0FBTyxNQUFNLFVBQVUsQ0FBQyxHQUFHO0FBQ3RDLFVBQU0sTUFBTSxPQUFPO0FBR25CLFVBQU0sU0FBUyxRQUFRLFVBQVUsT0FBTyxRQUFRLFNBQVM7QUFFekQsVUFBTSxVQUFVLElBQUksUUFBUSxRQUFRLE9BQU87QUFFM0MsUUFBSSxTQUFTLFFBQVEsQ0FBQyxRQUFRLElBQUksY0FBYyxHQUFHO0FBQ2xELFlBQU0sY0FBYyxtQkFBbUIsTUFBTSxJQUFJO0FBQ2pELFVBQUksYUFBYTtBQUNoQixnQkFBUSxPQUFPLGdCQUFnQixXQUFXO0FBQUEsTUFDM0M7QUFBQSxJQUNEO0FBRUEsU0FBS0EsVUFBUyxJQUFJO0FBQUEsTUFDakIsTUFBTTtBQUFBLE1BQ04sS0FBSyxRQUFRO0FBQUEsTUFDYjtBQUFBLE1BQ0EsWUFBWSxRQUFRLGNBQWM7QUFBQSxNQUNsQztBQUFBLE1BQ0EsU0FBUyxRQUFRO0FBQUEsTUFDakIsZUFBZSxRQUFRO0FBQUEsSUFDeEI7QUFBQSxFQUNEO0FBQUEsRUFFQSxJQUFJLE9BQU87QUFDVixXQUFPLEtBQUtBLFVBQVMsRUFBRTtBQUFBLEVBQ3hCO0FBQUEsRUFFQSxJQUFJLE1BQU07QUFDVCxXQUFPLEtBQUtBLFVBQVMsRUFBRSxPQUFPO0FBQUEsRUFDL0I7QUFBQSxFQUVBLElBQUksU0FBUztBQUNaLFdBQU8sS0FBS0EsVUFBUyxFQUFFO0FBQUEsRUFDeEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLElBQUksS0FBSztBQUNSLFdBQU8sS0FBS0EsVUFBUyxFQUFFLFVBQVUsT0FBTyxLQUFLQSxVQUFTLEVBQUUsU0FBUztBQUFBLEVBQ2xFO0FBQUEsRUFFQSxJQUFJLGFBQWE7QUFDaEIsV0FBTyxLQUFLQSxVQUFTLEVBQUUsVUFBVTtBQUFBLEVBQ2xDO0FBQUEsRUFFQSxJQUFJLGFBQWE7QUFDaEIsV0FBTyxLQUFLQSxVQUFTLEVBQUU7QUFBQSxFQUN4QjtBQUFBLEVBRUEsSUFBSSxVQUFVO0FBQ2IsV0FBTyxLQUFLQSxVQUFTLEVBQUU7QUFBQSxFQUN4QjtBQUFBLEVBRUEsSUFBSSxnQkFBZ0I7QUFDbkIsV0FBTyxLQUFLQSxVQUFTLEVBQUU7QUFBQSxFQUN4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLFFBQVE7QUFDUCxXQUFPLElBQUksVUFBUyxNQUFNLE1BQU0sS0FBSyxhQUFhLEdBQUc7QUFBQSxNQUNwRCxNQUFNLEtBQUs7QUFBQSxNQUNYLEtBQUssS0FBSztBQUFBLE1BQ1YsUUFBUSxLQUFLO0FBQUEsTUFDYixZQUFZLEtBQUs7QUFBQSxNQUNqQixTQUFTLEtBQUs7QUFBQSxNQUNkLElBQUksS0FBSztBQUFBLE1BQ1QsWUFBWSxLQUFLO0FBQUEsTUFDakIsTUFBTSxLQUFLO0FBQUEsTUFDWCxlQUFlLEtBQUs7QUFBQSxJQUNyQixDQUFDO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLE9BQU8sU0FBUyxLQUFLLFNBQVMsS0FBSztBQUNsQyxRQUFJLENBQUMsV0FBVyxNQUFNLEdBQUc7QUFDeEIsWUFBTSxJQUFJLFdBQVcsaUVBQWlFO0FBQUEsSUFDdkY7QUFFQSxXQUFPLElBQUksVUFBUyxNQUFNO0FBQUEsTUFDekIsU0FBUztBQUFBLFFBQ1IsVUFBVSxJQUFJLElBQUksR0FBRyxFQUFFLFNBQVM7QUFBQSxNQUNqQztBQUFBLE1BQ0E7QUFBQSxJQUNELENBQUM7QUFBQSxFQUNGO0FBQUEsRUFFQSxPQUFPLFFBQVE7QUFDZCxVQUFNLFdBQVcsSUFBSSxVQUFTLE1BQU0sRUFBQyxRQUFRLEdBQUcsWUFBWSxHQUFFLENBQUM7QUFDL0QsYUFBU0EsVUFBUyxFQUFFLE9BQU87QUFDM0IsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUVBLE9BQU8sS0FBSyxPQUFPLFFBQVcsT0FBTyxDQUFDLEdBQUc7QUFDeEMsVUFBTSxPQUFPLEtBQUssVUFBVSxJQUFJO0FBRWhDLFFBQUksU0FBUyxRQUFXO0FBQ3ZCLFlBQU0sSUFBSSxVQUFVLCtCQUErQjtBQUFBLElBQ3BEO0FBRUEsVUFBTSxVQUFVLElBQUksUUFBUSxRQUFRLEtBQUssT0FBTztBQUVoRCxRQUFJLENBQUMsUUFBUSxJQUFJLGNBQWMsR0FBRztBQUNqQyxjQUFRLElBQUksZ0JBQWdCLGtCQUFrQjtBQUFBLElBQy9DO0FBRUEsV0FBTyxJQUFJLFVBQVMsTUFBTTtBQUFBLE1BQ3pCLEdBQUc7QUFBQSxNQUNIO0FBQUEsSUFDRCxDQUFDO0FBQUEsRUFDRjtBQUFBLEVBRUEsS0FBSyxPQUFPLFdBQVcsSUFBSTtBQUMxQixXQUFPO0FBQUEsRUFDUjtBQUNEO0FBRUEsT0FBTyxpQkFBaUIsU0FBUyxXQUFXO0FBQUEsRUFDM0MsTUFBTSxFQUFDLFlBQVksS0FBSTtBQUFBLEVBQ3ZCLEtBQUssRUFBQyxZQUFZLEtBQUk7QUFBQSxFQUN0QixRQUFRLEVBQUMsWUFBWSxLQUFJO0FBQUEsRUFDekIsSUFBSSxFQUFDLFlBQVksS0FBSTtBQUFBLEVBQ3JCLFlBQVksRUFBQyxZQUFZLEtBQUk7QUFBQSxFQUM3QixZQUFZLEVBQUMsWUFBWSxLQUFJO0FBQUEsRUFDN0IsU0FBUyxFQUFDLFlBQVksS0FBSTtBQUFBLEVBQzFCLE9BQU8sRUFBQyxZQUFZLEtBQUk7QUFDekIsQ0FBQzs7O0FDdkpELHNCQUFrQztBQUNsQyxJQUFBQyxvQkFBd0I7OztBQ1RqQixJQUFNLFlBQVksZUFBYTtBQUNyQyxNQUFJLFVBQVUsUUFBUTtBQUNyQixXQUFPLFVBQVU7QUFBQSxFQUNsQjtBQUVBLFFBQU0sYUFBYSxVQUFVLEtBQUssU0FBUztBQUMzQyxRQUFNLE9BQU8sVUFBVSxTQUFTLFVBQVUsS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNO0FBQzNFLFNBQU8sVUFBVSxLQUFLLGFBQWEsS0FBSyxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBQ2pFOzs7QUNSQSxzQkFBbUI7QUFpQlosU0FBUywwQkFBMEIsS0FBSyxhQUFhLE9BQU87QUFFbEUsTUFBSSxPQUFPLE1BQU07QUFDaEIsV0FBTztBQUFBLEVBQ1I7QUFFQSxRQUFNLElBQUksSUFBSSxHQUFHO0FBR2pCLE1BQUksdUJBQXVCLEtBQUssSUFBSSxRQUFRLEdBQUc7QUFDOUMsV0FBTztBQUFBLEVBQ1I7QUFHQSxNQUFJLFdBQVc7QUFJZixNQUFJLFdBQVc7QUFJZixNQUFJLE9BQU87QUFHWCxNQUFJLFlBQVk7QUFHZixRQUFJLFdBQVc7QUFJZixRQUFJLFNBQVM7QUFBQSxFQUNkO0FBR0EsU0FBTztBQUNSO0FBS08sSUFBTSxpQkFBaUIsb0JBQUksSUFBSTtBQUFBLEVBQ3JDO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDRCxDQUFDO0FBS00sSUFBTSwwQkFBMEI7QUFPaEMsU0FBUyx1QkFBdUIsZ0JBQWdCO0FBQ3RELE1BQUksQ0FBQyxlQUFlLElBQUksY0FBYyxHQUFHO0FBQ3hDLFVBQU0sSUFBSSxVQUFVLDJCQUEyQixjQUFjLEVBQUU7QUFBQSxFQUNoRTtBQUVBLFNBQU87QUFDUjtBQU9PLFNBQVMsK0JBQStCLEtBQUs7QUFRbkQsTUFBSSxnQkFBZ0IsS0FBSyxJQUFJLFFBQVEsR0FBRztBQUN2QyxXQUFPO0FBQUEsRUFDUjtBQUdBLFFBQU0sU0FBUyxJQUFJLEtBQUssUUFBUSxlQUFlLEVBQUU7QUFDakQsUUFBTSxvQkFBZ0Isc0JBQUssTUFBTTtBQUVqQyxNQUFJLGtCQUFrQixLQUFLLFNBQVMsS0FBSyxNQUFNLEdBQUc7QUFDakQsV0FBTztBQUFBLEVBQ1I7QUFFQSxNQUFJLGtCQUFrQixLQUFLLG1DQUFtQyxLQUFLLE1BQU0sR0FBRztBQUMzRSxXQUFPO0FBQUEsRUFDUjtBQUtBLE1BQUksSUFBSSxTQUFTLGVBQWUsSUFBSSxLQUFLLFNBQVMsWUFBWSxHQUFHO0FBQ2hFLFdBQU87QUFBQSxFQUNSO0FBR0EsTUFBSSxJQUFJLGFBQWEsU0FBUztBQUM3QixXQUFPO0FBQUEsRUFDUjtBQVNBLFNBQU87QUFDUjtBQU9PLFNBQVMsNEJBQTRCLEtBQUs7QUFFaEQsTUFBSSx5QkFBeUIsS0FBSyxHQUFHLEdBQUc7QUFDdkMsV0FBTztBQUFBLEVBQ1I7QUFHQSxNQUFJLElBQUksYUFBYSxTQUFTO0FBQzdCLFdBQU87QUFBQSxFQUNSO0FBS0EsTUFBSSx1QkFBdUIsS0FBSyxJQUFJLFFBQVEsR0FBRztBQUM5QyxXQUFPO0FBQUEsRUFDUjtBQUdBLFNBQU8sK0JBQStCLEdBQUc7QUFDMUM7QUEwQk8sU0FBUywwQkFBMEIsU0FBUyxFQUFDLHFCQUFxQix1QkFBc0IsSUFBSSxDQUFDLEdBQUc7QUFNdEcsTUFBSSxRQUFRLGFBQWEsaUJBQWlCLFFBQVEsbUJBQW1CLElBQUk7QUFDeEUsV0FBTztBQUFBLEVBQ1I7QUFHQSxRQUFNLFNBQVMsUUFBUTtBQU12QixNQUFJLFFBQVEsYUFBYSxnQkFBZ0I7QUFDeEMsV0FBTztBQUFBLEVBQ1I7QUFHQSxRQUFNLGlCQUFpQixRQUFRO0FBRy9CLE1BQUksY0FBYywwQkFBMEIsY0FBYztBQUkxRCxNQUFJLGlCQUFpQiwwQkFBMEIsZ0JBQWdCLElBQUk7QUFJbkUsTUFBSSxZQUFZLFNBQVMsRUFBRSxTQUFTLE1BQU07QUFDekMsa0JBQWM7QUFBQSxFQUNmO0FBTUEsTUFBSSxxQkFBcUI7QUFDeEIsa0JBQWMsb0JBQW9CLFdBQVc7QUFBQSxFQUM5QztBQUVBLE1BQUksd0JBQXdCO0FBQzNCLHFCQUFpQix1QkFBdUIsY0FBYztBQUFBLEVBQ3ZEO0FBR0EsUUFBTSxhQUFhLElBQUksSUFBSSxRQUFRLEdBQUc7QUFFdEMsVUFBUSxRQUFRO0FBQUEsSUFDZixLQUFLO0FBQ0osYUFBTztBQUFBLElBRVIsS0FBSztBQUNKLGFBQU87QUFBQSxJQUVSLEtBQUs7QUFDSixhQUFPO0FBQUEsSUFFUixLQUFLO0FBR0osVUFBSSw0QkFBNEIsV0FBVyxLQUFLLENBQUMsNEJBQTRCLFVBQVUsR0FBRztBQUN6RixlQUFPO0FBQUEsTUFDUjtBQUdBLGFBQU8sZUFBZSxTQUFTO0FBQUEsSUFFaEMsS0FBSztBQUdKLFVBQUksWUFBWSxXQUFXLFdBQVcsUUFBUTtBQUM3QyxlQUFPO0FBQUEsTUFDUjtBQUlBLFVBQUksNEJBQTRCLFdBQVcsS0FBSyxDQUFDLDRCQUE0QixVQUFVLEdBQUc7QUFDekYsZUFBTztBQUFBLE1BQ1I7QUFHQSxhQUFPO0FBQUEsSUFFUixLQUFLO0FBR0osVUFBSSxZQUFZLFdBQVcsV0FBVyxRQUFRO0FBQzdDLGVBQU87QUFBQSxNQUNSO0FBR0EsYUFBTztBQUFBLElBRVIsS0FBSztBQUdKLFVBQUksWUFBWSxXQUFXLFdBQVcsUUFBUTtBQUM3QyxlQUFPO0FBQUEsTUFDUjtBQUdBLGFBQU87QUFBQSxJQUVSLEtBQUs7QUFHSixVQUFJLDRCQUE0QixXQUFXLEtBQUssQ0FBQyw0QkFBNEIsVUFBVSxHQUFHO0FBQ3pGLGVBQU87QUFBQSxNQUNSO0FBR0EsYUFBTztBQUFBLElBRVI7QUFDQyxZQUFNLElBQUksVUFBVSwyQkFBMkIsTUFBTSxFQUFFO0FBQUEsRUFDekQ7QUFDRDtBQU9PLFNBQVMsOEJBQThCLFNBQVM7QUFHdEQsUUFBTSxnQkFBZ0IsUUFBUSxJQUFJLGlCQUFpQixLQUFLLElBQUksTUFBTSxRQUFRO0FBRzFFLE1BQUksU0FBUztBQU1iLGFBQVcsU0FBUyxjQUFjO0FBQ2pDLFFBQUksU0FBUyxlQUFlLElBQUksS0FBSyxHQUFHO0FBQ3ZDLGVBQVM7QUFBQSxJQUNWO0FBQUEsRUFDRDtBQUdBLFNBQU87QUFDUjs7O0FGalVBLElBQU1DLGFBQVksT0FBTyxtQkFBbUI7QUFRNUMsSUFBTSxZQUFZLFlBQVU7QUFDM0IsU0FDQyxPQUFPLFdBQVcsWUFDbEIsT0FBTyxPQUFPQSxVQUFTLE1BQU07QUFFL0I7QUFFQSxJQUFNLG9CQUFnQjtBQUFBLEVBQVUsTUFBTTtBQUFBLEVBQUM7QUFBQSxFQUN0QztBQUFBLEVBQ0E7QUFBZ0U7QUFXakUsSUFBcUIsVUFBckIsTUFBcUIsaUJBQWdCLEtBQUs7QUFBQSxFQUN6QyxZQUFZLE9BQU8sT0FBTyxDQUFDLEdBQUc7QUFDN0IsUUFBSTtBQUdKLFFBQUksVUFBVSxLQUFLLEdBQUc7QUFDckIsa0JBQVksSUFBSSxJQUFJLE1BQU0sR0FBRztBQUFBLElBQzlCLE9BQU87QUFDTixrQkFBWSxJQUFJLElBQUksS0FBSztBQUN6QixjQUFRLENBQUM7QUFBQSxJQUNWO0FBRUEsUUFBSSxVQUFVLGFBQWEsTUFBTSxVQUFVLGFBQWEsSUFBSTtBQUMzRCxZQUFNLElBQUksVUFBVSxHQUFHLFNBQVMsdUNBQXVDO0FBQUEsSUFDeEU7QUFFQSxRQUFJLFNBQVMsS0FBSyxVQUFVLE1BQU0sVUFBVTtBQUM1QyxRQUFJLHdDQUF3QyxLQUFLLE1BQU0sR0FBRztBQUN6RCxlQUFTLE9BQU8sWUFBWTtBQUFBLElBQzdCO0FBRUEsUUFBSSxDQUFDLFVBQVUsSUFBSSxLQUFLLFVBQVUsTUFBTTtBQUN2QyxvQkFBYztBQUFBLElBQ2Y7QUFHQSxTQUFLLEtBQUssUUFBUSxRQUFTLFVBQVUsS0FBSyxLQUFLLE1BQU0sU0FBUyxVQUM1RCxXQUFXLFNBQVMsV0FBVyxTQUFTO0FBQ3pDLFlBQU0sSUFBSSxVQUFVLCtDQUErQztBQUFBLElBQ3BFO0FBRUEsVUFBTSxZQUFZLEtBQUssT0FDdEIsS0FBSyxPQUNKLFVBQVUsS0FBSyxLQUFLLE1BQU0sU0FBUyxPQUNuQyxNQUFNLEtBQUssSUFDWDtBQUVGLFVBQU0sV0FBVztBQUFBLE1BQ2hCLE1BQU0sS0FBSyxRQUFRLE1BQU0sUUFBUTtBQUFBLElBQ2xDLENBQUM7QUFFRCxVQUFNLFVBQVUsSUFBSSxRQUFRLEtBQUssV0FBVyxNQUFNLFdBQVcsQ0FBQyxDQUFDO0FBRS9ELFFBQUksY0FBYyxRQUFRLENBQUMsUUFBUSxJQUFJLGNBQWMsR0FBRztBQUN2RCxZQUFNLGNBQWMsbUJBQW1CLFdBQVcsSUFBSTtBQUN0RCxVQUFJLGFBQWE7QUFDaEIsZ0JBQVEsSUFBSSxnQkFBZ0IsV0FBVztBQUFBLE1BQ3hDO0FBQUEsSUFDRDtBQUVBLFFBQUksU0FBUyxVQUFVLEtBQUssSUFDM0IsTUFBTSxTQUNOO0FBQ0QsUUFBSSxZQUFZLE1BQU07QUFDckIsZUFBUyxLQUFLO0FBQUEsSUFDZjtBQUdBLFFBQUksVUFBVSxRQUFRLENBQUMsY0FBYyxNQUFNLEdBQUc7QUFDN0MsWUFBTSxJQUFJLFVBQVUsZ0VBQWdFO0FBQUEsSUFDckY7QUFJQSxRQUFJLFdBQVcsS0FBSyxZQUFZLE9BQU8sTUFBTSxXQUFXLEtBQUs7QUFDN0QsUUFBSSxhQUFhLElBQUk7QUFFcEIsaUJBQVc7QUFBQSxJQUNaLFdBQVcsVUFBVTtBQUVwQixZQUFNLGlCQUFpQixJQUFJLElBQUksUUFBUTtBQUV2QyxpQkFBVyx3QkFBd0IsS0FBSyxjQUFjLElBQUksV0FBVztBQUFBLElBQ3RFLE9BQU87QUFDTixpQkFBVztBQUFBLElBQ1o7QUFFQSxTQUFLQSxVQUFTLElBQUk7QUFBQSxNQUNqQjtBQUFBLE1BQ0EsVUFBVSxLQUFLLFlBQVksTUFBTSxZQUFZO0FBQUEsTUFDN0M7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNEO0FBR0EsU0FBSyxTQUFTLEtBQUssV0FBVyxTQUFhLE1BQU0sV0FBVyxTQUFZLEtBQUssTUFBTSxTQUFVLEtBQUs7QUFDbEcsU0FBSyxXQUFXLEtBQUssYUFBYSxTQUFhLE1BQU0sYUFBYSxTQUFZLE9BQU8sTUFBTSxXQUFZLEtBQUs7QUFDNUcsU0FBSyxVQUFVLEtBQUssV0FBVyxNQUFNLFdBQVc7QUFDaEQsU0FBSyxRQUFRLEtBQUssU0FBUyxNQUFNO0FBQ2pDLFNBQUssZ0JBQWdCLEtBQUssaUJBQWlCLE1BQU0saUJBQWlCO0FBQ2xFLFNBQUsscUJBQXFCLEtBQUssc0JBQXNCLE1BQU0sc0JBQXNCO0FBSWpGLFNBQUssaUJBQWlCLEtBQUssa0JBQWtCLE1BQU0sa0JBQWtCO0FBQUEsRUFDdEU7QUFBQTtBQUFBLEVBR0EsSUFBSSxTQUFTO0FBQ1osV0FBTyxLQUFLQSxVQUFTLEVBQUU7QUFBQSxFQUN4QjtBQUFBO0FBQUEsRUFHQSxJQUFJLE1BQU07QUFDVCxlQUFPLGdCQUFBQyxRQUFVLEtBQUtELFVBQVMsRUFBRSxTQUFTO0FBQUEsRUFDM0M7QUFBQTtBQUFBLEVBR0EsSUFBSSxVQUFVO0FBQ2IsV0FBTyxLQUFLQSxVQUFTLEVBQUU7QUFBQSxFQUN4QjtBQUFBLEVBRUEsSUFBSSxXQUFXO0FBQ2QsV0FBTyxLQUFLQSxVQUFTLEVBQUU7QUFBQSxFQUN4QjtBQUFBO0FBQUEsRUFHQSxJQUFJLFNBQVM7QUFDWixXQUFPLEtBQUtBLFVBQVMsRUFBRTtBQUFBLEVBQ3hCO0FBQUE7QUFBQSxFQUdBLElBQUksV0FBVztBQUNkLFFBQUksS0FBS0EsVUFBUyxFQUFFLGFBQWEsZUFBZTtBQUMvQyxhQUFPO0FBQUEsSUFDUjtBQUVBLFFBQUksS0FBS0EsVUFBUyxFQUFFLGFBQWEsVUFBVTtBQUMxQyxhQUFPO0FBQUEsSUFDUjtBQUVBLFFBQUksS0FBS0EsVUFBUyxFQUFFLFVBQVU7QUFDN0IsYUFBTyxLQUFLQSxVQUFTLEVBQUUsU0FBUyxTQUFTO0FBQUEsSUFDMUM7QUFFQSxXQUFPO0FBQUEsRUFDUjtBQUFBLEVBRUEsSUFBSSxpQkFBaUI7QUFDcEIsV0FBTyxLQUFLQSxVQUFTLEVBQUU7QUFBQSxFQUN4QjtBQUFBLEVBRUEsSUFBSSxlQUFlLGdCQUFnQjtBQUNsQyxTQUFLQSxVQUFTLEVBQUUsaUJBQWlCLHVCQUF1QixjQUFjO0FBQUEsRUFDdkU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPQSxRQUFRO0FBQ1AsV0FBTyxJQUFJLFNBQVEsSUFBSTtBQUFBLEVBQ3hCO0FBQUEsRUFFQSxLQUFLLE9BQU8sV0FBVyxJQUFJO0FBQzFCLFdBQU87QUFBQSxFQUNSO0FBQ0Q7QUFFQSxPQUFPLGlCQUFpQixRQUFRLFdBQVc7QUFBQSxFQUMxQyxRQUFRLEVBQUMsWUFBWSxLQUFJO0FBQUEsRUFDekIsS0FBSyxFQUFDLFlBQVksS0FBSTtBQUFBLEVBQ3RCLFNBQVMsRUFBQyxZQUFZLEtBQUk7QUFBQSxFQUMxQixVQUFVLEVBQUMsWUFBWSxLQUFJO0FBQUEsRUFDM0IsT0FBTyxFQUFDLFlBQVksS0FBSTtBQUFBLEVBQ3hCLFFBQVEsRUFBQyxZQUFZLEtBQUk7QUFBQSxFQUN6QixVQUFVLEVBQUMsWUFBWSxLQUFJO0FBQUEsRUFDM0IsZ0JBQWdCLEVBQUMsWUFBWSxLQUFJO0FBQ2xDLENBQUM7QUFRTSxJQUFNLHdCQUF3QixhQUFXO0FBQy9DLFFBQU0sRUFBQyxVQUFTLElBQUksUUFBUUEsVUFBUztBQUNyQyxRQUFNLFVBQVUsSUFBSSxRQUFRLFFBQVFBLFVBQVMsRUFBRSxPQUFPO0FBR3RELE1BQUksQ0FBQyxRQUFRLElBQUksUUFBUSxHQUFHO0FBQzNCLFlBQVEsSUFBSSxVQUFVLEtBQUs7QUFBQSxFQUM1QjtBQUdBLE1BQUkscUJBQXFCO0FBQ3pCLE1BQUksUUFBUSxTQUFTLFFBQVEsZ0JBQWdCLEtBQUssUUFBUSxNQUFNLEdBQUc7QUFDbEUseUJBQXFCO0FBQUEsRUFDdEI7QUFFQSxNQUFJLFFBQVEsU0FBUyxNQUFNO0FBQzFCLFVBQU0sYUFBYSxjQUFjLE9BQU87QUFFeEMsUUFBSSxPQUFPLGVBQWUsWUFBWSxDQUFDLE9BQU8sTUFBTSxVQUFVLEdBQUc7QUFDaEUsMkJBQXFCLE9BQU8sVUFBVTtBQUFBLElBQ3ZDO0FBQUEsRUFDRDtBQUVBLE1BQUksb0JBQW9CO0FBQ3ZCLFlBQVEsSUFBSSxrQkFBa0Isa0JBQWtCO0FBQUEsRUFDakQ7QUFLQSxNQUFJLFFBQVEsbUJBQW1CLElBQUk7QUFDbEMsWUFBUSxpQkFBaUI7QUFBQSxFQUMxQjtBQUtBLE1BQUksUUFBUSxZQUFZLFFBQVEsYUFBYSxlQUFlO0FBQzNELFlBQVFBLFVBQVMsRUFBRSxXQUFXLDBCQUEwQixPQUFPO0FBQUEsRUFDaEUsT0FBTztBQUNOLFlBQVFBLFVBQVMsRUFBRSxXQUFXO0FBQUEsRUFDL0I7QUFLQSxNQUFJLFFBQVFBLFVBQVMsRUFBRSxvQkFBb0IsS0FBSztBQUMvQyxZQUFRLElBQUksV0FBVyxRQUFRLFFBQVE7QUFBQSxFQUN4QztBQUdBLE1BQUksQ0FBQyxRQUFRLElBQUksWUFBWSxHQUFHO0FBQy9CLFlBQVEsSUFBSSxjQUFjLFlBQVk7QUFBQSxFQUN2QztBQUdBLE1BQUksUUFBUSxZQUFZLENBQUMsUUFBUSxJQUFJLGlCQUFpQixHQUFHO0FBQ3hELFlBQVEsSUFBSSxtQkFBbUIsbUJBQW1CO0FBQUEsRUFDbkQ7QUFFQSxNQUFJLEVBQUMsTUFBSyxJQUFJO0FBQ2QsTUFBSSxPQUFPLFVBQVUsWUFBWTtBQUNoQyxZQUFRLE1BQU0sU0FBUztBQUFBLEVBQ3hCO0FBS0EsUUFBTSxTQUFTLFVBQVUsU0FBUztBQUlsQyxRQUFNLFVBQVU7QUFBQTtBQUFBLElBRWYsTUFBTSxVQUFVLFdBQVc7QUFBQTtBQUFBLElBRTNCLFFBQVEsUUFBUTtBQUFBLElBQ2hCLFNBQVMsUUFBUSxPQUFPLElBQUksNEJBQTRCLENBQUMsRUFBRTtBQUFBLElBQzNELG9CQUFvQixRQUFRO0FBQUEsSUFDNUI7QUFBQSxFQUNEO0FBRUEsU0FBTztBQUFBO0FBQUEsSUFFTjtBQUFBLElBQ0E7QUFBQSxFQUNEO0FBQ0Q7OztBR25UTyxJQUFNLGFBQU4sY0FBeUIsZUFBZTtBQUFBLEVBQzlDLFlBQVksU0FBUyxPQUFPLFdBQVc7QUFDdEMsVUFBTSxTQUFTLElBQUk7QUFBQSxFQUNwQjtBQUNEOzs7QVpjQTtBQUdBO0FBWUEsSUFBTSxtQkFBbUIsb0JBQUksSUFBSSxDQUFDLFNBQVMsU0FBUyxRQUFRLENBQUM7QUFTN0QsZUFBTyxNQUE2QixLQUFLLFVBQVU7QUFDbEQsU0FBTyxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFFdkMsVUFBTSxVQUFVLElBQUksUUFBUSxLQUFLLFFBQVE7QUFDekMsVUFBTSxFQUFDLFdBQVcsUUFBTyxJQUFJLHNCQUFzQixPQUFPO0FBQzFELFFBQUksQ0FBQyxpQkFBaUIsSUFBSSxVQUFVLFFBQVEsR0FBRztBQUM5QyxZQUFNLElBQUksVUFBVSwwQkFBMEIsR0FBRyxpQkFBaUIsVUFBVSxTQUFTLFFBQVEsTUFBTSxFQUFFLENBQUMscUJBQXFCO0FBQUEsSUFDNUg7QUFFQSxRQUFJLFVBQVUsYUFBYSxTQUFTO0FBQ25DLFlBQU0sT0FBTyxhQUFnQixRQUFRLEdBQUc7QUFDeEMsWUFBTUUsWUFBVyxJQUFJLFNBQVMsTUFBTSxFQUFDLFNBQVMsRUFBQyxnQkFBZ0IsS0FBSyxTQUFRLEVBQUMsQ0FBQztBQUM5RSxjQUFRQSxTQUFRO0FBQ2hCO0FBQUEsSUFDRDtBQUdBLFVBQU0sUUFBUSxVQUFVLGFBQWEsV0FBVyxrQkFBQUMsVUFBUSxrQkFBQUMsU0FBTTtBQUM5RCxVQUFNLEVBQUMsT0FBTSxJQUFJO0FBQ2pCLFFBQUksV0FBVztBQUVmLFVBQU0sUUFBUSxNQUFNO0FBQ25CLFlBQU0sUUFBUSxJQUFJLFdBQVcsNEJBQTRCO0FBQ3pELGFBQU8sS0FBSztBQUNaLFVBQUksUUFBUSxRQUFRLFFBQVEsZ0JBQWdCLG9CQUFBQyxRQUFPLFVBQVU7QUFDNUQsZ0JBQVEsS0FBSyxRQUFRLEtBQUs7QUFBQSxNQUMzQjtBQUVBLFVBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxNQUFNO0FBQ2hDO0FBQUEsTUFDRDtBQUVBLGVBQVMsS0FBSyxLQUFLLFNBQVMsS0FBSztBQUFBLElBQ2xDO0FBRUEsUUFBSSxVQUFVLE9BQU8sU0FBUztBQUM3QixZQUFNO0FBQ047QUFBQSxJQUNEO0FBRUEsVUFBTSxtQkFBbUIsTUFBTTtBQUM5QixZQUFNO0FBQ04sZUFBUztBQUFBLElBQ1Y7QUFHQSxVQUFNLFdBQVcsS0FBSyxVQUFVLFNBQVMsR0FBRyxPQUFPO0FBRW5ELFFBQUksUUFBUTtBQUNYLGFBQU8saUJBQWlCLFNBQVMsZ0JBQWdCO0FBQUEsSUFDbEQ7QUFFQSxVQUFNLFdBQVcsTUFBTTtBQUN0QixlQUFTLE1BQU07QUFDZixVQUFJLFFBQVE7QUFDWCxlQUFPLG9CQUFvQixTQUFTLGdCQUFnQjtBQUFBLE1BQ3JEO0FBQUEsSUFDRDtBQUVBLGFBQVMsR0FBRyxTQUFTLFdBQVM7QUFDN0IsYUFBTyxJQUFJLFdBQVcsY0FBYyxRQUFRLEdBQUcsb0JBQW9CLE1BQU0sT0FBTyxJQUFJLFVBQVUsS0FBSyxDQUFDO0FBQ3BHLGVBQVM7QUFBQSxJQUNWLENBQUM7QUFFRCx3Q0FBb0MsVUFBVSxXQUFTO0FBQ3RELFVBQUksWUFBWSxTQUFTLE1BQU07QUFDOUIsaUJBQVMsS0FBSyxRQUFRLEtBQUs7QUFBQSxNQUM1QjtBQUFBLElBQ0QsQ0FBQztBQUdELFFBQUksUUFBUSxVQUFVLE9BQU87QUFHNUIsZUFBUyxHQUFHLFVBQVUsQ0FBQUMsT0FBSztBQUMxQixZQUFJO0FBQ0osUUFBQUEsR0FBRSxnQkFBZ0IsT0FBTyxNQUFNO0FBQzlCLGlDQUF1QkEsR0FBRTtBQUFBLFFBQzFCLENBQUM7QUFDRCxRQUFBQSxHQUFFLGdCQUFnQixTQUFTLGNBQVk7QUFFdEMsY0FBSSxZQUFZLHVCQUF1QkEsR0FBRSxnQkFBZ0IsQ0FBQyxVQUFVO0FBQ25FLGtCQUFNLFFBQVEsSUFBSSxNQUFNLGlCQUFpQjtBQUN6QyxrQkFBTSxPQUFPO0FBQ2IscUJBQVMsS0FBSyxLQUFLLFNBQVMsS0FBSztBQUFBLFVBQ2xDO0FBQUEsUUFDRCxDQUFDO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDRjtBQUVBLGFBQVMsR0FBRyxZQUFZLGVBQWE7QUFDcEMsZUFBUyxXQUFXLENBQUM7QUFDckIsWUFBTSxVQUFVLGVBQWUsVUFBVSxVQUFVO0FBR25ELFVBQUksV0FBVyxVQUFVLFVBQVUsR0FBRztBQUVyQyxjQUFNLFdBQVcsUUFBUSxJQUFJLFVBQVU7QUFHdkMsWUFBSSxjQUFjO0FBQ2xCLFlBQUk7QUFDSCx3QkFBYyxhQUFhLE9BQU8sT0FBTyxJQUFJLElBQUksVUFBVSxRQUFRLEdBQUc7QUFBQSxRQUN2RSxRQUFRO0FBSVAsY0FBSSxRQUFRLGFBQWEsVUFBVTtBQUNsQyxtQkFBTyxJQUFJLFdBQVcsd0RBQXdELFFBQVEsSUFBSSxrQkFBa0IsQ0FBQztBQUM3RyxxQkFBUztBQUNUO0FBQUEsVUFDRDtBQUFBLFFBQ0Q7QUFHQSxnQkFBUSxRQUFRLFVBQVU7QUFBQSxVQUN6QixLQUFLO0FBQ0osbUJBQU8sSUFBSSxXQUFXLDBFQUEwRSxRQUFRLEdBQUcsSUFBSSxhQUFhLENBQUM7QUFDN0gscUJBQVM7QUFDVDtBQUFBLFVBQ0QsS0FBSztBQUVKO0FBQUEsVUFDRCxLQUFLLFVBQVU7QUFFZCxnQkFBSSxnQkFBZ0IsTUFBTTtBQUN6QjtBQUFBLFlBQ0Q7QUFHQSxnQkFBSSxRQUFRLFdBQVcsUUFBUSxRQUFRO0FBQ3RDLHFCQUFPLElBQUksV0FBVyxnQ0FBZ0MsUUFBUSxHQUFHLElBQUksY0FBYyxDQUFDO0FBQ3BGLHVCQUFTO0FBQ1Q7QUFBQSxZQUNEO0FBSUEsa0JBQU0saUJBQWlCO0FBQUEsY0FDdEIsU0FBUyxJQUFJLFFBQVEsUUFBUSxPQUFPO0FBQUEsY0FDcEMsUUFBUSxRQUFRO0FBQUEsY0FDaEIsU0FBUyxRQUFRLFVBQVU7QUFBQSxjQUMzQixPQUFPLFFBQVE7QUFBQSxjQUNmLFVBQVUsUUFBUTtBQUFBLGNBQ2xCLFFBQVEsUUFBUTtBQUFBLGNBQ2hCLE1BQU0sTUFBTSxPQUFPO0FBQUEsY0FDbkIsUUFBUSxRQUFRO0FBQUEsY0FDaEIsTUFBTSxRQUFRO0FBQUEsY0FDZCxVQUFVLFFBQVE7QUFBQSxjQUNsQixnQkFBZ0IsUUFBUTtBQUFBLFlBQ3pCO0FBV0EsZ0JBQUksQ0FBQyxvQkFBb0IsUUFBUSxLQUFLLFdBQVcsS0FBSyxDQUFDLGVBQWUsUUFBUSxLQUFLLFdBQVcsR0FBRztBQUNoRyx5QkFBVyxRQUFRLENBQUMsaUJBQWlCLG9CQUFvQixVQUFVLFNBQVMsR0FBRztBQUM5RSwrQkFBZSxRQUFRLE9BQU8sSUFBSTtBQUFBLGNBQ25DO0FBQUEsWUFDRDtBQUdBLGdCQUFJLFVBQVUsZUFBZSxPQUFPLFFBQVEsUUFBUSxTQUFTLGdCQUFnQixvQkFBQUQsUUFBTyxVQUFVO0FBQzdGLHFCQUFPLElBQUksV0FBVyw0REFBNEQsc0JBQXNCLENBQUM7QUFDekcsdUJBQVM7QUFDVDtBQUFBLFlBQ0Q7QUFHQSxnQkFBSSxVQUFVLGVBQWUsUUFBUyxVQUFVLGVBQWUsT0FBTyxVQUFVLGVBQWUsUUFBUSxRQUFRLFdBQVcsUUFBUztBQUNsSSw2QkFBZSxTQUFTO0FBQ3hCLDZCQUFlLE9BQU87QUFDdEIsNkJBQWUsUUFBUSxPQUFPLGdCQUFnQjtBQUFBLFlBQy9DO0FBR0Esa0JBQU0seUJBQXlCLDhCQUE4QixPQUFPO0FBQ3BFLGdCQUFJLHdCQUF3QjtBQUMzQiw2QkFBZSxpQkFBaUI7QUFBQSxZQUNqQztBQUdBLG9CQUFRLE1BQU0sSUFBSSxRQUFRLGFBQWEsY0FBYyxDQUFDLENBQUM7QUFDdkQscUJBQVM7QUFDVDtBQUFBLFVBQ0Q7QUFBQSxVQUVBO0FBQ0MsbUJBQU8sT0FBTyxJQUFJLFVBQVUsb0JBQW9CLFFBQVEsUUFBUSwyQ0FBMkMsQ0FBQztBQUFBLFFBQzlHO0FBQUEsTUFDRDtBQUdBLFVBQUksUUFBUTtBQUNYLGtCQUFVLEtBQUssT0FBTyxNQUFNO0FBQzNCLGlCQUFPLG9CQUFvQixTQUFTLGdCQUFnQjtBQUFBLFFBQ3JELENBQUM7QUFBQSxNQUNGO0FBRUEsVUFBSSxXQUFPLG9CQUFBRSxVQUFLLFdBQVcsSUFBSSxnQ0FBWSxHQUFHLFdBQVM7QUFDdEQsWUFBSSxPQUFPO0FBQ1YsaUJBQU8sS0FBSztBQUFBLFFBQ2I7QUFBQSxNQUNELENBQUM7QUFHRCxVQUFJLFFBQVEsVUFBVSxVQUFVO0FBQy9CLGtCQUFVLEdBQUcsV0FBVyxnQkFBZ0I7QUFBQSxNQUN6QztBQUVBLFlBQU0sa0JBQWtCO0FBQUEsUUFDdkIsS0FBSyxRQUFRO0FBQUEsUUFDYixRQUFRLFVBQVU7QUFBQSxRQUNsQixZQUFZLFVBQVU7QUFBQSxRQUN0QjtBQUFBLFFBQ0EsTUFBTSxRQUFRO0FBQUEsUUFDZCxTQUFTLFFBQVE7QUFBQSxRQUNqQixlQUFlLFFBQVE7QUFBQSxNQUN4QjtBQUdBLFlBQU0sVUFBVSxRQUFRLElBQUksa0JBQWtCO0FBVTlDLFVBQUksQ0FBQyxRQUFRLFlBQVksUUFBUSxXQUFXLFVBQVUsWUFBWSxRQUFRLFVBQVUsZUFBZSxPQUFPLFVBQVUsZUFBZSxLQUFLO0FBQ3ZJLG1CQUFXLElBQUksU0FBUyxNQUFNLGVBQWU7QUFDN0MsZ0JBQVEsUUFBUTtBQUNoQjtBQUFBLE1BQ0Q7QUFPQSxZQUFNLGNBQWM7QUFBQSxRQUNuQixPQUFPLGlCQUFBQyxRQUFLO0FBQUEsUUFDWixhQUFhLGlCQUFBQSxRQUFLO0FBQUEsTUFDbkI7QUFHQSxVQUFJLFlBQVksVUFBVSxZQUFZLFVBQVU7QUFDL0MsbUJBQU8sb0JBQUFELFVBQUssTUFBTSxpQkFBQUMsUUFBSyxhQUFhLFdBQVcsR0FBRyxXQUFTO0FBQzFELGNBQUksT0FBTztBQUNWLG1CQUFPLEtBQUs7QUFBQSxVQUNiO0FBQUEsUUFDRCxDQUFDO0FBQ0QsbUJBQVcsSUFBSSxTQUFTLE1BQU0sZUFBZTtBQUM3QyxnQkFBUSxRQUFRO0FBQ2hCO0FBQUEsTUFDRDtBQUdBLFVBQUksWUFBWSxhQUFhLFlBQVksYUFBYTtBQUdyRCxjQUFNLFVBQU0sb0JBQUFELFVBQUssV0FBVyxJQUFJLGdDQUFZLEdBQUcsV0FBUztBQUN2RCxjQUFJLE9BQU87QUFDVixtQkFBTyxLQUFLO0FBQUEsVUFDYjtBQUFBLFFBQ0QsQ0FBQztBQUNELFlBQUksS0FBSyxRQUFRLFdBQVM7QUFFekIsZUFBSyxNQUFNLENBQUMsSUFBSSxRQUFVLEdBQU07QUFDL0IsdUJBQU8sb0JBQUFBLFVBQUssTUFBTSxpQkFBQUMsUUFBSyxjQUFjLEdBQUcsV0FBUztBQUNoRCxrQkFBSSxPQUFPO0FBQ1YsdUJBQU8sS0FBSztBQUFBLGNBQ2I7QUFBQSxZQUNELENBQUM7QUFBQSxVQUNGLE9BQU87QUFDTix1QkFBTyxvQkFBQUQsVUFBSyxNQUFNLGlCQUFBQyxRQUFLLGlCQUFpQixHQUFHLFdBQVM7QUFDbkQsa0JBQUksT0FBTztBQUNWLHVCQUFPLEtBQUs7QUFBQSxjQUNiO0FBQUEsWUFDRCxDQUFDO0FBQUEsVUFDRjtBQUVBLHFCQUFXLElBQUksU0FBUyxNQUFNLGVBQWU7QUFDN0Msa0JBQVEsUUFBUTtBQUFBLFFBQ2pCLENBQUM7QUFDRCxZQUFJLEtBQUssT0FBTyxNQUFNO0FBR3JCLGNBQUksQ0FBQyxVQUFVO0FBQ2QsdUJBQVcsSUFBSSxTQUFTLE1BQU0sZUFBZTtBQUM3QyxvQkFBUSxRQUFRO0FBQUEsVUFDakI7QUFBQSxRQUNELENBQUM7QUFDRDtBQUFBLE1BQ0Q7QUFHQSxVQUFJLFlBQVksTUFBTTtBQUNyQixtQkFBTyxvQkFBQUQsVUFBSyxNQUFNLGlCQUFBQyxRQUFLLHVCQUF1QixHQUFHLFdBQVM7QUFDekQsY0FBSSxPQUFPO0FBQ1YsbUJBQU8sS0FBSztBQUFBLFVBQ2I7QUFBQSxRQUNELENBQUM7QUFDRCxtQkFBVyxJQUFJLFNBQVMsTUFBTSxlQUFlO0FBQzdDLGdCQUFRLFFBQVE7QUFDaEI7QUFBQSxNQUNEO0FBR0EsaUJBQVcsSUFBSSxTQUFTLE1BQU0sZUFBZTtBQUM3QyxjQUFRLFFBQVE7QUFBQSxJQUNqQixDQUFDO0FBR0Qsa0JBQWMsVUFBVSxPQUFPLEVBQUUsTUFBTSxNQUFNO0FBQUEsRUFDOUMsQ0FBQztBQUNGO0FBRUEsU0FBUyxvQ0FBb0MsU0FBUyxlQUFlO0FBQ3BFLFFBQU0sYUFBYSwyQkFBTyxLQUFLLFdBQVc7QUFFMUMsTUFBSSxvQkFBb0I7QUFDeEIsTUFBSSwwQkFBMEI7QUFDOUIsTUFBSTtBQUVKLFVBQVEsR0FBRyxZQUFZLGNBQVk7QUFDbEMsVUFBTSxFQUFDLFFBQU8sSUFBSTtBQUNsQix3QkFBb0IsUUFBUSxtQkFBbUIsTUFBTSxhQUFhLENBQUMsUUFBUSxnQkFBZ0I7QUFBQSxFQUM1RixDQUFDO0FBRUQsVUFBUSxHQUFHLFVBQVUsWUFBVTtBQUM5QixVQUFNLGdCQUFnQixNQUFNO0FBQzNCLFVBQUkscUJBQXFCLENBQUMseUJBQXlCO0FBQ2xELGNBQU0sUUFBUSxJQUFJLE1BQU0saUJBQWlCO0FBQ3pDLGNBQU0sT0FBTztBQUNiLHNCQUFjLEtBQUs7QUFBQSxNQUNwQjtBQUFBLElBQ0Q7QUFFQSxVQUFNLFNBQVMsU0FBTztBQUNyQixnQ0FBMEIsMkJBQU8sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHLFVBQVUsTUFBTTtBQUd4RSxVQUFJLENBQUMsMkJBQTJCLGVBQWU7QUFDOUMsa0NBQ0MsMkJBQU8sUUFBUSxjQUFjLE1BQU0sRUFBRSxHQUFHLFdBQVcsTUFBTSxHQUFHLENBQUMsQ0FBQyxNQUFNLEtBQ3BFLDJCQUFPLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRyxXQUFXLE1BQU0sQ0FBQyxDQUFDLE1BQU07QUFBQSxNQUV6RDtBQUVBLHNCQUFnQjtBQUFBLElBQ2pCO0FBRUEsV0FBTyxnQkFBZ0IsU0FBUyxhQUFhO0FBQzdDLFdBQU8sR0FBRyxRQUFRLE1BQU07QUFFeEIsWUFBUSxHQUFHLFNBQVMsTUFBTTtBQUN6QixhQUFPLGVBQWUsU0FBUyxhQUFhO0FBQzVDLGFBQU8sZUFBZSxRQUFRLE1BQU07QUFBQSxJQUNyQyxDQUFDO0FBQUEsRUFDRixDQUFDO0FBQ0Y7OztBRHhaQSxxQkFBbUI7OztBY1JuQixJQUFNLFdBQU4sTUFBTSxrQkFBaUIsTUFBTTtBQUFBLEVBQzNCLFlBQVksTUFBTSxTQUFTLFlBQVksVUFBVTtBQUMvQyxRQUFJLE1BQU0sUUFBUSxPQUFPLEVBQUcsV0FBVSxRQUFRLEtBQUssR0FBRyxFQUFFLEtBQUs7QUFDN0QsVUFBTSxPQUFPO0FBQ2IsUUFBSSxNQUFNLHNCQUFzQixRQUFXO0FBQ3pDLFlBQU0sa0JBQWtCLE1BQU0sU0FBUTtBQUFBLElBQ3hDO0FBQ0EsU0FBSyxPQUFPO0FBQ1osZUFBVyxXQUFXLFVBQVU7QUFDOUIsaUJBQVcsT0FBTyxTQUFTO0FBQ3pCLGNBQU0sUUFBUSxRQUFRLEdBQUc7QUFDekIsYUFBSyxHQUFHLElBQUksT0FBTyxTQUFTLEtBQUssSUFDN0IsTUFBTSxTQUFTLFFBQVEsUUFBUSxJQUMvQixTQUFTLE9BQ1AsUUFDQSxLQUFLLE1BQU0sS0FBSyxVQUFVLEtBQUssQ0FBQztBQUFBLE1BQ3hDO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRjs7O0FDbkJBLElBQU0sWUFBWSxTQUFVLEtBQUs7QUFDL0IsU0FBTyxPQUFPLFFBQVEsWUFBWSxRQUFRLFFBQVEsQ0FBQyxNQUFNLFFBQVEsR0FBRztBQUN0RTs7O0FDQ0EsSUFBTSwwQkFBMEIsU0FBVSxTQUFTO0FBQ2pELFFBQU0sb0JBQW9CLENBQUM7QUFDM0IsV0FBU0MsS0FBSSxHQUFHLElBQUksUUFBUSxRQUFRQSxLQUFJLEdBQUdBLE1BQUs7QUFDOUMsVUFBTSxTQUFTLFFBQVFBLEVBQUM7QUFDeEIsUUFBSSxXQUFXLFVBQWEsV0FBVyxRQUFRLFdBQVcsT0FBTztBQUMvRCx3QkFBa0JBLEVBQUMsSUFBSSxFQUFFLFVBQVUsS0FBSztBQUFBLElBQzFDLFdBQVcsT0FBTyxXQUFXLFVBQVU7QUFDckMsd0JBQWtCQSxFQUFDLElBQUksRUFBRSxNQUFNLE9BQU87QUFBQSxJQUN4QyxXQUFXLFVBQVUsTUFBTSxHQUFHO0FBQzVCLFVBQUksT0FBTyxPQUFPLFNBQVMsVUFBVTtBQUNuQyxjQUFNLElBQUksU0FBUyxtQ0FBbUM7QUFBQSxVQUNwRDtBQUFBLFVBQ0EsMkNBQTJDQSxFQUFDO0FBQUEsVUFDNUM7QUFBQSxRQUNGLENBQUM7QUFBQSxNQUNIO0FBQ0Esd0JBQWtCQSxFQUFDLElBQUk7QUFBQSxJQUN6QixPQUFPO0FBQ0wsWUFBTSxJQUFJLFNBQVMsaUNBQWlDO0FBQUEsUUFDbEQ7QUFBQSxRQUNBO0FBQUEsUUFDQSxPQUFPLEtBQUssVUFBVSxNQUFNLENBQUMsZ0JBQWdCQSxFQUFDO0FBQUEsTUFDaEQsQ0FBQztBQUFBLElBQ0g7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUNUOzs7QUM3QkEsSUFBTSxtQkFBTixNQUF1QjtBQUFBLEVBQ3JCLFlBQVksT0FBTyxLQUFLO0FBQ3RCLFNBQUssT0FBTztBQUNaLFNBQUssU0FBUztBQUNkLFNBQUssTUFBTSxPQUFPLFlBQVksSUFBSTtBQUFBLEVBQ3BDO0FBQUEsRUFDQSxRQUFRLEtBQUs7QUFDWCxRQUFJLE9BQU8sU0FBUyxHQUFHLEdBQUc7QUFDeEIsWUFBTSxTQUFTLEtBQUssU0FBUyxJQUFJO0FBQ2pDLFVBQUksVUFBVSxLQUFLLE1BQU07QUFDdkIsYUFBSyxPQUFPO0FBQ1osWUFBSSxVQUFVLEtBQUssTUFBTTtBQUN2QixnQkFBTSxNQUFNLHNCQUFzQjtBQUFBLFFBQ3BDO0FBQUEsTUFDRjtBQUNBLFlBQU0sTUFBTSxLQUFLO0FBQ2pCLFdBQUssTUFBTSxPQUFPLFlBQVksS0FBSyxJQUFJO0FBQ3ZDLFVBQUksS0FBSyxLQUFLLEtBQUssQ0FBQztBQUNwQixVQUFJLEtBQUssS0FBSyxLQUFLLElBQUksTUFBTTtBQUM3QixXQUFLLFVBQVUsSUFBSTtBQUFBLElBQ3JCLE9BQU87QUFDTCxZQUFNLFNBQVMsS0FBSztBQUNwQixVQUFJLFdBQVcsS0FBSyxNQUFNO0FBQ3hCLGFBQUssT0FBTztBQUFBLE1BQ2Q7QUFDQSxZQUFNLE1BQU0sS0FBSyxNQUFNO0FBQ3ZCLFdBQUssSUFBSSxDQUFDLElBQUk7QUFDZCxVQUFJLEtBQUssS0FBSyxLQUFLLEdBQUcsR0FBRyxNQUFNO0FBQUEsSUFDakM7QUFBQSxFQUNGO0FBQUEsRUFDQSxPQUFPLEtBQUs7QUFDVixVQUFNLFNBQVMsS0FBSztBQUNwQixRQUFJLFdBQVcsS0FBSyxNQUFNO0FBQ3hCLFdBQUssT0FBTztBQUFBLElBQ2Q7QUFDQSxTQUFLLElBQUksTUFBTSxJQUFJO0FBQUEsRUFDckI7QUFBQSxFQUNBLFFBQVE7QUFDTixXQUFPLE9BQU8sS0FBSyxLQUFLLElBQUksTUFBTSxHQUFHLEtBQUssTUFBTSxDQUFDO0FBQUEsRUFDbkQ7QUFBQSxFQUNBLFNBQVM7QUFDUCxVQUFNLFNBQVMsS0FBSztBQUNwQixTQUFLLE9BQU8sS0FBSyxPQUFPO0FBQ3hCLFVBQU0sTUFBTSxPQUFPLFlBQVksS0FBSyxJQUFJO0FBQ3hDLFNBQUssSUFBSSxLQUFLLEtBQUssR0FBRyxHQUFHLE1BQU07QUFDL0IsU0FBSyxNQUFNO0FBQUEsRUFDYjtBQUFBLEVBQ0EsU0FBUyxVQUFVO0FBQ2pCLFFBQUksVUFBVTtBQUNaLGFBQU8sS0FBSyxJQUFJLE1BQU0sR0FBRyxLQUFLLE1BQU0sRUFBRSxTQUFTLFFBQVE7QUFBQSxJQUN6RCxPQUFPO0FBQ0wsYUFBTyxXQUFXLFVBQVUsTUFBTSxLQUFLLEtBQUssSUFBSSxNQUFNLEdBQUcsS0FBSyxNQUFNLENBQUM7QUFBQSxJQUN2RTtBQUFBLEVBQ0Y7QUFBQSxFQUNBLFNBQVM7QUFDUCxXQUFPLEtBQUssU0FBUyxNQUFNO0FBQUEsRUFDN0I7QUFBQSxFQUNBLFFBQVE7QUFDTixTQUFLLFNBQVM7QUFBQSxFQUNoQjtBQUNGO0FBRUEsSUFBTywyQkFBUTs7O0FDeERmLElBQU0sS0FBSztBQUNYLElBQU0sS0FBSztBQUNYLElBQU0sS0FBSztBQUNYLElBQU0sUUFBUTtBQUNkLElBQU0sTUFBTTtBQUVaLElBQU0sYUFBYSxTQUFVLFNBQVM7QUFDcEMsU0FBTztBQUFBLElBQ0wsWUFBWTtBQUFBLElBQ1osZUFBZTtBQUFBLElBQ2YsV0FBVyxRQUFRO0FBQUEsSUFDbkIsWUFBWTtBQUFBO0FBQUEsSUFFWixPQUFPO0FBQUEsSUFDUCxTQUFTLFFBQVEsY0FBYztBQUFBLElBQy9CLFVBQVU7QUFBQSxJQUNWLGVBQ0UsT0FBTyxTQUFTLFFBQVEsTUFBTSxLQUM5QixPQUFPLFNBQVMsUUFBUSxLQUFLLEtBQzdCLE9BQU8sUUFBUSxRQUFRLFFBQVEsUUFBUSxLQUFLLE1BQU07QUFBQTtBQUFBLElBRXBELHNCQUFzQixNQUFNLFFBQVEsUUFBUSxPQUFPLElBQy9DLFFBQVEsUUFBUSxTQUNoQjtBQUFBLElBQ0osT0FBTyxJQUFJLHlCQUFpQixFQUFFO0FBQUEsSUFDOUIsb0JBQW9CLFFBQVE7QUFBQSxJQUM1QixrQkFBa0IsS0FBSztBQUFBO0FBQUEsTUFFckIsUUFBUSxZQUFZLE9BQU8sUUFBUSxRQUFRLFNBQVM7QUFBQSxNQUVwRCxHQUFHLFFBQVEsVUFBVSxJQUFJLENBQUMsY0FBYyxVQUFVLE1BQU07QUFBQTtBQUFBLE1BRXhELFFBQVEsVUFBVSxPQUFPLFFBQVEsTUFBTSxTQUFTO0FBQUEsSUFDbEQ7QUFBQSxJQUNBLGFBQWE7QUFBQSxJQUNiLFNBQVM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLFdBQVcsSUFBSSx5QkFBaUIsR0FBRztBQUFBLElBQ25DLFFBQVEsQ0FBQztBQUFBLElBQ1QsZ0JBQWdCO0FBQUEsSUFDaEIsZUFBZTtBQUFBLElBQ2YsMEJBQ0UsUUFBUSxpQkFBaUIsV0FBVyxJQUNoQyxJQUNBLEtBQUssSUFBSSxHQUFHLFFBQVEsaUJBQWlCLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO0FBQUEsSUFDL0QsV0FBVztBQUFBLE1BQ1QsT0FBTyxLQUFLLEtBQUssUUFBUSxRQUFRLEVBQUUsQ0FBQztBQUFBLE1BQ3BDLE9BQU8sS0FBSyxLQUFNLFFBQVEsUUFBUSxFQUFFLENBQUM7QUFBQSxJQUN2QztBQUFBLElBQ0EsWUFBWTtBQUFBLElBQ1osaUJBQWlCO0FBQUEsSUFDakIsVUFBVTtBQUFBLE1BQ1IsT0FBTyxLQUFLLE9BQU8sS0FBSyxDQUFDLEVBQUUsR0FBRyxNQUFNLEVBQUUsU0FBUyxHQUFHLFFBQVEsUUFBUTtBQUFBLE1BQ2xFLE9BQU8sS0FBSyxPQUFPLEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTSxFQUFFLFNBQVMsR0FBRyxRQUFRLFFBQVE7QUFBQSxNQUNsRSxPQUFPLEtBQUssT0FBTyxLQUFLLENBQUMsRUFBRSxHQUFHLE1BQU0sRUFBRSxTQUFTLEdBQUcsUUFBUSxRQUFRO0FBQUEsTUFDbEUsT0FBTyxLQUFLLE9BQU8sS0FBSyxDQUFDLEtBQUssR0FBRyxNQUFNLEVBQUUsU0FBUyxHQUFHLFFBQVEsUUFBUTtBQUFBLE1BQ3JFLE9BQU8sS0FBSyxPQUFPLEtBQUssQ0FBQyxHQUFHLEdBQUcsTUFBTSxFQUFFLFNBQVMsR0FBRyxRQUFRLFFBQVE7QUFBQSxJQUNyRTtBQUFBLEVBQ0Y7QUFDRjs7O0FDakVBLElBQU0sYUFBYSxTQUFVLEtBQUs7QUFDaEMsU0FBTyxJQUFJLFFBQVEsWUFBWSxTQUFVLEdBQUcsT0FBTztBQUNqRCxXQUFPLE1BQU0sTUFBTSxZQUFZO0FBQUEsRUFDakMsQ0FBQztBQUNIOzs7QUNBQSxJQUFNLG9CQUFvQixTQUFVLE1BQU07QUFDeEMsUUFBTSxVQUFVLENBQUM7QUFFakIsYUFBVyxPQUFPLE1BQU07QUFDdEIsWUFBUSxXQUFXLEdBQUcsQ0FBQyxJQUFJLEtBQUssR0FBRztBQUFBLEVBQ3JDO0FBSUEsTUFBSSxRQUFRLGFBQWEsVUFBYSxRQUFRLGFBQWEsTUFBTTtBQUMvRCxZQUFRLFdBQVc7QUFBQSxFQUNyQixXQUFXLFFBQVEsYUFBYSxRQUFRLFFBQVEsYUFBYSxPQUFPO0FBQ2xFLFlBQVEsV0FBVztBQUFBLEVBQ3JCLFdBQ0UsT0FBTyxRQUFRLGFBQWEsWUFDNUIsUUFBUSxhQUFhLE1BQ3JCO0FBQ0EsVUFBTSxJQUFJO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0EsT0FBTyxLQUFLLFVBQVUsUUFBUSxRQUFRLENBQUM7QUFBQSxNQUN6QztBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVBLE1BQ0UsUUFBUSxRQUFRLFVBQ2hCLFFBQVEsUUFBUSxRQUNoQixRQUFRLFFBQVEsT0FDaEI7QUFDQSxZQUFRLE1BQU07QUFBQSxFQUNoQixXQUFXLFFBQVEsUUFBUSxNQUFNO0FBQy9CLFVBQU0sSUFBSTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRTtBQUFBLFFBQ0E7QUFBQSxRQUNBLE9BQU8sS0FBSyxVQUFVLFFBQVEsR0FBRyxDQUFDO0FBQUEsTUFDcEM7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFQSxVQUFRLGdCQUFnQjtBQUN4QixNQUNFLFFBQVEsU0FBUyxVQUNqQixRQUFRLFNBQVMsUUFDakIsUUFBUSxTQUFTLFNBQ2pCLFFBQVEsU0FBUyxJQUNqQjtBQUNBLFlBQVEsT0FBTztBQUFBLEVBQ2pCLFdBQVcsT0FBTyxRQUFRLFNBQVMsWUFBWTtBQUM3QyxZQUFRLGdCQUFnQixRQUFRO0FBQ2hDLFlBQVEsT0FBTztBQUFBLEVBQ2pCLFdBQVcsUUFBUSxTQUFTLE1BQU07QUFDaEMsVUFBTSxJQUFJO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0EsT0FBTyxLQUFLLFVBQVUsUUFBUSxJQUFJLENBQUM7QUFBQSxNQUNyQztBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVBLE1BQ0UsUUFBUSxjQUFjLFVBQ3RCLFFBQVEsY0FBYyxRQUN0QixRQUFRLGNBQWMsU0FDdEIsUUFBUSxjQUFjLElBQ3RCO0FBQ0EsWUFBUSxZQUFZO0FBQUEsRUFDdEIsV0FBVyxRQUFRLGNBQWMsTUFBTTtBQUNyQyxZQUFRLFlBQVksU0FBVSxPQUFPO0FBQ25DLFlBQU0sT0FBTyxLQUFLLE1BQU0sS0FBSztBQUM3QixhQUFPLENBQUMsTUFBTSxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksSUFBSTtBQUFBLElBQ3pDO0FBQUEsRUFDRixXQUFXLE9BQU8sUUFBUSxjQUFjLFlBQVk7QUFDbEQsVUFBTSxJQUFJO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0EsT0FBTyxLQUFLLFVBQVUsUUFBUSxTQUFTLENBQUM7QUFBQSxNQUMxQztBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVBLFVBQVEsNEJBQTRCO0FBQ3BDLE1BQUksUUFBUSxZQUFZLE1BQU07QUFFNUIsWUFBUSw0QkFBNEI7QUFBQSxFQUN0QyxXQUFXLE9BQU8sUUFBUSxZQUFZLFlBQVk7QUFDaEQsWUFBUSw0QkFBNEIsUUFBUTtBQUM1QyxZQUFRLFVBQVU7QUFBQSxFQUNwQixXQUFXLE1BQU0sUUFBUSxRQUFRLE9BQU8sR0FBRztBQUN6QyxZQUFRLFVBQVUsd0JBQXdCLFFBQVEsT0FBTztBQUFBLEVBQzNELFdBQ0UsUUFBUSxZQUFZLFVBQ3BCLFFBQVEsWUFBWSxRQUNwQixRQUFRLFlBQVksT0FDcEI7QUFDQSxZQUFRLFVBQVU7QUFBQSxFQUNwQixPQUFPO0FBQ0wsVUFBTSxJQUFJO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0EsT0FBTyxLQUFLLFVBQVUsUUFBUSxPQUFPLENBQUM7QUFBQSxNQUN4QztBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVBLE1BQ0UsUUFBUSwwQkFBMEIsVUFDbEMsUUFBUSwwQkFBMEIsUUFDbEMsUUFBUSwwQkFBMEIsT0FDbEM7QUFDQSxZQUFRLHdCQUF3QjtBQUFBLEVBQ2xDLFdBQVcsUUFBUSwwQkFBMEIsTUFBTTtBQUNqRCxVQUFNLElBQUk7QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0U7QUFBQSxRQUNBO0FBQUEsUUFDQSxPQUFPLEtBQUssVUFBVSxRQUFRLHFCQUFxQixDQUFDO0FBQUEsTUFDdEQ7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUFBLEVBQ0YsV0FBVyxRQUFRLFlBQVksT0FBTztBQUNwQyxVQUFNLElBQUk7QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0U7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVBLE1BQ0UsUUFBUSxZQUFZLFVBQ3BCLFFBQVEsWUFBWSxRQUNwQixRQUFRLFlBQVksU0FDcEIsUUFBUSxZQUFZLElBQ3BCO0FBQ0EsWUFBUSxVQUFVO0FBQUEsRUFDcEIsT0FBTztBQUNMLFFBQUksT0FBTyxRQUFRLFlBQVksVUFBVTtBQUN2QyxjQUFRLFVBQVUsT0FBTyxLQUFLLFFBQVEsU0FBUyxRQUFRLFFBQVE7QUFBQSxJQUNqRTtBQUNBLFFBQUksQ0FBQyxPQUFPLFNBQVMsUUFBUSxPQUFPLEdBQUc7QUFDckMsWUFBTSxJQUFJO0FBQUEsUUFDUjtBQUFBLFFBQ0E7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0EsT0FBTyxLQUFLLFVBQVUsUUFBUSxPQUFPLENBQUM7QUFBQSxRQUN4QztBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFQSxNQUNFLFFBQVEscUJBQXFCLFVBQzdCLFFBQVEscUJBQXFCLFFBQzdCLFFBQVEscUJBQXFCLE9BQzdCO0FBQ0EsWUFBUSxtQkFBbUI7QUFBQSxFQUM3QixXQUFXLFFBQVEscUJBQXFCLE1BQU07QUFDNUMsVUFBTSxJQUFJO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0EsT0FBTyxLQUFLLFVBQVUsUUFBUSxnQkFBZ0IsQ0FBQztBQUFBLE1BQ2pEO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBRUEsUUFBTSxpQkFBaUIsS0FBSyxVQUFVLFFBQVEsU0FBUztBQUN2RCxNQUFJLENBQUMsTUFBTSxRQUFRLFFBQVEsU0FBUztBQUNsQyxZQUFRLFlBQVksQ0FBQyxRQUFRLFNBQVM7QUFDeEMsTUFBSSxRQUFRLFVBQVUsV0FBVyxHQUFHO0FBQ2xDLFVBQU0sSUFBSTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRTtBQUFBLFFBQ0E7QUFBQSxRQUNBLE9BQU8sY0FBYztBQUFBLE1BQ3ZCO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsVUFBUSxZQUFZLFFBQVEsVUFBVSxJQUFJLFNBQVUsV0FBVztBQUM3RCxRQUFJLGNBQWMsVUFBYSxjQUFjLFFBQVEsY0FBYyxPQUFPO0FBQ3hFLGFBQU8sT0FBTyxLQUFLLEtBQUssUUFBUSxRQUFRO0FBQUEsSUFDMUM7QUFDQSxRQUFJLE9BQU8sY0FBYyxVQUFVO0FBQ2pDLGtCQUFZLE9BQU8sS0FBSyxXQUFXLFFBQVEsUUFBUTtBQUFBLElBQ3JEO0FBQ0EsUUFBSSxDQUFDLE9BQU8sU0FBUyxTQUFTLEtBQUssVUFBVSxXQUFXLEdBQUc7QUFDekQsWUFBTSxJQUFJO0FBQUEsUUFDUjtBQUFBLFFBQ0E7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0EsT0FBTyxjQUFjO0FBQUEsUUFDdkI7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxXQUFPO0FBQUEsRUFDVCxDQUFDO0FBRUQsTUFBSSxRQUFRLFdBQVcsVUFBYSxRQUFRLFdBQVcsTUFBTTtBQUMzRCxZQUFRLFNBQVMsT0FBTyxLQUFLLEtBQUssUUFBUSxRQUFRO0FBQUEsRUFDcEQsV0FBVyxPQUFPLFFBQVEsV0FBVyxVQUFVO0FBQzdDLFlBQVEsU0FBUyxPQUFPLEtBQUssUUFBUSxRQUFRLFFBQVEsUUFBUTtBQUFBLEVBQy9ELFdBQVcsUUFBUSxXQUFXLFFBQVEsUUFBUSxXQUFXLE9BQU87QUFDOUQsWUFBUSxTQUFTO0FBQUEsRUFDbkI7QUFDQSxNQUFJLFFBQVEsV0FBVyxNQUFNO0FBQzNCLFFBQUksQ0FBQyxPQUFPLFNBQVMsUUFBUSxNQUFNLEdBQUc7QUFDcEMsWUFBTSxJQUFJO0FBQUEsUUFDUix1RUFBdUUsS0FBSyxVQUFVLFFBQVEsTUFBTSxDQUFDO0FBQUEsTUFDdkc7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVBLE1BQUksUUFBUSxTQUFTLFVBQWEsUUFBUSxTQUFTLE1BQU07QUFDdkQsWUFBUSxPQUFPO0FBQUEsRUFDakIsT0FBTztBQUNMLFFBQUksT0FBTyxRQUFRLFNBQVMsWUFBWSxNQUFNLEtBQUssUUFBUSxJQUFJLEdBQUc7QUFDaEUsY0FBUSxPQUFPLFNBQVMsUUFBUSxJQUFJO0FBQUEsSUFDdEM7QUFDQSxRQUFJLE9BQU8sVUFBVSxRQUFRLElBQUksR0FBRztBQUNsQyxVQUFJLFFBQVEsT0FBTyxHQUFHO0FBQ3BCLGNBQU0sSUFBSTtBQUFBLFVBQ1Isd0RBQXdELEtBQUssVUFBVSxLQUFLLElBQUksQ0FBQztBQUFBLFFBQ25GO0FBQUEsTUFDRjtBQUFBLElBQ0YsT0FBTztBQUNMLFlBQU0sSUFBSTtBQUFBLFFBQ1IsZ0RBQWdELEtBQUssVUFBVSxRQUFRLElBQUksQ0FBQztBQUFBLE1BQzlFO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFQSxNQUFJLFFBQVEsY0FBYyxVQUFhLFFBQVEsY0FBYyxNQUFNO0FBQ2pFLFlBQVEsWUFBWTtBQUFBLEVBQ3RCLE9BQU87QUFDTCxRQUNFLE9BQU8sUUFBUSxjQUFjLFlBQzdCLE1BQU0sS0FBSyxRQUFRLFNBQVMsR0FDNUI7QUFDQSxjQUFRLFlBQVksU0FBUyxRQUFRLFNBQVM7QUFBQSxJQUNoRDtBQUNBLFFBQUksT0FBTyxVQUFVLFFBQVEsU0FBUyxHQUFHO0FBQ3ZDLFVBQUksUUFBUSxhQUFhLEdBQUc7QUFDMUIsY0FBTSxJQUFJO0FBQUEsVUFDUiw0RUFBNEUsS0FBSyxVQUFVLEtBQUssU0FBUyxDQUFDO0FBQUEsUUFDNUc7QUFBQSxNQUNGO0FBQUEsSUFDRixPQUFPO0FBQ0wsWUFBTSxJQUFJO0FBQUEsUUFDUixxREFBcUQsS0FBSyxVQUFVLEtBQUssU0FBUyxDQUFDO0FBQUEsTUFDckY7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVBLE1BQ0UsUUFBUSwyQkFBMkIsVUFDbkMsUUFBUSwyQkFBMkIsTUFDbkM7QUFDQSxZQUFRLHlCQUF5QjtBQUFBLEVBQ25DLFdBQVcsT0FBTyxRQUFRLDJCQUEyQixVQUFVO0FBQzdELFlBQVEseUJBQXlCLEtBQUssTUFBTSxRQUFRLHNCQUFzQjtBQUMxRSxRQUFJLFFBQVEsMkJBQTJCLEdBQUc7QUFDeEMsY0FBUSx5QkFBeUI7QUFBQSxJQUNuQztBQUFBLEVBQ0YsV0FBVyxPQUFPLFFBQVEsMkJBQTJCLFdBQVc7QUFDOUQsVUFBTSxJQUFJO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0EsT0FBTyxLQUFLLFVBQVUsUUFBUSxzQkFBc0IsQ0FBQztBQUFBLE1BQ3ZEO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsTUFBSSxRQUFRLDJCQUEyQixRQUFRLFFBQVEsWUFBWSxPQUFPO0FBQ3hFLFVBQU0sSUFBSTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBRUEsTUFDRSxRQUFRLFNBQVMsVUFDakIsUUFBUSxTQUFTLFFBQ2pCLFFBQVEsU0FBUyxPQUNqQjtBQUNBLFlBQVEsT0FBTztBQUFBLEVBQ2pCLFdBQVcsUUFBUSxTQUFTLE1BQU07QUFDaEMsVUFBTSxJQUFJO0FBQUEsTUFDUiwwQ0FBMEMsS0FBSyxVQUFVLFFBQVEsSUFBSSxDQUFDO0FBQUEsSUFDeEU7QUFBQSxFQUNGO0FBRUEsTUFDRSxRQUFRLG9CQUFvQixVQUM1QixRQUFRLG9CQUFvQixRQUM1QixRQUFRLG9CQUFvQixPQUM1QjtBQUNBLFlBQVEsa0JBQWtCO0FBQUEsRUFDNUIsV0FDRSxPQUFPLFVBQVUsUUFBUSxlQUFlLEtBQ3hDLFFBQVEsbUJBQW1CLEdBQzNCO0FBQUEsRUFFRixXQUNFLE9BQU8sUUFBUSxvQkFBb0IsWUFDbkMsTUFBTSxLQUFLLFFBQVEsZUFBZSxHQUNsQztBQUNBLFlBQVEsa0JBQWtCLFNBQVMsUUFBUSxlQUFlO0FBQUEsRUFDNUQsT0FBTztBQUNMLFVBQU0sSUFBSTtBQUFBLE1BQ1IsbUVBQW1FLEtBQUssVUFBVSxRQUFRLGVBQWUsQ0FBQztBQUFBLElBQzVHO0FBQUEsRUFDRjtBQUVBLE1BQ0UsUUFBUSxZQUFZLFVBQ3BCLFFBQVEsWUFBWSxRQUNwQixRQUFRLFlBQVksT0FDcEI7QUFDQSxZQUFRLFVBQVU7QUFBQSxFQUNwQixXQUFXLE9BQU8sU0FBUyxRQUFRLE9BQU8sR0FBRztBQUMzQyxRQUFJLFFBQVEsUUFBUSxXQUFXLEdBQUc7QUFDaEMsWUFBTSxJQUFJLE1BQU0sb0RBQW9EO0FBQUEsSUFDdEU7QUFDQSxRQUFJLFFBQVEsYUFBYSxNQUFNO0FBQUEsSUFFL0IsT0FBTztBQUNMLGNBQVEsVUFBVSxRQUFRLFFBQVEsU0FBUyxRQUFRLFFBQVE7QUFBQSxJQUM3RDtBQUFBLEVBQ0YsV0FBVyxPQUFPLFFBQVEsWUFBWSxVQUFVO0FBQzlDLFFBQUksUUFBUSxRQUFRLFdBQVcsR0FBRztBQUNoQyxZQUFNLElBQUksTUFBTSxvREFBb0Q7QUFBQSxJQUN0RTtBQUFBLEVBRUYsV0FBVyxPQUFPLFFBQVEsWUFBWSxVQUFVO0FBQUEsRUFLaEQsT0FBTztBQUNMLFVBQU0sSUFBSTtBQUFBLE1BQ1IsNkRBQTZELFFBQVEsT0FBTztBQUFBLElBQzlFO0FBQUEsRUFDRjtBQUNBLE1BQUksUUFBUSxZQUFZLFFBQVc7QUFDakMsUUFBSSxPQUFPLFFBQVEsWUFBWSxVQUFVO0FBQ3ZDLFVBQUksUUFBUSxZQUFZLE9BQU87QUFDN0IsY0FBTTtBQUFBLFVBQ0o7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0YsT0FBTztBQUVMLFVBQUksUUFBUSxZQUFZLE9BQU87QUFDN0IsY0FBTTtBQUFBLFVBQ0o7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBRUEsTUFBSSxRQUFRLGNBQWMsVUFBYSxRQUFRLGNBQWMsTUFBTTtBQUNqRSxZQUFRLFlBQVk7QUFBQSxFQUN0QixXQUFXLE9BQU8sUUFBUSxjQUFjLFlBQVk7QUFDbEQsVUFBTSxJQUFJO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0EsT0FBTyxLQUFLLFVBQVUsUUFBUSxTQUFTLENBQUM7QUFBQSxNQUMxQztBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUtBLE1BQ0UsUUFBUSxZQUFZLFVBQ3BCLFFBQVEsWUFBWSxRQUNwQixPQUFPLFFBQVEsWUFBWSxZQUMzQjtBQUNBLFVBQU0sSUFBSTtBQUFBLE1BQ1IsbURBQW1ELEtBQUssVUFBVSxRQUFRLE9BQU8sQ0FBQztBQUFBLElBQ3BGO0FBQUEsRUFDRjtBQUVBLE1BQ0UsUUFBUSxVQUFVLFFBQ2xCLFFBQVEsVUFBVSxTQUNsQixRQUFRLFVBQVUsSUFDbEI7QUFDQSxZQUFRLFFBQVE7QUFBQSxFQUNsQixPQUFPO0FBQ0wsUUFBSSxRQUFRLFVBQVUsVUFBYSxRQUFRLFVBQVUsTUFBTTtBQUN6RCxjQUFRLFFBQVEsT0FBTyxLQUFLLEtBQUssUUFBUSxRQUFRO0FBQUEsSUFDbkQsV0FBVyxPQUFPLFFBQVEsVUFBVSxVQUFVO0FBQzVDLGNBQVEsUUFBUSxPQUFPLEtBQUssUUFBUSxPQUFPLFFBQVEsUUFBUTtBQUFBLElBQzdEO0FBQ0EsUUFBSSxDQUFDLE9BQU8sU0FBUyxRQUFRLEtBQUssR0FBRztBQUNuQyxZQUFNLElBQUk7QUFBQSxRQUNSLDJEQUEyRCxLQUFLLFVBQVUsUUFBUSxLQUFLLENBQUM7QUFBQSxNQUMxRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBRUEsTUFDRSxRQUFRLFFBQVEsVUFDaEIsUUFBUSxRQUFRLFFBQ2hCLFFBQVEsUUFBUSxPQUNoQjtBQUNBLFlBQVEsTUFBTTtBQUFBLEVBQ2hCLFdBQVcsUUFBUSxRQUFRLE1BQU07QUFDL0IsVUFBTSxJQUFJO0FBQUEsTUFDUix5Q0FBeUMsS0FBSyxVQUFVLFFBQVEsR0FBRyxDQUFDO0FBQUEsSUFDdEU7QUFBQSxFQUNGO0FBRUEsTUFBSSxRQUFRLHFCQUFxQixRQUFXO0FBQzFDLFlBQVEsbUJBQW1CLENBQUM7QUFBQSxFQUM5QixXQUNFLE9BQU8sUUFBUSxxQkFBcUIsWUFDcEMsT0FBTyxTQUFTLFFBQVEsZ0JBQWdCLEdBQ3hDO0FBQ0EsUUFBSSxRQUFRLGlCQUFpQixXQUFXLEdBQUc7QUFDekMsWUFBTSxJQUFJO0FBQUEsUUFDUjtBQUFBLFFBQ0E7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0EsT0FBTyxLQUFLLFVBQVUsUUFBUSxnQkFBZ0IsQ0FBQztBQUFBLFFBQ2pEO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsWUFBUSxtQkFBbUIsQ0FBQyxRQUFRLGdCQUFnQjtBQUFBLEVBQ3RELFdBQVcsQ0FBQyxNQUFNLFFBQVEsUUFBUSxnQkFBZ0IsR0FBRztBQUNuRCxVQUFNLElBQUk7QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0U7QUFBQSxRQUNBO0FBQUEsUUFDQSxPQUFPLEtBQUssVUFBVSxRQUFRLGdCQUFnQixDQUFDO0FBQUEsTUFDakQ7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxVQUFRLG1CQUFtQixRQUFRLGlCQUFpQixJQUFJLFNBQVUsSUFBSUMsSUFBRztBQUN2RSxRQUFJLE9BQU8sT0FBTyxZQUFZLENBQUMsT0FBTyxTQUFTLEVBQUUsR0FBRztBQUNsRCxZQUFNLElBQUk7QUFBQSxRQUNSO0FBQUEsUUFDQTtBQUFBLFVBQ0U7QUFBQSxVQUNBO0FBQUEsVUFDQSxZQUFZQSxFQUFDO0FBQUEsVUFDYixPQUFPLEtBQUssVUFBVSxFQUFFLENBQUM7QUFBQSxRQUMzQjtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQUEsSUFDRixXQUFXLEdBQUcsV0FBVyxHQUFHO0FBQzFCLFlBQU0sSUFBSTtBQUFBLFFBQ1I7QUFBQSxRQUNBO0FBQUEsVUFDRTtBQUFBLFVBQ0E7QUFBQSxVQUNBLFlBQVlBLEVBQUM7QUFBQSxVQUNiLE9BQU8sS0FBSyxVQUFVLEVBQUUsQ0FBQztBQUFBLFFBQzNCO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsUUFBSSxPQUFPLE9BQU8sVUFBVTtBQUMxQixXQUFLLE9BQU8sS0FBSyxJQUFJLFFBQVEsUUFBUTtBQUFBLElBQ3ZDO0FBQ0EsV0FBTztBQUFBLEVBQ1QsQ0FBQztBQUVELE1BQUksT0FBTyxRQUFRLHVCQUF1QixXQUFXO0FBQUEsRUFFckQsV0FDRSxRQUFRLHVCQUF1QixVQUMvQixRQUFRLHVCQUF1QixNQUMvQjtBQUNBLFlBQVEscUJBQXFCO0FBQUEsRUFDL0IsT0FBTztBQUNMLFVBQU0sSUFBSTtBQUFBLE1BQ1IsNkRBQTZELEtBQUssVUFBVSxRQUFRLGtCQUFrQixDQUFDO0FBQUEsSUFDekc7QUFBQSxFQUNGO0FBQ0EsTUFBSSxPQUFPLFFBQVEsNEJBQTRCLFdBQVc7QUFBQSxFQUUxRCxXQUNFLFFBQVEsNEJBQTRCLFVBQ3BDLFFBQVEsNEJBQTRCLE1BQ3BDO0FBQ0EsWUFBUSwwQkFBMEI7QUFBQSxFQUNwQyxPQUFPO0FBQ0wsVUFBTSxJQUFJO0FBQUEsTUFDUixrRUFBa0UsS0FBSyxVQUFVLFFBQVEsdUJBQXVCLENBQUM7QUFBQSxJQUNuSDtBQUFBLEVBQ0Y7QUFDQSxNQUFJLE9BQU8sUUFBUSw0QkFBNEIsV0FBVztBQUFBLEVBRTFELFdBQ0UsUUFBUSw0QkFBNEIsVUFDcEMsUUFBUSw0QkFBNEIsTUFDcEM7QUFDQSxZQUFRLDBCQUEwQjtBQUFBLEVBQ3BDLE9BQU87QUFDTCxVQUFNLElBQUk7QUFBQSxNQUNSLGtFQUFrRSxLQUFLLFVBQVUsUUFBUSx1QkFBdUIsQ0FBQztBQUFBLElBQ25IO0FBQUEsRUFDRjtBQUVBLE1BQUksT0FBTyxRQUFRLGlCQUFpQixXQUFXO0FBQUEsRUFFL0MsV0FDRSxRQUFRLGlCQUFpQixVQUN6QixRQUFRLGlCQUFpQixNQUN6QjtBQUNBLFlBQVEsZUFBZTtBQUFBLEVBQ3pCLE9BQU87QUFDTCxVQUFNLElBQUk7QUFBQSxNQUNSLHVEQUF1RCxLQUFLLFVBQVUsUUFBUSxZQUFZLENBQUM7QUFBQSxJQUM3RjtBQUFBLEVBQ0Y7QUFFQSxNQUFJLE9BQU8sUUFBUSxxQkFBcUIsV0FBVztBQUFBLEVBRW5ELFdBQ0UsUUFBUSxxQkFBcUIsVUFDN0IsUUFBUSxxQkFBcUIsTUFDN0I7QUFDQSxZQUFRLG1CQUFtQjtBQUFBLEVBQzdCLE9BQU87QUFDTCxVQUFNLElBQUk7QUFBQSxNQUNSLDJEQUEyRCxLQUFLLFVBQVUsUUFBUSxnQkFBZ0IsQ0FBQztBQUFBLElBQ3JHO0FBQUEsRUFDRjtBQUVBLE1BQUksT0FBTyxRQUFRLG1DQUFtQyxXQUFXO0FBQUEsRUFFakUsV0FDRSxRQUFRLG1DQUFtQyxVQUMzQyxRQUFRLG1DQUFtQyxNQUMzQztBQUNBLFlBQVEsaUNBQWlDO0FBQUEsRUFDM0MsT0FBTztBQUNMLFVBQU0sSUFBSTtBQUFBLE1BQ1IseUVBQXlFLEtBQUssVUFBVSxRQUFRLDhCQUE4QixDQUFDO0FBQUEsSUFDakk7QUFBQSxFQUNGO0FBRUEsTUFBSSxPQUFPLFFBQVEsNEJBQTRCLFdBQVc7QUFBQSxFQUUxRCxXQUNFLFFBQVEsNEJBQTRCLFVBQ3BDLFFBQVEsNEJBQTRCLE1BQ3BDO0FBQ0EsWUFBUSwwQkFBMEI7QUFBQSxFQUNwQyxPQUFPO0FBQ0wsVUFBTSxJQUFJO0FBQUEsTUFDUixrRUFBa0UsS0FBSyxVQUFVLFFBQVEsdUJBQXVCLENBQUM7QUFBQSxJQUNuSDtBQUFBLEVBQ0Y7QUFFQSxNQUNFLFFBQVEsVUFBVSxVQUNsQixRQUFRLFVBQVUsUUFDbEIsUUFBUSxVQUFVLE9BQ2xCO0FBQ0EsWUFBUSxRQUFRO0FBQUEsRUFDbEIsV0FBVyxRQUFRLFVBQVUsTUFBTTtBQUNqQyxVQUFNLElBQUk7QUFBQSxNQUNSLGdEQUFnRCxLQUFLLFVBQVUsUUFBUSxLQUFLLENBQUM7QUFBQSxJQUMvRTtBQUFBLEVBQ0Y7QUFFQSxNQUNFLFFBQVEsVUFBVSxVQUNsQixRQUFRLFVBQVUsUUFDbEIsUUFBUSxVQUFVLE9BQ2xCO0FBQ0EsWUFBUSxRQUFRO0FBQUEsRUFDbEIsV0FBVyxRQUFRLFVBQVUsTUFBTTtBQUNqQyxVQUFNLElBQUk7QUFBQSxNQUNSLGdEQUFnRCxLQUFLLFVBQVUsUUFBUSxLQUFLLENBQUM7QUFBQSxJQUMvRTtBQUFBLEVBQ0Y7QUFFQSxNQUNFLFFBQVEsU0FBUyxVQUNqQixRQUFRLFNBQVMsUUFDakIsUUFBUSxTQUFTLE9BQ2pCO0FBQ0EsWUFBUSxPQUFPO0FBQUEsRUFDakIsV0FBVyxRQUFRLFNBQVMsTUFBTTtBQUNoQyxVQUFNLElBQUk7QUFBQSxNQUNSLCtDQUErQyxLQUFLLFVBQVUsUUFBUSxJQUFJLENBQUM7QUFBQSxJQUM3RTtBQUFBLEVBQ0Y7QUFFQSxNQUFJLFFBQVEsU0FBUyxRQUFRLEtBQUssVUFBVSxPQUFPO0FBQ2pELFlBQVEsUUFBUTtBQUFBLEVBQ2xCLFdBQVcsUUFBUSxVQUFVLE1BQU07QUFDakMsWUFBUSxRQUFRO0FBQUEsRUFDbEI7QUFDQSxNQUFJLFFBQVEsU0FBUyxRQUFRLEtBQUssVUFBVSxPQUFPO0FBQ2pELFlBQVEsUUFBUTtBQUFBLEVBQ2xCLFdBQVcsUUFBUSxVQUFVLE1BQU07QUFDakMsWUFBUSxRQUFRO0FBQUEsRUFDbEI7QUFFQSxNQUFJLFFBQVEsT0FBTyxVQUFhLFFBQVEsT0FBTyxNQUFNO0FBQ25ELFlBQVEsS0FBSztBQUFBLEVBQ2YsT0FBTztBQUNMLFFBQUksT0FBTyxRQUFRLE9BQU8sWUFBWSxNQUFNLEtBQUssUUFBUSxFQUFFLEdBQUc7QUFDNUQsY0FBUSxLQUFLLFNBQVMsUUFBUSxFQUFFO0FBQUEsSUFDbEM7QUFDQSxRQUFJLE9BQU8sVUFBVSxRQUFRLEVBQUUsR0FBRztBQUNoQyxVQUFJLFFBQVEsTUFBTSxHQUFHO0FBQ25CLGNBQU0sSUFBSTtBQUFBLFVBQ1IscUVBQXFFLEtBQUssVUFBVSxLQUFLLEVBQUUsQ0FBQztBQUFBLFFBQzlGO0FBQUEsTUFDRjtBQUFBLElBQ0YsT0FBTztBQUNMLFlBQU0sSUFBSTtBQUFBLFFBQ1IsOENBQThDLEtBQUssVUFBVSxLQUFLLEVBQUUsQ0FBQztBQUFBLE1BQ3ZFO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFQSxNQUFJLFFBQVEsWUFBWSxVQUFhLFFBQVEsWUFBWSxNQUFNO0FBQzdELFlBQVEsVUFBVTtBQUFBLEVBQ3BCLE9BQU87QUFDTCxRQUFJLE9BQU8sUUFBUSxZQUFZLFlBQVksTUFBTSxLQUFLLFFBQVEsT0FBTyxHQUFHO0FBQ3RFLGNBQVEsVUFBVSxTQUFTLFFBQVEsT0FBTztBQUFBLElBQzVDO0FBQ0EsUUFBSSxPQUFPLFVBQVUsUUFBUSxPQUFPLEdBQUc7QUFDckMsVUFBSSxRQUFRLFdBQVcsR0FBRztBQUN4QixjQUFNLElBQUk7QUFBQSxVQUNSLDBFQUEwRSxLQUFLLFVBQVUsS0FBSyxPQUFPLENBQUM7QUFBQSxRQUN4RztBQUFBLE1BQ0Y7QUFBQSxJQUNGLE9BQU87QUFDTCxZQUFNLElBQUk7QUFBQSxRQUNSLG1EQUFtRCxLQUFLLFVBQVUsS0FBSyxPQUFPLENBQUM7QUFBQSxNQUNqRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUNUOzs7QUMzcUJBLElBQU0sZ0JBQWdCLFNBQVUsUUFBUTtBQUN0QyxTQUFPLE9BQU87QUFBQSxJQUNaLENBQUMsVUFDQyxTQUFTLFFBQVMsTUFBTSxZQUFZLE1BQU0sU0FBUyxFQUFFLEtBQUssTUFBTTtBQUFBLEVBQ3BFO0FBQ0Y7QUFFQSxJQUFNQyxNQUFLO0FBQ1gsSUFBTUMsTUFBSztBQUVYLElBQU0sT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLWCxNQUFNLE9BQU8sS0FBSyxDQUFDLEtBQUssS0FBSyxHQUFHLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlqQyxTQUFTLE9BQU8sS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDO0FBQ2pDO0FBRUEsSUFBTSxZQUFZLFNBQVUsbUJBQW1CLENBQUMsR0FBRztBQUNqRCxRQUFNLE9BQU87QUFBQSxJQUNYLE9BQU87QUFBQSxJQUNQLGVBQWU7QUFBQSxJQUNmLGFBQWE7QUFBQSxJQUNiLHNCQUFzQjtBQUFBLElBQ3RCLE9BQU87QUFBQSxJQUNQLFNBQVM7QUFBQSxFQUNYO0FBQ0EsUUFBTSxVQUFVLGtCQUFrQixnQkFBZ0I7QUFDbEQsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0EsT0FBTyxXQUFXLE9BQU87QUFBQSxJQUN6QixnQkFBZ0IsU0FBVUMsSUFBRyxRQUFRLEtBQUs7QUFDeEMsVUFBSSxJQUFLLFFBQU87QUFDaEIsWUFBTSxFQUFFLFVBQVUsUUFBUSxNQUFNLElBQUksS0FBSztBQUN6QyxZQUFNLEVBQUUsU0FBUyxrQkFBa0IseUJBQXlCLElBQzFELEtBQUs7QUFDUCxZQUFNLGdCQUFnQixTQUFTQSxLQUFJO0FBQ25DLFlBQU0saUJBQWlCLEtBQUs7QUFBQSxRQUMxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBT0EsNkJBQTZCLElBQ3pCLE9BQU8sS0FBSyxRQUFRLFFBQVEsRUFBRSxTQUM5QjtBQUFBO0FBQUEsUUFFSixXQUFXLFdBQVcsT0FBTyxJQUFJLE9BQU8sVUFBVSxNQUFNLFNBQVM7QUFBQTtBQUFBLFFBRWpFLFVBQVUsTUFBTSxTQUFTLDJCQUEyQjtBQUFBLE1BQ3REO0FBQ0EsYUFBTyxnQkFBZ0I7QUFBQSxJQUN6QjtBQUFBO0FBQUEsSUFFQSxPQUFPLFNBQVUsU0FBUyxLQUFLLE1BQU0sT0FBTztBQUMxQyxZQUFNO0FBQUEsUUFDSjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRixJQUFJLEtBQUs7QUFDVCxVQUFJLEVBQUUsU0FBUyxRQUFRLE9BQU8saUJBQWlCLElBQUksS0FBSztBQUN4RCxZQUFNLEVBQUUsWUFBWSxhQUFhLFdBQVcsY0FBYyxJQUFJLEtBQUs7QUFDbkUsVUFBSTtBQUNKLFVBQUksZ0JBQWdCLFFBQVc7QUFDN0IsWUFBSSxZQUFZLFFBQVc7QUFFekIsZ0JBQU07QUFDTjtBQUFBLFFBQ0YsT0FBTztBQUNMLGdCQUFNO0FBQUEsUUFDUjtBQUFBLE1BQ0YsV0FBVyxnQkFBZ0IsVUFBYSxZQUFZLFFBQVc7QUFDN0QsY0FBTTtBQUFBLE1BQ1IsT0FBTztBQUNMLGNBQU0sT0FBTyxPQUFPLENBQUMsYUFBYSxPQUFPLENBQUM7QUFBQSxNQUM1QztBQUVBLFVBQUksZUFBZSxPQUFPO0FBQ3hCLFlBQUksUUFBUSxPQUFPO0FBQ2pCLGVBQUssTUFBTSxhQUFhO0FBQUEsUUFDMUIsV0FBVyxJQUFJLFNBQVMsR0FBRztBQUV6QixjQUFJLFFBQVEsT0FBTztBQUVqQixpQkFBSyxNQUFNLGNBQWM7QUFDekI7QUFBQSxVQUNGO0FBQUEsUUFDRixPQUFPO0FBQ0wscUJBQVdDLGFBQVksTUFBTTtBQUMzQixnQkFBSSxLQUFLQSxTQUFRLEVBQUUsUUFBUSxLQUFLLEdBQUcsS0FBS0EsU0FBUSxFQUFFLE1BQU0sTUFBTSxHQUFHO0FBRS9ELG9CQUFNLFlBQVksS0FBS0EsU0FBUSxFQUFFO0FBQ2pDLG1CQUFLLE1BQU0saUJBQWlCO0FBQzVCLG9CQUFNLElBQUksTUFBTSxTQUFTO0FBRXpCLG1CQUFLLFVBQVUsa0JBQWtCO0FBQUEsZ0JBQy9CLEdBQUcsS0FBSztBQUFBLGdCQUNSLFVBQVVBO0FBQUEsY0FDWixDQUFDO0FBRUQsZUFBQyxFQUFFLFNBQVMsUUFBUSxNQUFNLElBQUksS0FBSztBQUNuQztBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQ0EsZUFBSyxNQUFNLGFBQWE7QUFBQSxRQUMxQjtBQUFBLE1BQ0Y7QUFDQSxZQUFNLFNBQVMsSUFBSTtBQUNuQixVQUFJO0FBQ0osV0FBSyxNQUFNLEdBQUcsTUFBTSxRQUFRLE9BQU87QUFHakMsWUFBSSxLQUFLLGVBQWUsS0FBSyxRQUFRLEdBQUcsR0FBRztBQUN6QztBQUFBLFFBQ0Y7QUFDQSxZQUFJLEtBQUssTUFBTSxvQkFBb0IsTUFBTTtBQUN2QyxlQUFLLEtBQUs7QUFDVixlQUFLLE1BQU0sa0JBQWtCO0FBQUEsUUFDL0I7QUFDQSxZQUFJLFlBQVksTUFBTSxLQUFLLEtBQUssUUFBUSxTQUFTO0FBQy9DLGVBQUssTUFBTSxPQUFPO0FBQ2xCLGdCQUFNO0FBQ047QUFBQSxRQUNGO0FBRUEsWUFBSSxLQUFLLE1BQU0sWUFBWSxTQUFTLGlCQUFpQixXQUFXLEdBQUc7QUFDakUsZ0JBQU0sd0JBQXdCLEtBQUs7QUFBQSxZQUNqQztBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQ0EsY0FBSSx1QkFBdUI7QUFDekIsK0JBQW1CLEtBQUssUUFBUTtBQUFBLFVBQ2xDO0FBQUEsUUFDRjtBQUNBLGNBQU0sTUFBTSxJQUFJLEdBQUc7QUFDbkIsWUFBSSxRQUFRLE1BQU07QUFDaEIsb0JBQVUsT0FBTyxHQUFHO0FBQUEsUUFDdEI7QUFDQSxhQUNHLFFBQVFILE9BQU0sUUFBUUMsUUFDdkIsS0FBSyxNQUFNLG9CQUFvQixPQUMvQjtBQUNBLGVBQUssTUFBTSxrQkFBa0I7QUFBQSxRQUMvQjtBQUdBLFlBQUksS0FBSyxNQUFNLGFBQWEsTUFBTTtBQUNoQyxlQUFLLE1BQU0sV0FBVztBQUFBLFFBQ3hCLE9BQU87QUFJTCxjQUNFLFdBQVcsUUFDWCxLQUFLLE1BQU0sWUFBWSxRQUN2QixLQUFLLFdBQVcsS0FBSyxLQUFLLEdBQUcsS0FDN0IsTUFBTSxPQUFPLFNBQVMsUUFDdEI7QUFDQSxnQkFBSSxlQUFlO0FBQ2pCLGtCQUFJLEtBQUssVUFBVSxLQUFLLE1BQU0sT0FBTyxNQUFNLEdBQUc7QUFDNUMscUJBQUssTUFBTSxXQUFXO0FBQ3RCLHVCQUFPLE9BQU8sU0FBUztBQUN2QjtBQUFBLGNBQ0Y7QUFBQSxZQUNGLE9BQU87QUFDTCxtQkFBSyxNQUFNLFdBQVc7QUFDdEIscUJBQU8sT0FBTyxTQUFTO0FBQ3ZCO0FBQUEsWUFDRjtBQUFBLFVBQ0Y7QUFHQSxjQUFJLEtBQUssTUFBTSxlQUFlLFNBQVMsS0FBSyxVQUFVLEtBQUssR0FBRyxHQUFHO0FBQy9ELGdCQUFJLEtBQUssTUFBTSxZQUFZLE1BQU07QUFDL0Isb0JBQU0sVUFBVSxJQUFJLE1BQU0sTUFBTSxNQUFNO0FBQ3RDLG9CQUFNLG9CQUNKLFNBQVMsS0FBSyxpQkFBaUIsS0FBSyxNQUFNLE1BQU0sTUFBTTtBQUN4RCxvQkFBTSxtQkFDSixZQUFZLFFBQ1osS0FBSyxlQUFlLFNBQVMsS0FBSyxNQUFNLE1BQU0sUUFBUSxPQUFPO0FBQy9ELG9CQUFNLHFCQUFxQixLQUFLO0FBQUEsZ0JBQzlCO0FBQUEsZ0JBQ0EsTUFBTSxNQUFNO0FBQUEsZ0JBQ1o7QUFBQSxjQUNGO0FBQ0Esb0JBQU0sMkJBQ0osaUJBQWlCLFdBQVcsSUFDeEIsS0FBSyw4QkFBOEIsS0FBSyxNQUFNLE1BQU0sTUFBTSxJQUMxRCxLQUFLLG9CQUFvQixTQUFTLEtBQUssTUFBTSxNQUFNLE1BQU07QUFHL0Qsa0JBQ0UsV0FBVyxRQUNYLEtBQUssV0FBVyxLQUFLLEtBQUssR0FBRyxLQUM3QixLQUFLLFVBQVUsS0FBSyxNQUFNLE9BQU8sTUFBTSxHQUN2QztBQUNBLHVCQUFPLE9BQU8sU0FBUztBQUFBLGNBQ3pCLFdBQ0UsQ0FBQyxXQUNELHNCQUNBLDRCQUNBLG9CQUNBLG1CQUNBO0FBQ0EscUJBQUssTUFBTSxVQUFVO0FBQ3JCLHFCQUFLLE1BQU0sYUFBYTtBQUN4Qix1QkFBTyxNQUFNLFNBQVM7QUFDdEI7QUFBQSxjQUNGLFdBQVcsaUJBQWlCLE9BQU87QUFDakMsc0JBQU0sTUFBTSxLQUFLO0FBQUEsa0JBQ2YsSUFBSTtBQUFBLG9CQUNGO0FBQUEsb0JBQ0E7QUFBQSxzQkFDRTtBQUFBLHNCQUNBLFFBQVEsT0FBTyxhQUFhLE9BQU8sQ0FBQztBQUFBLHNCQUNwQyxXQUFXLEtBQUssS0FBSyxLQUFLO0FBQUEsc0JBQzFCO0FBQUEsc0JBQ0E7QUFBQSxvQkFDRjtBQUFBLG9CQUNBLEtBQUs7QUFBQSxvQkFDTCxLQUFLLFlBQVk7QUFBQSxrQkFDbkI7QUFBQSxnQkFDRjtBQUNBLG9CQUFJLFFBQVEsT0FBVyxRQUFPO0FBQUEsY0FDaEMsT0FBTztBQUNMLHFCQUFLLE1BQU0sVUFBVTtBQUNyQixxQkFBSyxNQUFNLGFBQWE7QUFDeEIscUJBQUssTUFBTSxNQUFNLFFBQVEsS0FBSztBQUM5Qix1QkFBTyxNQUFNLFNBQVM7QUFBQSxjQUN4QjtBQUFBLFlBQ0YsT0FBTztBQUNMLGtCQUFJLEtBQUssTUFBTSxNQUFNLFdBQVcsR0FBRztBQUVqQyxvQkFBSSxpQkFBaUIsT0FBTztBQUMxQix3QkFBTUcsUUFBTyxLQUFLLFlBQVk7QUFDOUIsd0JBQU1DLE9BQU0sT0FBTyxLQUFLLElBQUksRUFDekI7QUFBQSxvQkFBSSxDQUFDLE1BQ0osS0FBSyxDQUFDLEVBQUUsT0FBTyxLQUFLLE1BQU0sTUFBTSxTQUFTLENBQUMsSUFBSSxJQUFJO0FBQUEsa0JBQ3BELEVBQ0MsT0FBTyxPQUFPLEVBQUUsQ0FBQztBQUNwQix3QkFBTSxNQUFNLEtBQUs7QUFBQSxvQkFDZixJQUFJO0FBQUEsc0JBQ0Y7QUFBQSxzQkFDQTtBQUFBLHdCQUNFO0FBQUEsd0JBQ0EsNkJBQTZCLEtBQUssVUFBVUQsTUFBSyxNQUFNLENBQUMsWUFBWUEsTUFBSyxLQUFLLGNBQWMsS0FBSyxVQUFVLEtBQUssTUFBTSxNQUFNLFNBQVMsUUFBUSxDQUFDLENBQUM7QUFBQSx3QkFDL0lDLE9BQU0sSUFBSUEsSUFBRyxVQUFVO0FBQUEsc0JBQ3pCO0FBQUEsc0JBQ0EsS0FBSztBQUFBLHNCQUNMRDtBQUFBLHNCQUNBO0FBQUEsd0JBQ0UsT0FBTyxLQUFLLE1BQU07QUFBQSxzQkFDcEI7QUFBQSxvQkFDRjtBQUFBLGtCQUNGO0FBQ0Esc0JBQUksUUFBUSxPQUFXLFFBQU87QUFBQSxnQkFDaEM7QUFBQSxjQUNGLE9BQU87QUFDTCxxQkFBSyxNQUFNLFVBQVU7QUFDckIsdUJBQU8sTUFBTSxTQUFTO0FBQ3RCO0FBQUEsY0FDRjtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQ0EsY0FBSSxLQUFLLE1BQU0sWUFBWSxPQUFPO0FBQ2hDLGtCQUFNLHdCQUF3QixLQUFLO0FBQUEsY0FDakM7QUFBQSxjQUNBO0FBQUEsY0FDQTtBQUFBLFlBQ0Y7QUFDQSxnQkFBSSwwQkFBMEIsR0FBRztBQUUvQixvQkFBTSxrQkFDSixLQUFLLE1BQU0sY0FDWCxLQUFLLE1BQU0sZUFBZSxTQUMxQixLQUFLLE1BQU0sT0FBTyxXQUFXLEtBQzdCLEtBQUssTUFBTSxNQUFNLFdBQVc7QUFDOUIsa0JBQUksaUJBQWlCO0FBQ25CLHFCQUFLLEtBQUs7QUFBQSxjQUVaLE9BQU87QUFFTCxvQkFDRSxLQUFLLE1BQU0sWUFBWSxTQUN2QixLQUFLLEtBQUssU0FDUCxLQUFLLE1BQU0sb0JBQW9CLE9BQU8sSUFBSSxNQUMzQyxXQUNGO0FBQ0EsdUJBQUssTUFBTSxVQUFVO0FBQ3JCLHVCQUFLLGFBQWE7QUFDbEIsdUJBQUssY0FBYztBQUNuQix5QkFBTyx3QkFBd0I7QUFDL0I7QUFBQSxnQkFDRjtBQUVBLG9CQUNFLHFCQUFxQixRQUNyQixLQUFLLE1BQU0sZUFBZSxTQUMxQixLQUFLLE1BQU0sT0FBTyxXQUFXLEtBQzdCLEtBQUssTUFBTSxNQUFNLFdBQVcsR0FDNUI7QUFDQSx1QkFBSyxLQUFLO0FBQ1YseUJBQU8sd0JBQXdCO0FBQy9CO0FBQUEsZ0JBQ0Y7QUFDQSxxQkFBSyxLQUFLLFFBQVEsS0FBSyxNQUFNLGdCQUFnQjtBQUM3QyxzQkFBTSxXQUFXLEtBQUssVUFBVTtBQUNoQyxvQkFBSSxhQUFhLE9BQVcsUUFBTztBQUNuQyxxQkFBSyxLQUFLLFFBQ1IsS0FBSyxNQUFNLGdCQUFnQixNQUFNO0FBQ25DLHNCQUFNLFlBQVksS0FBSyxXQUFXLElBQUk7QUFDdEMsb0JBQUksY0FBYyxPQUFXLFFBQU87QUFDcEMsb0JBQUksT0FBTyxNQUFNLEtBQUssS0FBSyxXQUFXLElBQUk7QUFDeEMsdUJBQUssTUFBTSxPQUFPO0FBQ2xCLHdCQUFNO0FBQ047QUFBQSxnQkFDRjtBQUFBLGNBQ0Y7QUFDQSxtQkFBSyxNQUFNLGFBQWE7QUFDeEIscUJBQU8sd0JBQXdCO0FBQy9CO0FBQUEsWUFDRjtBQUNBLGdCQUFJLEtBQUssTUFBTSxZQUFZO0FBQ3pCO0FBQUEsWUFDRjtBQUNBLGdCQUNFLFlBQVksU0FDWCxxQkFBcUIsU0FDbkIsS0FBSyxNQUFNLE9BQU8sV0FBVyxLQUM1QixLQUFLLE1BQU0sTUFBTSxXQUFXLElBQ2hDO0FBQ0Esb0JBQU0sZUFBZSxLQUFLLGVBQWUsU0FBUyxLQUFLLEtBQUssR0FBRztBQUMvRCxrQkFBSSxpQkFBaUIsR0FBRztBQUN0QixxQkFBSyxNQUFNLGFBQWE7QUFDeEI7QUFBQSxjQUNGO0FBQUEsWUFDRjtBQUNBLGtCQUFNLGtCQUFrQixLQUFLLGNBQWMsS0FBSyxLQUFLLEdBQUc7QUFDeEQsZ0JBQUksb0JBQW9CLEdBQUc7QUFDekIsbUJBQUssS0FBSyxRQUFRLEtBQUssTUFBTSxnQkFBZ0I7QUFDN0Msb0JBQU0sV0FBVyxLQUFLLFVBQVU7QUFDaEMsa0JBQUksYUFBYSxPQUFXLFFBQU87QUFDbkMscUJBQU8sa0JBQWtCO0FBQ3pCO0FBQUEsWUFDRjtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQ0EsWUFBSSxLQUFLLE1BQU0sZUFBZSxPQUFPO0FBQ25DLGNBQ0Usb0JBQW9CLEtBQ3BCLEtBQUssTUFBTSxnQkFBZ0IsS0FBSyxNQUFNLE1BQU0sU0FBUyxpQkFDckQ7QUFDQSxtQkFBTyxLQUFLO0FBQUEsY0FDVixJQUFJO0FBQUEsZ0JBQ0Y7QUFBQSxnQkFDQTtBQUFBLGtCQUNFO0FBQUEsa0JBQ0E7QUFBQSxrQkFDQSxNQUFNLGVBQWU7QUFBQSxrQkFDckIsV0FBVyxLQUFLLEtBQUssS0FBSztBQUFBLGdCQUM1QjtBQUFBLGdCQUNBLEtBQUs7QUFBQSxnQkFDTCxLQUFLLFlBQVk7QUFBQSxjQUNuQjtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUNBLGNBQU0sVUFDSixVQUFVLFNBQ1YsS0FBSyxNQUFNLFlBQVksUUFDdkIsS0FBSyxNQUFNLE1BQU0sV0FBVyxLQUM1QixDQUFDLEtBQUssaUJBQWlCLEtBQUssR0FBRztBQUVqQyxjQUFNLFVBQVUsVUFBVSxTQUFTLEtBQUssTUFBTSxlQUFlO0FBQzdELFlBQUksWUFBWSxRQUFRLFlBQVksTUFBTTtBQUN4QyxlQUFLLE1BQU0sTUFBTSxPQUFPLEdBQUc7QUFBQSxRQUM3QixXQUFXLFVBQVUsUUFBUSxDQUFDLEtBQUssaUJBQWlCLEtBQUssR0FBRyxHQUFHO0FBQzdELGlCQUFPLEtBQUs7QUFBQSxZQUNWLElBQUk7QUFBQSxjQUNGO0FBQUEsY0FDQTtBQUFBLGdCQUNFO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQSxXQUFXLEtBQUssS0FBSyxLQUFLO0FBQUEsY0FDNUI7QUFBQSxjQUNBLEtBQUs7QUFBQSxjQUNMLEtBQUssWUFBWTtBQUFBLFlBQ25CO0FBQUEsVUFDRjtBQUFBLFFBQ0YsT0FBTztBQUNMLGNBQUksWUFBWSxPQUFPO0FBQ3JCLG1CQUFPLEtBQUssaUJBQWlCLEtBQUssR0FBRyxJQUFJO0FBQUEsVUFDM0M7QUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0EsVUFBSSxRQUFRLE1BQU07QUFFaEIsWUFBSSxLQUFLLE1BQU0sWUFBWSxNQUFNO0FBQy9CLGdCQUFNLE1BQU0sS0FBSztBQUFBLFlBQ2YsSUFBSTtBQUFBLGNBQ0Y7QUFBQSxjQUNBO0FBQUEsZ0JBQ0U7QUFBQSxnQkFDQSx5REFBeUQsS0FBSyxLQUFLLEtBQUs7QUFBQSxjQUMxRTtBQUFBLGNBQ0EsS0FBSztBQUFBLGNBQ0wsS0FBSyxZQUFZO0FBQUEsWUFDbkI7QUFBQSxVQUNGO0FBQ0EsY0FBSSxRQUFRLE9BQVcsUUFBTztBQUFBLFFBQ2hDLE9BQU87QUFFTCxjQUNFLEtBQUssTUFBTSxlQUFlLFFBQzFCLEtBQUssTUFBTSxPQUFPLFdBQVcsS0FDN0IsS0FBSyxNQUFNLE1BQU0sV0FBVyxHQUM1QjtBQUNBLGlCQUFLLEtBQUssUUFBUSxLQUFLLE1BQU0sZ0JBQWdCO0FBQzdDLGtCQUFNLFdBQVcsS0FBSyxVQUFVO0FBQ2hDLGdCQUFJLGFBQWEsT0FBVyxRQUFPO0FBQ25DLGtCQUFNLFlBQVksS0FBSyxXQUFXLElBQUk7QUFDdEMsZ0JBQUksY0FBYyxPQUFXLFFBQU87QUFBQSxVQUN0QyxXQUFXLEtBQUssTUFBTSxvQkFBb0IsTUFBTTtBQUM5QyxpQkFBSyxLQUFLO0FBQUEsVUFDWixXQUFXLEtBQUssTUFBTSxlQUFlLE1BQU07QUFDekMsaUJBQUssS0FBSztBQUFBLFVBQ1o7QUFBQSxRQUNGO0FBQUEsTUFDRixPQUFPO0FBQ0wsYUFBSyxNQUFNLGlCQUFpQjtBQUM1QixhQUFLLE1BQU0sY0FBYyxJQUFJLE1BQU0sR0FBRztBQUFBLE1BQ3hDO0FBQ0EsVUFBSSxLQUFLLE1BQU0sb0JBQW9CLE1BQU07QUFDdkMsYUFBSyxLQUFLO0FBQ1YsYUFBSyxNQUFNLGtCQUFrQjtBQUFBLE1BQy9CO0FBQUEsSUFDRjtBQUFBLElBQ0EsWUFBWSxTQUFVLE1BQU07QUFDMUIsWUFBTTtBQUFBLFFBQ0o7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0EsTUFBQUE7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGLElBQUksS0FBSztBQUNULFlBQU0sRUFBRSxTQUFTLE9BQU8sSUFBSSxLQUFLO0FBQ2pDLFVBQUksWUFBWSxPQUFPO0FBQ3JCLGVBQU8sS0FBSyxjQUFjO0FBQUEsTUFDNUI7QUFFQSxZQUFNLGVBQWUsT0FBTztBQUM1QixVQUFJLFlBQVksTUFBTTtBQUNwQixZQUFJLG1DQUFtQyxRQUFRLGNBQWMsTUFBTSxHQUFHO0FBQ3BFLGVBQUssY0FBYztBQUNuQjtBQUFBLFFBQ0Y7QUFDQSxlQUFPLEtBQUsscUJBQXFCLE1BQU07QUFBQSxNQUN6QztBQUNBLFVBQUksWUFBWSxTQUFTLEtBQUssS0FBSyxZQUFZLEdBQUc7QUFDaEQsYUFBSyxNQUFNLHVCQUF1QjtBQUFBLE1BQ3BDO0FBQ0EsVUFBSSxpQkFBaUIsS0FBSyxNQUFNLHNCQUFzQjtBQUNwRCxjQUFNLE1BQ0osWUFBWSxRQUNSLElBQUk7QUFBQSxVQUNGO0FBQUEsVUFDQTtBQUFBLFlBQ0U7QUFBQSxZQUNBLFVBQVUsS0FBSyxNQUFNLG9CQUFvQjtBQUFBLFlBQ3pDLE9BQU8sWUFBWSxZQUFZLEtBQUssS0FBSyxLQUFLO0FBQUEsVUFDaEQ7QUFBQSxVQUNBLEtBQUs7QUFBQSxVQUNMLEtBQUssWUFBWTtBQUFBLFVBQ2pCO0FBQUEsWUFDRTtBQUFBLFVBQ0Y7QUFBQSxRQUNGLElBQ0EsSUFBSTtBQUFBLFVBQ0Y7QUFBQSxVQUNBO0FBQUEsWUFDRTtBQUFBLFlBQ0EscUJBQXFCLFFBQVEsTUFBTTtBQUFBO0FBQUEsWUFDbkMsT0FBTyxZQUFZLFlBQVksS0FBSyxLQUFLLEtBQUs7QUFBQSxVQUNoRDtBQUFBLFVBQ0EsS0FBSztBQUFBLFVBQ0wsS0FBSyxZQUFZO0FBQUEsVUFDakI7QUFBQSxZQUNFO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDTixZQUNFLHVCQUF1QixRQUN0Qiw0QkFBNEIsUUFDM0IsZUFBZSxLQUFLLE1BQU0sd0JBQzNCLDRCQUE0QixRQUMzQixlQUFlLEtBQUssTUFBTSxzQkFDNUI7QUFDQSxlQUFLLEtBQUs7QUFDVixlQUFLLE1BQU0sUUFBUTtBQUFBLFFBRXJCLE9BQU87QUFDTCxnQkFBTSxXQUFXLEtBQUssUUFBUSxHQUFHO0FBQ2pDLGNBQUksU0FBVSxRQUFPO0FBQUEsUUFDdkI7QUFBQSxNQUNGO0FBQ0EsVUFBSSxtQ0FBbUMsUUFBUSxjQUFjLE1BQU0sR0FBRztBQUNwRSxhQUFLLGNBQWM7QUFDbkI7QUFBQSxNQUNGO0FBQ0EsVUFBSSxLQUFLLE1BQU0sbUJBQW1CLE1BQU07QUFDdEMsYUFBSyxjQUFjO0FBQ25CLGFBQUssTUFBTSxpQkFBaUI7QUFDNUI7QUFBQSxNQUNGO0FBQ0EsV0FBSyxLQUFLO0FBQ1YsVUFBSSxTQUFTLEtBQUssS0FBSyxLQUFLLFdBQVcsTUFBTTtBQUMzQyxjQUFNLEVBQUUsUUFBUSxJQUFJLEtBQUs7QUFFekIsWUFBSSxZQUFZLE9BQU87QUFDckIsZ0JBQU0sTUFBTSxDQUFDO0FBRWIsbUJBQVNGLEtBQUksR0FBRyxJQUFJLE9BQU8sUUFBUUEsS0FBSSxHQUFHQSxNQUFLO0FBQzdDLGdCQUFJLFFBQVFBLEVBQUMsTUFBTSxVQUFhLFFBQVFBLEVBQUMsRUFBRSxTQUFVO0FBRXJELGdCQUNFLDBCQUEwQixRQUMxQixJQUFJLFFBQVFBLEVBQUMsRUFBRSxJQUFJLE1BQU0sUUFDekI7QUFDQSxrQkFBSSxNQUFNLFFBQVEsSUFBSSxRQUFRQSxFQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUc7QUFDdkMsb0JBQUksUUFBUUEsRUFBQyxFQUFFLElBQUksSUFBSSxJQUFJLFFBQVFBLEVBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxPQUFPQSxFQUFDLENBQUM7QUFBQSxjQUM5RCxPQUFPO0FBQ0wsb0JBQUksUUFBUUEsRUFBQyxFQUFFLElBQUksSUFBSSxDQUFDLElBQUksUUFBUUEsRUFBQyxFQUFFLElBQUksR0FBRyxPQUFPQSxFQUFDLENBQUM7QUFBQSxjQUN6RDtBQUFBLFlBQ0YsT0FBTztBQUNMLGtCQUFJLFFBQVFBLEVBQUMsRUFBRSxJQUFJLElBQUksT0FBT0EsRUFBQztBQUFBLFlBQ2pDO0FBQUEsVUFDRjtBQUVBLGNBQUksUUFBUSxRQUFRRSxVQUFTLE1BQU07QUFDakMsa0JBQU0sWUFBWSxPQUFPO0FBQUEsY0FDdkIsRUFBRSxRQUFRLElBQUk7QUFBQSxjQUNkLFFBQVEsT0FDSixFQUFFLEtBQUssS0FBSyxNQUFNLFVBQVUsU0FBUyxRQUFRLEVBQUUsSUFDL0MsQ0FBQztBQUFBLGNBQ0xBLFVBQVMsT0FBTyxFQUFFLE1BQU0sS0FBSyxhQUFhLEVBQUUsSUFBSSxDQUFDO0FBQUEsWUFDbkQ7QUFDQSxrQkFBTSxNQUFNLEtBQUs7QUFBQSxjQUNmLFlBQVksU0FBWSxZQUFZLENBQUMsSUFBSSxPQUFPLEdBQUcsU0FBUztBQUFBLGNBQzVEO0FBQUEsWUFDRjtBQUNBLGdCQUFJLEtBQUs7QUFDUCxxQkFBTztBQUFBLFlBQ1Q7QUFBQSxVQUNGLE9BQU87QUFDTCxrQkFBTSxNQUFNLEtBQUs7QUFBQSxjQUNmLFlBQVksU0FBWSxNQUFNLENBQUMsSUFBSSxPQUFPLEdBQUcsR0FBRztBQUFBLGNBQ2hEO0FBQUEsWUFDRjtBQUNBLGdCQUFJLEtBQUs7QUFDUCxxQkFBTztBQUFBLFlBQ1Q7QUFBQSxVQUNGO0FBQUEsUUFFRixPQUFPO0FBQ0wsY0FBSSxRQUFRLFFBQVFBLFVBQVMsTUFBTTtBQUNqQyxrQkFBTSxZQUFZLE9BQU87QUFBQSxjQUN2QixFQUFFLE9BQWU7QUFBQSxjQUNqQixRQUFRLE9BQ0osRUFBRSxLQUFLLEtBQUssTUFBTSxVQUFVLFNBQVMsUUFBUSxFQUFFLElBQy9DLENBQUM7QUFBQSxjQUNMQSxVQUFTLE9BQU8sRUFBRSxNQUFNLEtBQUssYUFBYSxFQUFFLElBQUksQ0FBQztBQUFBLFlBQ25EO0FBQ0Esa0JBQU0sTUFBTSxLQUFLO0FBQUEsY0FDZixZQUFZLFNBQVksWUFBWSxDQUFDLE9BQU8sT0FBTyxHQUFHLFNBQVM7QUFBQSxjQUMvRDtBQUFBLFlBQ0Y7QUFDQSxnQkFBSSxLQUFLO0FBQ1AscUJBQU87QUFBQSxZQUNUO0FBQUEsVUFDRixPQUFPO0FBQ0wsa0JBQU0sTUFBTSxLQUFLO0FBQUEsY0FDZixZQUFZLFNBQVksU0FBUyxDQUFDLE9BQU8sT0FBTyxHQUFHLE1BQU07QUFBQSxjQUN6RDtBQUFBLFlBQ0Y7QUFDQSxnQkFBSSxLQUFLO0FBQ1AscUJBQU87QUFBQSxZQUNUO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0EsV0FBSyxjQUFjO0FBQUEsSUFDckI7QUFBQSxJQUNBLHNCQUFzQixTQUFVLFFBQVE7QUFDdEMsWUFBTSxFQUFFLG1CQUFtQixJQUFJLEtBQUs7QUFDcEMsVUFBSTtBQUNGLGNBQU0sVUFDSix1QkFBdUIsU0FDbkIsU0FDQSxtQkFBbUIsS0FBSyxNQUFNLE1BQU07QUFDMUMsWUFBSSxDQUFDLE1BQU0sUUFBUSxPQUFPLEdBQUc7QUFDM0IsaUJBQU8sS0FBSztBQUFBLFlBQ1YsSUFBSTtBQUFBLGNBQ0Y7QUFBQSxjQUNBO0FBQUEsZ0JBQ0U7QUFBQSxnQkFDQTtBQUFBLGdCQUNBLE9BQU8sS0FBSyxVQUFVLE9BQU8sQ0FBQztBQUFBLGNBQ2hDO0FBQUEsY0FDQSxLQUFLO0FBQUEsY0FDTCxLQUFLLFlBQVk7QUFBQSxjQUNqQjtBQUFBLGdCQUNFO0FBQUEsY0FDRjtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUNBLGNBQU0sb0JBQW9CLHdCQUF3QixPQUFPO0FBQ3pELGFBQUssTUFBTSx1QkFBdUIsa0JBQWtCO0FBQ3BELGFBQUssUUFBUSxVQUFVO0FBQ3ZCLGFBQUssY0FBYztBQUNuQjtBQUFBLE1BQ0YsU0FBUyxLQUFLO0FBQ1osZUFBTztBQUFBLE1BQ1Q7QUFBQSxJQUNGO0FBQUEsSUFDQSxlQUFlLFdBQVk7QUFDekIsVUFBSSxLQUFLLFFBQVEsUUFBUSxNQUFNO0FBQzdCLGFBQUssTUFBTSxVQUFVLE1BQU07QUFBQSxNQUM3QjtBQUNBLFdBQUssTUFBTSxRQUFRO0FBQ25CLFdBQUssTUFBTSxTQUFTLENBQUM7QUFDckIsV0FBSyxNQUFNLGdCQUFnQjtBQUFBLElBQzdCO0FBQUEsSUFDQSxXQUFXLFdBQVk7QUFDckIsWUFBTSxFQUFFLE1BQU0sVUFBVSxPQUFPLGdCQUFnQixJQUFJLEtBQUs7QUFDeEQsWUFBTSxFQUFFLFNBQVMsV0FBVyxJQUFJLEtBQUs7QUFFckMsVUFBSSxZQUFZLE9BQU87QUFDckIsZUFBTyxLQUFLLGFBQWE7QUFBQSxNQUMzQjtBQUNBLFVBQUksUUFBUSxLQUFLLE1BQU0sTUFBTSxTQUFTLFFBQVE7QUFDOUMsVUFBSSxVQUFVLFFBQVEsZUFBZSxPQUFPO0FBQzFDLGdCQUFRLE1BQU0sVUFBVTtBQUFBLE1BQzFCO0FBQ0EsVUFBSSxTQUFTLE1BQU07QUFDakIsY0FBTSxDQUFDLEtBQUtFLEVBQUMsSUFBSSxLQUFLLE9BQU8sS0FBSztBQUNsQyxZQUFJLFFBQVEsT0FBVyxRQUFPO0FBQzlCLGdCQUFRQTtBQUFBLE1BQ1Y7QUFDQSxXQUFLLE1BQU0sT0FBTyxLQUFLLEtBQUs7QUFFNUIsVUFBSSxvQkFBb0IsS0FBSyxPQUFPLFVBQVUsVUFBVTtBQUN0RCxhQUFLLE1BQU0saUJBQWlCLE1BQU07QUFBQSxNQUNwQztBQUNBLFdBQUssYUFBYTtBQUFBLElBQ3BCO0FBQUEsSUFDQSxjQUFjLFdBQVk7QUFDeEIsV0FBSyxNQUFNLE1BQU0sTUFBTTtBQUN2QixXQUFLLE1BQU0sYUFBYTtBQUFBLElBQzFCO0FBQUEsSUFDQSxRQUFRLFNBQVUsUUFBUSxNQUFNO0FBQzlCLFlBQU0sRUFBRSxVQUFVLElBQUksS0FBSztBQUMzQixVQUFJLGNBQWMsUUFBVztBQUMzQixjQUFNRixRQUFPLEtBQUssYUFBYTtBQUMvQixZQUFJO0FBQ0YsbUJBQVMsVUFBVSxLQUFLLE1BQU0sUUFBUUEsS0FBSTtBQUFBLFFBQzVDLFNBQVMsS0FBSztBQUNaLGlCQUFPO0FBQUEsUUFDVDtBQUNBLFlBQUksV0FBVyxVQUFhLFdBQVcsTUFBTTtBQUMzQztBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0EsV0FBSyxNQUFNO0FBQUEsSUFDYjtBQUFBO0FBQUEsSUFFQSxRQUFRLFNBQVUsT0FBTztBQUN2QixZQUFNLEVBQUUsU0FBUyxtQkFBbUIsSUFBSSxLQUFLO0FBQzdDLFlBQU0sWUFBWSxNQUFNLFFBQVEsT0FBTztBQUl2QyxVQUNFLGNBQWMsUUFDZCxzQkFDQSxLQUFLLFFBQVEsUUFBUSxVQUFVLEtBQUssTUFBTSxPQUFPLFFBQ2pEO0FBQ0EsZUFBTyxDQUFDLFFBQVcsTUFBUztBQUFBLE1BQzlCO0FBQ0EsVUFBSSxLQUFLLE1BQU0sY0FBYyxNQUFNO0FBQ2pDLFlBQUk7QUFDRixnQkFBTUEsUUFBTyxLQUFLLFlBQVk7QUFDOUIsaUJBQU8sQ0FBQyxRQUFXLEtBQUssTUFBTSxVQUFVLEtBQUssTUFBTSxPQUFPQSxLQUFJLENBQUM7QUFBQSxRQUNqRSxTQUFTLEtBQUs7QUFDWixpQkFBTyxDQUFDLEdBQUc7QUFBQSxRQUNiO0FBQUEsTUFDRjtBQUNBLFVBQUksS0FBSyxVQUFVLEtBQUssR0FBRztBQUN6QixlQUFPLENBQUMsUUFBVyxXQUFXLEtBQUssQ0FBQztBQUFBLE1BQ3RDLFdBQVcsS0FBSyxRQUFRLGNBQWMsT0FBTztBQUMzQyxjQUFNQSxRQUFPLEtBQUssWUFBWTtBQUM5QixlQUFPLENBQUMsUUFBVyxLQUFLLFFBQVEsVUFBVSxLQUFLLE1BQU0sT0FBT0EsS0FBSSxDQUFDO0FBQUEsTUFDbkU7QUFDQSxhQUFPLENBQUMsUUFBVyxLQUFLO0FBQUEsSUFDMUI7QUFBQTtBQUFBLElBRUEsa0JBQWtCLFNBQVUsS0FBSyxLQUFLO0FBQ3BDLFlBQU0sU0FBUyxDQUFDRyxNQUFLQyxTQUFRO0FBQzNCLGNBQU0sRUFBRSxTQUFTLElBQUksS0FBSztBQUMxQixjQUFPLFVBQVNOLEtBQUksR0FBR0EsS0FBSSxTQUFTLFFBQVFBLE1BQUs7QUFDL0MsZ0JBQU0sVUFBVSxTQUFTQSxFQUFDO0FBQzFCLG1CQUFTLElBQUksR0FBRyxJQUFJLFFBQVEsUUFBUSxLQUFLO0FBQ3ZDLGdCQUFJLFFBQVEsQ0FBQyxNQUFNSyxLQUFJQyxPQUFNLENBQUMsRUFBRyxVQUFTO0FBQUEsVUFDNUM7QUFDQSxpQkFBTyxRQUFRO0FBQUEsUUFDakI7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUNBLGFBQU8sT0FBTyxLQUFLLEdBQUc7QUFBQSxJQUN4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBT0EsV0FBVyxTQUFVLE9BQU87QUFDMUIsYUFBTyxRQUFRLFdBQVcsS0FBSyxJQUFJLEtBQUs7QUFBQSxJQUMxQztBQUFBLElBQ0EsZ0JBQWdCLFNBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVztBQUNwRSxVQUFJLFVBQVUsQ0FBQyxNQUFNLFVBQVcsUUFBTztBQUN2QyxZQUFNLGVBQWUsVUFBVTtBQUMvQixlQUFTTixLQUFJLEdBQUdBLEtBQUksY0FBY0EsTUFBSztBQUNyQyxZQUFJLFVBQVVBLEVBQUMsTUFBTSxVQUFVLFlBQVlBLEVBQUMsRUFBRyxRQUFPO0FBQUEsTUFDeEQ7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQUFBLElBQ0EsZUFBZSxTQUFVLEtBQUssS0FBSyxLQUFLO0FBQ3RDLFlBQU0sRUFBRSxXQUFXLHVCQUF1QixJQUFJLEtBQUs7QUFDbkQsVUFDRSwyQkFBMkIsUUFDM0IsS0FBSyxNQUFNLE9BQU8sV0FBVyxLQUFLLFFBQVEsUUFBUSxTQUFTLEdBQzNEO0FBQ0EsZUFBTztBQUFBLE1BQ1QsV0FDRSwyQkFBMkIsU0FDM0IsT0FBTywyQkFBMkIsWUFDbEMsS0FBSyxNQUFNLE9BQU8sV0FBVyx5QkFBeUIsR0FDdEQ7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUNBLFlBQU8sVUFBU0EsS0FBSSxHQUFHQSxLQUFJLFVBQVUsUUFBUUEsTUFBSztBQUNoRCxjQUFNLE1BQU0sVUFBVUEsRUFBQztBQUN2QixZQUFJLElBQUksQ0FBQyxNQUFNLEtBQUs7QUFDbEIsbUJBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEtBQUs7QUFDbkMsZ0JBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsRUFBRyxVQUFTO0FBQUEsVUFDeEM7QUFDQSxpQkFBTyxJQUFJO0FBQUEsUUFDYjtBQUFBLE1BQ0Y7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQUFBLElBQ0EscUJBQXFCLFNBQVUsS0FBSyxLQUFLLEtBQUs7QUFDNUMsWUFBTSxFQUFFLGlCQUFpQixJQUFJLEtBQUs7QUFDbEMsWUFBTSx3QkFBd0IsaUJBQWlCO0FBQy9DLFlBQU8sVUFBU0EsS0FBSSxHQUFHQSxLQUFJLHVCQUF1QkEsTUFBSztBQUNyRCxjQUFNLEtBQUssaUJBQWlCQSxFQUFDO0FBQzdCLGNBQU0sV0FBVyxHQUFHO0FBQ3BCLFlBQUksR0FBRyxDQUFDLE1BQU0sS0FBSztBQUNqQjtBQUFBLFFBQ0Y7QUFDQSxpQkFBUyxJQUFJLEdBQUcsSUFBSSxVQUFVLEtBQUs7QUFDakMsY0FBSSxHQUFHLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxHQUFHO0FBQzFCLHFCQUFTO0FBQUEsVUFDWDtBQUFBLFFBQ0Y7QUFDQSxlQUFPLEdBQUc7QUFBQSxNQUNaO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFBQSxJQUNBLFlBQVksU0FBVSxLQUFLLEtBQUssS0FBSztBQUNuQyxZQUFNLEVBQUUsT0FBTyxJQUFJLEtBQUs7QUFDeEIsVUFBSSxXQUFXLEtBQU0sUUFBTztBQUM1QixZQUFNLElBQUksT0FBTztBQUNqQixVQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUs7QUFDckIsaUJBQVNBLEtBQUksR0FBR0EsS0FBSSxHQUFHQSxNQUFLO0FBQzFCLGNBQUksT0FBT0EsRUFBQyxNQUFNLElBQUksTUFBTUEsRUFBQyxHQUFHO0FBQzlCLG1CQUFPO0FBQUEsVUFDVDtBQUFBLFFBQ0Y7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUNBLGFBQU87QUFBQSxJQUNUO0FBQUEsSUFDQSxXQUFXLFNBQVUsS0FBSyxLQUFLO0FBQzdCLFlBQU0sRUFBRSxNQUFNLElBQUksS0FBSztBQUN2QixVQUFJLFVBQVUsS0FBTSxRQUFPO0FBQzNCLFlBQU0sSUFBSSxNQUFNO0FBQ2hCLGVBQVNBLEtBQUksR0FBR0EsS0FBSSxHQUFHQSxNQUFLO0FBQzFCLFlBQUksTUFBTUEsRUFBQyxNQUFNLElBQUksTUFBTUEsRUFBQyxHQUFHO0FBQzdCLGlCQUFPO0FBQUEsUUFDVDtBQUFBLE1BQ0Y7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQUFBLElBQ0EsK0JBQStCLFNBQVUsS0FBSyxLQUFLO0FBQ2pELFlBQU0sRUFBRSxTQUFTLElBQUksS0FBSztBQUkxQixZQUFNLE1BQU07QUFBQTtBQUFBLFFBRVYsT0FBTyxLQUFLLFFBQVEsUUFBUTtBQUFBLFFBQzVCLE9BQU8sS0FBSyxNQUFNLFFBQVE7QUFBQSxRQUMxQixPQUFPLEtBQUssTUFBTSxRQUFRO0FBQUEsTUFDNUI7QUFDQSxXQUFNLFVBQVNBLEtBQUksR0FBR0EsS0FBSSxJQUFJLFFBQVFBLE1BQUs7QUFDekMsY0FBTSxJQUFJLElBQUlBLEVBQUMsRUFBRTtBQUNqQixpQkFBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDMUIsY0FBSSxJQUFJQSxFQUFDLEVBQUUsQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLEdBQUc7QUFDOUIscUJBQVM7QUFBQSxVQUNYO0FBQUEsUUFDRjtBQUNBLGFBQUssUUFBUSxpQkFBaUIsS0FBSyxJQUFJQSxFQUFDLENBQUM7QUFDekMsYUFBSyxNQUFNLDJCQUEyQixJQUFJQSxFQUFDLEVBQUU7QUFDN0MsZUFBTyxJQUFJQSxFQUFDLEVBQUU7QUFBQSxNQUNoQjtBQUNBLGFBQU87QUFBQSxJQUNUO0FBQUEsSUFDQSxTQUFTLFNBQVUsS0FBSztBQUN0QixZQUFNLEVBQUUsVUFBVSxLQUFLLHdCQUF3QixJQUFJLEtBQUs7QUFDeEQsWUFBTSxNQUFNLE9BQU8sUUFBUSxXQUFXLElBQUksTUFBTSxHQUFHLElBQUk7QUFDdkQsVUFBSSx5QkFBeUI7QUFDM0IsYUFBSyxNQUFNLGlCQUFpQjtBQUM1QixZQUFJLEtBQUssUUFBUSxZQUFZLFFBQVc7QUFDdEMsZUFBSyxRQUFRO0FBQUEsWUFDWDtBQUFBLFlBQ0EsTUFBTSxLQUFLLE1BQU0sVUFBVSxTQUFTLFFBQVEsSUFBSTtBQUFBLFVBQ2xEO0FBQUEsUUFDRjtBQUVBLGVBQU87QUFBQSxNQUNULE9BQU87QUFDTCxlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0Y7QUFBQSxJQUNBLGVBQWUsV0FBWTtBQUN6QixhQUFPO0FBQUEsUUFDTCxHQUFHLEtBQUs7QUFBQSxRQUNSLFNBQVMsS0FBSyxRQUFRO0FBQUEsTUFDeEI7QUFBQSxJQUNGO0FBQUEsSUFDQSxjQUFjLFdBQVk7QUFDeEIsWUFBTSxFQUFFLFNBQVMsS0FBSyxTQUFTLElBQUksS0FBSztBQUN4QyxhQUFPO0FBQUEsUUFDTCxHQUFHLEtBQUssY0FBYztBQUFBLFFBQ3RCLE9BQU8sS0FBSyxNQUFNO0FBQUEsUUFDbEIsUUFBUSxZQUFZO0FBQUEsUUFDcEIsT0FBTyxLQUFLLE1BQU0sT0FBTztBQUFBLFFBQ3pCLEtBQUssTUFBTSxLQUFLLE1BQU0sVUFBVSxTQUFTLFFBQVEsSUFBSTtBQUFBLE1BQ3ZEO0FBQUEsSUFDRjtBQUFBLElBQ0EsYUFBYSxXQUFZO0FBQ3ZCLFlBQU0sRUFBRSxRQUFRLElBQUksS0FBSztBQUN6QixZQUFNLFlBQVksTUFBTSxRQUFRLE9BQU87QUFDdkMsYUFBTztBQUFBLFFBQ0wsR0FBRyxLQUFLLGFBQWE7QUFBQSxRQUNyQixRQUNFLGNBQWMsT0FDVixRQUFRLFNBQVMsS0FBSyxNQUFNLE9BQU8sU0FDakMsUUFBUSxLQUFLLE1BQU0sT0FBTyxNQUFNLEVBQUUsT0FDbEMsT0FDRixLQUFLLE1BQU0sT0FBTztBQUFBLFFBQ3hCLFNBQVMsS0FBSyxNQUFNO0FBQUEsTUFDdEI7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGOzs7QUN2NEJBLElBQU0sUUFBUSxTQUFVLE1BQU0sT0FBTyxDQUFDLEdBQUc7QUFDdkMsTUFBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixXQUFPLE9BQU8sS0FBSyxJQUFJO0FBQUEsRUFDekI7QUFDQSxRQUFNLFVBQVUsUUFBUSxLQUFLLFVBQVUsQ0FBQyxJQUFJLENBQUM7QUFDN0MsUUFBTSxTQUFTLFVBQVUsSUFBSTtBQUM3QixRQUFNLE9BQU8sQ0FBQyxXQUFXO0FBQ3ZCLFFBQUksT0FBTyxRQUFRLFlBQVksT0FBVyxTQUFRLEtBQUssTUFBTTtBQUFBLFNBQ3hEO0FBQ0gsY0FBUSxPQUFPLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQztBQUFBLElBQy9CO0FBQUEsRUFDRjtBQUNBLFFBQU0sUUFBUSxNQUFNO0FBQUEsRUFBQztBQUNyQixRQUFNLE9BQU8sT0FBTyxNQUFNLE1BQU0sT0FBTyxNQUFNLEtBQUs7QUFDbEQsTUFBSSxTQUFTLE9BQVcsT0FBTTtBQUM5QixRQUFNLE9BQU8sT0FBTyxNQUFNLFFBQVcsTUFBTSxNQUFNLEtBQUs7QUFDdEQsTUFBSSxTQUFTLE9BQVcsT0FBTTtBQUM5QixTQUFPO0FBQ1Q7OztBdEJWQSxJQUFBTyxjQUE0QjtBQVk1QixJQUFNLFlBQVksWUFBQUMsUUFBSyxLQUFLLHdCQUFZLGFBQWEsWUFBWTtBQUNqRSxJQUFNLFlBQVksS0FBSyxLQUFLLEtBQUs7QUFDakMsSUFBTSxnQkFBZ0I7QUFLdEIsZUFBZSxpQkFBZ0M7QUFDN0MsTUFBSTtBQUNGLFVBQU0sZ0JBQUFDLFFBQUcsTUFBTSxXQUFXLEVBQUUsV0FBVyxLQUFLLENBQUM7QUFBQSxFQUMvQyxTQUFTLE9BQU87QUFDZCxZQUFRLE1BQU0scUNBQXFDLEtBQUs7QUFBQSxFQUMxRDtBQUNGO0FBTUEsZUFBZSxnQkFBZ0Q7QUFDN0QsTUFBSTtBQUNGLFVBQU0sWUFBWSxZQUFBRCxRQUFLLEtBQUssV0FBVyxrQkFBa0I7QUFDekQsVUFBTSxjQUFjLE1BQU0sZ0JBQUFDLFFBQUcsT0FBTyxTQUFTLEVBQUUsS0FBSyxNQUFNLElBQUksRUFBRSxNQUFNLE1BQU0sS0FBSztBQUVqRixRQUFJLENBQUMsYUFBYTtBQUNoQixhQUFPO0FBQUEsSUFDVDtBQUVBLFVBQU0sZUFBZSxNQUFNLGdCQUFBQSxRQUFHLFNBQVMsV0FBVyxPQUFPO0FBQ3pELFVBQU0sUUFBb0MsS0FBSyxNQUFNLFlBQVk7QUFHakUsUUFBSSxLQUFLLElBQUksSUFBSSxNQUFNLFlBQVksTUFBTSxLQUFLO0FBQzVDLGNBQVEsSUFBSSxvQkFBb0I7QUFDaEMsYUFBTztBQUFBLElBQ1Q7QUFHQSxVQUFNLE9BQU8sTUFBTTtBQUNuQixXQUFPO0FBQUEsTUFDTCxPQUFPLElBQUksSUFBSSxPQUFPLFFBQVEsS0FBSyxLQUFZLENBQUM7QUFBQSxNQUNoRCxRQUFRLElBQUksSUFBSSxPQUFPLFFBQVEsS0FBSyxNQUFhLENBQUM7QUFBQSxNQUNsRCxPQUFPLElBQUksSUFBSSxPQUFPLFFBQVEsS0FBSyxLQUFZLENBQUM7QUFBQSxNQUNoRCxXQUFXLEtBQUs7QUFBQSxNQUNoQixlQUFlLEtBQUs7QUFBQSxNQUNwQixhQUFhLElBQUksS0FBSyxLQUFLLFdBQVc7QUFBQSxJQUN4QztBQUFBLEVBQ0YsU0FBUyxPQUFPO0FBQ2QsWUFBUSxNQUFNLHlCQUF5QixLQUFLO0FBQzVDLFdBQU87QUFBQSxFQUNUO0FBQ0Y7QUFNQSxlQUFlLFlBQVksTUFBcUM7QUFDOUQsTUFBSTtBQUNGLFVBQU0sZUFBZTtBQUdyQixVQUFNLGVBQWU7QUFBQSxNQUNuQixPQUFPLE9BQU8sWUFBWSxLQUFLLEtBQUs7QUFBQSxNQUNwQyxRQUFRLE9BQU8sWUFBWSxLQUFLLE1BQU07QUFBQSxNQUN0QyxPQUFPLE9BQU8sWUFBWSxLQUFLLEtBQUs7QUFBQSxNQUNwQyxXQUFXLEtBQUs7QUFBQSxNQUNoQixlQUFlLEtBQUs7QUFBQSxNQUNwQixhQUFhLEtBQUs7QUFBQSxJQUNwQjtBQUVBLFVBQU0sUUFBeUI7QUFBQSxNQUM3QixNQUFNO0FBQUEsTUFDTixXQUFXLEtBQUssSUFBSTtBQUFBLE1BQ3BCLEtBQUs7QUFBQSxJQUNQO0FBRUEsVUFBTSxZQUFZLFlBQUFELFFBQUssS0FBSyxXQUFXLGtCQUFrQjtBQUN6RCxVQUFNLGdCQUFBQyxRQUFHLFVBQVUsV0FBVyxLQUFLLFVBQVUsS0FBSyxDQUFDO0FBQ25ELFlBQVEsSUFBSSwrQkFBK0I7QUFBQSxFQUM3QyxTQUFTLE9BQU87QUFDZCxZQUFRLE1BQU0seUJBQXlCLEtBQUs7QUFBQSxFQUM5QztBQUNGO0FBTUEsZUFBZSx5QkFBMEM7QUFDdkQsUUFBTSxVQUFVLFlBQUFELFFBQUssS0FBSyxVQUFBRSxRQUFHLE9BQU8sR0FBRyxRQUFRLEtBQUssSUFBSSxDQUFDLEVBQUU7QUFDM0QsUUFBTSxnQkFBQUQsUUFBRyxNQUFNLFNBQVMsRUFBRSxXQUFXLEtBQUssQ0FBQztBQUUzQyxNQUFJO0FBQ0YsWUFBUSxJQUFJLCtCQUErQixhQUFhO0FBR3hELFVBQU0sV0FBVyxNQUFNLE1BQU0sZUFBZTtBQUFBLE1BQzFDLFFBQVEsWUFBWSxRQUFRLEdBQUs7QUFBQTtBQUFBLElBQ25DLENBQUM7QUFFRCxRQUFJLENBQUMsU0FBUyxJQUFJO0FBQ2hCLFlBQU0sSUFBSSxNQUFNLGlDQUFpQyxTQUFTLFVBQVUsRUFBRTtBQUFBLElBQ3hFO0FBR0EsVUFBTSxTQUFTLE1BQU0sU0FBUyxZQUFZO0FBQzFDLFVBQU0sWUFBWSxPQUFPLEtBQUssTUFBTTtBQUdwQyxVQUFNLE1BQU0sSUFBSSxlQUFBRSxRQUFPLFNBQVM7QUFDaEMsUUFBSSxhQUFhLFNBQVMsSUFBSTtBQUU5QixZQUFRLElBQUksMkJBQTJCLE9BQU87QUFDOUMsV0FBTztBQUFBLEVBQ1QsU0FBUyxPQUFPO0FBRWQsVUFBTSxnQkFBQUYsUUFBRyxHQUFHLFNBQVMsRUFBRSxXQUFXLE1BQU0sT0FBTyxLQUFLLENBQUMsRUFBRSxNQUFNLE1BQU07QUFBQSxJQUFDLENBQUM7QUFDckUsVUFBTTtBQUFBLEVBQ1I7QUFDRjtBQVFBLGVBQWUsYUFBZ0IsVUFBa0IsV0FBb0IsT0FBcUI7QUFDeEYsTUFBSTtBQUNGLFVBQU0sVUFBVSxNQUFNLGdCQUFBQSxRQUFHLFNBQVMsVUFBVSxPQUFPO0FBQ25ELFdBQU8sTUFBTSxTQUFTO0FBQUEsTUFDcEIsU0FBUztBQUFBLE1BQ1Qsa0JBQWtCO0FBQUEsTUFDbEIsTUFBTTtBQUFBLE1BQ04sTUFBTSxDQUFDLE9BQU8sWUFBWTtBQUV4QixZQUFJLFFBQVEsT0FBUSxRQUFPO0FBQzNCLFlBQUksVUFBVSxHQUFJLFFBQU87QUFDekIsY0FBTSxNQUFNLE9BQU8sS0FBSztBQUN4QixZQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssTUFBTSxNQUFNLGlCQUFpQixHQUFHO0FBQ2pELGlCQUFPO0FBQUEsUUFDVDtBQUNBLGVBQU87QUFBQSxNQUNUO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSCxTQUFTLE9BQVk7QUFDbkIsUUFBSSxZQUFZLE1BQU0sU0FBUyxVQUFVO0FBQ3ZDLGNBQVEsTUFBTSxtQkFBbUIsUUFBUSxLQUFLLEtBQUs7QUFBQSxJQUNyRDtBQUNBLFdBQU8sQ0FBQztBQUFBLEVBQ1Y7QUFDRjtBQU9BLGVBQXNCLGVBQWUsZUFBd0IsT0FBZ0M7QUFFM0YsTUFBSSxDQUFDLGNBQWM7QUFDakIsVUFBTSxTQUFTLE1BQU0sY0FBYztBQUNuQyxRQUFJLFFBQVE7QUFDVixjQUFRLElBQUksd0JBQXdCO0FBQ3BDLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUVBLFVBQVEsSUFBSSx5QkFBeUI7QUFDckMsTUFBSSxhQUE0QjtBQUVoQyxNQUFJO0FBRUYsaUJBQWEsTUFBTSx1QkFBdUI7QUFHMUMsVUFBTSxDQUFDLE9BQU8sUUFBUSxPQUFPLFdBQVcsYUFBYSxJQUFJLE1BQU0sUUFBUSxJQUFJO0FBQUEsTUFDekUsYUFBbUIsWUFBQUQsUUFBSyxLQUFLLFlBQVksV0FBVyxHQUFHLElBQUk7QUFBQSxNQUMzRCxhQUFvQixZQUFBQSxRQUFLLEtBQUssWUFBWSxZQUFZLEdBQUcsSUFBSTtBQUFBLE1BQzdELGFBQW1CLFlBQUFBLFFBQUssS0FBSyxZQUFZLFdBQVcsR0FBRyxJQUFJO0FBQUEsTUFDM0QsYUFBdUIsWUFBQUEsUUFBSyxLQUFLLFlBQVksZ0JBQWdCLEdBQUcsSUFBSTtBQUFBLE1BQ3BFLGFBQTJCLFlBQUFBLFFBQUssS0FBSyxZQUFZLG9CQUFvQixHQUFHLEtBQUs7QUFBQSxJQUMvRSxDQUFDO0FBRUQsWUFBUSxJQUFJLFdBQVcsTUFBTSxNQUFNLFdBQVcsT0FBTyxNQUFNLFlBQVksTUFBTSxNQUFNLFFBQVE7QUFHM0YsVUFBTSxXQUFXLG9CQUFJLElBQWtCO0FBQ3ZDLFVBQU0sUUFBUSxDQUFDLFNBQVM7QUFDdEIsZUFBUyxJQUFJLEtBQUssU0FBUyxJQUFJO0FBQUEsSUFDakMsQ0FBQztBQUVELFVBQU0sWUFBWSxvQkFBSSxJQUFtQjtBQUN6QyxXQUFPLFFBQVEsQ0FBQyxVQUFVO0FBQ3hCLGdCQUFVLElBQUksTUFBTSxVQUFVLEtBQUs7QUFBQSxJQUNyQyxDQUFDO0FBRUQsVUFBTSxXQUFXLG9CQUFJLElBQWtCO0FBQ3ZDLFVBQU0sUUFBUSxDQUFDLFNBQVM7QUFDdEIsZUFBUyxJQUFJLEtBQUssU0FBUyxJQUFJO0FBQUEsSUFDakMsQ0FBQztBQUVELFVBQU0sT0FBdUI7QUFBQSxNQUMzQixPQUFPO0FBQUEsTUFDUCxRQUFRO0FBQUEsTUFDUixPQUFPO0FBQUEsTUFDUDtBQUFBLE1BQ0E7QUFBQSxNQUNBLGFBQWEsb0JBQUksS0FBSztBQUFBLElBQ3hCO0FBR0EsVUFBTSxZQUFZLElBQUk7QUFFdEIsV0FBTztBQUFBLEVBQ1QsVUFBRTtBQUVBLFFBQUksWUFBWTtBQUNkLFlBQU0sZ0JBQUFDLFFBQUcsR0FBRyxZQUFZLEVBQUUsV0FBVyxNQUFNLE9BQU8sS0FBSyxDQUFDLEVBQUUsTUFBTSxNQUFNO0FBQUEsTUFBQyxDQUFDO0FBQUEsSUFDMUU7QUFBQSxFQUNGO0FBQ0Y7OztBRGxHb0I7QUFoSUwsU0FBUixjQUErQjtBQUNwQyxRQUFNLENBQUMsV0FBVyxZQUFZLFFBQUksdUJBQVMsSUFBSTtBQUMvQyxRQUFNLENBQUMsT0FBTyxRQUFRLFFBQUksdUJBQWlCLENBQUMsQ0FBQztBQUM3QyxRQUFNLENBQUMsWUFBWSxhQUFhLFFBQUksdUJBQVMsRUFBRTtBQUMvQyxRQUFNLENBQUMsYUFBYSxjQUFjLFFBQUksdUJBQXdCLElBQUk7QUFFbEUsOEJBQVUsTUFBTTtBQUNkLGNBQVU7QUFDVixrQkFBYztBQUFBLEVBQ2hCLEdBQUcsQ0FBQyxDQUFDO0FBRUwsUUFBTSxnQkFBZ0IsWUFBWTtBQUNoQyxRQUFJO0FBQ0YsWUFBTSxRQUFRLE1BQU0seUJBQWEsUUFBZ0IsaUJBQWlCO0FBQ2xFLFVBQUksT0FBTztBQUNULHVCQUFlLEtBQUs7QUFBQSxNQUN0QjtBQUFBLElBQ0YsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLDZCQUE2QixLQUFLO0FBQUEsSUFDbEQ7QUFBQSxFQUNGO0FBRUEsUUFBTSxZQUFZLFlBQVk7QUFDNUIsUUFBSTtBQUNGLFlBQU0sV0FBVyxNQUFNLGVBQWU7QUFDdEMsWUFBTSxXQUFXLE1BQU0sS0FBSyxTQUFTLE1BQU0sT0FBTyxDQUFDO0FBR25ELGVBQVMsS0FBSyxDQUFDLEdBQUcsTUFBTSxFQUFFLFVBQVUsY0FBYyxFQUFFLFNBQVMsQ0FBQztBQUU5RCxlQUFTLFFBQVE7QUFBQSxJQUNuQixTQUFTLE9BQU87QUFDZCxjQUFRLE1BQU0sd0JBQXdCLEtBQUs7QUFDM0MsaUNBQVU7QUFBQSxRQUNSLE9BQU8sa0JBQU0sTUFBTTtBQUFBLFFBQ25CLE9BQU87QUFBQSxRQUNQLFNBQVMsaUJBQWlCLFFBQVEsTUFBTSxVQUFVO0FBQUEsTUFDcEQsQ0FBQztBQUFBLElBQ0gsVUFBRTtBQUNBLG1CQUFhLEtBQUs7QUFBQSxJQUNwQjtBQUFBLEVBQ0Y7QUFFQSxRQUFNLGtCQUFrQixPQUFPLFNBQWU7QUFDNUMsUUFBSTtBQUNGLFlBQU0sU0FBUyxPQUFPLEtBQUssT0FBTztBQUNsQyxZQUFNLHlCQUFhLFFBQVEsbUJBQW1CLE1BQU07QUFDcEQsWUFBTSx5QkFBYSxRQUFRLHFCQUFxQixLQUFLLFNBQVM7QUFDOUQscUJBQWUsTUFBTTtBQUVyQixpQ0FBVTtBQUFBLFFBQ1IsT0FBTyxrQkFBTSxNQUFNO0FBQUEsUUFDbkIsT0FBTztBQUFBLFFBQ1AsU0FBUyxHQUFHLEtBQUssU0FBUyxLQUFLLE1BQU07QUFBQSxNQUN2QyxDQUFDO0FBQUEsSUFDSCxTQUFTLE9BQU87QUFDZCxpQ0FBVTtBQUFBLFFBQ1IsT0FBTyxrQkFBTSxNQUFNO0FBQUEsUUFDbkIsT0FBTztBQUFBLFFBQ1AsU0FBUyxpQkFBaUIsUUFBUSxNQUFNLFVBQVU7QUFBQSxNQUNwRCxDQUFDO0FBQUEsSUFDSDtBQUFBLEVBQ0Y7QUFHQSxRQUFNLGdCQUFnQixNQUFNLE9BQU8sQ0FBQyxTQUFTO0FBQzNDLFVBQU0sU0FBUyxXQUFXLFlBQVk7QUFDdEMsVUFBTSxTQUFTLE9BQU8sS0FBSyxPQUFPO0FBQ2xDLFVBQU0sV0FBVyxLQUFLLGFBQWE7QUFDbkMsV0FDRSxPQUFPLFlBQVksRUFBRSxTQUFTLE1BQU0sS0FDcEMsU0FBUyxZQUFZLEVBQUUsU0FBUyxNQUFNO0FBQUEsRUFFMUMsQ0FBQztBQUdELFFBQU0sY0FBYyxjQUFjO0FBQUEsSUFBTyxDQUFDRyxPQUN4Q0EsR0FBRSxVQUFVLFNBQVMsUUFBUSxLQUM3QkEsR0FBRSxVQUFVLFNBQVMsUUFBUSxLQUM3QkEsR0FBRSxVQUFVLFNBQVMsS0FBSyxLQUMxQkEsR0FBRSxVQUFVLFNBQVMsU0FBUyxLQUM5QkEsR0FBRSxVQUFVLFNBQVMsU0FBUyxLQUM5QkEsR0FBRSxVQUFVLFNBQVMsU0FBUztBQUFBLEVBQ2hDO0FBRUEsUUFBTSxnQkFBZ0IsY0FBYztBQUFBLElBQU8sQ0FBQ0EsT0FDMUNBLEdBQUUsVUFBVSxTQUFTLFVBQVUsS0FDL0JBLEdBQUUsVUFBVSxTQUFTLGFBQWEsS0FDbENBLEdBQUUsVUFBVSxTQUFTLFlBQVksS0FDakNBLEdBQUUsVUFBVSxTQUFTLFVBQVU7QUFBQSxFQUNqQztBQUVBLFFBQU0saUJBQWlCLGNBQWM7QUFBQSxJQUFPLENBQUNBLE9BQzNDQSxHQUFFLFVBQVUsU0FBUyxXQUFXLEtBQ2hDQSxHQUFFLFVBQVUsU0FBUyxTQUFTLEtBQzlCQSxHQUFFLFVBQVUsU0FBUyxNQUFNLEtBQzNCQSxHQUFFLFVBQVUsU0FBUyxPQUFPLEtBQzVCQSxHQUFFLFVBQVUsU0FBUyxPQUFPLEtBQzVCQSxHQUFFLFVBQVUsU0FBUyxVQUFVO0FBQUEsRUFDakM7QUFFQSxRQUFNLGFBQWEsY0FBYztBQUFBLElBQU8sQ0FBQ0EsT0FDdkMsQ0FBQyxZQUFZLFNBQVNBLEVBQUMsS0FDdkIsQ0FBQyxjQUFjLFNBQVNBLEVBQUMsS0FDekIsQ0FBQyxlQUFlLFNBQVNBLEVBQUM7QUFBQSxFQUM1QjtBQUVBLFNBQ0U7QUFBQSxJQUFDO0FBQUE7QUFBQSxNQUNDO0FBQUEsTUFDQTtBQUFBLE1BQ0Esb0JBQW9CO0FBQUEsTUFDcEIsc0JBQXFCO0FBQUEsTUFDckIsaUJBQWdCO0FBQUEsTUFFZjtBQUFBLHVCQUNDLDRDQUFDLGlCQUFLLFNBQUwsRUFBYSxPQUFNLG1CQUNqQixnQkFDRSxPQUFPLENBQUNBLE9BQU0sT0FBT0EsR0FBRSxPQUFPLE1BQU0sV0FBVyxFQUMvQyxJQUFJLENBQUMsU0FDSjtBQUFBLFVBQUMsaUJBQUs7QUFBQSxVQUFMO0FBQUEsWUFFQyxPQUFPLEtBQUs7QUFBQSxZQUNaLFVBQVUsUUFBUSxPQUFPLEtBQUssT0FBTyxDQUFDO0FBQUEsWUFDdEMsTUFBTSxFQUFFLFFBQVEsaUJBQUssTUFBTSxXQUFXLFVBQVU7QUFBQSxZQUNoRCxhQUFhLENBQUMsRUFBRSxNQUFNLG1CQUFtQixNQUFNLGlCQUFLLFVBQVUsQ0FBQztBQUFBLFlBQy9ELFNBQ0UsNENBQUMsMkJBQ0M7QUFBQSxjQUFDO0FBQUE7QUFBQSxnQkFDQyxPQUFNO0FBQUEsZ0JBQ04sTUFBTSxpQkFBSztBQUFBLGdCQUNYLFVBQVUsTUFBTTtBQUVkLDZDQUFVO0FBQUEsb0JBQ1IsT0FBTyxrQkFBTSxNQUFNO0FBQUEsb0JBQ25CLE9BQU87QUFBQSxvQkFDUCxTQUFTO0FBQUEsa0JBQ1gsQ0FBQztBQUFBLGdCQUNIO0FBQUE7QUFBQSxZQUNGLEdBQ0Y7QUFBQTtBQUFBLFVBbkJHLE9BQU8sS0FBSyxPQUFPO0FBQUEsUUFxQjFCLENBQ0QsR0FDTDtBQUFBLFFBR0QsWUFBWSxTQUFTLEtBQ3BCLDRDQUFDLGlCQUFLLFNBQUwsRUFBYSxPQUFNLGdCQUNqQixzQkFBWSxJQUFJLENBQUMsU0FDaEI7QUFBQSxVQUFDLGlCQUFLO0FBQUEsVUFBTDtBQUFBLFlBRUMsT0FBTyxLQUFLO0FBQUEsWUFDWixVQUFVLFFBQVEsT0FBTyxLQUFLLE9BQU8sQ0FBQztBQUFBLFlBQ3RDLE1BQU0saUJBQUs7QUFBQSxZQUNYLGFBQWE7QUFBQSxjQUNYLE9BQU8sS0FBSyxPQUFPLE1BQU0sZUFBZSxFQUFFLE1BQU0saUJBQUssVUFBVTtBQUFBLFlBQ2pFLEVBQUUsT0FBTyxPQUFPO0FBQUEsWUFDaEIsU0FDRSw2Q0FBQywyQkFDQztBQUFBO0FBQUEsZ0JBQUM7QUFBQTtBQUFBLGtCQUNDLE9BQU07QUFBQSxrQkFDTixNQUFNLGlCQUFLO0FBQUEsa0JBQ1gsVUFBVSxNQUFNLGdCQUFnQixJQUFJO0FBQUE7QUFBQSxjQUN0QztBQUFBLGNBQ0E7QUFBQSxnQkFBQyxtQkFBTztBQUFBLGdCQUFQO0FBQUEsa0JBQ0MsT0FBTTtBQUFBLGtCQUNOLFNBQVMsT0FBTyxLQUFLLE9BQU87QUFBQSxrQkFDNUIsVUFBVSxFQUFFLFdBQVcsQ0FBQyxLQUFLLEdBQUcsS0FBSyxJQUFJO0FBQUE7QUFBQSxjQUMzQztBQUFBLGNBQ0E7QUFBQSxnQkFBQztBQUFBO0FBQUEsa0JBQ0MsT0FBTTtBQUFBLGtCQUNOLE1BQU0saUJBQUs7QUFBQSxrQkFDWCxVQUFVO0FBQUEsa0JBQ1YsVUFBVSxFQUFFLFdBQVcsQ0FBQyxLQUFLLEdBQUcsS0FBSyxJQUFJO0FBQUE7QUFBQSxjQUMzQztBQUFBLGVBQ0Y7QUFBQTtBQUFBLFVBekJHLE9BQU8sS0FBSyxPQUFPO0FBQUEsUUEyQjFCLENBQ0QsR0FDSDtBQUFBLFFBR0QsY0FBYyxTQUFTLEtBQ3RCLDRDQUFDLGlCQUFLLFNBQUwsRUFBYSxPQUFNLGtCQUNqQix3QkFBYyxJQUFJLENBQUMsU0FDbEI7QUFBQSxVQUFDLGlCQUFLO0FBQUEsVUFBTDtBQUFBLFlBRUMsT0FBTyxLQUFLO0FBQUEsWUFDWixVQUFVLFFBQVEsT0FBTyxLQUFLLE9BQU8sQ0FBQztBQUFBLFlBQ3RDLE1BQU0saUJBQUs7QUFBQSxZQUNYLGFBQWE7QUFBQSxjQUNYLE9BQU8sS0FBSyxPQUFPLE1BQU0sZUFBZSxFQUFFLE1BQU0saUJBQUssVUFBVTtBQUFBLFlBQ2pFLEVBQUUsT0FBTyxPQUFPO0FBQUEsWUFDaEIsU0FDRSw2Q0FBQywyQkFDQztBQUFBO0FBQUEsZ0JBQUM7QUFBQTtBQUFBLGtCQUNDLE9BQU07QUFBQSxrQkFDTixNQUFNLGlCQUFLO0FBQUEsa0JBQ1gsVUFBVSxNQUFNLGdCQUFnQixJQUFJO0FBQUE7QUFBQSxjQUN0QztBQUFBLGNBQ0E7QUFBQSxnQkFBQyxtQkFBTztBQUFBLGdCQUFQO0FBQUEsa0JBQ0MsT0FBTTtBQUFBLGtCQUNOLFNBQVMsT0FBTyxLQUFLLE9BQU87QUFBQSxrQkFDNUIsVUFBVSxFQUFFLFdBQVcsQ0FBQyxLQUFLLEdBQUcsS0FBSyxJQUFJO0FBQUE7QUFBQSxjQUMzQztBQUFBLGNBQ0E7QUFBQSxnQkFBQztBQUFBO0FBQUEsa0JBQ0MsT0FBTTtBQUFBLGtCQUNOLE1BQU0saUJBQUs7QUFBQSxrQkFDWCxVQUFVO0FBQUEsa0JBQ1YsVUFBVSxFQUFFLFdBQVcsQ0FBQyxLQUFLLEdBQUcsS0FBSyxJQUFJO0FBQUE7QUFBQSxjQUMzQztBQUFBLGVBQ0Y7QUFBQTtBQUFBLFVBekJHLE9BQU8sS0FBSyxPQUFPO0FBQUEsUUEyQjFCLENBQ0QsR0FDSDtBQUFBLFFBR0QsZUFBZSxTQUFTLEtBQ3ZCLDRDQUFDLGlCQUFLLFNBQUwsRUFBYSxPQUFNLDRCQUNqQix5QkFBZSxJQUFJLENBQUMsU0FDbkI7QUFBQSxVQUFDLGlCQUFLO0FBQUEsVUFBTDtBQUFBLFlBRUMsT0FBTyxLQUFLO0FBQUEsWUFDWixVQUFVLFFBQVEsT0FBTyxLQUFLLE9BQU8sQ0FBQztBQUFBLFlBQ3RDLE1BQU0saUJBQUs7QUFBQSxZQUNYLGFBQWE7QUFBQSxjQUNYLE9BQU8sS0FBSyxPQUFPLE1BQU0sZUFBZSxFQUFFLE1BQU0saUJBQUssVUFBVTtBQUFBLFlBQ2pFLEVBQUUsT0FBTyxPQUFPO0FBQUEsWUFDaEIsU0FDRSw2Q0FBQywyQkFDQztBQUFBO0FBQUEsZ0JBQUM7QUFBQTtBQUFBLGtCQUNDLE9BQU07QUFBQSxrQkFDTixNQUFNLGlCQUFLO0FBQUEsa0JBQ1gsVUFBVSxNQUFNLGdCQUFnQixJQUFJO0FBQUE7QUFBQSxjQUN0QztBQUFBLGNBQ0E7QUFBQSxnQkFBQyxtQkFBTztBQUFBLGdCQUFQO0FBQUEsa0JBQ0MsT0FBTTtBQUFBLGtCQUNOLFNBQVMsT0FBTyxLQUFLLE9BQU87QUFBQSxrQkFDNUIsVUFBVSxFQUFFLFdBQVcsQ0FBQyxLQUFLLEdBQUcsS0FBSyxJQUFJO0FBQUE7QUFBQSxjQUMzQztBQUFBLGNBQ0E7QUFBQSxnQkFBQztBQUFBO0FBQUEsa0JBQ0MsT0FBTTtBQUFBLGtCQUNOLE1BQU0saUJBQUs7QUFBQSxrQkFDWCxVQUFVO0FBQUEsa0JBQ1YsVUFBVSxFQUFFLFdBQVcsQ0FBQyxLQUFLLEdBQUcsS0FBSyxJQUFJO0FBQUE7QUFBQSxjQUMzQztBQUFBLGVBQ0Y7QUFBQTtBQUFBLFVBekJHLE9BQU8sS0FBSyxPQUFPO0FBQUEsUUEyQjFCLENBQ0QsR0FDSDtBQUFBLFFBR0QsV0FBVyxTQUFTLEtBQ25CLDRDQUFDLGlCQUFLLFNBQUwsRUFBYSxPQUFNLGVBQ2pCLHFCQUFXLElBQUksQ0FBQyxTQUNmO0FBQUEsVUFBQyxpQkFBSztBQUFBLFVBQUw7QUFBQSxZQUVDLE9BQU8sS0FBSztBQUFBLFlBQ1osVUFBVSxRQUFRLE9BQU8sS0FBSyxPQUFPLENBQUM7QUFBQSxZQUN0QyxNQUFNLGlCQUFLO0FBQUEsWUFDWCxhQUFhO0FBQUEsY0FDWCxPQUFPLEtBQUssT0FBTyxNQUFNLGVBQWUsRUFBRSxNQUFNLGlCQUFLLFVBQVU7QUFBQSxZQUNqRSxFQUFFLE9BQU8sT0FBTztBQUFBLFlBQ2hCLFNBQ0UsNkNBQUMsMkJBQ0M7QUFBQTtBQUFBLGdCQUFDO0FBQUE7QUFBQSxrQkFDQyxPQUFNO0FBQUEsa0JBQ04sTUFBTSxpQkFBSztBQUFBLGtCQUNYLFVBQVUsTUFBTSxnQkFBZ0IsSUFBSTtBQUFBO0FBQUEsY0FDdEM7QUFBQSxjQUNBO0FBQUEsZ0JBQUMsbUJBQU87QUFBQSxnQkFBUDtBQUFBLGtCQUNDLE9BQU07QUFBQSxrQkFDTixTQUFTLE9BQU8sS0FBSyxPQUFPO0FBQUEsa0JBQzVCLFVBQVUsRUFBRSxXQUFXLENBQUMsS0FBSyxHQUFHLEtBQUssSUFBSTtBQUFBO0FBQUEsY0FDM0M7QUFBQSxjQUNBO0FBQUEsZ0JBQUM7QUFBQTtBQUFBLGtCQUNDLE9BQU07QUFBQSxrQkFDTixNQUFNLGlCQUFLO0FBQUEsa0JBQ1gsVUFBVTtBQUFBLGtCQUNWLFVBQVUsRUFBRSxXQUFXLENBQUMsS0FBSyxHQUFHLEtBQUssSUFBSTtBQUFBO0FBQUEsY0FDM0M7QUFBQSxlQUNGO0FBQUE7QUFBQSxVQXpCRyxPQUFPLEtBQUssT0FBTztBQUFBLFFBMkIxQixDQUNELEdBQ0g7QUFBQSxRQUdELGNBQWMsV0FBVyxLQUFLLGNBQzdCO0FBQUEsVUFBQyxpQkFBSztBQUFBLFVBQUw7QUFBQSxZQUNDLE9BQU07QUFBQSxZQUNOLGFBQWEsc0JBQXNCLFVBQVU7QUFBQSxZQUM3QyxNQUFNLGlCQUFLO0FBQUE7QUFBQSxRQUNiO0FBQUE7QUFBQTtBQUFBLEVBRUo7QUFFSjsiLAogICJuYW1lcyI6IFsibm9vcCIsICJ4IiwgIl9hIiwgIkYiLCAiaSIsICJlIiwgInF1ZXVlTWljcm90YXNrIiwgInIiLCAiaXNBYm9ydFNpZ25hbCIsICJzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uIiwgImRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsICJET01FeGNlcHRpb24iLCAiUmVhZGFibGVTdHJlYW0iLCAidHJhbnNmb3JtIiwgIlBPT0xfU0laRSIsICJwcm9jZXNzIiwgIkJsb2IiLCAiY2xvbmUiLCAiQmxvYiIsICJzaXplIiwgIkZpbGUiLCAiRiIsICJmIiwgImUiLCAiRm9ybURhdGEiLCAibSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmcyIsICJtIiwgIkJvZHkiLCAiZiIsICJpIiwgImNsZWFyIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAidCIsICJzZWxmIiwgInN0YXQiLCAiZSIsICJwYXRoIiwgImVyciIsICJmZCIsICJpIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInBhdGgiLCAiZnMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJ6bGliIiwgImkiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiemxpYiIsICJpIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInQiLCAiaSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIkhlYWRlcnMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiSGVhZGVycyIsICJpIiwgImUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAibG9jYWxQYXRoIiwgIm9wdGlvbnMiLCAic2VsZiIsICJlcnIiLCAiaSIsICJjb250ZW50IiwgImZpbGVBdHRyIiwgImUiLCAiaW1wb3J0X2FwaSIsICJpbXBvcnRfbm9kZV9odHRwIiwgImltcG9ydF9ub2RlX3N0cmVhbSIsICJpbXBvcnRfbm9kZV9idWZmZXIiLCAiaSIsICJTdHJlYW0iLCAidG9Gb3JtRGF0YSIsICJpbXBvcnRfbm9kZV91dGlsIiwgImh0dHAiLCAiSU5URVJOQUxTIiwgImltcG9ydF9ub2RlX3V0aWwiLCAiSU5URVJOQUxTIiwgImZvcm1hdFVybCIsICJyZXNwb25zZSIsICJodHRwcyIsICJodHRwIiwgIlN0cmVhbSIsICJzIiwgInB1bXAiLCAiemxpYiIsICJpIiwgImkiLCAiY3IiLCAibmwiLCAiaSIsICJlbmNvZGluZyIsICJpbmZvIiwgImJvbSIsICJmIiwgImJ1ZiIsICJwb3MiLCAiaW1wb3J0X2FwaSIsICJwYXRoIiwgImZzIiwgIm9zIiwgIkFkbVppcCIsICJzIl0KfQo=
